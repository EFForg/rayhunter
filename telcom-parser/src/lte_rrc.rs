/*
This file was autogenerated using hampi (https://github.com/ystero-dev/hampi), do not modify!

    This place is not a place of honor...
    no highly esteemed deed is commemorated here...
    nothing valued is here.
*/

pub const MAX_ACDC_CAT_R13: i64 = 16;

pub const MAX_ACCESS_CAT_1_R15: i64 = 63;

pub const MAX_AVAIL_NARROW_BANDS_1_R16: i64 = 15;

pub const MAX_AVAIL_NARROW_BANDS_R13: i64 = 16;

pub const MAX_BT_ID_REPORT_R15: i64 = 32;

pub const MAX_BT_NAME_R15: i64 = 4;

pub const MAX_BAND_COMB_R10: i64 = 128;

pub const MAX_BAND_COMB_R11: i64 = 256;

pub const MAX_BAND_COMB_R13: i64 = 384;

pub const MAX_BAND_COMB_SIDELINK_NR_R16: i64 = 512;

pub const MAX_BANDS: i64 = 64;

pub const MAX_BANDS_ENDC_R16: i64 = 10;

pub const MAX_BANDS_NR_R15: i64 = 1024;

pub const MAX_BANDWIDTH_CLASS_R10: i64 = 16;

pub const MAX_BANDWIDTH_COMB_SET_R10: i64 = 32;

pub const MAX_BARRING_INFO_SET_R15: i64 = 8;

pub const MAX_CBR_LEVEL_1_R14: i64 = 15;

pub const MAX_CBR_LEVEL_R14: i64 = 16;

pub const MAX_CBR_REPORT_R14: i64 = 72;

pub const MAX_CDMA_BAND_CLASS: i64 = 32;

pub const MAX_CE_LEVEL_R13: i64 = 4;

pub const MAX_CQI_PROC_EXT_R11: i64 = 3;

pub const MAX_CSI_IM_R11: i64 = 3;

pub const MAX_CSI_IM_R12: i64 = 4;

pub const MAX_CSI_IM_R13: i64 = 24;

pub const MAX_CSI_IM_V1310: i64 = 20;

pub const MAX_CSI_PROC_R11: i64 = 4;

pub const MAX_CSI_RS_MEAS_R12: i64 = 96;

pub const MAX_CSI_RS_NZP_R11: i64 = 3;

pub const MAX_CSI_RS_NZP_R13: i64 = 24;

pub const MAX_CSI_RS_NZP_V1310: i64 = 21;

pub const MAX_CSI_RS_ZP_R11: i64 = 4;

pub const MAX_CELL_ALLOWED_NR_R16: i64 = 16;

pub const MAX_CELL_HISTORY_R12: i64 = 16;

pub const MAX_CELL_INFO_GERAN_R9: i64 = 32;

pub const MAX_CELL_INFO_UTRA_R9: i64 = 16;

pub const MAX_CELL_INTER: i64 = 16;

pub const MAX_CELL_INTRA: i64 = 16;

pub const MAX_CELL_LIST_GERAN: i64 = 3;

pub const MAX_CELL_MEAS: i64 = 32;

pub const MAX_CELL_MEAS_IDLE_R15: i64 = 8;

pub const MAX_CELL_NR_R17: i64 = 8;

pub const MAX_CELL_REPORT: i64 = 8;

pub const MAX_CELL_SFTD: i64 = 3;

pub const MAX_COMB_IDC_R11: i64 = 128;

pub const MAX_COND_CONFIG_R16: i64 = 8;

pub const MAX_CONFIG_SPS_R14: i64 = 8;

pub const MAX_CONFIG_SPS_R15: i64 = 6;

pub const MAX_DRB: i64 = 11;

pub const MAX_DRB_R15: i64 = 15;

pub const MAX_DRB_EXT_R15: i64 = 4;

pub const MAX_DS_DURATION_R12: i64 = 5;

pub const MAX_DS_ZTP_CSI_RS_R12: i64 = 5;

pub const MAX_EARFCN: i64 = 65535;

pub const MAX_EARFCN_PLUS1: i64 = 65536;

pub const MAX_EARFCN2: i64 = 262143;

pub const MAX_EPDCCH_SET_R11: i64 = 2;

pub const MAX_EXCLUDED_CELL: i64 = 16;

pub const MAX_FBI: i64 = 64;

pub const MAX_FBI_NR_R15: i64 = 1024;

pub const MAX_FBI_PLUS1: i64 = 65;

pub const MAX_FBI2: i64 = 256;

pub const MAX_FEATURE_SETS_R15: i64 = 256;

pub const MAX_FREQ: i64 = 8;

pub const MAX_FREQ_1_R16: i64 = 7;

pub const MAX_FREQ_IDC_R11: i64 = 32;

pub const MAX_FREQ_IDLE_R15: i64 = 8;

pub const MAX_FREQ_MBMS_R11: i64 = 5;

pub const MAX_FREQ_NBIOT_R16: i64 = 8;

pub const MAX_FREQ_NR_R15: i64 = 5;

pub const MAX_FREQ_SL_NR_R16: i64 = 8;

pub const MAX_FREQ_UTRA_TDD_R10: i64 = 6;

pub const MAX_FREQ_V2X_1_R14: i64 = 7;

pub const MAX_FREQ_V2X_R14: i64 = 8;

pub const MAX_GERAN_SI: i64 = 10;

pub const MAX_GNFG: i64 = 16;

pub const MAX_GWUS_GROUPS_1_R16: i64 = 31;

pub const MAX_GWUS_PROB_THRESHOLDS_R16: i64 = 3;

pub const MAX_GWUS_RESOURCES_R16: i64 = 4;

pub const MAX_IDLE_MEAS_CARRIERS_R15: i64 = 3;

pub const MAX_IDLE_MEAS_CARRIERS_R16: i64 = 8;

pub const MAX_IDLE_MEAS_CARRIERS_EXT_R16: i64 = 5;

pub const MAX_LCG_R13: i64 = 4;

pub const MAX_LOG_MEAS_R10: i64 = 4060;

pub const MAX_LOG_MEAS_REPORT_R10: i64 = 520;

pub const MAX_MBMS_SERVICE_LIST_PER_UE_R13: i64 = 15;

pub const MAX_MBSFN_ALLOCATIONS: i64 = 8;

pub const MAX_MBSFN_AREA: i64 = 8;

pub const MAX_MBSFN_AREA_1: i64 = 7;

pub const MAX_MEAS_ID: i64 = 32;

pub const MAX_MEAS_ID_PLUS1: i64 = 33;

pub const MAX_MEAS_ID_R12: i64 = 64;

pub const MAX_MULTI_BANDS: i64 = 8;

pub const MAX_MULTI_BANDS_NR_1_R15: i64 = 31;

pub const MAX_MULTI_BANDS_NR_R15: i64 = 32;

pub const MAX_NAICS_ENTRIES_R12: i64 = 8;

pub const MAX_NS_PMAX_R10: i64 = 8;

pub const MAX_NEIGH_CELL_SCPTM_R13: i64 = 8;

pub const MAX_NEIGH_CELL_R12: i64 = 8;

pub const MAX_NROF_PCI_PER_SMTC_R16: i64 = 64;

pub const MAX_NROF_S_NSSAI_R15: i64 = 8;

pub const MAX_OBJECT_ID: i64 = 32;

pub const MAX_OBJECT_ID_PLUS1_R13: i64 = 33;

pub const MAX_OBJECT_ID_R13: i64 = 64;

pub const MAX_P_A_PER_NEIGH_CELL_R12: i64 = 3;

pub const MAX_PLMN_1_R14: i64 = 5;

pub const MAX_PLMN_NR_R15: i64 = 12;

pub const MAX_PLMN_R11: i64 = 6;

pub const MAX_PLMN_R15: i64 = 8;

pub const MAX_PMCH_PER_MBSFN: i64 = 15;

pub const MAX_PN_OFFSET: i64 = 511;

pub const MAX_PSSCH_TX_CONFIG_R14: i64 = 16;

pub const MAX_PAGE_REC: i64 = 16;

pub const MAX_PER_CC_FEATURE_SETS_R15: i64 = 32;

pub const MAX_PHYS_CELL_ID_RANGE_R9: i64 = 4;

pub const MAX_QCI_R13: i64 = 6;

pub const MAX_QUANT_SETS_NR_R15: i64 = 2;

pub const MAX_RAT_CAPABILITIES: i64 = 8;

pub const MAX_RE_MAP_QCL_R11: i64 = 4;

pub const MAX_RS_INDEX_1_R15: i64 = 63;

pub const MAX_RS_INDEX_R15: i64 = 64;

pub const MAX_RS_INDEX_CELL_QUAL_R15: i64 = 16;

pub const MAX_RS_INDEX_REPORT_R15: i64 = 32;

pub const MAX_RSTD_FREQ_R10: i64 = 3;

pub const MAX_REESTAB_INFO: i64 = 32;

pub const MAX_REPORT_CONFIG_ID: i64 = 32;

pub const MAX_RESERVATION_PERIOD_R14: i64 = 16;

pub const MAX_SAI_MBMS_R11: i64 = 64;

pub const MAX_SC_MTCH_BR_R14: i64 = 128;

pub const MAX_SC_MTCH_R13: i64 = 1023;

pub const MAX_S_CELL_R10: i64 = 4;

pub const MAX_S_CELL_R13: i64 = 31;

pub const MAX_S_CELL_GROUPS_R15: i64 = 4;

pub const MAX_SI_MESSAGE: i64 = 32;

pub const MAX_SIB: i64 = 32;

pub const MAX_SIB_1: i64 = 31;

pub const MAX_SL_COMM_RX_POOL_N_FREQ_R13: i64 = 32;

pub const MAX_SL_COMM_RX_POOL_PRECONF_V1310: i64 = 12;

pub const MAX_SL_COMM_TX_POOL_PRECONF_V1310: i64 = 7;

pub const MAX_SL_DEST_R12: i64 = 16;

pub const MAX_SL_DISC_CELLS_R13: i64 = 16;

pub const MAX_SL_DISC_POWER_CLASS_R12: i64 = 3;

pub const MAX_SL_DISC_RX_POOL_PRECONF_R13: i64 = 16;

pub const MAX_SL_DISC_SYS_INFO_REPORT_FREQ_R13: i64 = 8;

pub const MAX_SL_DISC_TX_POOL_PRECONF_R13: i64 = 4;

pub const MAX_SL_GP_R13: i64 = 8;

pub const MAX_SL_POOL_TO_MEASURE_R14: i64 = 72;

pub const MAX_SL_PRIO_R13: i64 = 8;

pub const MAX_SL_RELIABILITY_R15: i64 = 8;

pub const MAX_SL_RX_POOL_R12: i64 = 16;

pub const MAX_SL_SYNC_CONFIG_R12: i64 = 16;

pub const MAX_SL_TF_INDEX_PAIR_R12: i64 = 64;

pub const MAX_SL_TX_POOL_R12: i64 = 4;

pub const MAX_SL_TX_POOL_R12_PLUS1_R13: i64 = 5;

pub const MAX_SL_TX_POOL_R13: i64 = 8;

pub const MAX_SL_TX_POOL_V1310: i64 = 4;

pub const MAX_SL_V2X_CBR_CONFIG_1_R14: i64 = 3;

pub const MAX_SL_V2X_CBR_CONFIG_R14: i64 = 4;

pub const MAX_SL_V2X_CBR_CONFIG2_1_R14: i64 = 7;

pub const MAX_SL_V2X_CBR_CONFIG2_R14: i64 = 8;

pub const MAX_SL_V2X_RX_POOL_R14: i64 = 16;

pub const MAX_SL_V2X_RX_POOL_PRECONF_R14: i64 = 16;

pub const MAX_SL_V2X_SYNC_CONFIG_R14: i64 = 16;

pub const MAX_SL_V2X_TX_CONFIG_1_R14: i64 = 63;

pub const MAX_SL_V2X_TX_CONFIG_R14: i64 = 64;

pub const MAX_SL_V2X_TX_CONFIG2_1_R14: i64 = 127;

pub const MAX_SL_V2X_TX_CONFIG2_R14: i64 = 128;

pub const MAX_SL_V2X_TX_POOL_R14: i64 = 8;

pub const MAX_SL_V2X_TX_POOL_PRECONF_R14: i64 = 8;

pub const MAX_STAG_R11: i64 = 3;

pub const MAX_SAT_R17: i64 = 4;

pub const MAX_SERV_CELL_R10: i64 = 5;

pub const MAX_SERV_CELL_R13: i64 = 32;

pub const MAX_SERV_CELL_NR_R15: i64 = 16;

pub const MAX_SERVICE_COUNT: i64 = 16;

pub const MAX_SERVICE_COUNT_1: i64 = 15;

pub const MAX_SESSION_PER_PMCH: i64 = 29;

pub const MAX_SESSION_PER_PMCH_1: i64 = 28;

pub const MAX_SIMULTANEOUS_BANDS_R10: i64 = 64;

pub const MAX_SUBFRAME_PATTERN_IDC_R11: i64 = 8;

pub const MAX_TAC_R17: i64 = 12;

pub const MAX_TRAFFIC_PATTERN_R14: i64 = 8;

pub const MAX_UTRA_FDD_CARRIER: i64 = 16;

pub const MAX_UTRA_TDD_CARRIER: i64 = 16;

pub const MAX_WLAN_BANDS_R13: i64 = 8;

pub const MAX_WLAN_CARRIER_INFO_R13: i64 = 8;

pub const MAX_WLAN_CHANNELS_R13: i64 = 16;

pub const MAX_WLAN_ID_REPORT_R14: i64 = 32;

pub const MAX_WLAN_ID_R12: i64 = 16;

pub const MAX_WLAN_ID_R13: i64 = 32;

pub const MAX_WLAN_NAME_R15: i64 = 4;

pub const MAX_WAY_POINT_R15: i64 = 20;

pub const MIN_CSI_IM_R13: i64 = 5;

pub const MIN_CSI_RS_NZP_R13: i64 = 4;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AC_BarringConfig {
    pub ac_barring_factor: AC_BarringConfigAc_BarringFactor,
    pub ac_barring_time: AC_BarringConfigAc_BarringTime,
    pub ac_barring_for_special_ac: AC_BarringConfigAc_BarringForSpecialAC,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AC_BarringConfig1XRTT_r9 {
    pub ac_barring0to9_r9: AC_BarringConfig1XRTT_r9Ac_Barring0to9_r9,
    pub ac_barring10_r9: AC_BarringConfig1XRTT_r9Ac_Barring10_r9,
    pub ac_barring11_r9: AC_BarringConfig1XRTT_r9Ac_Barring11_r9,
    pub ac_barring12_r9: AC_BarringConfig1XRTT_r9Ac_Barring12_r9,
    pub ac_barring13_r9: AC_BarringConfig1XRTT_r9Ac_Barring13_r9,
    pub ac_barring14_r9: AC_BarringConfig1XRTT_r9Ac_Barring14_r9,
    pub ac_barring15_r9: AC_BarringConfig1XRTT_r9Ac_Barring15_r9,
    pub ac_barring_msg_r9: AC_BarringConfig1XRTT_r9Ac_BarringMsg_r9,
    pub ac_barring_reg_r9: AC_BarringConfig1XRTT_r9Ac_BarringReg_r9,
    pub ac_barring_emg_r9: AC_BarringConfig1XRTT_r9Ac_BarringEmg_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct AC_BarringPerPLMN_List_r12(pub Vec<AC_BarringPerPLMN_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 7)]
pub struct AC_BarringPerPLMN_r12 {
    pub plmn_identity_index_r12: AC_BarringPerPLMN_r12Plmn_IdentityIndex_r12,
    #[asn(optional_idx = 0)]
    pub ac_barring_info_r12: Option<AC_BarringPerPLMN_r12Ac_BarringInfo_r12>,
    #[asn(optional_idx = 1)]
    pub ac_barring_skip_for_mmtel_voice_r12:
        Option<AC_BarringPerPLMN_r12Ac_BarringSkipForMMTELVoice_r12>,
    #[asn(optional_idx = 2)]
    pub ac_barring_skip_for_mmtel_video_r12:
        Option<AC_BarringPerPLMN_r12Ac_BarringSkipForMMTELVideo_r12>,
    #[asn(optional_idx = 3)]
    pub ac_barring_skip_for_sms_r12: Option<AC_BarringPerPLMN_r12Ac_BarringSkipForSMS_r12>,
    #[asn(optional_idx = 4)]
    pub ac_barring_for_csfb_r12: Option<AC_BarringConfig>,
    #[asn(optional_idx = 5)]
    pub ssac_barring_for_mmtel_voice_r12: Option<AC_BarringConfig>,
    #[asn(optional_idx = 6)]
    pub ssac_barring_for_mmtel_video_r12: Option<AC_BarringConfig>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ACDC_BarringForCommon_r13 {
    pub acdc_hplm_nonly_r13: ACDC_BarringForCommon_r13Acdc_HPLMNonly_r13,
    pub barring_per_acdc_category_list_r13: BarringPerACDC_CategoryList_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct ACDC_BarringPerPLMN_List_r13(pub Vec<ACDC_BarringPerPLMN_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ACDC_BarringPerPLMN_r13 {
    pub plmn_identity_index_r13: ACDC_BarringPerPLMN_r13Plmn_IdentityIndex_r13,
    pub acdc_only_for_hplmn_r13: ACDC_BarringPerPLMN_r13Acdc_OnlyForHPLMN_r13,
    pub barring_per_acdc_category_list_r13: BarringPerACDC_CategoryList_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "24", sz_ub = "24")]
pub struct AMF_Identifier_r15(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct ARFCN_ValueCDMA2000(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct ARFCN_ValueEUTRA(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "262143")]
pub struct ARFCN_ValueEUTRA_r9(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "65536", ub = "262143")]
pub struct ARFCN_ValueEUTRA_v9e0(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct ARFCN_ValueGERAN(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3279165")]
pub struct ARFCN_ValueNR_r15(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "16383")]
pub struct ARFCN_ValueUTRA(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct AS_Config {
    pub source_meas_config: MeasConfig,
    pub source_radio_resource_config: RadioResourceConfigDedicated,
    pub source_security_algorithm_config: SecurityAlgorithmConfig,
    pub source_ue_identity: C_RNTI,
    pub source_master_information_block: MasterInformationBlock,
    pub source_system_information_block_type1: SystemInformationBlockType1,
    pub source_system_information_block_type2: SystemInformationBlockType2,
    pub antenna_info_common: AntennaInfoCommon,
    pub source_dl_carrier_freq: ARFCN_ValueEUTRA,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct AS_Config_v10j0 {
    #[asn(optional_idx = 0)]
    pub antenna_info_dedicated_p_cell_v10i0: Option<AntennaInfoDedicated_v10i0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct AS_Config_v1250 {
    #[asn(optional_idx = 0)]
    pub source_wlan_offload_config_r12: Option<WLAN_OffloadConfig_r12>,
    #[asn(optional_idx = 1)]
    pub source_sl_comm_config_r12: Option<SL_CommConfig_r12>,
    #[asn(optional_idx = 2)]
    pub source_sl_disc_config_r12: Option<SL_DiscConfig_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct AS_Config_v1320 {
    #[asn(optional_idx = 0)]
    pub source_s_cell_config_list_r13: Option<SCellToAddModListExt_r13>,
    #[asn(optional_idx = 1)]
    pub source_rclwi_configuration_r13: Option<RCLWI_Configuration_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct AS_Config_v13c0 {
    #[asn(optional_idx = 0)]
    pub radio_resource_config_dedicated_v13c01: Option<RadioResourceConfigDedicated_v1370>,
    #[asn(optional_idx = 1)]
    pub radio_resource_config_dedicated_v13c02: Option<RadioResourceConfigDedicated_v13c0>,
    #[asn(optional_idx = 2)]
    pub s_cell_to_add_mod_list_v13c0: Option<SCellToAddModList_v13c0>,
    #[asn(optional_idx = 3)]
    pub s_cell_to_add_mod_list_ext_v13c0: Option<SCellToAddModListExt_v13c0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct AS_Config_v1430 {
    #[asn(optional_idx = 0)]
    pub source_sl_v2x_comm_config_r14: Option<SL_V2X_ConfigDedicated_r14>,
    #[asn(optional_idx = 1)]
    pub source_lwa_config_r14: Option<LWA_Config_r13>,
    #[asn(optional_idx = 2)]
    pub source_wlan_meas_result_r14: Option<MeasResultListWLAN_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct AS_Config_v1550 {
    #[asn(optional_idx = 0)]
    pub tdm_pattern_config_r15: Option<AS_Config_v1550Tdm_PatternConfig_r15>,
    #[asn(optional_idx = 1)]
    pub p_max_eutra_r15: Option<P_Max>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct AS_Config_v1700 {
    #[asn(optional_idx = 0)]
    pub scg_state_r17: Option<AS_Config_v1700Scg_State_r17>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AS_Config_v9e0 {
    pub source_dl_carrier_freq_v9e0: ARFCN_ValueEUTRA_v9e0,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct AS_ConfigNR_r15 {
    #[asn(optional_idx = 0)]
    pub source_rb_config_nr_r15: Option<AS_ConfigNR_r15SourceRB_ConfigNR_r15>,
    #[asn(optional_idx = 1)]
    pub source_rb_config_sn_nr_r15: Option<AS_ConfigNR_r15SourceRB_ConfigSN_NR_r15>,
    #[asn(optional_idx = 2)]
    pub source_other_config_sn_nr_r15: Option<AS_ConfigNR_r15SourceOtherConfigSN_NR_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AS_ConfigNR_v1570 {
    pub source_scg_configured_nr_r15: AS_ConfigNR_v1570SourceSCG_ConfiguredNR_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AS_ConfigNR_v1620 {
    pub tdm_pattern_config2_r16: TDM_PatternConfig_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct AS_Context {
    #[asn(optional_idx = 0)]
    pub reestablishment_info: Option<ReestablishmentInfo>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct AS_Context_v1130 {
    #[asn(optional_idx = 0)]
    pub idc_indication_r11: Option<AS_Context_v1130Idc_Indication_r11>,
    #[asn(optional_idx = 1)]
    pub mbms_interest_indication_r11: Option<AS_Context_v1130MbmsInterestIndication_r11>,
    #[asn(optional_idx = 2)]
    pub ue_assistance_information_r11: Option<AS_Context_v1130UeAssistanceInformation_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct AS_Context_v1320 {
    #[asn(optional_idx = 0)]
    pub wlan_connection_status_report_r13: Option<AS_Context_v1320WlanConnectionStatusReport_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct AS_Context_v1610 {
    #[asn(optional_idx = 0)]
    pub sidelink_ue_information_nr_r16: Option<AS_Context_v1610SidelinkUEInformationNR_r16>,
    #[asn(optional_idx = 1)]
    pub ue_assistance_information_nr_r16: Option<AS_Context_v1610UeAssistanceInformationNR_r16>,
    #[asn(optional_idx = 2)]
    pub config_restrict_info_daps_r16: Option<ConfigRestrictInfoDAPS_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct AS_Context_v1620 {
    #[asn(optional_idx = 0)]
    pub ue_assistance_information_nr_scg_r16:
        Option<AS_Context_v1620UeAssistanceInformationNR_SCG_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct AS_Context_v1630 {
    #[asn(optional_idx = 0)]
    pub config_restrict_info_daps_v1630: Option<ConfigRestrictInfoDAPS_v1630>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum AUL_Config_r15 {
    #[asn(key = 0, extended = false)]
    Release(AUL_Config_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(AUL_Config_r15_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "48", sz_ub = "48")]
pub struct AbsoluteTimeInfo_r10(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "7")]
pub struct AccessStratumRelease(pub u8);
impl AccessStratumRelease {
    pub const REL8: u8 = 0u8;
    pub const REL9: u8 = 1u8;
    pub const REL10: u8 = 2u8;
    pub const REL11: u8 = 3u8;
    pub const REL12: u8 = 4u8;
    pub const REL13: u8 = 5u8;
    pub const REL14: u8 = 6u8;
    pub const REL15: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AdditionalReestabInfo {
    pub cell_identity: CellIdentity,
    pub key_e_node_b_star: Key_eNodeB_Star,
    pub short_mac_i: ShortMAC_I,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct AdditionalReestabInfoList(pub Vec<AdditionalReestabInfo>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct AdditionalSI_Info_r9 {
    #[asn(optional_idx = 0)]
    pub csg_member_status_r9: Option<AdditionalSI_Info_r9Csg_MemberStatus_r9>,
    #[asn(optional_idx = 1)]
    pub csg_identity_r9: Option<CSG_Identity>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct AdditionalSpectrumEmission(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "33", ub = "288")]
pub struct AdditionalSpectrumEmission_v10l0(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct AdditionalSpectrumEmissionNR_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "8", ub = "39")]
pub struct AdditionalSpectrumEmissionNR_v1760(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AffectedCarrierFreq_r11 {
    pub carrier_freq_r11: MeasObjectId,
    pub interference_direction_r11: AffectedCarrierFreq_r11InterferenceDirection_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct AffectedCarrierFreq_v1310 {
    #[asn(optional_idx = 0)]
    pub carrier_freq_v1310: Option<MeasObjectId_v1310>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "2", sz_ub = "5")]
pub struct AffectedCarrierFreqComb_r11(pub Vec<MeasObjectId>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "2", sz_ub = "32")]
pub struct AffectedCarrierFreqComb_r13(pub Vec<MeasObjectId_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct AffectedCarrierFreqComb_r15(pub Vec<MeasObjectId_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct AffectedCarrierFreqCombInfoMRDC_r15 {
    pub victim_system_type_r15: VictimSystemType_r11,
    pub interference_direction_mrdc_r15:
        AffectedCarrierFreqCombInfoMRDC_r15InterferenceDirectionMRDC_r15,
    #[asn(optional_idx = 0)]
    pub affected_carrier_freq_comb_mrdc_r15:
        Option<AffectedCarrierFreqCombInfoMRDC_r15AffectedCarrierFreqCombMRDC_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct AffectedCarrierFreqCombList_r11(pub Vec<AffectedCarrierFreqComb_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct AffectedCarrierFreqCombList_r13(pub Vec<AffectedCarrierFreqComb_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct AffectedCarrierFreqCombNR_r15(pub Vec<ARFCN_ValueNR_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct AffectedCarrierFreqList_r11(pub Vec<AffectedCarrierFreq_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct AffectedCarrierFreqList_v1310(pub Vec<AffectedCarrierFreq_v1310>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct AllowedCellListNR_r16(pub Vec<PhysCellIdNR_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AllowedCellsToAddMod_r13 {
    pub cell_index_r13: AllowedCellsToAddMod_r13CellIndex_r13,
    pub phys_cell_id_range_r13: PhysCellIdRange,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct AllowedCellsToAddModList_r13(pub Vec<AllowedCellsToAddMod_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct AllowedMeasBandwidth(pub u8);
impl AllowedMeasBandwidth {
    pub const MBW6: u8 = 0u8;
    pub const MBW15: u8 = 1u8;
    pub const MBW25: u8 = 2u8;
    pub const MBW50: u8 = 3u8;
    pub const MBW75: u8 = 4u8;
    pub const MBW100: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct Alpha_r12(pub u8);
impl Alpha_r12 {
    pub const AL0: u8 = 0u8;
    pub const AL04: u8 = 1u8;
    pub const AL05: u8 = 2u8;
    pub const AL06: u8 = 3u8;
    pub const AL07: u8 = 4u8;
    pub const AL08: u8 = 5u8;
    pub const AL09: u8 = 6u8;
    pub const AL1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AltTTT_CellsToAddMod_r12 {
    pub cell_index_r12: AltTTT_CellsToAddMod_r12CellIndex_r12,
    pub phys_cell_id_range_r12: PhysCellIdRange,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct AltTTT_CellsToAddModList_r12(pub Vec<AltTTT_CellsToAddMod_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AntennaInfoCommon {
    pub antenna_ports_count: AntennaInfoCommonAntennaPortsCount,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct AntennaInfoDedicated {
    pub transmission_mode: AntennaInfoDedicatedTransmissionMode,
    #[asn(optional_idx = 0)]
    pub codebook_subset_restriction: Option<AntennaInfoDedicatedCodebookSubsetRestriction>,
    pub ue_transmit_antenna_selection: AntennaInfoDedicatedUe_TransmitAntennaSelection,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct AntennaInfoDedicated_r10 {
    pub transmission_mode_r10: AntennaInfoDedicated_r10TransmissionMode_r10,
    #[asn(optional_idx = 0)]
    pub codebook_subset_restriction_r10:
        Option<AntennaInfoDedicated_r10CodebookSubsetRestriction_r10>,
    pub ue_transmit_antenna_selection: AntennaInfoDedicated_r10Ue_TransmitAntennaSelection,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct AntennaInfoDedicated_v10i0 {
    #[asn(optional_idx = 0)]
    pub max_layers_mimo_r10: Option<AntennaInfoDedicated_v10i0MaxLayersMIMO_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AntennaInfoDedicated_v1250 {
    pub alternative_codebook_enabled_for4_tx_r12:
        AntennaInfoDedicated_v1250AlternativeCodebookEnabledFor4TX_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct AntennaInfoDedicated_v1430 {
    #[asn(optional_idx = 0)]
    pub ce_ue_tx_antenna_selection_config_r14:
        Option<AntennaInfoDedicated_v1430Ce_UE_TxAntennaSelection_config_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum AntennaInfoDedicated_v1530 {
    #[asn(key = 0, extended = false)]
    Release(AntennaInfoDedicated_v1530_release),
    #[asn(key = 1, extended = false)]
    Setup(AntennaInfoDedicated_v1530_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct AntennaInfoDedicated_v920 {
    #[asn(optional_idx = 0)]
    pub codebook_subset_restriction_v920:
        Option<AntennaInfoDedicated_v920CodebookSubsetRestriction_v920>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum AntennaInfoDedicatedSTTI_r15 {
    #[asn(key = 0, extended = false)]
    Release(AntennaInfoDedicatedSTTI_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(AntennaInfoDedicatedSTTI_r15_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct AntennaInfoUL_STTI_r15 {
    #[asn(optional_idx = 0)]
    pub transmission_mode_ul_stti_r15: Option<AntennaInfoUL_STTI_r15TransmissionModeUL_STTI_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct AntennaInfoUL_r10 {
    #[asn(optional_idx = 0)]
    pub transmission_mode_ul_r10: Option<AntennaInfoUL_r10TransmissionModeUL_r10>,
    #[asn(optional_idx = 1)]
    pub four_antenna_port_activated_r10: Option<AntennaInfoUL_r10FourAntennaPortActivated_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum ApplicableDisasterInfo_r17 {
    #[asn(key = 0, extended = false)]
    NoDisasterRoaming_r17(ApplicableDisasterInfo_r17_noDisasterRoaming_r17),
    #[asn(key = 1, extended = false)]
    DisasterRelatedIndication_r17(ApplicableDisasterInfo_r17_disasterRelatedIndication_r17),
    #[asn(key = 2, extended = false)]
    CommonPLMNs_r17(ApplicableDisasterInfo_r17_commonPLMNs_r17),
    #[asn(key = 3, extended = false)]
    DedicatedPLMNs_r17(ApplicableDisasterInfo_r17_dedicatedPLMNs_r17),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum AreaConfiguration_r10 {
    #[asn(key = 0, extended = false)]
    CellGlobalIdList_r10(CellGlobalIdList_r10),
    #[asn(key = 1, extended = false)]
    TrackingAreaCodeList_r10(TrackingAreaCodeList_r10),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AreaConfiguration_v1130 {
    pub tracking_area_code_list_v1130: TrackingAreaCodeList_v1130,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BCCH_BCH_Message {
    pub message: BCCH_BCH_MessageType,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BCCH_BCH_Message_MBMS {
    pub message: BCCH_BCH_MessageType_MBMS_r14,
}

pub type BCCH_BCH_MessageType = MasterInformationBlock;

pub type BCCH_BCH_MessageType_MBMS_r14 = MasterInformationBlock_MBMS_r14;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BCCH_Config {
    pub modification_period_coeff: BCCH_ConfigModificationPeriodCoeff,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BCCH_Config_v1310 {
    pub modification_period_coeff_v1310: BCCH_Config_v1310ModificationPeriodCoeff_v1310,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BCCH_DL_SCH_Message {
    pub message: BCCH_DL_SCH_MessageType,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BCCH_DL_SCH_Message_BR {
    pub message: BCCH_DL_SCH_MessageType_BR_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BCCH_DL_SCH_Message_MBMS {
    pub message: BCCH_DL_SCH_MessageType_MBMS_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum BCCH_DL_SCH_MessageType {
    #[asn(key = 0, extended = false)]
    C1(BCCH_DL_SCH_MessageType_c1),
    #[asn(key = 1, extended = false)]
    MessageClassExtension(BCCH_DL_SCH_MessageType_messageClassExtension),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum BCCH_DL_SCH_MessageType_BR_r13 {
    #[asn(key = 0, extended = false)]
    C1(BCCH_DL_SCH_MessageType_BR_r13_c1),
    #[asn(key = 1, extended = false)]
    MessageClassExtension(BCCH_DL_SCH_MessageType_BR_r13_messageClassExtension),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum BCCH_DL_SCH_MessageType_MBMS_r14 {
    #[asn(key = 0, extended = false)]
    C1(BCCH_DL_SCH_MessageType_MBMS_r14_c1),
    #[asn(key = 1, extended = false)]
    MessageClassExtension(BCCH_DL_SCH_MessageType_MBMS_r14_messageClassExtension),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct BLER_Range_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BLER_Result_r12 {
    pub bler_r12: BLER_Range_r12,
    pub blocks_received_r12: BLER_Result_r12BlocksReceived_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "248"
)]
pub struct BT_Name_r15(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct BT_NameList_r15(pub Vec<BT_Name_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum BT_NameListConfig_r15 {
    #[asn(key = 0, extended = false)]
    Release(BT_NameListConfig_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(BT_NameList_r15),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct BW_Preference_r14 {
    #[asn(optional_idx = 0)]
    pub dl_preference_r14: Option<BW_Preference_r14Dl_Preference_r14>,
    #[asn(optional_idx = 1)]
    pub ul_preference_r14: Option<BW_Preference_r14Ul_Preference_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct BandClassInfoCDMA2000 {
    pub band_class: BandclassCDMA2000,
    #[asn(optional_idx = 0)]
    pub cell_reselection_priority: Option<CellReselectionPriority>,
    pub thresh_x_high: BandClassInfoCDMA2000ThreshX_High,
    pub thresh_x_low: BandClassInfoCDMA2000ThreshX_Low,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct BandClassListCDMA2000(pub Vec<BandClassInfoCDMA2000>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BandClassPriority1XRTT {
    pub band_class: BandclassCDMA2000,
    pub cell_reselection_priority: CellReselectionPriority,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BandClassPriorityHRPD {
    pub band_class: BandclassCDMA2000,
    pub cell_reselection_priority: CellReselectionPriority,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct BandClassPriorityList1XRTT(pub Vec<BandClassPriority1XRTT>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct BandClassPriorityListHRPD(pub Vec<BandClassPriorityHRPD>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct BandCombination_r14(pub Vec<BandIndication_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "384"
)]
pub struct BandCombinationList_r14(pub Vec<BandCombination_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct BandCombinationListEUTRA_r10(pub Vec<BandInfoEUTRA>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct BandCombinationParameters_r10(pub Vec<BandParameters_r10>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct BandCombinationParameters_r11 {
    pub band_parameter_list_r11: BandCombinationParameters_r11BandParameterList_r11,
    #[asn(optional_idx = 0)]
    pub supported_bandwidth_combination_set_r11: Option<SupportedBandwidthCombinationSet_r10>,
    #[asn(optional_idx = 1)]
    pub multiple_timing_advance_r11: Option<BandCombinationParameters_r11MultipleTimingAdvance_r11>,
    #[asn(optional_idx = 2)]
    pub simultaneous_rx_tx_r11: Option<BandCombinationParameters_r11SimultaneousRx_Tx_r11>,
    pub band_info_eutra_r11: BandInfoEUTRA,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 7)]
pub struct BandCombinationParameters_r13 {
    #[asn(optional_idx = 0)]
    pub different_fallback_supported_r13:
        Option<BandCombinationParameters_r13DifferentFallbackSupported_r13>,
    pub band_parameter_list_r13: BandCombinationParameters_r13BandParameterList_r13,
    #[asn(optional_idx = 1)]
    pub supported_bandwidth_combination_set_r13: Option<SupportedBandwidthCombinationSet_r10>,
    #[asn(optional_idx = 2)]
    pub multiple_timing_advance_r13: Option<BandCombinationParameters_r13MultipleTimingAdvance_r13>,
    #[asn(optional_idx = 3)]
    pub simultaneous_rx_tx_r13: Option<BandCombinationParameters_r13SimultaneousRx_Tx_r13>,
    pub band_info_eutra_r13: BandInfoEUTRA,
    #[asn(optional_idx = 4)]
    pub dc_support_r13: Option<BandCombinationParameters_r13Dc_Support_r13>,
    #[asn(optional_idx = 5)]
    pub supported_naics_2crs_ap_r13:
        Option<BandCombinationParameters_r13SupportedNAICS_2CRS_AP_r13>,
    #[asn(optional_idx = 6)]
    pub comm_supported_bands_per_bc_r13:
        Option<BandCombinationParameters_r13CommSupportedBandsPerBC_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct BandCombinationParameters_v1090(pub Vec<BandParameters_v1090>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct BandCombinationParameters_v10i0 {
    #[asn(optional_idx = 0)]
    pub band_parameter_list_v10i0: Option<BandCombinationParameters_v10i0BandParameterList_v10i0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct BandCombinationParameters_v1130 {
    #[asn(optional_idx = 0)]
    pub multiple_timing_advance_r11:
        Option<BandCombinationParameters_v1130MultipleTimingAdvance_r11>,
    #[asn(optional_idx = 1)]
    pub simultaneous_rx_tx_r11: Option<BandCombinationParameters_v1130SimultaneousRx_Tx_r11>,
    #[asn(optional_idx = 2)]
    pub band_parameter_list_r11: Option<BandCombinationParameters_v1130BandParameterList_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct BandCombinationParameters_v1250 {
    #[asn(optional_idx = 0)]
    pub dc_support_r12: Option<BandCombinationParameters_v1250Dc_Support_r12>,
    #[asn(optional_idx = 1)]
    pub supported_naics_2crs_ap_r12:
        Option<BandCombinationParameters_v1250SupportedNAICS_2CRS_AP_r12>,
    #[asn(optional_idx = 2)]
    pub comm_supported_bands_per_bc_r12:
        Option<BandCombinationParameters_v1250CommSupportedBandsPerBC_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct BandCombinationParameters_v1270 {
    #[asn(optional_idx = 0)]
    pub band_parameter_list_v1270: Option<BandCombinationParameters_v1270BandParameterList_v1270>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct BandCombinationParameters_v1320 {
    #[asn(optional_idx = 0)]
    pub band_parameter_list_v1320: Option<BandCombinationParameters_v1320BandParameterList_v1320>,
    #[asn(optional_idx = 1)]
    pub additional_rx_tx_performance_req_r13:
        Option<BandCombinationParameters_v1320AdditionalRx_Tx_PerformanceReq_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct BandCombinationParameters_v1380 {
    #[asn(optional_idx = 0)]
    pub band_parameter_list_v1380: Option<BandCombinationParameters_v1380BandParameterList_v1380>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct BandCombinationParameters_v1390 {
    #[asn(optional_idx = 0)]
    pub ue_ca_power_class_n_r13: Option<BandCombinationParameters_v1390Ue_CA_PowerClass_N_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct BandCombinationParameters_v1430 {
    #[asn(optional_idx = 0)]
    pub band_parameter_list_v1430: Option<BandCombinationParameters_v1430BandParameterList_v1430>,
    #[asn(optional_idx = 1)]
    pub v2x_supported_tx_band_comb_list_per_bc_r14:
        Option<BandCombinationParameters_v1430V2x_SupportedTxBandCombListPerBC_r14>,
    #[asn(optional_idx = 2)]
    pub v2x_supported_rx_band_comb_list_per_bc_r14:
        Option<BandCombinationParameters_v1430V2x_SupportedRxBandCombListPerBC_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct BandCombinationParameters_v1450 {
    #[asn(optional_idx = 0)]
    pub band_parameter_list_v1450: Option<BandCombinationParameters_v1450BandParameterList_v1450>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct BandCombinationParameters_v1470 {
    #[asn(optional_idx = 0)]
    pub band_parameter_list_v1470: Option<BandCombinationParameters_v1470BandParameterList_v1470>,
    #[asn(optional_idx = 1)]
    pub srs_max_simultaneous_c_cs_r14:
        Option<BandCombinationParameters_v1470Srs_MaxSimultaneousCCs_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct BandCombinationParameters_v14b0 {
    #[asn(optional_idx = 0)]
    pub band_parameter_list_v14b0: Option<BandCombinationParameters_v14b0BandParameterList_v14b0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct BandCombinationParameters_v1530 {
    #[asn(optional_idx = 0)]
    pub band_parameter_list_v1530: Option<BandCombinationParameters_v1530BandParameterList_v1530>,
    #[asn(optional_idx = 1)]
    pub spt_parameters_r15: Option<SPT_Parameters_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct BandCombinationParameters_v1610 {
    #[asn(optional_idx = 0)]
    pub meas_gap_info_nr_r16: Option<MeasGapInfoNR_r16>,
    #[asn(optional_idx = 1)]
    pub band_parameter_list_v1610: Option<BandCombinationParameters_v1610BandParameterList_v1610>,
    #[asn(optional_idx = 2)]
    pub inter_freq_daps_r16: Option<BandCombinationParameters_v1610InterFreqDAPS_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct BandCombinationParameters_v1630 {
    #[asn(optional_idx = 0)]
    pub v2x_supported_tx_band_comb_list_per_bc_v1630:
        Option<BandCombinationParameters_v1630V2x_SupportedTxBandCombListPerBC_v1630>,
    #[asn(optional_idx = 1)]
    pub v2x_supported_rx_band_comb_list_per_bc_v1630:
        Option<BandCombinationParameters_v1630V2x_SupportedRxBandCombListPerBC_v1630>,
    #[asn(optional_idx = 2)]
    pub scaling_factor_tx_sidelink_r16:
        Option<BandCombinationParameters_v1630ScalingFactorTxSidelink_r16>,
    #[asn(optional_idx = 3)]
    pub scaling_factor_rx_sidelink_r16:
        Option<BandCombinationParameters_v1630ScalingFactorRxSidelink_r16>,
    #[asn(optional_idx = 4)]
    pub inter_band_power_sharing_sync_daps_r16:
        Option<BandCombinationParameters_v1630InterBandPowerSharingSyncDAPS_r16>,
    #[asn(optional_idx = 5)]
    pub inter_band_power_sharing_async_daps_r16:
        Option<BandCombinationParameters_v1630InterBandPowerSharingAsyncDAPS_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct BandCombinationParametersExt_r10 {
    #[asn(optional_idx = 0)]
    pub supported_bandwidth_combination_set_r10: Option<SupportedBandwidthCombinationSet_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct BandIndication_r14 {
    pub band_eutra_r14: FreqBandIndicator_r11,
    pub ca_bandwidth_class_dl_r14: CA_BandwidthClass_r10,
    #[asn(optional_idx = 0)]
    pub ca_bandwidth_class_ul_r14: Option<CA_BandwidthClass_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct BandIndicatorGERAN(pub u8);
impl BandIndicatorGERAN {
    pub const DCS1800: u8 = 0u8;
    pub const PCS1900: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct BandInfoEUTRA {
    pub inter_freq_band_list: InterFreqBandList,
    #[asn(optional_idx = 0)]
    pub inter_rat_band_list: Option<InterRAT_BandList>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "10")]
pub struct BandListENDC_r16(pub Vec<FreqBandIndicatorNR_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct BandListEUTRA(pub Vec<BandInfoEUTRA>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct BandParameters_r10 {
    pub band_eutra_r10: FreqBandIndicator,
    #[asn(optional_idx = 0)]
    pub band_parameters_ul_r10: Option<BandParametersUL_r10>,
    #[asn(optional_idx = 1)]
    pub band_parameters_dl_r10: Option<BandParametersDL_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct BandParameters_r11 {
    pub band_eutra_r11: FreqBandIndicator_r11,
    #[asn(optional_idx = 0)]
    pub band_parameters_ul_r11: Option<BandParametersUL_r10>,
    #[asn(optional_idx = 1)]
    pub band_parameters_dl_r11: Option<BandParametersDL_r10>,
    #[asn(optional_idx = 2)]
    pub supported_csi_proc_r11: Option<BandParameters_r11SupportedCSI_Proc_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct BandParameters_r13 {
    pub band_eutra_r13: FreqBandIndicator_r11,
    #[asn(optional_idx = 0)]
    pub band_parameters_ul_r13: Option<BandParametersUL_r13>,
    #[asn(optional_idx = 1)]
    pub band_parameters_dl_r13: Option<BandParametersDL_r13>,
    #[asn(optional_idx = 2)]
    pub supported_csi_proc_r13: Option<BandParameters_r13SupportedCSI_Proc_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct BandParameters_v1090 {
    #[asn(optional_idx = 0)]
    pub band_eutra_v1090: Option<FreqBandIndicator_v9e0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BandParameters_v10i0 {
    pub band_parameters_dl_v10i0: BandParameters_v10i0BandParametersDL_v10i0,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BandParameters_v1130 {
    pub supported_csi_proc_r11: BandParameters_v1130SupportedCSI_Proc_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BandParameters_v1270 {
    pub band_parameters_dl_v1270: BandParameters_v1270BandParametersDL_v1270,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BandParameters_v1320 {
    pub band_parameters_dl_v1320: MIMO_CA_ParametersPerBoBC_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct BandParameters_v1380 {
    #[asn(optional_idx = 0)]
    pub tx_antenna_switch_dl_r13: Option<BandParameters_v1380TxAntennaSwitchDL_r13>,
    #[asn(optional_idx = 1)]
    pub tx_antenna_switch_ul_r13: Option<BandParameters_v1380TxAntennaSwitchUL_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct BandParameters_v1430 {
    #[asn(optional_idx = 0)]
    pub band_parameters_dl_v1430: Option<MIMO_CA_ParametersPerBoBC_v1430>,
    #[asn(optional_idx = 1)]
    pub ul_256qam_r14: Option<BandParameters_v1430Ul_256QAM_r14>,
    #[asn(optional_idx = 2)]
    pub ul_256qam_per_cc_info_list_r14: Option<BandParameters_v1430Ul_256QAM_perCC_InfoList_r14>,
    #[asn(optional_idx = 3)]
    pub srs_capability_per_band_pair_list_r14:
        Option<BandParameters_v1430Srs_CapabilityPerBandPairList_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct BandParameters_v1450 {
    #[asn(optional_idx = 0)]
    pub must_capability_per_band_r14: Option<MUST_Parameters_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct BandParameters_v1470 {
    #[asn(optional_idx = 0)]
    pub band_parameters_dl_v1470: Option<MIMO_CA_ParametersPerBoBC_v1470>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct BandParameters_v14b0 {
    #[asn(optional_idx = 0)]
    pub srs_capability_per_band_pair_list_v14b0:
        Option<BandParameters_v14b0Srs_CapabilityPerBandPairList_v14b0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 7)]
pub struct BandParameters_v1530 {
    #[asn(optional_idx = 0)]
    pub ue_tx_antenna_selection_srs_1t4r_r15:
        Option<BandParameters_v1530Ue_TxAntennaSelection_SRS_1T4R_r15>,
    #[asn(optional_idx = 1)]
    pub ue_tx_antenna_selection_srs_2t4r_2pairs_r15:
        Option<BandParameters_v1530Ue_TxAntennaSelection_SRS_2T4R_2Pairs_r15>,
    #[asn(optional_idx = 2)]
    pub ue_tx_antenna_selection_srs_2t4r_3pairs_r15:
        Option<BandParameters_v1530Ue_TxAntennaSelection_SRS_2T4R_3Pairs_r15>,
    #[asn(optional_idx = 3)]
    pub dl_1024qam_r15: Option<BandParameters_v1530Dl_1024QAM_r15>,
    #[asn(optional_idx = 4)]
    pub qcl_type_c_operation_r15: Option<BandParameters_v1530Qcl_TypeC_Operation_r15>,
    #[asn(optional_idx = 5)]
    pub qcl_cri_based_csi_reporting_r15: Option<BandParameters_v1530Qcl_CRI_BasedCSI_Reporting_r15>,
    #[asn(optional_idx = 6)]
    pub stti_spt_band_parameters_r15: Option<STTI_SPT_BandParameters_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct BandParameters_v1610 {
    #[asn(optional_idx = 0)]
    pub intra_freq_daps_r16: Option<BandParameters_v1610IntraFreqDAPS_r16>,
    #[asn(optional_idx = 1)]
    pub add_srs_frequency_hopping_r16: Option<BandParameters_v1610AddSRS_FrequencyHopping_r16>,
    #[asn(optional_idx = 2)]
    pub add_srs_antenna_switching_r16: Option<BandParameters_v1610AddSRS_AntennaSwitching_r16>,
    #[asn(optional_idx = 3)]
    pub srs_capability_per_band_pair_list_v1610:
        Option<BandParameters_v1610Srs_CapabilityPerBandPairList_v1610>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct BandParametersDL_r10(pub Vec<CA_MIMO_ParametersDL_r10>);

pub type BandParametersDL_r13 = CA_MIMO_ParametersDL_r13;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct BandParametersRxSL_r14 {
    pub v2x_bandwidth_class_rx_sl_r14: V2X_BandwidthClassSL_r14,
    #[asn(optional_idx = 0)]
    pub v2x_high_reception_r14: Option<BandParametersRxSL_r14V2x_HighReception_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct BandParametersTxSL_r14 {
    pub v2x_bandwidth_class_tx_sl_r14: V2X_BandwidthClassSL_r14,
    #[asn(optional_idx = 0)]
    pub v2x_e_nb_scheduled_r14: Option<BandParametersTxSL_r14V2x_eNB_Scheduled_r14>,
    #[asn(optional_idx = 1)]
    pub v2x_high_power_r14: Option<BandParametersTxSL_r14V2x_HighPower_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct BandParametersUL_r10(pub Vec<CA_MIMO_ParametersUL_r10>);

pub type BandParametersUL_r13 = CA_MIMO_ParametersUL_r10;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "31")]
pub struct BandclassCDMA2000(pub u8);
impl BandclassCDMA2000 {
    pub const BC0: u8 = 0u8;
    pub const BC1: u8 = 1u8;
    pub const BC2: u8 = 2u8;
    pub const BC3: u8 = 3u8;
    pub const BC4: u8 = 4u8;
    pub const BC5: u8 = 5u8;
    pub const BC6: u8 = 6u8;
    pub const BC7: u8 = 7u8;
    pub const BC8: u8 = 8u8;
    pub const BC9: u8 = 9u8;
    pub const BC10: u8 = 10u8;
    pub const BC11: u8 = 11u8;
    pub const BC12: u8 = 12u8;
    pub const BC13: u8 = 13u8;
    pub const BC14: u8 = 14u8;
    pub const BC15: u8 = 15u8;
    pub const BC16: u8 = 16u8;
    pub const BC17: u8 = 17u8;
    pub const BC18_V9A0: u8 = 18u8;
    pub const BC19_V9A0: u8 = 19u8;
    pub const BC20_V9A0: u8 = 20u8;
    pub const BC21_V9A0: u8 = 21u8;
    pub const SPARE10: u8 = 22u8;
    pub const SPARE9: u8 = 23u8;
    pub const SPARE8: u8 = 24u8;
    pub const SPARE7: u8 = 25u8;
    pub const SPARE6: u8 = 26u8;
    pub const SPARE5: u8 = 27u8;
    pub const SPARE4: u8 = 28u8;
    pub const SPARE3: u8 = 29u8;
    pub const SPARE2: u8 = 30u8;
    pub const SPARE1: u8 = 31u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct BarringPerACDC_Category_r13 {
    pub acdc_category_r13: BarringPerACDC_Category_r13Acdc_Category_r13,
    #[asn(optional_idx = 0)]
    pub acdc_barring_config_r13: Option<BarringPerACDC_Category_r13Acdc_BarringConfig_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct BarringPerACDC_CategoryList_r13(pub Vec<BarringPerACDC_Category_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BeamMeasConfigIdleNR_r16 {
    pub report_quantity_rs_index_nr_r16: BeamMeasConfigIdleNR_r16ReportQuantityRS_IndexNR_r16,
    pub max_report_rs_index_r16: BeamMeasConfigIdleNR_r16MaxReportRS_Index_r16,
    pub report_rs_index_results_nr_r16: BeamMeasConfigIdleNR_r16ReportRS_IndexResultsNR_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct C_RNTI(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct CA_BandwidthClass_r10(pub u8);
impl CA_BandwidthClass_r10 {
    pub const A: u8 = 0u8;
    pub const B: u8 = 1u8;
    pub const C: u8 = 2u8;
    pub const D: u8 = 3u8;
    pub const E: u8 = 4u8;
    pub const F: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CA_MIMO_ParametersDL_r10 {
    pub ca_bandwidth_class_dl_r10: CA_BandwidthClass_r10,
    #[asn(optional_idx = 0)]
    pub supported_mimo_capability_dl_r10: Option<MIMO_CapabilityDL_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CA_MIMO_ParametersDL_r13 {
    pub ca_bandwidth_class_dl_r13: CA_BandwidthClass_r10,
    #[asn(optional_idx = 0)]
    pub supported_mimo_capability_dl_r13: Option<MIMO_CapabilityDL_r10>,
    #[asn(optional_idx = 1)]
    pub four_layer_tm3_tm4_r13: Option<CA_MIMO_ParametersDL_r13FourLayerTM3_TM4_r13>,
    pub intra_band_contiguous_cc_info_list_r13:
        CA_MIMO_ParametersDL_r13IntraBandContiguousCC_InfoList_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct CA_MIMO_ParametersDL_r15 {
    #[asn(optional_idx = 0)]
    pub supported_mimo_capability_dl_r15: Option<MIMO_CapabilityDL_r10>,
    #[asn(optional_idx = 1)]
    pub four_layer_tm3_tm4_r15: Option<CA_MIMO_ParametersDL_r15FourLayerTM3_TM4_r15>,
    #[asn(optional_idx = 2)]
    pub intra_band_contiguous_cc_info_list_r15:
        Option<CA_MIMO_ParametersDL_r15IntraBandContiguousCC_InfoList_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CA_MIMO_ParametersDL_v10i0 {
    #[asn(optional_idx = 0)]
    pub four_layer_tm3_tm4_r10: Option<CA_MIMO_ParametersDL_v10i0FourLayerTM3_TM4_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CA_MIMO_ParametersDL_v1270 {
    pub intra_band_contiguous_cc_info_list_r12:
        CA_MIMO_ParametersDL_v1270IntraBandContiguousCC_InfoList_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CA_MIMO_ParametersUL_r10 {
    pub ca_bandwidth_class_ul_r10: CA_BandwidthClass_r10,
    #[asn(optional_idx = 0)]
    pub supported_mimo_capability_ul_r10: Option<MIMO_CapabilityUL_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CA_MIMO_ParametersUL_r15 {
    #[asn(optional_idx = 0)]
    pub supported_mimo_capability_ul_r15: Option<MIMO_CapabilityUL_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct CDMA2000_Type(pub u8);
impl CDMA2000_Type {
    pub const TYPE1_XRTT: u8 = 0u8;
    pub const TYPE_HRPD: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 10)]
pub struct CE_MultiTB_Parameters_r16 {
    #[asn(optional_idx = 0)]
    pub pdsch_multi_tb_ce_mode_a_r16: Option<CE_MultiTB_Parameters_r16Pdsch_MultiTB_CE_ModeA_r16>,
    #[asn(optional_idx = 1)]
    pub pdsch_multi_tb_ce_mode_b_r16: Option<CE_MultiTB_Parameters_r16Pdsch_MultiTB_CE_ModeB_r16>,
    #[asn(optional_idx = 2)]
    pub pusch_multi_tb_ce_mode_a_r16: Option<CE_MultiTB_Parameters_r16Pusch_MultiTB_CE_ModeA_r16>,
    #[asn(optional_idx = 3)]
    pub pusch_multi_tb_ce_mode_b_r16: Option<CE_MultiTB_Parameters_r16Pusch_MultiTB_CE_ModeB_r16>,
    #[asn(optional_idx = 4)]
    pub ce_multi_tb_64qam_r16: Option<CE_MultiTB_Parameters_r16Ce_MultiTB_64QAM_r16>,
    #[asn(optional_idx = 5)]
    pub ce_multi_tb_early_termination_r16:
        Option<CE_MultiTB_Parameters_r16Ce_MultiTB_EarlyTermination_r16>,
    #[asn(optional_idx = 6)]
    pub ce_multi_tb_frequency_hopping_r16:
        Option<CE_MultiTB_Parameters_r16Ce_MultiTB_FrequencyHopping_r16>,
    #[asn(optional_idx = 7)]
    pub ce_multi_tb_harq_ack_bundling_r16:
        Option<CE_MultiTB_Parameters_r16Ce_MultiTB_HARQ_AckBundling_r16>,
    #[asn(optional_idx = 8)]
    pub ce_multi_tb_interleaving_r16: Option<CE_MultiTB_Parameters_r16Ce_MultiTB_Interleaving_r16>,
    #[asn(optional_idx = 9)]
    pub ce_multi_tb_sub_prb_r16: Option<CE_MultiTB_Parameters_r16Ce_MultiTB_SubPRB_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CE_PDSCH_14HARQ_Config_r17 {
    pub ce_harq_ack_delay_r17: CE_PDSCH_14HARQ_Config_r17Ce_HARQ_AckDelay_r17,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CE_PDSCH_MultiTB_Config_r16 {
    #[asn(optional_idx = 0)]
    pub interleaving_r16: Option<CE_PDSCH_MultiTB_Config_r16Interleaving_r16>,
    #[asn(optional_idx = 1)]
    pub harq_ack_bundling_r16: Option<CE_PDSCH_MultiTB_Config_r16Harq_AckBundling_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CE_PUSCH_MultiTB_Config_r16 {
    #[asn(optional_idx = 0)]
    pub interleaving_r16: Option<CE_PUSCH_MultiTB_Config_r16Interleaving_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CE_Parameters_r13 {
    #[asn(optional_idx = 0)]
    pub ce_mode_a_r13: Option<CE_Parameters_r13Ce_ModeA_r13>,
    #[asn(optional_idx = 1)]
    pub ce_mode_b_r13: Option<CE_Parameters_r13Ce_ModeB_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct CE_Parameters_v1320 {
    #[asn(optional_idx = 0)]
    pub intra_freq_a3_ce_mode_a_r13: Option<CE_Parameters_v1320IntraFreqA3_CE_ModeA_r13>,
    #[asn(optional_idx = 1)]
    pub intra_freq_a3_ce_mode_b_r13: Option<CE_Parameters_v1320IntraFreqA3_CE_ModeB_r13>,
    #[asn(optional_idx = 2)]
    pub intra_freq_ho_ce_mode_a_r13: Option<CE_Parameters_v1320IntraFreqHO_CE_ModeA_r13>,
    #[asn(optional_idx = 3)]
    pub intra_freq_ho_ce_mode_b_r13: Option<CE_Parameters_v1320IntraFreqHO_CE_ModeB_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CE_Parameters_v1350 {
    #[asn(optional_idx = 0)]
    pub unicast_frequency_hopping_r13: Option<CE_Parameters_v1350UnicastFrequencyHopping_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CE_Parameters_v1370 {
    #[asn(optional_idx = 0)]
    pub tm9_ce_mode_a_r13: Option<CE_Parameters_v1370Tm9_CE_ModeA_r13>,
    #[asn(optional_idx = 1)]
    pub tm9_ce_mode_b_r13: Option<CE_Parameters_v1370Tm9_CE_ModeB_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CE_Parameters_v1380 {
    #[asn(optional_idx = 0)]
    pub tm6_ce_mode_a_r13: Option<CE_Parameters_v1380Tm6_CE_ModeA_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CE_Parameters_v1430 {
    #[asn(optional_idx = 0)]
    pub ce_switch_without_ho_r14: Option<CE_Parameters_v1430Ce_SwitchWithoutHO_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 10)]
pub struct CE_ResourceResvParameters_r16 {
    #[asn(optional_idx = 0)]
    pub subframe_resource_resv_dl_ce_mode_a_r16:
        Option<CE_ResourceResvParameters_r16SubframeResourceResvDL_CE_ModeA_r16>,
    #[asn(optional_idx = 1)]
    pub subframe_resource_resv_dl_ce_mode_b_r16:
        Option<CE_ResourceResvParameters_r16SubframeResourceResvDL_CE_ModeB_r16>,
    #[asn(optional_idx = 2)]
    pub subframe_resource_resv_ul_ce_mode_a_r16:
        Option<CE_ResourceResvParameters_r16SubframeResourceResvUL_CE_ModeA_r16>,
    #[asn(optional_idx = 3)]
    pub subframe_resource_resv_ul_ce_mode_b_r16:
        Option<CE_ResourceResvParameters_r16SubframeResourceResvUL_CE_ModeB_r16>,
    #[asn(optional_idx = 4)]
    pub slot_symbol_resource_resv_dl_ce_mode_a_r16:
        Option<CE_ResourceResvParameters_r16SlotSymbolResourceResvDL_CE_ModeA_r16>,
    #[asn(optional_idx = 5)]
    pub slot_symbol_resource_resv_dl_ce_mode_b_r16:
        Option<CE_ResourceResvParameters_r16SlotSymbolResourceResvDL_CE_ModeB_r16>,
    #[asn(optional_idx = 6)]
    pub slot_symbol_resource_resv_ul_ce_mode_a_r16:
        Option<CE_ResourceResvParameters_r16SlotSymbolResourceResvUL_CE_ModeA_r16>,
    #[asn(optional_idx = 7)]
    pub slot_symbol_resource_resv_ul_ce_mode_b_r16:
        Option<CE_ResourceResvParameters_r16SlotSymbolResourceResvUL_CE_ModeB_r16>,
    #[asn(optional_idx = 8)]
    pub subcarrier_puncturing_ce_mode_a_r16:
        Option<CE_ResourceResvParameters_r16SubcarrierPuncturingCE_ModeA_r16>,
    #[asn(optional_idx = 9)]
    pub subcarrier_puncturing_ce_mode_b_r16:
        Option<CE_ResourceResvParameters_r16SubcarrierPuncturingCE_ModeB_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct CFI_Config_r15 {
    #[asn(optional_idx = 0)]
    pub cfi_subframe_non_mbsfn_r15: Option<CFI_Config_r15Cfi_SubframeNonMBSFN_r15>,
    #[asn(optional_idx = 1)]
    pub cfi_slot_subslot_non_mbsfn_r15: Option<CFI_Config_r15Cfi_SlotSubslotNonMBSFN_r15>,
    #[asn(optional_idx = 2)]
    pub cfi_subframe_mbsfn_r15: Option<CFI_Config_r15Cfi_SubframeMBSFN_r15>,
    #[asn(optional_idx = 3)]
    pub cfi_slot_subslot_mbsfn_r15: Option<CFI_Config_r15Cfi_SlotSubslotMBSFN_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CFI_PatternConfig_r15 {
    #[asn(optional_idx = 0)]
    pub cfi_pattern_subframe_r15: Option<CFI_PatternConfig_r15Cfi_PatternSubframe_r15>,
    #[asn(optional_idx = 1)]
    pub cfi_pattern_slot_subslot_r15: Option<CFI_PatternConfig_r15Cfi_PatternSlotSubslot_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct CGI_InfoNR_r15 {
    #[asn(optional_idx = 0)]
    pub plmn_identity_info_list_r15: Option<PLMN_IdentityInfoListNR_r15>,
    #[asn(optional_idx = 1)]
    pub frequency_band_list_r15: Option<MultiFrequencyBandListNR_r15>,
    #[asn(optional_idx = 2)]
    pub no_sib1_r15: Option<CGI_InfoNR_r15NoSIB1_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct CIOT_EPS_OptimisationInfo_r13(pub Vec<CIOT_OptimisationPLMN_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct CIOT_OptimisationPLMN_r13 {
    #[asn(optional_idx = 0)]
    pub up_c_io_t_eps_optimisation_r13:
        Option<CIOT_OptimisationPLMN_r13Up_CIoT_EPS_Optimisation_r13>,
    #[asn(optional_idx = 1)]
    pub cp_c_io_t_eps_optimisation_r13:
        Option<CIOT_OptimisationPLMN_r13Cp_CIoT_EPS_Optimisation_r13>,
    #[asn(optional_idx = 2)]
    pub attach_without_pdn_connectivity_r13:
        Option<CIOT_OptimisationPLMN_r13AttachWithoutPDN_Connectivity_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CQI_ReportAperiodic_r10 {
    #[asn(key = 0, extended = false)]
    Release(CQI_ReportAperiodic_r10_release),
    #[asn(key = 1, extended = false)]
    Setup(CQI_ReportAperiodic_r10_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CQI_ReportAperiodic_v1250 {
    #[asn(key = 0, extended = false)]
    Release(CQI_ReportAperiodic_v1250_release),
    #[asn(key = 1, extended = false)]
    Setup(CQI_ReportAperiodic_v1250_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CQI_ReportAperiodic_v1310 {
    #[asn(key = 0, extended = false)]
    Release(CQI_ReportAperiodic_v1310_release),
    #[asn(key = 1, extended = false)]
    Setup(CQI_ReportAperiodic_v1310_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CQI_ReportAperiodicHybrid_r14 {
    #[asn(optional_idx = 0)]
    pub triggers_r14: Option<CQI_ReportAperiodicHybrid_r14Triggers_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CQI_ReportAperiodicProc_r11 {
    pub cqi_report_mode_aperiodic_r11: CQI_ReportModeAperiodic,
    pub trigger01_r11: CQI_ReportAperiodicProc_r11Trigger01_r11,
    pub trigger10_r11: CQI_ReportAperiodicProc_r11Trigger10_r11,
    pub trigger11_r11: CQI_ReportAperiodicProc_r11Trigger11_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CQI_ReportAperiodicProc_v1310 {
    pub trigger001_r13: CQI_ReportAperiodicProc_v1310Trigger001_r13,
    pub trigger010_r13: CQI_ReportAperiodicProc_v1310Trigger010_r13,
    pub trigger011_r13: CQI_ReportAperiodicProc_v1310Trigger011_r13,
    pub trigger100_r13: CQI_ReportAperiodicProc_v1310Trigger100_r13,
    pub trigger101_r13: CQI_ReportAperiodicProc_v1310Trigger101_r13,
    pub trigger110_r13: CQI_ReportAperiodicProc_v1310Trigger110_r13,
    pub trigger111_r13: CQI_ReportAperiodicProc_v1310Trigger111_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct CQI_ReportBoth_r11 {
    #[asn(optional_idx = 0)]
    pub csi_im_config_to_release_list_r11: Option<CSI_IM_ConfigToReleaseList_r11>,
    #[asn(optional_idx = 1)]
    pub csi_im_config_to_add_mod_list_r11: Option<CSI_IM_ConfigToAddModList_r11>,
    #[asn(optional_idx = 2)]
    pub csi_process_to_release_list_r11: Option<CSI_ProcessToReleaseList_r11>,
    #[asn(optional_idx = 3)]
    pub csi_process_to_add_mod_list_r11: Option<CSI_ProcessToAddModList_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CQI_ReportBoth_v1250 {
    #[asn(optional_idx = 0)]
    pub csi_im_config_to_release_list_ext_r12: Option<CSI_IM_ConfigId_v1250>,
    #[asn(optional_idx = 1)]
    pub csi_im_config_to_add_mod_list_ext_r12: Option<CSI_IM_ConfigExt_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CQI_ReportBoth_v1310 {
    #[asn(optional_idx = 0)]
    pub csi_im_config_to_release_list_ext_r13: Option<CSI_IM_ConfigToReleaseListExt_r13>,
    #[asn(optional_idx = 1)]
    pub csi_im_config_to_add_mod_list_ext_r13: Option<CSI_IM_ConfigToAddModListExt_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CQI_ReportBothProc_r11 {
    #[asn(optional_idx = 0)]
    pub ri_ref_csi_process_id_r11: Option<CSI_ProcessId_r11>,
    #[asn(optional_idx = 1)]
    pub pmi_ri_report_r11: Option<CQI_ReportBothProc_r11Pmi_RI_Report_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CQI_ReportConfig {
    #[asn(optional_idx = 0)]
    pub cqi_report_mode_aperiodic: Option<CQI_ReportModeAperiodic>,
    pub nom_pdsch_rs_epre_offset: CQI_ReportConfigNomPDSCH_RS_EPRE_Offset,
    #[asn(optional_idx = 1)]
    pub cqi_report_periodic: Option<CQI_ReportPeriodic>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct CQI_ReportConfig_r10 {
    #[asn(optional_idx = 0)]
    pub cqi_report_aperiodic_r10: Option<CQI_ReportAperiodic_r10>,
    pub nom_pdsch_rs_epre_offset: CQI_ReportConfig_r10NomPDSCH_RS_EPRE_Offset,
    #[asn(optional_idx = 1)]
    pub cqi_report_periodic_r10: Option<CQI_ReportPeriodic_r10>,
    #[asn(optional_idx = 2)]
    pub pmi_ri_report_r9: Option<CQI_ReportConfig_r10Pmi_RI_Report_r9>,
    #[asn(optional_idx = 3)]
    pub csi_subframe_pattern_config_r10: Option<CQI_ReportConfig_r10Csi_SubframePatternConfig_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CQI_ReportConfig_r15 {
    #[asn(key = 0, extended = false)]
    Release(CQI_ReportConfig_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(CQI_ReportConfig_r15_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CQI_ReportConfig_v1130 {
    pub cqi_report_periodic_v1130: CQI_ReportPeriodic_v1130,
    pub cqi_report_both_r11: CQI_ReportBoth_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct CQI_ReportConfig_v1250 {
    #[asn(optional_idx = 0)]
    pub csi_subframe_pattern_config_r12:
        Option<CQI_ReportConfig_v1250Csi_SubframePatternConfig_r12>,
    #[asn(optional_idx = 1)]
    pub cqi_report_both_v1250: Option<CQI_ReportBoth_v1250>,
    #[asn(optional_idx = 2)]
    pub cqi_report_aperiodic_v1250: Option<CQI_ReportAperiodic_v1250>,
    #[asn(optional_idx = 3)]
    pub alt_cqi_table_r12: Option<CQI_ReportConfig_v1250AltCQI_Table_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct CQI_ReportConfig_v1310 {
    #[asn(optional_idx = 0)]
    pub cqi_report_both_v1310: Option<CQI_ReportBoth_v1310>,
    #[asn(optional_idx = 1)]
    pub cqi_report_aperiodic_v1310: Option<CQI_ReportAperiodic_v1310>,
    #[asn(optional_idx = 2)]
    pub cqi_report_periodic_v1310: Option<CQI_ReportPeriodic_v1310>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CQI_ReportConfig_v1320 {
    #[asn(optional_idx = 0)]
    pub cqi_report_periodic_v1320: Option<CQI_ReportPeriodic_v1320>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CQI_ReportConfig_v1430 {
    #[asn(optional_idx = 0)]
    pub cqi_report_aperiodic_hybrid_r14: Option<CQI_ReportAperiodicHybrid_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CQI_ReportConfig_v1530 {
    #[asn(optional_idx = 0)]
    pub alt_cqi_table_1024qam_r15: Option<CQI_ReportConfig_v1530AltCQI_Table_1024QAM_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CQI_ReportConfig_v920 {
    #[asn(optional_idx = 0)]
    pub cqi_mask_r9: Option<CQI_ReportConfig_v920Cqi_Mask_r9>,
    #[asn(optional_idx = 1)]
    pub pmi_ri_report_r9: Option<CQI_ReportConfig_v920Pmi_RI_Report_r9>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct CQI_ReportConfigSCell_r10 {
    #[asn(optional_idx = 0)]
    pub cqi_report_mode_aperiodic_r10: Option<CQI_ReportModeAperiodic>,
    pub nom_pdsch_rs_epre_offset_r10: CQI_ReportConfigSCell_r10NomPDSCH_RS_EPRE_Offset_r10,
    #[asn(optional_idx = 1)]
    pub cqi_report_periodic_s_cell_r10: Option<CQI_ReportPeriodic_r10>,
    #[asn(optional_idx = 2)]
    pub pmi_ri_report_r10: Option<CQI_ReportConfigSCell_r10Pmi_RI_Report_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CQI_ReportConfigSCell_r15 {
    #[asn(optional_idx = 0)]
    pub cqi_report_periodic_s_cell_r15: Option<CQI_ReportPeriodicSCell_r15>,
    #[asn(optional_idx = 1)]
    pub alt_cqi_table_1024qam_r15: Option<CQI_ReportConfigSCell_r15AltCQI_Table_1024QAM_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct CQI_ReportModeAperiodic(pub u8);
impl CQI_ReportModeAperiodic {
    pub const RM12: u8 = 0u8;
    pub const RM20: u8 = 1u8;
    pub const RM22: u8 = 2u8;
    pub const RM30: u8 = 3u8;
    pub const RM31: u8 = 4u8;
    pub const RM32_V1250: u8 = 5u8;
    pub const RM10_V1310: u8 = 6u8;
    pub const RM11_V1310: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CQI_ReportPeriodic {
    #[asn(key = 0, extended = false)]
    Release(CQI_ReportPeriodic_release),
    #[asn(key = 1, extended = false)]
    Setup(CQI_ReportPeriodic_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CQI_ReportPeriodic_r10 {
    #[asn(key = 0, extended = false)]
    Release(CQI_ReportPeriodic_r10_release),
    #[asn(key = 1, extended = false)]
    Setup(CQI_ReportPeriodic_r10_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct CQI_ReportPeriodic_v1130 {
    #[asn(optional_idx = 0)]
    pub simultaneous_ack_nack_and_cqi_format3_r11:
        Option<CQI_ReportPeriodic_v1130SimultaneousAckNackAndCQI_Format3_r11>,
    #[asn(optional_idx = 1)]
    pub cqi_report_periodic_proc_ext_to_release_list_r11:
        Option<CQI_ReportPeriodicProcExtToReleaseList_r11>,
    #[asn(optional_idx = 2)]
    pub cqi_report_periodic_proc_ext_to_add_mod_list_r11:
        Option<CQI_ReportPeriodicProcExtToAddModList_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CQI_ReportPeriodic_v1310 {
    #[asn(optional_idx = 0)]
    pub cri_report_config_r13: Option<CRI_ReportConfig_r13>,
    #[asn(optional_idx = 1)]
    pub simultaneous_ack_nack_and_cqi_format4_format5_r13:
        Option<CQI_ReportPeriodic_v1310SimultaneousAckNackAndCQI_Format4_Format5_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CQI_ReportPeriodic_v1320 {
    #[asn(optional_idx = 0)]
    pub periodicity_factor_wb_r13: Option<CQI_ReportPeriodic_v1320PeriodicityFactorWB_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct CQI_ReportPeriodicProcExt_r11 {
    pub cqi_report_periodic_proc_ext_id_r11: CQI_ReportPeriodicProcExtId_r11,
    pub cqi_pmi_config_index_r11: CQI_ReportPeriodicProcExt_r11Cqi_pmi_ConfigIndex_r11,
    pub cqi_format_indicator_periodic_r11:
        CQI_ReportPeriodicProcExt_r11Cqi_FormatIndicatorPeriodic_r11,
    #[asn(optional_idx = 0)]
    pub ri_config_index_r11: Option<CQI_ReportPeriodicProcExt_r11Ri_ConfigIndex_r11>,
    #[asn(optional_idx = 1)]
    pub csi_config_index_r11: Option<CQI_ReportPeriodicProcExt_r11Csi_ConfigIndex_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "3")]
pub struct CQI_ReportPeriodicProcExtId_r11(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct CQI_ReportPeriodicProcExtToAddModList_r11(pub Vec<CQI_ReportPeriodicProcExt_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct CQI_ReportPeriodicProcExtToReleaseList_r11(pub Vec<CQI_ReportPeriodicProcExtId_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CQI_ReportPeriodicSCell_r15 {
    #[asn(key = 0, extended = false)]
    Release(CQI_ReportPeriodicSCell_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(CQI_ReportPeriodicSCell_r15_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CQI_ReportPeriodicSCell_v1730 {
    pub cqi_pmi_config_index2_dormant_r17:
        CQI_ReportPeriodicSCell_v1730Cqi_pmi_ConfigIndex2Dormant_r17,
    #[asn(optional_idx = 0)]
    pub ri_config_index2_dormant_r17:
        Option<CQI_ReportPeriodicSCell_v1730Ri_ConfigIndex2Dormant_r17>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CQI_ShortConfigSCell_r15 {
    #[asn(key = 0, extended = false)]
    Release(CQI_ShortConfigSCell_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(CQI_ShortConfigSCell_r15_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct CRI_ConfigIndex_r13(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CRI_ReportConfig_r13 {
    #[asn(key = 0, extended = false)]
    Release(CRI_ReportConfig_r13_release),
    #[asn(key = 1, extended = false)]
    Setup(CRI_ReportConfig_r13_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct CRS_AssistanceInfo_r11 {
    pub phys_cell_id_r11: PhysCellId,
    pub antenna_ports_count_r11: CRS_AssistanceInfo_r11AntennaPortsCount_r11,
    pub mbsfn_subframe_config_list_r11: MBSFN_SubframeConfigList,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CRS_AssistanceInfo_r13 {
    pub phys_cell_id_r13: PhysCellId,
    pub antenna_ports_count_r13: CRS_AssistanceInfo_r13AntennaPortsCount_r13,
    #[asn(optional_idx = 0)]
    pub mbsfn_subframe_config_list_r13: Option<MBSFN_SubframeConfigList>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CRS_AssistanceInfo_r15 {
    pub phys_cell_id_r15: PhysCellId,
    #[asn(optional_idx = 0)]
    pub crs_intf_mitig_enabled_r15: Option<CRS_AssistanceInfo_r15Crs_IntfMitigEnabled_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CRS_AssistanceInfoList_r11(pub Vec<CRS_AssistanceInfo_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CRS_AssistanceInfoList_r13(pub Vec<CRS_AssistanceInfo_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CRS_AssistanceInfoList_r15(pub Vec<CRS_AssistanceInfo_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CRS_ChEstMPDCCH_ConfigCommon_r16 {
    pub power_ratio_r16: CRS_ChEstMPDCCH_ConfigCommon_r16PowerRatio_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CRS_ChEstMPDCCH_ConfigDedicated_r16 {
    #[asn(optional_idx = 0)]
    pub power_ratio_r16: Option<CRS_ChEstMPDCCH_ConfigDedicated_r16PowerRatio_r16>,
    #[asn(optional_idx = 1)]
    pub localized_mapping_type_r16:
        Option<CRS_ChEstMPDCCH_ConfigDedicated_r16LocalizedMappingType_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CSFB_RegistrationParam1XRTT {
    pub sid: CSFB_RegistrationParam1XRTTSid,
    pub nid: CSFB_RegistrationParam1XRTTNid,
    pub multiple_sid: CSFB_RegistrationParam1XRTTMultipleSID,
    pub multiple_nid: CSFB_RegistrationParam1XRTTMultipleNID,
    pub home_reg: CSFB_RegistrationParam1XRTTHomeReg,
    pub foreign_sid_reg: CSFB_RegistrationParam1XRTTForeignSIDReg,
    pub foreign_nid_reg: CSFB_RegistrationParam1XRTTForeignNIDReg,
    pub parameter_reg: CSFB_RegistrationParam1XRTTParameterReg,
    pub power_up_reg: CSFB_RegistrationParam1XRTTPowerUpReg,
    pub registration_period: CSFB_RegistrationParam1XRTTRegistrationPeriod,
    pub registration_zone: CSFB_RegistrationParam1XRTTRegistrationZone,
    pub total_zone: CSFB_RegistrationParam1XRTTTotalZone,
    pub zone_timer: CSFB_RegistrationParam1XRTTZoneTimer,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CSFB_RegistrationParam1XRTT_v920 {
    pub power_down_reg_r9: CSFB_RegistrationParam1XRTT_v920PowerDownReg_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CSFBParametersRequestCDMA2000 {
    pub critical_extensions: CSFBParametersRequestCDMA2000CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CSFBParametersRequestCDMA2000_r8_IEs {
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<CSFBParametersRequestCDMA2000_v8a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CSFBParametersRequestCDMA2000_v8a0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<CSFBParametersRequestCDMA2000_v8a0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<CSFBParametersRequestCDMA2000_v8a0_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CSFBParametersResponseCDMA2000 {
    pub rrc_transaction_identifier: RRC_TransactionIdentifier,
    pub critical_extensions: CSFBParametersResponseCDMA2000CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CSFBParametersResponseCDMA2000_r8_IEs {
    pub rand: RAND_CDMA2000,
    pub mobility_parameters: MobilityParametersCDMA2000,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<CSFBParametersResponseCDMA2000_v8a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CSFBParametersResponseCDMA2000_v8a0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<CSFBParametersResponseCDMA2000_v8a0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<CSFBParametersResponseCDMA2000_v8a0_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CSG_AllowedReportingCells_r9 {
    #[asn(optional_idx = 0)]
    pub phys_cell_id_range_utra_fdd_list_r9: Option<PhysCellIdRangeUTRA_FDDList_r9>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "27", sz_ub = "27")]
pub struct CSG_Identity(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct CSG_ProximityIndicationParameters_r9 {
    #[asn(optional_idx = 0)]
    pub intra_freq_proximity_indication_r9:
        Option<CSG_ProximityIndicationParameters_r9IntraFreqProximityIndication_r9>,
    #[asn(optional_idx = 1)]
    pub inter_freq_proximity_indication_r9:
        Option<CSG_ProximityIndicationParameters_r9InterFreqProximityIndication_r9>,
    #[asn(optional_idx = 2)]
    pub utran_proximity_indication_r9:
        Option<CSG_ProximityIndicationParameters_r9Utran_ProximityIndication_r9>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct CSI_IM_Config_r11 {
    pub csi_im_config_id_r11: CSI_IM_ConfigId_r11,
    pub resource_config_r11: CSI_IM_Config_r11ResourceConfig_r11,
    pub subframe_config_r11: CSI_IM_Config_r11SubframeConfig_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct CSI_IM_ConfigExt_r12 {
    pub csi_im_config_id_v1250: CSI_IM_ConfigId_v1250,
    pub resource_config_r12: CSI_IM_ConfigExt_r12ResourceConfig_r12,
    pub subframe_config_r12: CSI_IM_ConfigExt_r12SubframeConfig_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "3")]
pub struct CSI_IM_ConfigId_r11(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4")]
pub struct CSI_IM_ConfigId_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "24")]
pub struct CSI_IM_ConfigId_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "4", ub = "4")]
pub struct CSI_IM_ConfigId_v1250(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "5", ub = "24")]
pub struct CSI_IM_ConfigId_v1310(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct CSI_IM_ConfigToAddModList_r11(pub Vec<CSI_IM_Config_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "20")]
pub struct CSI_IM_ConfigToAddModListExt_r13(pub Vec<CSI_IM_ConfigExt_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct CSI_IM_ConfigToReleaseList_r11(pub Vec<CSI_IM_ConfigId_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "20")]
pub struct CSI_IM_ConfigToReleaseListExt_r13(pub Vec<CSI_IM_ConfigId_v1310>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct CSI_Process_r11 {
    pub csi_process_id_r11: CSI_ProcessId_r11,
    pub csi_rs_config_nzp_id_r11: CSI_RS_ConfigNZPId_r11,
    pub csi_im_config_id_r11: CSI_IM_ConfigId_r11,
    pub p_c_and_cbsr_list_r11: P_C_AndCBSR_Pair_r13a,
    #[asn(optional_idx = 0)]
    pub cqi_report_both_proc_r11: Option<CQI_ReportBothProc_r11>,
    #[asn(optional_idx = 1)]
    pub cqi_report_periodic_proc_id_r11: Option<CSI_Process_r11Cqi_ReportPeriodicProcId_r11>,
    #[asn(optional_idx = 2)]
    pub cqi_report_aperiodic_proc_r11: Option<CQI_ReportAperiodicProc_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4")]
pub struct CSI_ProcessId_r11(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct CSI_ProcessToAddModList_r11(pub Vec<CSI_Process_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct CSI_ProcessToReleaseList_r11(pub Vec<CSI_ProcessId_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CSI_RS_Config_NZP_v1430 {
    #[asn(optional_idx = 0)]
    pub transmission_comb_r14: Option<NZP_TransmissionComb_r14>,
    #[asn(optional_idx = 1)]
    pub frequency_density_r14: Option<NZP_FrequencyDensity_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CSI_RS_Config_r10 {
    #[asn(optional_idx = 0)]
    pub csi_rs_r10: Option<CSI_RS_Config_r10Csi_RS_r10>,
    #[asn(optional_idx = 1)]
    pub zero_tx_power_csi_rs_r10: Option<ZeroTxPowerCSI_RS_Conf_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CSI_RS_Config_r15 {
    #[asn(key = 0, extended = false)]
    Release(CSI_RS_Config_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(CSI_RS_Config_r15_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CSI_RS_Config_v1250 {
    #[asn(optional_idx = 0)]
    pub zero_tx_power_csi_rs2_r12: Option<ZeroTxPowerCSI_RS_Conf_r12>,
    #[asn(optional_idx = 1)]
    pub ds_zero_tx_power_csi_rs_r12: Option<CSI_RS_Config_v1250Ds_ZeroTxPowerCSI_RS_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CSI_RS_Config_v1310 {
    #[asn(optional_idx = 0)]
    pub emimo_type_r13: Option<CSI_RS_ConfigEMIMO_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct CSI_RS_Config_v1430 {
    #[asn(optional_idx = 0)]
    pub dummy: Option<CSI_RS_ConfigEMIMO_v1430>,
    #[asn(optional_idx = 1)]
    pub emimo_hybrid_r14: Option<CSI_RS_ConfigEMIMO_Hybrid_r14>,
    #[asn(optional_idx = 2)]
    pub advanced_codebook_enabled_r14: Option<CSI_RS_Config_v1430AdvancedCodebookEnabled_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CSI_RS_Config_v1480 {
    #[asn(optional_idx = 0)]
    pub emimo_type_v1480: Option<CSI_RS_ConfigEMIMO_v1480>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CSI_RS_Config_v1530 {
    #[asn(optional_idx = 0)]
    pub emimo_type_v1530: Option<CSI_RS_ConfigEMIMO_v1530>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct CSI_RS_ConfigBeamformed_r13 {
    #[asn(optional_idx = 0)]
    pub csi_rs_config_nzp_id_list_ext_r13:
        Option<CSI_RS_ConfigBeamformed_r13Csi_RS_ConfigNZPIdListExt_r13>,
    #[asn(optional_idx = 1)]
    pub csi_im_config_id_list_r13: Option<CSI_RS_ConfigBeamformed_r13Csi_IM_ConfigIdList_r13>,
    #[asn(optional_idx = 2)]
    pub p_c_and_cbsr_per_resource_config_list_r13:
        Option<CSI_RS_ConfigBeamformed_r13P_C_AndCBSR_PerResourceConfigList_r13>,
    #[asn(optional_idx = 3)]
    pub ace_for4_tx_per_resource_config_list_r13:
        Option<CSI_RS_ConfigBeamformed_r13Ace_For4Tx_PerResourceConfigList_r13>,
    #[asn(optional_idx = 4)]
    pub alternative_codebook_enabled_beamformed_r13:
        Option<CSI_RS_ConfigBeamformed_r13AlternativeCodebookEnabledBeamformed_r13>,
    #[asn(optional_idx = 5)]
    pub channel_meas_restriction_r13: Option<CSI_RS_ConfigBeamformed_r13ChannelMeasRestriction_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 9)]
pub struct CSI_RS_ConfigBeamformed_r14 {
    #[asn(optional_idx = 0)]
    pub csi_rs_config_nzp_id_list_ext_r14:
        Option<CSI_RS_ConfigBeamformed_r14Csi_RS_ConfigNZPIdListExt_r14>,
    #[asn(optional_idx = 1)]
    pub csi_im_config_id_list_r14: Option<CSI_RS_ConfigBeamformed_r14Csi_IM_ConfigIdList_r14>,
    #[asn(optional_idx = 2)]
    pub p_c_and_cbsr_per_resource_config_list_r14:
        Option<CSI_RS_ConfigBeamformed_r14P_C_AndCBSR_PerResourceConfigList_r14>,
    #[asn(optional_idx = 3)]
    pub ace_for4_tx_per_resource_config_list_r14:
        Option<CSI_RS_ConfigBeamformed_r14Ace_For4Tx_PerResourceConfigList_r14>,
    #[asn(optional_idx = 4)]
    pub alternative_codebook_enabled_beamformed_r14:
        Option<CSI_RS_ConfigBeamformed_r14AlternativeCodebookEnabledBeamformed_r14>,
    #[asn(optional_idx = 5)]
    pub channel_meas_restriction_r14: Option<CSI_RS_ConfigBeamformed_r14ChannelMeasRestriction_r14>,
    #[asn(optional_idx = 6)]
    pub csi_rs_config_nzp_ap_list_r14:
        Option<CSI_RS_ConfigBeamformed_r14Csi_RS_ConfigNZP_ApList_r14>,
    #[asn(optional_idx = 7)]
    pub nzp_resource_config_original_v1430: Option<CSI_RS_Config_NZP_v1430>,
    #[asn(optional_idx = 8)]
    pub csi_rs_nzp_activation_r14: Option<CSI_RS_ConfigNZP_Activation_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct CSI_RS_ConfigBeamformed_v1430 {
    #[asn(optional_idx = 0)]
    pub csi_rs_config_nzp_ap_list_r14:
        Option<CSI_RS_ConfigBeamformed_v1430Csi_RS_ConfigNZP_ApList_r14>,
    #[asn(optional_idx = 1)]
    pub nzp_resource_config_original_v1430: Option<CSI_RS_Config_NZP_v1430>,
    #[asn(optional_idx = 2)]
    pub csi_rs_nzp_activation_r14: Option<CSI_RS_ConfigNZP_Activation_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CSI_RS_ConfigEMIMO_Hybrid_r14 {
    #[asn(key = 0, extended = false)]
    Release(CSI_RS_ConfigEMIMO_Hybrid_r14_release),
    #[asn(key = 1, extended = false)]
    Setup(CSI_RS_ConfigEMIMO_Hybrid_r14_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CSI_RS_ConfigEMIMO_r13 {
    #[asn(key = 0, extended = false)]
    Release(CSI_RS_ConfigEMIMO_r13_release),
    #[asn(key = 1, extended = false)]
    Setup(CSI_RS_ConfigEMIMO_r13_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CSI_RS_ConfigEMIMO_v1430 {
    #[asn(key = 0, extended = false)]
    Release(CSI_RS_ConfigEMIMO_v1430_release),
    #[asn(key = 1, extended = false)]
    Setup(CSI_RS_ConfigEMIMO_v1430_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CSI_RS_ConfigEMIMO_v1480 {
    #[asn(key = 0, extended = false)]
    Release(CSI_RS_ConfigEMIMO_v1480_release),
    #[asn(key = 1, extended = false)]
    Setup(CSI_RS_ConfigEMIMO_v1480_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CSI_RS_ConfigEMIMO_v1530 {
    #[asn(key = 0, extended = false)]
    Release(CSI_RS_ConfigEMIMO_v1530_release),
    #[asn(key = 1, extended = false)]
    Setup(CSI_RS_ConfigEMIMO_v1530_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CSI_RS_ConfigEMIMO2_r14 {
    #[asn(key = 0, extended = false)]
    Release(CSI_RS_ConfigEMIMO2_r14_release),
    #[asn(key = 1, extended = false)]
    Setup(CSI_RS_ConfigBeamformed_r14),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CSI_RS_ConfigNZP_Activation_r14 {
    pub csi_rs_nzp_mode_r14: CSI_RS_ConfigNZP_Activation_r14Csi_RS_NZP_mode_r14,
    pub activated_resources_r14: CSI_RS_ConfigNZP_Activation_r14ActivatedResources_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CSI_RS_ConfigNZP_EMIMO_r13 {
    #[asn(key = 0, extended = false)]
    Release(CSI_RS_ConfigNZP_EMIMO_r13_release),
    #[asn(key = 1, extended = false)]
    Setup(CSI_RS_ConfigNZP_EMIMO_r13_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CSI_RS_ConfigNZP_EMIMO_v1430 {
    pub nzp_resource_config_list_ext_r14: CSI_RS_ConfigNZP_EMIMO_v1430Nzp_resourceConfigListExt_r14,
    #[asn(optional_idx = 0)]
    pub cdm_type_v1430: Option<CSI_RS_ConfigNZP_EMIMO_v1430CdmType_v1430>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CSI_RS_ConfigNZP_r11 {
    pub csi_rs_config_nzp_id_r11: CSI_RS_ConfigNZPId_r11,
    pub antenna_ports_count_r11: CSI_RS_ConfigNZP_r11AntennaPortsCount_r11,
    pub resource_config_r11: CSI_RS_ConfigNZP_r11ResourceConfig_r11,
    pub subframe_config_r11: CSI_RS_ConfigNZP_r11SubframeConfig_r11,
    pub scrambling_identity_r11: CSI_RS_ConfigNZP_r11ScramblingIdentity_r11,
    #[asn(optional_idx = 0)]
    pub qcl_crs_info_r11: Option<CSI_RS_ConfigNZP_r11Qcl_CRS_Info_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "3")]
pub struct CSI_RS_ConfigNZPId_r11(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "24")]
pub struct CSI_RS_ConfigNZPId_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "4", ub = "24")]
pub struct CSI_RS_ConfigNZPId_v1310(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct CSI_RS_ConfigNZPToAddModList_r11(pub Vec<CSI_RS_ConfigNZP_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "24")]
pub struct CSI_RS_ConfigNZPToAddModList_r15(pub Vec<CSI_RS_ConfigNZP_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "21")]
pub struct CSI_RS_ConfigNZPToAddModListExt_r13(pub Vec<CSI_RS_ConfigNZP_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct CSI_RS_ConfigNZPToReleaseList_r11(pub Vec<CSI_RS_ConfigNZPId_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "24")]
pub struct CSI_RS_ConfigNZPToReleaseList_r15(pub Vec<CSI_RS_ConfigNZPId_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "21")]
pub struct CSI_RS_ConfigNZPToReleaseListExt_r13(pub Vec<CSI_RS_ConfigNZPId_v1310>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct CSI_RS_ConfigNonPrecoded_r13 {
    #[asn(optional_idx = 0)]
    pub p_c_and_cbsr_list_r13: Option<P_C_AndCBSR_Pair_r13>,
    pub codebook_config_n1_r13: CSI_RS_ConfigNonPrecoded_r13CodebookConfigN1_r13,
    pub codebook_config_n2_r13: CSI_RS_ConfigNonPrecoded_r13CodebookConfigN2_r13,
    #[asn(optional_idx = 1)]
    pub codebook_over_sampling_rate_config_o1_r13:
        Option<CSI_RS_ConfigNonPrecoded_r13CodebookOverSamplingRateConfig_O1_r13>,
    #[asn(optional_idx = 2)]
    pub codebook_over_sampling_rate_config_o2_r13:
        Option<CSI_RS_ConfigNonPrecoded_r13CodebookOverSamplingRateConfig_O2_r13>,
    pub codebook_config_r13: CSI_RS_ConfigNonPrecoded_r13CodebookConfig_r13,
    #[asn(optional_idx = 3)]
    pub csi_im_config_id_list_r13: Option<CSI_RS_ConfigNonPrecoded_r13Csi_IM_ConfigIdList_r13>,
    #[asn(optional_idx = 4)]
    pub csi_rs_config_nzp_emimo_r13: Option<CSI_RS_ConfigNZP_EMIMO_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CSI_RS_ConfigNonPrecoded_v1430 {
    #[asn(optional_idx = 0)]
    pub csi_rs_config_nzp_emimo_v1430: Option<CSI_RS_ConfigNZP_EMIMO_v1430>,
    pub codebook_config_n1_v1430: CSI_RS_ConfigNonPrecoded_v1430CodebookConfigN1_v1430,
    pub codebook_config_n2_v1430: CSI_RS_ConfigNonPrecoded_v1430CodebookConfigN2_v1430,
    pub nzp_resource_config_tm9_original_v1430: CSI_RS_Config_NZP_v1430,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct CSI_RS_ConfigNonPrecoded_v1480 {
    #[asn(optional_idx = 0)]
    pub csi_rs_config_nzp_emimo_v1480: Option<CSI_RS_ConfigNZP_EMIMO_v1430>,
    #[asn(optional_idx = 1)]
    pub codebook_config_n1_v1480: Option<CSI_RS_ConfigNonPrecoded_v1480CodebookConfigN1_v1480>,
    #[asn(optional_idx = 2)]
    pub codebook_config_n2_r1480: Option<CSI_RS_ConfigNonPrecoded_v1480CodebookConfigN2_r1480>,
    pub nzp_resource_config_tm9_original_v1480: CSI_RS_Config_NZP_v1430,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CSI_RS_ConfigNonPrecoded_v1530 {
    #[asn(optional_idx = 0)]
    pub p_c_and_cbsr_list_r15: Option<P_C_AndCBSR_Pair_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CSI_RS_ConfigZP_ApList_r14 {
    #[asn(key = 0, extended = false)]
    Release(CSI_RS_ConfigZP_ApList_r14_release),
    #[asn(key = 1, extended = false)]
    Setup(CSI_RS_ConfigZP_ApList_r14_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct CSI_RS_ConfigZP_r11 {
    pub csi_rs_config_zp_id_r11: CSI_RS_ConfigZPId_r11,
    pub resource_config_list_r11: CSI_RS_ConfigZP_r11ResourceConfigList_r11,
    pub subframe_config_r11: CSI_RS_ConfigZP_r11SubframeConfig_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4")]
pub struct CSI_RS_ConfigZPId_r11(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct CSI_RS_ConfigZPToAddModList_r11(pub Vec<CSI_RS_ConfigZP_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct CSI_RS_ConfigZPToReleaseList_r11(pub Vec<CSI_RS_ConfigZPId_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "96")]
pub struct CSI_RS_TriggeredList_r12(pub Vec<MeasCSI_RS_Id_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "97")]
pub struct CSI_RSRP_Range_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct CandidateCellInfo_r10 {
    pub phys_cell_id_r10: PhysCellId,
    pub dl_carrier_freq_r10: ARFCN_ValueEUTRA,
    #[asn(optional_idx = 0)]
    pub rsrp_result_r10: Option<RSRP_Range>,
    #[asn(optional_idx = 1)]
    pub rsrq_result_r10: Option<RSRQ_Range>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CandidateCellInfoList_r10(pub Vec<CandidateCellInfo_r10>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CandidateServingFreqListNR_r15(pub Vec<ARFCN_ValueNR_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CarrierBandwidthEUTRA {
    pub dl_bandwidth: CarrierBandwidthEUTRADl_Bandwidth,
    #[asn(optional_idx = 0)]
    pub ul_bandwidth: Option<CarrierBandwidthEUTRAUl_Bandwidth>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CarrierFreqCDMA2000 {
    pub band_class: BandclassCDMA2000,
    pub arfcn: ARFCN_ValueCDMA2000,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CarrierFreqEUTRA {
    pub dl_carrier_freq: ARFCN_ValueEUTRA,
    #[asn(optional_idx = 0)]
    pub ul_carrier_freq: Option<ARFCN_ValueEUTRA>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CarrierFreqEUTRA_v9e0 {
    pub dl_carrier_freq_v9e0: ARFCN_ValueEUTRA_r9,
    #[asn(optional_idx = 0)]
    pub ul_carrier_freq_v9e0: Option<ARFCN_ValueEUTRA_r9>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CarrierFreqGERAN {
    pub arfcn: ARFCN_ValueGERAN,
    pub band_indicator: BandIndicatorGERAN,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CarrierFreqInfoUTRA_FDD_v8h0 {
    #[asn(optional_idx = 0)]
    pub multi_band_info_list: Option<CarrierFreqInfoUTRA_FDD_v8h0MultiBandInfoList>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CarrierFreqInfoUTRA_v1250 {
    #[asn(optional_idx = 0)]
    pub reduced_meas_performance_r12: Option<CarrierFreqInfoUTRA_v1250ReducedMeasPerformance_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "5")]
pub struct CarrierFreqListMBMS_r11(pub Vec<ARFCN_ValueEUTRA_r9>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CarrierFreqListNBIOT_r16(pub Vec<CarrierFreqNBIOT_r16>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CarrierFreqListNR_r15(pub Vec<CarrierFreqNR_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CarrierFreqListNR_v1610(pub Vec<CarrierFreqNR_v1610>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CarrierFreqListNR_v1700(pub Vec<CarrierFreqNR_v1700>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CarrierFreqListNR_v1720(pub Vec<CarrierFreqNR_v1720>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct CarrierFreqListUTRA_FDD(pub Vec<CarrierFreqUTRA_FDD>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct CarrierFreqListUTRA_FDD_Ext_r12(pub Vec<CarrierFreqUTRA_FDD_Ext_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct CarrierFreqListUTRA_TDD(pub Vec<CarrierFreqUTRA_TDD>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct CarrierFreqListUTRA_TDD_Ext_r12(pub Vec<CarrierFreqUTRA_TDD_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct CarrierFreqListUTRA_TDD_r10(pub Vec<ARFCN_ValueUTRA>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CarrierFreqNBIOT_r16 {
    pub carrier_freq_r16: ARFCN_ValueEUTRA_r9,
    pub carrier_freq_offset_r16: CarrierFreqNBIOT_r16CarrierFreqOffset_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 12)]
pub struct CarrierFreqNR_r15 {
    pub carrier_freq_r15: ARFCN_ValueNR_r15,
    #[asn(optional_idx = 0)]
    pub multi_band_info_list_r15: Option<MultiFrequencyBandListNR_r15>,
    #[asn(optional_idx = 1)]
    pub multi_band_info_list_sul_r15: Option<MultiFrequencyBandListNR_r15>,
    #[asn(optional_idx = 2)]
    pub meas_timing_config_r15: Option<MTC_SSB_NR_r15>,
    pub subcarrier_spacing_ssb_r15: CarrierFreqNR_r15SubcarrierSpacingSSB_r15,
    #[asn(optional_idx = 3)]
    pub ss_rssi_measurement_r15: Option<SS_RSSI_Measurement_r15>,
    #[asn(optional_idx = 4)]
    pub cell_reselection_priority_r15: Option<CellReselectionPriority>,
    #[asn(optional_idx = 5)]
    pub cell_reselection_sub_priority_r15: Option<CellReselectionSubPriority_r13>,
    pub thresh_x_high_r15: ReselectionThreshold,
    pub thresh_x_low_r15: ReselectionThreshold,
    #[asn(optional_idx = 6)]
    pub thresh_x_q_r15: Option<CarrierFreqNR_r15ThreshX_Q_r15>,
    pub q_rx_lev_min_r15: CarrierFreqNR_r15Q_RxLevMin_r15,
    #[asn(optional_idx = 7)]
    pub q_rx_lev_min_sul_r15: Option<CarrierFreqNR_r15Q_RxLevMinSUL_r15>,
    pub p_max_nr_r15: P_MaxNR_r15,
    #[asn(optional_idx = 8)]
    pub ns_pmax_list_nr_r15: Option<NS_PmaxListNR_r15>,
    #[asn(optional_idx = 9)]
    pub q_qual_min_r15: Option<CarrierFreqNR_r15Q_QualMin_r15>,
    pub derive_ssb_index_from_cell_r15: CarrierFreqNR_r15DeriveSSB_IndexFromCell_r15,
    #[asn(optional_idx = 10)]
    pub max_rs_index_cell_qual_r15: Option<MaxRS_IndexCellQualNR_r15>,
    #[asn(optional_idx = 11)]
    pub thresh_rs_index_r15: Option<ThresholdListNR_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct CarrierFreqNR_v1610 {
    #[asn(optional_idx = 0)]
    pub smtc2_lp_r16: Option<MTC_SSB2_LP_NR_r16>,
    #[asn(optional_idx = 1)]
    pub ssb_position_qcl_common_nr_r16: Option<SSB_PositionQCL_RelationNR_r16>,
    #[asn(optional_idx = 2)]
    pub allowed_cell_list_nr_r16: Option<AllowedCellListNR_r16>,
    #[asn(optional_idx = 3)]
    pub high_speed_carrier_nr_r16: Option<CarrierFreqNR_v1610HighSpeedCarrierNR_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CarrierFreqNR_v1700 {
    #[asn(optional_idx = 0)]
    pub nr_freq_neigh_hsdn_cell_list_r17: Option<NR_FreqNeighHSDN_CellList_r17>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CarrierFreqNR_v1720 {
    #[asn(optional_idx = 0)]
    pub subcarrier_spacing_ssb_r17: Option<CarrierFreqNR_v1720SubcarrierSpacingSSB_r17>,
    #[asn(optional_idx = 1)]
    pub ssb_position_qcl_common_nr_r17: Option<SSB_PositionQCL_RelationNR_r17>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CarrierFreqUTRA_FDD {
    pub carrier_freq: ARFCN_ValueUTRA,
    #[asn(optional_idx = 0)]
    pub cell_reselection_priority: Option<CellReselectionPriority>,
    pub thresh_x_high: ReselectionThreshold,
    pub thresh_x_low: ReselectionThreshold,
    pub q_rx_lev_min: CarrierFreqUTRA_FDDQ_RxLevMin,
    pub p_max_utra: CarrierFreqUTRA_FDDP_MaxUTRA,
    pub q_qual_min: CarrierFreqUTRA_FDDQ_QualMin,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct CarrierFreqUTRA_FDD_Ext_r12 {
    pub carrier_freq_r12: ARFCN_ValueUTRA,
    #[asn(optional_idx = 0)]
    pub cell_reselection_priority_r12: Option<CellReselectionPriority>,
    pub thresh_x_high_r12: ReselectionThreshold,
    pub thresh_x_low_r12: ReselectionThreshold,
    pub q_rx_lev_min_r12: CarrierFreqUTRA_FDD_Ext_r12Q_RxLevMin_r12,
    pub p_max_utra_r12: CarrierFreqUTRA_FDD_Ext_r12P_MaxUTRA_r12,
    pub q_qual_min_r12: CarrierFreqUTRA_FDD_Ext_r12Q_QualMin_r12,
    #[asn(optional_idx = 1)]
    pub thresh_x_q_r12: Option<CarrierFreqUTRA_FDD_Ext_r12ThreshX_Q_r12>,
    #[asn(optional_idx = 2)]
    pub multi_band_info_list_r12: Option<CarrierFreqUTRA_FDD_Ext_r12MultiBandInfoList_r12>,
    #[asn(optional_idx = 3)]
    pub reduced_meas_performance_r12: Option<CarrierFreqUTRA_FDD_Ext_r12ReducedMeasPerformance_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CarrierFreqUTRA_TDD {
    pub carrier_freq: ARFCN_ValueUTRA,
    #[asn(optional_idx = 0)]
    pub cell_reselection_priority: Option<CellReselectionPriority>,
    pub thresh_x_high: ReselectionThreshold,
    pub thresh_x_low: ReselectionThreshold,
    pub q_rx_lev_min: CarrierFreqUTRA_TDDQ_RxLevMin,
    pub p_max_utra: CarrierFreqUTRA_TDDP_MaxUTRA,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct CarrierFreqUTRA_TDD_r12 {
    pub carrier_freq_r12: ARFCN_ValueUTRA,
    #[asn(optional_idx = 0)]
    pub cell_reselection_priority_r12: Option<CellReselectionPriority>,
    pub thresh_x_high_r12: ReselectionThreshold,
    pub thresh_x_low_r12: ReselectionThreshold,
    pub q_rx_lev_min_r12: CarrierFreqUTRA_TDD_r12Q_RxLevMin_r12,
    pub p_max_utra_r12: CarrierFreqUTRA_TDD_r12P_MaxUTRA_r12,
    #[asn(optional_idx = 1)]
    pub reduced_meas_performance_r12: Option<CarrierFreqUTRA_TDD_r12ReducedMeasPerformance_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CarrierFreqsGERAN {
    pub starting_arfcn: ARFCN_ValueGERAN,
    pub band_indicator: BandIndicatorGERAN,
    pub following_arfc_ns: CarrierFreqsGERANFollowingARFCNs,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct CarrierFreqsInfoGERAN {
    pub carrier_freqs: CarrierFreqsGERAN,
    pub common_info: CarrierFreqsInfoGERANCommonInfo,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct CarrierFreqsInfoListGERAN(pub Vec<CarrierFreqsInfoGERAN>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CarrierInfoNR_r15 {
    pub carrier_freq_r15: ARFCN_ValueNR_r15,
    pub subcarrier_spacing_ssb_r15: CarrierInfoNR_r15SubcarrierSpacingSSB_r15,
    #[asn(optional_idx = 0)]
    pub smtc_r15: Option<MTC_SSB_NR_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CarrierInfoNR_r17 {
    pub carrier_freq_r17: ARFCN_ValueNR_r15,
    pub subcarrier_spacing_ssb_r17: CarrierInfoNR_r17SubcarrierSpacingSSB_r17,
    #[asn(optional_idx = 0)]
    pub smtc_r17: Option<MTC_SSB_NR_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct Cell_ToAddMod_r12 {
    pub s_cell_index_r12: SCellIndex_r10,
    #[asn(optional_idx = 0)]
    pub cell_identification_r12: Option<Cell_ToAddMod_r12CellIdentification_r12>,
    #[asn(optional_idx = 1)]
    pub meas_result_cell_to_add_r12: Option<Cell_ToAddMod_r12MeasResultCellToAdd_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CellAccessRelatedInfo_5GC_r15 {
    pub plmn_identity_list_r15: PLMN_IdentityList_r15,
    #[asn(optional_idx = 0)]
    pub ran_area_code_r15: Option<RAN_AreaCode_r15>,
    pub tracking_area_code_5gc_r15: TrackingAreaCode_5GC_r15,
    pub cell_identity_5gc_r15: CellIdentity_5GC_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellAccessRelatedInfo_r14 {
    pub plmn_identity_list_r14: PLMN_IdentityList,
    pub tracking_area_code_r14: TrackingAreaCode,
    pub cell_identity_r14: CellIdentity,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellChangeOrder {
    pub t304: CellChangeOrderT304,
    pub target_rat_type: CellChangeOrderTargetRAT_Type,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CellGlobalIdCDMA2000 {
    #[asn(key = 0, extended = false)]
    CellGlobalId1XRTT(CellGlobalIdCDMA2000_cellGlobalId1XRTT),
    #[asn(key = 1, extended = false)]
    CellGlobalIdHRPD(CellGlobalIdCDMA2000_cellGlobalIdHRPD),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellGlobalIdEUTRA {
    pub plmn_identity: PLMN_Identity,
    pub cell_identity: CellIdentity,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellGlobalIdGERAN {
    pub plmn_identity: PLMN_Identity,
    pub location_area_code: CellGlobalIdGERANLocationAreaCode,
    pub cell_identity: CellGlobalIdGERANCellIdentity,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CellGlobalIdList_r10(pub Vec<CellGlobalIdEUTRA>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CellGlobalIdNR_r16 {
    pub plmn_identity_r16: PLMN_Identity,
    pub cell_identity_r16: CellIdentityNR_r15,
    #[asn(optional_idx = 0)]
    pub tracking_area_code_r16: Option<TrackingAreaCodeNR_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellGlobalIdUTRA {
    pub plmn_identity: PLMN_Identity,
    pub cell_identity: CellGlobalIdUTRACellIdentity,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "28", sz_ub = "28")]
pub struct CellIdentity(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CellIdentity_5GC_r15 {
    #[asn(key = 0, extended = false)]
    CellIdentity_r15(CellIdentity),
    #[asn(key = 1, extended = false)]
    CellId_Index_r15(CellIdentity_5GC_r15_cellId_Index_r15),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "36", sz_ub = "36")]
pub struct CellIdentityNR_r15(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct CellIndex(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CellIndexList(pub Vec<CellIndex>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellInfoGERAN_r9 {
    pub phys_cell_id_r9: PhysCellIdGERAN,
    pub carrier_freq_r9: CarrierFreqGERAN,
    pub system_information_r9: SystemInfoListGERAN,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CellInfoListGERAN_r9(pub Vec<CellInfoGERAN_r9>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct CellInfoListUTRA_FDD_r9(pub Vec<CellInfoUTRA_FDD_r9>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct CellInfoListUTRA_TDD_r10(pub Vec<CellInfoUTRA_TDD_r10>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct CellInfoListUTRA_TDD_r9(pub Vec<CellInfoUTRA_TDD_r9>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellInfoUTRA_FDD_r9 {
    pub phys_cell_id_r9: PhysCellIdUTRA_FDD,
    pub utra_bcch_container_r9: CellInfoUTRA_FDD_r9Utra_BCCH_Container_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellInfoUTRA_TDD_r10 {
    pub phys_cell_id_r10: PhysCellIdUTRA_TDD,
    pub carrier_freq_r10: ARFCN_ValueUTRA,
    pub utra_bcch_container_r10: CellInfoUTRA_TDD_r10Utra_BCCH_Container_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellInfoUTRA_TDD_r9 {
    pub phys_cell_id_r9: PhysCellIdUTRA_TDD,
    pub utra_bcch_container_r9: CellInfoUTRA_TDD_r9Utra_BCCH_Container_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CellList_r15(pub Vec<PhysCellIdRange>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CellListNR_r16(pub Vec<PhysCellIdRangeNR_r16>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellReselectionInfoCommon_v1460 {
    pub s_search_delta_p_r14: CellReselectionInfoCommon_v1460S_SearchDeltaP_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellReselectionInfoHSDN_r15 {
    pub cell_equivalent_size_r15: CellReselectionInfoHSDN_r15CellEquivalentSize_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CellReselectionParametersCDMA2000 {
    pub band_class_list: BandClassListCDMA2000,
    pub neigh_cell_list: NeighCellListCDMA2000,
    pub t_reselection_cdma2000: T_Reselection,
    #[asn(optional_idx = 0)]
    pub t_reselection_cdma2000_sf: Option<SpeedStateScaleFactors>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CellReselectionParametersCDMA2000_r11 {
    pub band_class_list: BandClassListCDMA2000,
    pub neigh_cell_list_r11: CellReselectionParametersCDMA2000_r11NeighCellList_r11,
    pub t_reselection_cdma2000: T_Reselection,
    #[asn(optional_idx = 0)]
    pub t_reselection_cdma2000_sf: Option<SpeedStateScaleFactors>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellReselectionParametersCDMA2000_v920 {
    pub neigh_cell_list_v920: NeighCellListCDMA2000_v920,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct CellReselectionPriority(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellReselectionServingFreqInfo_v1310 {
    pub cell_reselection_sub_priority_r13: CellReselectionSubPriority_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CellReselectionServingFreqInfo_v1610 {
    #[asn(optional_idx = 0)]
    pub alt_cell_reselection_priority_r16: Option<CellReselectionPriority>,
    #[asn(optional_idx = 1)]
    pub alt_cell_reselection_sub_priority_r16: Option<CellReselectionSubPriority_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct CellReselectionSubPriority_r13(pub u8);
impl CellReselectionSubPriority_r13 {
    pub const O_DOT2: u8 = 0u8;
    pub const O_DOT4: u8 = 1u8;
    pub const O_DOT6: u8 = 2u8;
    pub const O_DOT8: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellSelectionInfo_v1130 {
    pub q_qual_min_wb_r11: Q_QualMin_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellSelectionInfo_v1250 {
    pub q_qual_min_rsrq_on_all_symbols_r12: Q_QualMin_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CellSelectionInfo_v920 {
    pub q_qual_min_r9: Q_QualMin_r9,
    #[asn(optional_idx = 0)]
    pub q_qual_min_offset_r9: Option<CellSelectionInfo_v920Q_QualMinOffset_r9>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CellSelectionInfoCE_r13 {
    pub q_rx_lev_min_ce_r13: Q_RxLevMin,
    #[asn(optional_idx = 0)]
    pub q_qual_min_rsrq_ce_r13: Option<Q_QualMin_r9>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellSelectionInfoCE_v1530 {
    pub power_class14d_bm_offset_r15: CellSelectionInfoCE_v1530PowerClass14dBm_Offset_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CellSelectionInfoCE1_r13 {
    pub q_rx_lev_min_ce1_r13: Q_RxLevMin,
    #[asn(optional_idx = 0)]
    pub q_qual_min_rsrq_ce1_r13: Option<Q_QualMin_r9>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellSelectionInfoCE1_v1360 {
    pub delta_rx_lev_min_ce1_v1360: CellSelectionInfoCE1_v1360Delta_RxLevMinCE1_v1360,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CellSelectionInfoNFreq_r13 {
    pub q_rx_lev_min_r13: Q_RxLevMin,
    #[asn(optional_idx = 0)]
    pub q_rx_lev_min_offset: Option<CellSelectionInfoNFreq_r13Q_RxLevMinOffset>,
    pub q_hyst_r13: CellSelectionInfoNFreq_r13Q_Hyst_r13,
    pub q_rx_lev_min_reselection_r13: Q_RxLevMin,
    pub t_reselection_eutra_r13: T_Reselection,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellsToAddMod {
    pub cell_index: CellsToAddModCellIndex,
    pub phys_cell_id: PhysCellId,
    pub cell_individual_offset: Q_OffsetRange,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellsToAddMod_v1610 {
    pub rss_meas_power_bias_r16: RSS_MeasPowerBias_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellsToAddModCDMA2000 {
    pub cell_index: CellsToAddModCDMA2000CellIndex,
    pub phys_cell_id: PhysCellIdCDMA2000,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CellsToAddModList(pub Vec<CellsToAddMod>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CellsToAddModList_v1610(pub Vec<CellsToAddMod_v1610>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CellsToAddModListCDMA2000(pub Vec<CellsToAddModCDMA2000>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CellsToAddModListNR_r15(pub Vec<CellsToAddModNR_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CellsToAddModListNR_r16(pub Vec<CellsToAddModNR_r16>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CellsToAddModListUTRA_FDD(pub Vec<CellsToAddModUTRA_FDD>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CellsToAddModListUTRA_TDD(pub Vec<CellsToAddModUTRA_TDD>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellsToAddModNR_r15 {
    pub cell_index_r15: CellsToAddModNR_r15CellIndex_r15,
    pub phys_cell_id_r15: PhysCellIdNR_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellsToAddModNR_r16 {
    pub cell_index_r16: CellsToAddModNR_r16CellIndex_r16,
    pub phys_cell_id_r16: PhysCellIdNR_r15,
    pub cell_individual_offset_r16: Q_OffsetRange,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellsToAddModUTRA_FDD {
    pub cell_index: CellsToAddModUTRA_FDDCellIndex,
    pub phys_cell_id: PhysCellIdUTRA_FDD,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellsToAddModUTRA_TDD {
    pub cell_index: CellsToAddModUTRA_TDDCellIndex,
    pub phys_cell_id: PhysCellIdUTRA_TDD,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CellsTriggeredList(pub Vec<CellsTriggeredList_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "7")]
pub struct CipheringAlgorithm_r12(pub u8);
impl CipheringAlgorithm_r12 {
    pub const EEA0: u8 = 0u8;
    pub const EEA1: u8 = 1u8;
    pub const EEA2: u8 = 2u8;
    pub const EEA3_V1130: u8 = 3u8;
    pub const SPARE4: u8 = 4u8;
    pub const SPARE3: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CommonSF_AllocPatternList_r9(pub Vec<MBSFN_SubframeConfig>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CommonSF_AllocPatternList_v1430(pub Vec<MBSFN_SubframeConfig_v1430>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CommonSF_AllocPatternList_v1610(pub Vec<MBSFN_SubframeConfig_v1610>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct CondReconfigurationAddMod_r16 {
    pub cond_reconfiguration_id_r16: CondReconfigurationId_r16,
    #[asn(optional_idx = 0)]
    pub trigger_condition_r16: Option<CondReconfigurationAddMod_r16TriggerCondition_r16>,
    #[asn(optional_idx = 1)]
    pub cond_reconfiguration_to_apply_r16:
        Option<CondReconfigurationAddMod_r16CondReconfigurationToApply_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8")]
pub struct CondReconfigurationId_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CondReconfigurationToAddModList_r16(pub Vec<CondReconfigurationAddMod_r16>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CondReconfigurationToRemoveList_r16(pub Vec<CondReconfigurationId_r16>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CondReconfigurationTriggerEUTRA_r16 {
    pub cond_event_id_r16: CondReconfigurationTriggerEUTRA_r16CondEventId_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CondReconfigurationTriggerNR_r17 {
    pub cond_event_id_r17: CondReconfigurationTriggerNR_r17CondEventId_r17,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct ConditionalReconfiguration_r16 {
    #[asn(optional_idx = 0)]
    pub cond_reconfiguration_to_add_mod_list_r16: Option<CondReconfigurationToAddModList_r16>,
    #[asn(optional_idx = 1)]
    pub cond_reconfiguration_to_remove_list_r16: Option<CondReconfigurationToRemoveList_r16>,
    #[asn(optional_idx = 2)]
    pub attempt_cond_reconf_r16: Option<ConditionalReconfiguration_r16AttemptCondReconf_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct ConfigRestrictInfoDAPS_r16 {
    #[asn(optional_idx = 0)]
    pub max_sch_tb_bits_dl_r16: Option<ConfigRestrictInfoDAPS_r16MaxSCH_TB_BitsDL_r16>,
    #[asn(optional_idx = 1)]
    pub max_sch_tb_bits_ul_r16: Option<ConfigRestrictInfoDAPS_r16MaxSCH_TB_BitsUL_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct ConfigRestrictInfoDAPS_v1630 {
    #[asn(optional_idx = 0)]
    pub daps_power_coordination_info_r16: Option<DAPS_PowerCoordinationInfo_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct ConnEstFailReport_r11 {
    pub failed_cell_id_r11: CellGlobalIdEUTRA,
    #[asn(optional_idx = 0)]
    pub location_info_r11: Option<LocationInfo_r10>,
    pub meas_result_failed_cell_r11: ConnEstFailReport_r11MeasResultFailedCell_r11,
    #[asn(optional_idx = 1)]
    pub meas_result_neigh_cells_r11: Option<ConnEstFailReport_r11MeasResultNeighCells_r11>,
    pub number_of_preambles_sent_r11: NumberOfPreamblesSent_r11,
    pub contention_detected_r11: ConnEstFailReport_r11ContentionDetected_r11,
    pub max_tx_power_reached_r11: ConnEstFailReport_r11MaxTxPowerReached_r11,
    pub time_since_failure_r11: TimeSinceFailure_r11,
    #[asn(optional_idx = 2)]
    pub meas_result_list_eutra_v1130: Option<MeasResultList2EUTRA_v9e0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CounterCheck {
    pub rrc_transaction_identifier: RRC_TransactionIdentifier,
    pub critical_extensions: CounterCheckCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CounterCheck_r8_IEs {
    pub drb_count_msb_info_list: DRB_CountMSB_InfoList,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<CounterCheck_v8a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CounterCheck_v1530_IEs {
    #[asn(optional_idx = 0)]
    pub drb_count_msb_info_list_ext_r15: Option<DRB_CountMSB_InfoListExt_r15>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<CounterCheck_v1530_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CounterCheck_v8a0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<CounterCheck_v8a0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<CounterCheck_v1530_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CounterCheckResponse {
    pub rrc_transaction_identifier: RRC_TransactionIdentifier,
    pub critical_extensions: CounterCheckResponseCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CounterCheckResponse_r8_IEs {
    pub drb_count_info_list: DRB_CountInfoList,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<CounterCheckResponse_v8a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CounterCheckResponse_v1530_IEs {
    #[asn(optional_idx = 0)]
    pub drb_count_info_list_ext_r15: Option<DRB_CountInfoListExt_r15>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<CounterCheckResponse_v1530_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CounterCheckResponse_v8a0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<CounterCheckResponse_v8a0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<CounterCheckResponse_v1530_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct CountingRequestInfo_r10 {
    pub tmgi_r10: TMGI_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct CountingRequestList_r10(pub Vec<CountingRequestInfo_r10>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct CountingResponseInfo_r10 {
    pub counting_response_service_r10: CountingResponseInfo_r10CountingResponseService_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct CountingResponseList_r10(pub Vec<CountingResponseInfo_r10>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CrossCarrierSchedulingConfig_r10 {
    pub scheduling_cell_info_r10: CrossCarrierSchedulingConfig_r10SchedulingCellInfo_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CrossCarrierSchedulingConfig_r13 {
    pub scheduling_cell_info_r13: CrossCarrierSchedulingConfig_r13SchedulingCellInfo_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CrossCarrierSchedulingConfigLAA_UL_r14 {
    pub scheduling_cell_id_r14: ServCellIndex_r13,
    pub cif_in_scheduling_cell_r14: CrossCarrierSchedulingConfigLAA_UL_r14Cif_InSchedulingCell_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DAPS_Config_r16 {
    #[asn(optional_idx = 0)]
    pub daps_power_coordination_info_r16: Option<DAPS_PowerCoordinationInfo_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DAPS_PowerCoordinationInfo_r16 {
    pub p_daps_source_r16: DAPS_PowerCoordinationInfo_r16P_DAPS_Source_r16,
    pub p_daps_target_r16: DAPS_PowerCoordinationInfo_r16P_DAPS_Target_r16,
    pub power_control_mode_r16: DAPS_PowerCoordinationInfo_r16PowerControlMode_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct DC_Parameters_r12 {
    #[asn(optional_idx = 0)]
    pub drb_type_split_r12: Option<DC_Parameters_r12Drb_TypeSplit_r12>,
    #[asn(optional_idx = 1)]
    pub drb_type_scg_r12: Option<DC_Parameters_r12Drb_TypeSCG_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct DC_Parameters_v1310 {
    #[asn(optional_idx = 0)]
    pub pdcp_transfer_split_ul_r13: Option<DC_Parameters_v1310Pdcp_TransferSplitUL_r13>,
    #[asn(optional_idx = 1)]
    pub ue_sstd_meas_r13: Option<DC_Parameters_v1310Ue_SSTD_Meas_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "6")]
pub struct DCI7_Candidates_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct DCI7_CandidatesPerAL_SPDCCH_r15(pub Vec<DCI7_Candidates_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DL_AM_RLC {
    pub t_reordering: T_Reordering,
    pub t_status_prohibit: T_StatusProhibit,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DL_AM_RLC_r15 {
    pub t_reordering_r15: T_Reordering,
    pub t_status_prohibit_r15: T_StatusProhibit,
    pub extended_rlc_li_field_r15: DL_AM_RLC_r15Extended_RLC_LI_Field_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DL_CCCH_Message {
    pub message: DL_CCCH_MessageType,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum DL_CCCH_MessageType {
    #[asn(key = 0, extended = false)]
    C1(DL_CCCH_MessageType_c1),
    #[asn(key = 1, extended = false)]
    MessageClassExtension(DL_CCCH_MessageType_messageClassExtension),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DL_DCCH_Message {
    pub message: DL_DCCH_MessageType,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum DL_DCCH_MessageType {
    #[asn(key = 0, extended = false)]
    C1(DL_DCCH_MessageType_c1),
    #[asn(key = 1, extended = false)]
    MessageClassExtension(DL_DCCH_MessageType_messageClassExtension),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct DL_UL_CCs_r15 {
    #[asn(optional_idx = 0)]
    pub max_number_dl_c_cs_r15: Option<DL_UL_CCs_r15MaxNumberDL_CCs_r15>,
    #[asn(optional_idx = 1)]
    pub max_number_ul_c_cs_r15: Option<DL_UL_CCs_r15MaxNumberUL_CCs_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DL_UM_RLC {
    pub sn_field_length: SN_FieldLength,
    pub t_reordering: T_Reordering,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DL_UM_RLC_r15 {
    pub sn_field_length_r15: SN_FieldLength_r15,
    pub t_reordering_r15: T_Reordering,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DLDedicatedMessageSegment_r16 {
    pub critical_extensions: DLDedicatedMessageSegment_r16CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct DLDedicatedMessageSegment_r16_IEs {
    pub segment_number_r16: DLDedicatedMessageSegment_r16_IEsSegmentNumber_r16,
    pub rrc_message_segment_container_r16:
        DLDedicatedMessageSegment_r16_IEsRrc_MessageSegmentContainer_r16,
    pub rrc_message_segment_type_r16: DLDedicatedMessageSegment_r16_IEsRrc_MessageSegmentType_r16,
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<DLDedicatedMessageSegment_r16_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<DLDedicatedMessageSegment_r16_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DLInformationTransfer {
    pub rrc_transaction_identifier: RRC_TransactionIdentifier,
    pub critical_extensions: DLInformationTransferCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct DLInformationTransfer_r15_IEs {
    #[asn(optional_idx = 0)]
    pub dedicated_info_type_r15: Option<DLInformationTransfer_r15_IEsDedicatedInfoType_r15>,
    #[asn(optional_idx = 1)]
    pub time_reference_info_r15: Option<TimeReferenceInfo_r15>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<DLInformationTransfer_v8a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct DLInformationTransfer_r8_IEs {
    pub dedicated_info_type: DLInformationTransfer_r8_IEsDedicatedInfoType,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<DLInformationTransfer_v8a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct DLInformationTransfer_v1610_IEs {
    #[asn(optional_idx = 0)]
    pub dedicated_info_f1c_r16: Option<DedicatedInfoF1c_r16>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<DLInformationTransfer_v1610_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct DLInformationTransfer_v8a0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<DLInformationTransfer_v8a0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<DLInformationTransfer_v1610_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum DMRS_Config_r11 {
    #[asn(key = 0, extended = false)]
    Release(DMRS_Config_r11_release),
    #[asn(key = 1, extended = false)]
    Setup(DMRS_Config_r11_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct DMRS_Config_v1310 {
    #[asn(optional_idx = 0)]
    pub dmrs_table_alt_r13: Option<DMRS_Config_v1310Dmrs_tableAlt_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DRB_CountInfo {
    pub drb_identity: DRB_Identity,
    pub count_uplink: DRB_CountInfoCount_Uplink,
    pub count_downlink: DRB_CountInfoCount_Downlink,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "0", sz_ub = "11")]
pub struct DRB_CountInfoList(pub Vec<DRB_CountInfo>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct DRB_CountInfoListExt_r15(pub Vec<DRB_CountInfo>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DRB_CountMSB_Info {
    pub drb_identity: DRB_Identity,
    pub count_msb_uplink: DRB_CountMSB_InfoCountMSB_Uplink,
    pub count_msb_downlink: DRB_CountMSB_InfoCountMSB_Downlink,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "11")]
pub struct DRB_CountMSB_InfoList(pub Vec<DRB_CountMSB_Info>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct DRB_CountMSB_InfoListExt_r15(pub Vec<DRB_CountMSB_Info>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct DRB_Identity(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "11")]
pub struct DRB_InfoListSCG_r12(pub Vec<DRB_InfoSCG_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "15")]
pub struct DRB_InfoListSCG_r15(pub Vec<DRB_InfoSCG_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct DRB_InfoSCG_r12 {
    #[asn(optional_idx = 0)]
    pub eps_bearer_identity_r12: Option<DRB_InfoSCG_r12Eps_BearerIdentity_r12>,
    pub drb_identity_r12: DRB_Identity,
    #[asn(optional_idx = 1)]
    pub drb_type_r12: Option<DRB_InfoSCG_r12Drb_Type_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct DRB_ToAddMod {
    #[asn(optional_idx = 0)]
    pub eps_bearer_identity: Option<DRB_ToAddModEps_BearerIdentity>,
    pub drb_identity: DRB_Identity,
    #[asn(optional_idx = 1)]
    pub pdcp_config: Option<PDCP_Config>,
    #[asn(optional_idx = 2)]
    pub rlc_config: Option<RLC_Config>,
    #[asn(optional_idx = 3)]
    pub logical_channel_identity: Option<DRB_ToAddModLogicalChannelIdentity>,
    #[asn(optional_idx = 4)]
    pub logical_channel_config: Option<LogicalChannelConfig>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "11")]
pub struct DRB_ToAddModList(pub Vec<DRB_ToAddMod>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "15")]
pub struct DRB_ToAddModList_r15(pub Vec<DRB_ToAddMod>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "11")]
pub struct DRB_ToAddModListSCG_r12(pub Vec<DRB_ToAddModSCG_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "15")]
pub struct DRB_ToAddModListSCG_r15(pub Vec<DRB_ToAddModSCG_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct DRB_ToAddModSCG_r12 {
    pub drb_identity_r12: DRB_Identity,
    #[asn(optional_idx = 0)]
    pub drb_type_r12: Option<DRB_ToAddModSCG_r12Drb_Type_r12>,
    #[asn(optional_idx = 1)]
    pub rlc_config_scg_r12: Option<RLC_Config>,
    #[asn(optional_idx = 2)]
    pub rlc_config_v1250: Option<RLC_Config_v1250>,
    #[asn(optional_idx = 3)]
    pub logical_channel_identity_scg_r12: Option<DRB_ToAddModSCG_r12LogicalChannelIdentitySCG_r12>,
    #[asn(optional_idx = 4)]
    pub logical_channel_config_scg_r12: Option<LogicalChannelConfig>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "11")]
pub struct DRB_ToReleaseList(pub Vec<DRB_Identity>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "15")]
pub struct DRB_ToReleaseList_r15(pub Vec<DRB_Identity>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum DRX_Config {
    #[asn(key = 0, extended = false)]
    Release(DRX_Config_release),
    #[asn(key = 1, extended = false)]
    Setup(DRX_Config_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct DRX_Config_r13 {
    #[asn(optional_idx = 0)]
    pub on_duration_timer_v1310: Option<DRX_Config_r13OnDurationTimer_v1310>,
    #[asn(optional_idx = 1)]
    pub drx_retransmission_timer_v1310: Option<DRX_Config_r13Drx_RetransmissionTimer_v1310>,
    #[asn(optional_idx = 2)]
    pub drx_ul_retransmission_timer_r13: Option<DRX_Config_r13Drx_ULRetransmissionTimer_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct DRX_Config_r15 {
    #[asn(optional_idx = 0)]
    pub drx_retransmission_timer_short_tti_r15:
        Option<DRX_Config_r15Drx_RetransmissionTimerShortTTI_r15>,
    #[asn(optional_idx = 1)]
    pub drx_ul_retransmission_timer_short_tti_r15:
        Option<DRX_Config_r15Drx_UL_RetransmissionTimerShortTTI_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct DRX_Config_v1130 {
    #[asn(optional_idx = 0)]
    pub drx_retransmission_timer_v1130: Option<DRX_Config_v1130Drx_RetransmissionTimer_v1130>,
    #[asn(optional_idx = 1)]
    pub long_drx_cycle_start_offset_v1130: Option<DRX_Config_v1130LongDRX_CycleStartOffset_v1130>,
    #[asn(optional_idx = 2)]
    pub short_drx_cycle_v1130: Option<DRX_Config_v1130ShortDRX_Cycle_v1130>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct DRX_Config_v1310 {
    #[asn(optional_idx = 0)]
    pub long_drx_cycle_start_offset_v1310: Option<DRX_Config_v1310LongDRX_CycleStartOffset_v1310>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DataBLER_MCH_Result_r12 {
    pub mch_index_r12: DataBLER_MCH_Result_r12Mch_Index_r12,
    pub data_bler_result_r12: BLER_Result_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "15")]
pub struct DataBLER_MCH_ResultList_r12(pub Vec<DataBLER_MCH_Result_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct DataInactivityTimer_r14(pub u8);
impl DataInactivityTimer_r14 {
    pub const S1: u8 = 0u8;
    pub const S2: u8 = 1u8;
    pub const S3: u8 = 2u8;
    pub const S5: u8 = 3u8;
    pub const S7: u8 = 4u8;
    pub const S10: u8 = 5u8;
    pub const S15: u8 = 6u8;
    pub const S20: u8 = 7u8;
    pub const S40: u8 = 8u8;
    pub const S50: u8 = 9u8;
    pub const S60: u8 = 10u8;
    pub const S80: u8 = 11u8;
    pub const S100: u8 = 12u8;
    pub const S120: u8 = 13u8;
    pub const S150: u8 = 14u8;
    pub const S180: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct DedicatedInfoCDMA2000(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct DedicatedInfoF1c_r16(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct DedicatedInfoNAS(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum DelayBudgetReport_r14 {
    #[asn(key = 0, extended = false)]
    Type1(DelayBudgetReport_r14_type1),
    #[asn(key = 1, extended = false)]
    Type2(DelayBudgetReport_r14_type2),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DeltaFList_PUCCH {
    pub delta_f_pucch_format1: DeltaFList_PUCCHDeltaF_PUCCH_Format1,
    pub delta_f_pucch_format1b: DeltaFList_PUCCHDeltaF_PUCCH_Format1b,
    pub delta_f_pucch_format2: DeltaFList_PUCCHDeltaF_PUCCH_Format2,
    pub delta_f_pucch_format2a: DeltaFList_PUCCHDeltaF_PUCCH_Format2a,
    pub delta_f_pucch_format2b: DeltaFList_PUCCHDeltaF_PUCCH_Format2b,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum DeltaFList_SPUCCH_r15 {
    #[asn(key = 0, extended = false)]
    Release(DeltaFList_SPUCCH_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(DeltaFList_SPUCCH_r15_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DeltaTxD_OffsetListPUCCH_r10 {
    pub delta_tx_d_offset_pucch_format1_r10:
        DeltaTxD_OffsetListPUCCH_r10DeltaTxD_OffsetPUCCH_Format1_r10,
    pub delta_tx_d_offset_pucch_format1a1b_r10:
        DeltaTxD_OffsetListPUCCH_r10DeltaTxD_OffsetPUCCH_Format1a1b_r10,
    pub delta_tx_d_offset_pucch_format22a2b_r10:
        DeltaTxD_OffsetListPUCCH_r10DeltaTxD_OffsetPUCCH_Format22a2b_r10,
    pub delta_tx_d_offset_pucch_format3_r10:
        DeltaTxD_OffsetListPUCCH_r10DeltaTxD_OffsetPUCCH_Format3_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DeltaTxD_OffsetListPUCCH_v1130 {
    pub delta_tx_d_offset_pucch_format1b_cs_r11:
        DeltaTxD_OffsetListPUCCH_v1130DeltaTxD_OffsetPUCCH_Format1bCS_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DeltaTxD_OffsetListSPUCCH_r15 {
    pub delta_tx_d_offset_spucch_format1_r15:
        DeltaTxD_OffsetListSPUCCH_r15DeltaTxD_OffsetSPUCCH_Format1_r15,
    pub delta_tx_d_offset_spucch_format1a_r15:
        DeltaTxD_OffsetListSPUCCH_r15DeltaTxD_OffsetSPUCCH_Format1a_r15,
    pub delta_tx_d_offset_spucch_format1b_r15:
        DeltaTxD_OffsetListSPUCCH_r15DeltaTxD_OffsetSPUCCH_Format1b_r15,
    pub delta_tx_d_offset_spucch_format3_r15:
        DeltaTxD_OffsetListSPUCCH_r15DeltaTxD_OffsetSPUCCH_Format3_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct DiscardTimerExt_r17(pub u8);
impl DiscardTimerExt_r17 {
    pub const MS2000: u8 = 0u8;
    pub const SPARE: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct E_CSFB_r9 {
    #[asn(optional_idx = 0)]
    pub message_cont_cdma2000_1xrtt_r9: Option<E_CSFB_r9MessageContCDMA2000_1XRTT_r9>,
    #[asn(optional_idx = 1)]
    pub mobility_cdma2000_hrpd_r9: Option<E_CSFB_r9MobilityCDMA2000_HRPD_r9>,
    #[asn(optional_idx = 2)]
    pub message_cont_cdma2000_hrpd_r9: Option<E_CSFB_r9MessageContCDMA2000_HRPD_r9>,
    #[asn(optional_idx = 3)]
    pub redirect_carrier_cdma2000_hrpd_r9: Option<CarrierFreqCDMA2000>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EAB_Config_r11 {
    pub eab_category_r11: EAB_Config_r11Eab_Category_r11,
    pub eab_barring_bitmap_r11: EAB_Config_r11Eab_BarringBitmap_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct EAB_ConfigPLMN_r11 {
    #[asn(optional_idx = 0)]
    pub eab_config_r11: Option<EAB_Config_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct EDT_PRACH_ParametersCE_r15 {
    #[asn(optional_idx = 0)]
    pub edt_prach_parameters_ce_r15: Option<EDT_PRACH_ParametersCE_r15Edt_PRACH_ParametersCE_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum EIMTA_MainConfig_r12 {
    #[asn(key = 0, extended = false)]
    Release(EIMTA_MainConfig_r12_release),
    #[asn(key = 1, extended = false)]
    Setup(EIMTA_MainConfig_r12_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum EIMTA_MainConfigServCell_r12 {
    #[asn(key = 0, extended = false)]
    Release(EIMTA_MainConfigServCell_r12_release),
    #[asn(key = 1, extended = false)]
    Setup(EIMTA_MainConfigServCell_r12_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EPDCCH_Config_r11 {
    pub config_r11: EPDCCH_Config_r11Config_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EPDCCH_SetConfig_r11 {
    pub set_config_id_r11: EPDCCH_SetConfigId_r11,
    pub transmission_type_r11: EPDCCH_SetConfig_r11TransmissionType_r11,
    pub resource_block_assignment_r11: EPDCCH_SetConfig_r11ResourceBlockAssignment_r11,
    pub dmrs_scrambling_sequence_int_r11: EPDCCH_SetConfig_r11Dmrs_ScramblingSequenceInt_r11,
    pub pucch_resource_start_offset_r11: EPDCCH_SetConfig_r11Pucch_ResourceStartOffset_r11,
    #[asn(optional_idx = 0)]
    pub re_mapping_qcl_config_id_r11: Option<PDSCH_RE_MappingQCL_ConfigId_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1")]
pub struct EPDCCH_SetConfigId_r11(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct EPDCCH_SetConfigToAddModList_r11(pub Vec<EPDCCH_SetConfig_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct EPDCCH_SetConfigToReleaseList_r11(pub Vec<EPDCCH_SetConfigId_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 7)]
pub struct EUTRA_5GC_Parameters_r15 {
    #[asn(optional_idx = 0)]
    pub eutra_5gc_r15: Option<EUTRA_5GC_Parameters_r15Eutra_5GC_r15>,
    #[asn(optional_idx = 1)]
    pub eutra_epc_ho_eutra_5gc_r15: Option<EUTRA_5GC_Parameters_r15Eutra_EPC_HO_EUTRA_5GC_r15>,
    #[asn(optional_idx = 2)]
    pub ho_eutra_5gc_fdd_tdd_r15: Option<EUTRA_5GC_Parameters_r15Ho_EUTRA_5GC_FDD_TDD_r15>,
    #[asn(optional_idx = 3)]
    pub ho_interfreq_eutra_5gc_r15: Option<EUTRA_5GC_Parameters_r15Ho_InterfreqEUTRA_5GC_r15>,
    #[asn(optional_idx = 4)]
    pub ims_voice_over_mcg_bearer_eutra_5gc_r15:
        Option<EUTRA_5GC_Parameters_r15Ims_VoiceOverMCG_BearerEUTRA_5GC_r15>,
    #[asn(optional_idx = 5)]
    pub inactive_state_r15: Option<EUTRA_5GC_Parameters_r15InactiveState_r15>,
    #[asn(optional_idx = 6)]
    pub reflective_qo_s_r15: Option<EUTRA_5GC_Parameters_r15ReflectiveQoS_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct EUTRA_5GC_Parameters_v1610 {
    #[asn(optional_idx = 0)]
    pub ce_inactive_state_r16: Option<EUTRA_5GC_Parameters_v1610Ce_InactiveState_r16>,
    #[asn(optional_idx = 1)]
    pub ce_eutra_5gc_r16: Option<EUTRA_5GC_Parameters_v1610Ce_EUTRA_5GC_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct EUTRA_CarrierList_r15(pub Vec<MeasIdleCarrierEUTRA_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum Enable256QAM_r14 {
    #[asn(key = 0, extended = false)]
    Release(Enable256QAM_r14_release),
    #[asn(key = 1, extended = false)]
    Setup(Enable256QAM_r14_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EphemerisOrbitalParameters_r17 {
    pub semi_major_axis_r17: EphemerisOrbitalParameters_r17SemiMajorAxis_r17,
    pub eccentricity_r17: EphemerisOrbitalParameters_r17Eccentricity_r17,
    pub periapsis_r17: EphemerisOrbitalParameters_r17Periapsis_r17,
    pub longitude_r17: EphemerisOrbitalParameters_r17Longitude_r17,
    pub inclination_r17: EphemerisOrbitalParameters_r17Inclination_r17,
    pub anomaly_r17: EphemerisOrbitalParameters_r17Anomaly_r17,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EphemerisStateVectors_r17 {
    pub position_x_r17: PositionStateVector_r17,
    pub position_y_r17: PositionStateVector_r17,
    pub position_z_r17: PositionStateVector_r17,
    pub velocity_vx_r17: VelocityStateVector_r17,
    pub velocity_vy_r17: VelocityStateVector_r17,
    pub velocity_vz_r17: VelocityStateVector_r17,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct EstablishmentCause(pub u8);
impl EstablishmentCause {
    pub const EMERGENCY: u8 = 0u8;
    pub const HIGH_PRIORITY_ACCESS: u8 = 1u8;
    pub const MT_ACCESS: u8 = 2u8;
    pub const MO_SIGNALLING: u8 = 3u8;
    pub const MO_DATA: u8 = 4u8;
    pub const DELAY_TOLERANT_ACCESS_V1020: u8 = 5u8;
    pub const MO_VOICE_CALL_V1280: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct EstablishmentCause_5GC_r15(pub u8);
impl EstablishmentCause_5GC_r15 {
    pub const EMERGENCY: u8 = 0u8;
    pub const HIGH_PRIORITY_ACCESS: u8 = 1u8;
    pub const MT_ACCESS: u8 = 2u8;
    pub const MO_SIGNALLING: u8 = 3u8;
    pub const MO_DATA: u8 = 4u8;
    pub const MO_VOICE_CALL: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct EthernetHeaderCompression_r16 {
    pub ehc_common_r16: EthernetHeaderCompression_r16Ehc_Common_r16,
    #[asn(optional_idx = 0)]
    pub ehc_downlink_r16: Option<EthernetHeaderCompression_r16Ehc_Downlink_r16>,
    #[asn(optional_idx = 1)]
    pub ehc_uplink_r16: Option<EthernetHeaderCompression_r16Ehc_Uplink_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum EventType_r17 {
    #[asn(key = 0, extended = false)]
    OutOfCoverage(EventType_r17_outOfCoverage),
    #[asn(key = 1, extended = false)]
    EventL1(EventType_r17_eventL1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ExcludedCellsToAddMod {
    pub cell_index: ExcludedCellsToAddModCellIndex,
    pub phys_cell_id_range: PhysCellIdRange,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct ExcludedCellsToAddModList(pub Vec<ExcludedCellsToAddMod>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "0", sz_ub = "31")]
pub struct ExplicitListOfARFCNs(pub Vec<ARFCN_ValueGERAN>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct FailedLogicalChannelIdentity_r16 {
    pub cell_group_indication_r16: FailedLogicalChannelIdentity_r16CellGroupIndication_r16,
    #[asn(optional_idx = 0)]
    pub logical_channel_identity_r16:
        Option<FailedLogicalChannelIdentity_r16LogicalChannelIdentity_r16>,
    #[asn(optional_idx = 1)]
    pub logical_channel_identity_ext_r16:
        Option<FailedLogicalChannelIdentity_r16LogicalChannelIdentityExt_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FailedLogicalChannelInfo_r15 {
    pub failed_logical_channel_identity_r15:
        FailedLogicalChannelInfo_r15FailedLogicalChannelIdentity_r15,
    pub failure_type: FailedLogicalChannelInfo_r15FailureType,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct FailureInformation_r15 {
    #[asn(optional_idx = 0)]
    pub failed_logical_channel_info_r15: Option<FailedLogicalChannelInfo_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FailureInformation_r16 {
    pub critical_extensions: FailureInformation_r16CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct FailureInformation_r16_IEs {
    #[asn(optional_idx = 0)]
    pub failed_logical_channel_identity_r16: Option<FailedLogicalChannelIdentity_r16>,
    #[asn(optional_idx = 1)]
    pub failure_type_r16: Option<FailureInformation_r16_IEsFailureType_r16>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<FailureInformation_r16_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 6)]
pub struct FailureReportMCG_r16 {
    #[asn(optional_idx = 0)]
    pub failure_type_r16: Option<FailureReportMCG_r16FailureType_r16>,
    #[asn(optional_idx = 1)]
    pub meas_result_freq_list_eutra_r16: Option<MeasResultList3EUTRA_r15>,
    #[asn(optional_idx = 2)]
    pub meas_result_freq_list_nr_r16: Option<MeasResultFreqListFailNR_r15>,
    #[asn(optional_idx = 3)]
    pub meas_result_freq_list_geran_r16: Option<MeasResultList2GERAN_r10>,
    #[asn(optional_idx = 4)]
    pub meas_result_freq_list_utra_r16: Option<MeasResultList2UTRA_r9>,
    #[asn(optional_idx = 5)]
    pub meas_result_scg_r16: Option<FailureReportMCG_r16MeasResultSCG_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct FailureReportSCG_NR_r15 {
    pub failure_type_r15: FailureReportSCG_NR_r15FailureType_r15,
    #[asn(optional_idx = 0)]
    pub meas_result_freq_list_nr_r15: Option<MeasResultFreqListFailNR_r15>,
    #[asn(optional_idx = 1)]
    pub meas_result_scg_r15: Option<FailureReportSCG_NR_r15MeasResultSCG_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct FailureReportSCG_r12 {
    pub failure_type_r12: FailureReportSCG_r12FailureType_r12,
    #[asn(optional_idx = 0)]
    pub meas_result_serv_freq_list_r12: Option<MeasResultServFreqList_r10>,
    #[asn(optional_idx = 1)]
    pub meas_result_neigh_cells_r12: Option<MeasResultList2EUTRA_r9>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct FailureReportSCG_v12d0 {
    #[asn(optional_idx = 0)]
    pub meas_result_neigh_cells_v12d0: Option<MeasResultList2EUTRA_v9e0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct FeMBMS_Unicast_Parameters_r14 {
    #[asn(optional_idx = 0)]
    pub unicast_fembms_mixed_s_cell_r14:
        Option<FeMBMS_Unicast_Parameters_r14Unicast_fembmsMixedSCell_r14>,
    #[asn(optional_idx = 1)]
    pub empty_unicast_region_r14: Option<FeMBMS_Unicast_Parameters_r14EmptyUnicastRegion_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "32")]
pub struct FeatureSetDL_PerCC_Id_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct FeatureSetDL_PerCC_r15 {
    #[asn(optional_idx = 0)]
    pub four_layer_tm3_tm4_r15: Option<FeatureSetDL_PerCC_r15FourLayerTM3_TM4_r15>,
    #[asn(optional_idx = 1)]
    pub supported_mimo_capability_dl_mrdc_r15: Option<MIMO_CapabilityDL_r10>,
    #[asn(optional_idx = 2)]
    pub supported_csi_proc_r15: Option<FeatureSetDL_PerCC_r15SupportedCSI_Proc_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct FeatureSetDL_r15 {
    #[asn(optional_idx = 0)]
    pub mimo_ca_parameters_per_bo_bc_r15: Option<MIMO_CA_ParametersPerBoBC_r15>,
    pub feature_set_per_cc_list_dl_r15: FeatureSetDL_r15FeatureSetPerCC_ListDL_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct FeatureSetDL_v1550 {
    #[asn(optional_idx = 0)]
    pub dl_1024qam_r15: Option<FeatureSetDL_v1550Dl_1024QAM_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "32")]
pub struct FeatureSetUL_PerCC_Id_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct FeatureSetUL_PerCC_r15 {
    #[asn(optional_idx = 0)]
    pub supported_mimo_capability_ul_r15: Option<MIMO_CapabilityUL_r10>,
    #[asn(optional_idx = 1)]
    pub ul_256qam_r15: Option<FeatureSetUL_PerCC_r15Ul_256QAM_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FeatureSetUL_r15 {
    pub feature_set_per_cc_list_ul_r15: FeatureSetUL_r15FeatureSetPerCC_ListUL_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct FeatureSetsEUTRA_r15 {
    #[asn(optional_idx = 0)]
    pub feature_sets_dl_r15: Option<FeatureSetsEUTRA_r15FeatureSetsDL_r15>,
    #[asn(optional_idx = 1)]
    pub feature_sets_dl_per_cc_r15: Option<FeatureSetsEUTRA_r15FeatureSetsDL_PerCC_r15>,
    #[asn(optional_idx = 2)]
    pub feature_sets_ul_r15: Option<FeatureSetsEUTRA_r15FeatureSetsUL_r15>,
    #[asn(optional_idx = 3)]
    pub feature_sets_ul_per_cc_r15: Option<FeatureSetsEUTRA_r15FeatureSetsUL_PerCC_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "15")]
pub struct FilterCoefficient(pub u8);
impl FilterCoefficient {
    pub const FC0: u8 = 0u8;
    pub const FC1: u8 = 1u8;
    pub const FC2: u8 = 2u8;
    pub const FC3: u8 = 3u8;
    pub const FC4: u8 = 4u8;
    pub const FC5: u8 = 5u8;
    pub const FC6: u8 = 6u8;
    pub const FC7: u8 = 7u8;
    pub const FC8: u8 = 8u8;
    pub const FC9: u8 = 9u8;
    pub const FC11: u8 = 10u8;
    pub const FC13: u8 = 11u8;
    pub const FC15: u8 = 12u8;
    pub const FC17: u8 = 13u8;
    pub const FC19: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct FlightPathInfoReport_r15 {
    #[asn(optional_idx = 0)]
    pub flight_path_r15: Option<FlightPathInfoReport_r15FlightPath_r15>,
    #[asn(optional_idx = 1)]
    pub dummy: Option<FlightPathInfoReport_r15Dummy>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct FlightPathInfoReportConfig_r15 {
    pub max_way_point_number_r15: FlightPathInfoReportConfig_r15MaxWayPointNumber_r15,
    #[asn(optional_idx = 0)]
    pub include_time_stamp_r15: Option<FlightPathInfoReportConfig_r15IncludeTimeStamp_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Format4_resource_r13 {
    pub starting_prb_format4_r13: Format4_resource_r13StartingPRB_format4_r13,
    pub number_of_prb_format4_r13: Format4_resource_r13NumberOfPRB_format4_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Format5_resource_r13 {
    pub starting_prb_format5_r13: Format5_resource_r13StartingPRB_format5_r13,
    pub cdm_index_format5_r13: Format5_resource_r13Cdm_index_format5_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "64")]
pub struct FreqBandIndicator(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "86")]
pub struct FreqBandIndicator_UTRA_FDD(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "256")]
pub struct FreqBandIndicator_r11(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "65", ub = "256")]
pub struct FreqBandIndicator_v9e0(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct FreqBandIndicatorListEUTRA_r12(pub Vec<FreqBandIndicator_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "1024")]
pub struct FreqBandIndicatorNR_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct FreqHoppingParameters_r13 {
    #[asn(optional_idx = 0)]
    pub dummy: Option<FreqHoppingParameters_r13Dummy>,
    #[asn(optional_idx = 1)]
    pub dummy2: Option<FreqHoppingParameters_r13Dummy2>,
    #[asn(optional_idx = 2)]
    pub dummy3: Option<FreqHoppingParameters_r13Dummy3>,
    #[asn(optional_idx = 3)]
    pub interval_ul_hopping_config_common_mode_a_r13:
        Option<FreqHoppingParameters_r13Interval_ULHoppingConfigCommonModeA_r13>,
    #[asn(optional_idx = 4)]
    pub interval_ul_hopping_config_common_mode_b_r13:
        Option<FreqHoppingParameters_r13Interval_ULHoppingConfigCommonModeB_r13>,
    #[asn(optional_idx = 5)]
    pub dummy4: Option<FreqHoppingParameters_r13Dummy4>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FreqPriorityEUTRA {
    pub carrier_freq: ARFCN_ValueEUTRA,
    pub cell_reselection_priority: CellReselectionPriority,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FreqPriorityEUTRA_r12 {
    pub carrier_freq_r12: ARFCN_ValueEUTRA_r9,
    pub cell_reselection_priority_r12: CellReselectionPriority,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct FreqPriorityEUTRA_v1310 {
    #[asn(optional_idx = 0)]
    pub cell_reselection_sub_priority_r13: Option<CellReselectionSubPriority_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct FreqPriorityEUTRA_v9e0 {
    #[asn(optional_idx = 0)]
    pub carrier_freq_v9e0: Option<ARFCN_ValueEUTRA_v9e0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct FreqPriorityListEUTRA(pub Vec<FreqPriorityEUTRA>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct FreqPriorityListEUTRA_v1310(pub Vec<FreqPriorityEUTRA_v1310>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct FreqPriorityListExtEUTRA_r12(pub Vec<FreqPriorityEUTRA_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct FreqPriorityListExtEUTRA_v1310(pub Vec<FreqPriorityEUTRA_v1310>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct FreqPriorityListNR_r15(pub Vec<FreqPriorityNR_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct FreqPriorityListUTRA_FDD(pub Vec<FreqPriorityUTRA_FDD>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct FreqPriorityListUTRA_TDD(pub Vec<FreqPriorityUTRA_TDD>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct FreqPriorityNR_r15 {
    pub carrier_freq_r15: ARFCN_ValueNR_r15,
    pub cell_reselection_priority_r15: CellReselectionPriority,
    #[asn(optional_idx = 0)]
    pub cell_reselection_sub_priority_r15: Option<CellReselectionSubPriority_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FreqPriorityUTRA_FDD {
    pub carrier_freq: ARFCN_ValueUTRA,
    pub cell_reselection_priority: CellReselectionPriority,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FreqPriorityUTRA_TDD {
    pub carrier_freq: ARFCN_ValueUTRA,
    pub cell_reselection_priority: CellReselectionPriority,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FreqsPriorityGERAN {
    pub carrier_freqs: CarrierFreqsGERAN,
    pub cell_reselection_priority: CellReselectionPriority,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct FreqsPriorityListGERAN(pub Vec<FreqsPriorityGERAN>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct GNSS_ID_r15 {
    pub gnss_id_r15: GNSS_ID_r15Gnss_id_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct GNSS_ValidityDuration_r17(pub u8);
impl GNSS_ValidityDuration_r17 {
    pub const S10: u8 = 0u8;
    pub const S20: u8 = 1u8;
    pub const S30: u8 = 2u8;
    pub const S40: u8 = 3u8;
    pub const S50: u8 = 4u8;
    pub const S60: u8 = 5u8;
    pub const MIN5: u8 = 6u8;
    pub const MIN10: u8 = 7u8;
    pub const MIN15: u8 = 8u8;
    pub const MIN20: u8 = 9u8;
    pub const MIN25: u8 = 10u8;
    pub const MIN30: u8 = 11u8;
    pub const MIN50: u8 = 12u8;
    pub const MIN90: u8 = 13u8;
    pub const MIN120: u8 = 14u8;
    pub const INFINITY: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 7)]
pub struct GWUS_Config_r16 {
    #[asn(optional_idx = 0)]
    pub group_alternation_r16: Option<GWUS_Config_r16GroupAlternation_r16>,
    #[asn(optional_idx = 1)]
    pub common_sequence_r16: Option<GWUS_Config_r16CommonSequence_r16>,
    #[asn(optional_idx = 2)]
    pub time_parameters_r16: Option<GWUS_TimeParameters_r16>,
    pub resource_config_drx_r16: GWUS_ResourceConfig_r16,
    #[asn(optional_idx = 3)]
    pub resource_config_e_drx_short_r16: Option<GWUS_ResourceConfig_r16>,
    #[asn(optional_idx = 4)]
    pub resource_config_e_drx_long_r16: Option<GWUS_ResourceConfig_r16>,
    #[asn(optional_idx = 5)]
    pub prob_thresh_list_r16: Option<GWUS_ProbThreshList_r16>,
    #[asn(optional_idx = 6)]
    pub group_narrow_band_list_r16: Option<GWUS_GroupNarrowBandList_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct GWUS_GroupNarrowBandList_r16(pub Vec<GWUS_GroupNarrowBandList_r16_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct GWUS_GroupsForServiceList_r16(pub Vec<GWUS_GroupsForServiceList_r16_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct GWUS_NumGroups_r16(pub u8);
impl GWUS_NumGroups_r16 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N4: u8 = 2u8;
    pub const N8: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct GWUS_NumGroupsList_r16(pub Vec<GWUS_NumGroups_r16>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct GWUS_PagingProbThresh_r16(pub u8);
impl GWUS_PagingProbThresh_r16 {
    pub const P20: u8 = 0u8;
    pub const P30: u8 = 1u8;
    pub const P40: u8 = 2u8;
    pub const P50: u8 = 3u8;
    pub const P60: u8 = 4u8;
    pub const P70: u8 = 5u8;
    pub const P80: u8 = 6u8;
    pub const P90: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct GWUS_ProbThreshList_r16(pub Vec<GWUS_PagingProbThresh_r16>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct GWUS_ResourceConfig_r16 {
    pub resource_mapping_pattern_r16: GWUS_ResourceConfig_r16ResourceMappingPattern_r16,
    #[asn(optional_idx = 0)]
    pub num_groups_list_r16: Option<GWUS_NumGroupsList_r16>,
    #[asn(optional_idx = 1)]
    pub groups_for_service_list_r16: Option<GWUS_GroupsForServiceList_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct GWUS_TimeParameters_r16 {
    pub max_duration_factor_r16: GWUS_TimeParameters_r16MaxDurationFactor_r16,
    #[asn(optional_idx = 0)]
    pub num_p_os_r16: Option<GWUS_TimeParameters_r16NumPOs_r16>,
    pub time_offset_drx_r16: GWUS_TimeParameters_r16TimeOffsetDRX_r16,
    pub time_offset_e_drx_short_r16: GWUS_TimeParameters_r16TimeOffset_eDRX_Short_r16,
    #[asn(optional_idx = 1)]
    pub time_offset_e_drx_long_r16: Option<GWUS_TimeParameters_r16TimeOffset_eDRX_Long_r16>,
    #[asn(optional_idx = 2)]
    pub num_drx_cycles_relaxed_r16: Option<GWUS_TimeParameters_r16NumDRX_CyclesRelaxed_r16>,
    #[asn(optional_idx = 3)]
    pub power_boost_r16: Option<GWUS_TimeParameters_r16PowerBoost_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct Handover {
    pub target_rat_type: HandoverTargetRAT_Type,
    pub target_rat_message_container: HandoverTargetRAT_MessageContainer,
    #[asn(optional_idx = 0)]
    pub nas_security_param_from_eutra: Option<HandoverNas_SecurityParamFromEUTRA>,
    #[asn(optional_idx = 1)]
    pub system_information: Option<SI_OrPSI_GERAN>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverCommand {
    pub critical_extensions: HandoverCommandCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct HandoverCommand_r8_IEs {
    pub handover_command_message: HandoverCommand_r8_IEsHandoverCommandMessage,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<HandoverCommand_r8_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverFromEUTRAPreparationRequest {
    pub rrc_transaction_identifier: RRC_TransactionIdentifier,
    pub critical_extensions: HandoverFromEUTRAPreparationRequestCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct HandoverFromEUTRAPreparationRequest_r8_IEs {
    pub cdma2000_type: CDMA2000_Type,
    #[asn(optional_idx = 0)]
    pub rand: Option<RAND_CDMA2000>,
    #[asn(optional_idx = 1)]
    pub mobility_parameters: Option<MobilityParametersCDMA2000>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<HandoverFromEUTRAPreparationRequest_v890_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct HandoverFromEUTRAPreparationRequest_v1020_IEs {
    #[asn(optional_idx = 0)]
    pub dual_rx_tx_redirect_indicator_r10:
        Option<HandoverFromEUTRAPreparationRequest_v1020_IEsDualRxTxRedirectIndicator_r10>,
    #[asn(optional_idx = 1)]
    pub redirect_carrier_cdma2000_1xrtt_r10: Option<CarrierFreqCDMA2000>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension:
        Option<HandoverFromEUTRAPreparationRequest_v1020_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct HandoverFromEUTRAPreparationRequest_v890_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<HandoverFromEUTRAPreparationRequest_v890_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<HandoverFromEUTRAPreparationRequest_v920_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct HandoverFromEUTRAPreparationRequest_v920_IEs {
    #[asn(optional_idx = 0)]
    pub concurr_prep_cdma2000_hrpd_r9:
        Option<HandoverFromEUTRAPreparationRequest_v920_IEsConcurrPrepCDMA2000_HRPD_r9>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<HandoverFromEUTRAPreparationRequest_v1020_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverPreparationInformation {
    pub critical_extensions: HandoverPreparationInformationCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct HandoverPreparationInformation_r8_IEs {
    pub ue_radio_access_capability_info: UE_CapabilityRAT_ContainerList,
    #[asn(optional_idx = 0)]
    pub as_config: Option<AS_Config>,
    #[asn(optional_idx = 1)]
    pub rrm_config: Option<RRM_Config>,
    #[asn(optional_idx = 2)]
    pub as_context: Option<AS_Context>,
    #[asn(optional_idx = 3)]
    pub non_critical_extension: Option<HandoverPreparationInformation_v920_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct HandoverPreparationInformation_v10j0_IEs {
    #[asn(optional_idx = 0)]
    pub as_config_v10j0: Option<AS_Config_v10j0>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<HandoverPreparationInformation_v10x0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct HandoverPreparationInformation_v10x0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<HandoverPreparationInformation_v10x0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<HandoverPreparationInformation_v13c0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct HandoverPreparationInformation_v1130_IEs {
    #[asn(optional_idx = 0)]
    pub as_context_v1130: Option<AS_Context_v1130>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<HandoverPreparationInformation_v1250_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct HandoverPreparationInformation_v1250_IEs {
    #[asn(optional_idx = 0)]
    pub ue_supported_earfcn_r12: Option<ARFCN_ValueEUTRA_r9>,
    #[asn(optional_idx = 1)]
    pub as_config_v1250: Option<AS_Config_v1250>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<HandoverPreparationInformation_v1320_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct HandoverPreparationInformation_v1320_IEs {
    #[asn(optional_idx = 0)]
    pub as_config_v1320: Option<AS_Config_v1320>,
    #[asn(optional_idx = 1)]
    pub as_context_v1320: Option<AS_Context_v1320>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<HandoverPreparationInformation_v1430_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct HandoverPreparationInformation_v13c0_IEs {
    #[asn(optional_idx = 0)]
    pub as_config_v13c0: Option<AS_Config_v13c0>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension:
        Option<HandoverPreparationInformation_v13c0_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct HandoverPreparationInformation_v1430_IEs {
    #[asn(optional_idx = 0)]
    pub as_config_v1430: Option<AS_Config_v1430>,
    #[asn(optional_idx = 1)]
    pub make_before_break_req_r14:
        Option<HandoverPreparationInformation_v1430_IEsMakeBeforeBreakReq_r14>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<HandoverPreparationInformation_v1530_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct HandoverPreparationInformation_v1530_IEs {
    #[asn(optional_idx = 0)]
    pub ran_notification_area_info_r15: Option<RAN_NotificationAreaInfo_r15>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<HandoverPreparationInformation_v1540_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct HandoverPreparationInformation_v1540_IEs {
    #[asn(optional_idx = 0)]
    pub source_rb_config_intra5_gc_r15:
        Option<HandoverPreparationInformation_v1540_IEsSourceRB_ConfigIntra5GC_r15>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<HandoverPreparationInformation_v1610_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct HandoverPreparationInformation_v1610_IEs {
    #[asn(optional_idx = 0)]
    pub as_context_v1610: Option<AS_Context_v1610>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<HandoverPreparationInformation_v1620_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct HandoverPreparationInformation_v1620_IEs {
    #[asn(optional_idx = 0)]
    pub as_context_v1620: Option<AS_Context_v1620>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<HandoverPreparationInformation_v1630_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct HandoverPreparationInformation_v1630_IEs {
    #[asn(optional_idx = 0)]
    pub as_context_v1630: Option<AS_Context_v1630>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<HandoverPreparationInformation_v1700_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct HandoverPreparationInformation_v1700_IEs {
    #[asn(optional_idx = 0)]
    pub as_config_v1700: Option<AS_Config_v1700>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension:
        Option<HandoverPreparationInformation_v1700_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct HandoverPreparationInformation_v920_IEs {
    #[asn(optional_idx = 0)]
    pub ue_config_release_r9: Option<HandoverPreparationInformation_v920_IEsUe_ConfigRelease_r9>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<HandoverPreparationInformation_v9d0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct HandoverPreparationInformation_v9d0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<HandoverPreparationInformation_v9d0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<HandoverPreparationInformation_v9e0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct HandoverPreparationInformation_v9e0_IEs {
    #[asn(optional_idx = 0)]
    pub as_config_v9e0: Option<AS_Config_v9e0>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<HandoverPreparationInformation_v1130_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct HandoverPreparationInformation_v9j0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<HandoverPreparationInformation_v9j0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<HandoverPreparationInformation_v10j0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct HighSpeedConfig_r14 {
    #[asn(optional_idx = 0)]
    pub high_speed_enhanced_meas_flag_r14: Option<HighSpeedConfig_r14HighSpeedEnhancedMeasFlag_r14>,
    #[asn(optional_idx = 1)]
    pub high_speed_enhanced_demodulation_flag_r14:
        Option<HighSpeedConfig_r14HighSpeedEnhancedDemodulationFlag_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HighSpeedConfig_v1530 {
    pub high_speed_meas_gap_ce_mode_a_r15: HighSpeedConfig_v1530HighSpeedMeasGapCE_ModeA_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct HighSpeedConfig_v1610 {
    #[asn(optional_idx = 0)]
    pub high_speed_enh_meas_flag2_r16: Option<HighSpeedConfig_v1610HighSpeedEnhMeasFlag2_r16>,
    #[asn(optional_idx = 1)]
    pub high_speed_enh_demod_flag2_r16: Option<HighSpeedConfig_v1610HighSpeedEnhDemodFlag2_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct HighSpeedConfigSCell_r14 {
    #[asn(optional_idx = 0)]
    pub high_speed_enhanced_demodulation_flag_r14:
        Option<HighSpeedConfigSCell_r14HighSpeedEnhancedDemodulationFlag_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct HighSpeedEnhParameters_r14 {
    #[asn(optional_idx = 0)]
    pub measurement_enhancements_r14: Option<HighSpeedEnhParameters_r14MeasurementEnhancements_r14>,
    #[asn(optional_idx = 1)]
    pub demodulation_enhancements_r14:
        Option<HighSpeedEnhParameters_r14DemodulationEnhancements_r14>,
    #[asn(optional_idx = 2)]
    pub prach_enhancements_r14: Option<HighSpeedEnhParameters_r14Prach_Enhancements_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct HighSpeedEnhParameters_v1610 {
    #[asn(optional_idx = 0)]
    pub measurement_enhancements_s_cell_r16:
        Option<HighSpeedEnhParameters_v1610MeasurementEnhancementsSCell_r16>,
    #[asn(optional_idx = 1)]
    pub measurement_enhancements2_r16:
        Option<HighSpeedEnhParameters_v1610MeasurementEnhancements2_r16>,
    #[asn(optional_idx = 2)]
    pub demodulation_enhancements2_r16:
        Option<HighSpeedEnhParameters_v1610DemodulationEnhancements2_r16>,
    #[asn(optional_idx = 3)]
    pub inter_rat_enhancement_nr_r16:
        Option<HighSpeedEnhParameters_v1610InterRAT_enhancementNR_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "30")]
pub struct Hysteresis(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "40", sz_ub = "40")]
pub struct I_RNTI_r15(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct IDC_Config_r11 {
    #[asn(optional_idx = 0)]
    pub idc_indication_r11: Option<IDC_Config_r11Idc_Indication_r11>,
    #[asn(optional_idx = 1)]
    pub autonomous_denial_parameters_r11: Option<IDC_Config_r11AutonomousDenialParameters_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum IDC_SubframePattern_r11 {
    #[asn(key = 0, extended = false)]
    SubframePatternFDD_r11(IDC_SubframePattern_r11_subframePatternFDD_r11),
    #[asn(key = 1, extended = false)]
    SubframePatternTDD_r11(IDC_SubframePattern_r11_subframePatternTDD_r11),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct IDC_SubframePatternList_r11(pub Vec<IDC_SubframePattern_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IKE_Identity_r13 {
    pub id_i_r13: IKE_Identity_r13IdI_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "6", sz_ub = "21")]
pub struct IMSI(pub Vec<IMSI_Digit>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "9")]
pub struct IMSI_Digit(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum IP_Address_r13 {
    #[asn(key = 0, extended = false)]
    Ipv4_r13(IP_Address_r13_ipv4_r13),
    #[asn(key = 1, extended = false)]
    Ipv6_r13(IP_Address_r13_ipv6_r13),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IRAT_ParametersCDMA2000_1XRTT {
    pub supported_band_list1_xrtt: SupportedBandList1XRTT,
    pub tx_config1_xrtt: IRAT_ParametersCDMA2000_1XRTTTx_Config1XRTT,
    pub rx_config1_xrtt: IRAT_ParametersCDMA2000_1XRTTRx_Config1XRTT,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IRAT_ParametersCDMA2000_1XRTT_v1020 {
    pub e_csfb_dual_1xrtt_r10: IRAT_ParametersCDMA2000_1XRTT_v1020E_CSFB_dual_1XRTT_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct IRAT_ParametersCDMA2000_1XRTT_v920 {
    pub e_csfb_1xrtt_r9: IRAT_ParametersCDMA2000_1XRTT_v920E_CSFB_1XRTT_r9,
    #[asn(optional_idx = 0)]
    pub e_csfb_conc_ps_mob1_xrtt_r9:
        Option<IRAT_ParametersCDMA2000_1XRTT_v920E_CSFB_ConcPS_Mob1XRTT_r9>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IRAT_ParametersCDMA2000_HRPD {
    pub supported_band_list_hrpd: SupportedBandListHRPD,
    pub tx_config_hrpd: IRAT_ParametersCDMA2000_HRPDTx_ConfigHRPD,
    pub rx_config_hrpd: IRAT_ParametersCDMA2000_HRPDRx_ConfigHRPD,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct IRAT_ParametersCDMA2000_v1130 {
    #[asn(optional_idx = 0)]
    pub cdma2000_nw_sharing_r11: Option<IRAT_ParametersCDMA2000_v1130Cdma2000_NW_Sharing_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IRAT_ParametersGERAN {
    pub supported_band_list_geran: SupportedBandListGERAN,
    pub inter_rat_ps_ho_to_geran: IRAT_ParametersGERANInterRAT_PS_HO_ToGERAN,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct IRAT_ParametersGERAN_v920 {
    #[asn(optional_idx = 0)]
    pub dtm_r9: Option<IRAT_ParametersGERAN_v920Dtm_r9>,
    #[asn(optional_idx = 1)]
    pub e_redirection_geran_r9: Option<IRAT_ParametersGERAN_v920E_RedirectionGERAN_r9>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct IRAT_ParametersNR_r15 {
    #[asn(optional_idx = 0)]
    pub en_dc_r15: Option<IRAT_ParametersNR_r15En_DC_r15>,
    #[asn(optional_idx = 1)]
    pub event_b2_r15: Option<IRAT_ParametersNR_r15EventB2_r15>,
    #[asn(optional_idx = 2)]
    pub supported_band_list_en_dc_r15: Option<SupportedBandListNR_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 12)]
pub struct IRAT_ParametersNR_v1540 {
    #[asn(optional_idx = 0)]
    pub eutra_5gc_ho_to_nr_fdd_fr1_r15:
        Option<IRAT_ParametersNR_v1540Eutra_5GC_HO_ToNR_FDD_FR1_r15>,
    #[asn(optional_idx = 1)]
    pub eutra_5gc_ho_to_nr_tdd_fr1_r15:
        Option<IRAT_ParametersNR_v1540Eutra_5GC_HO_ToNR_TDD_FR1_r15>,
    #[asn(optional_idx = 2)]
    pub eutra_5gc_ho_to_nr_fdd_fr2_r15:
        Option<IRAT_ParametersNR_v1540Eutra_5GC_HO_ToNR_FDD_FR2_r15>,
    #[asn(optional_idx = 3)]
    pub eutra_5gc_ho_to_nr_tdd_fr2_r15:
        Option<IRAT_ParametersNR_v1540Eutra_5GC_HO_ToNR_TDD_FR2_r15>,
    #[asn(optional_idx = 4)]
    pub eutra_epc_ho_to_nr_fdd_fr1_r15:
        Option<IRAT_ParametersNR_v1540Eutra_EPC_HO_ToNR_FDD_FR1_r15>,
    #[asn(optional_idx = 5)]
    pub eutra_epc_ho_to_nr_tdd_fr1_r15:
        Option<IRAT_ParametersNR_v1540Eutra_EPC_HO_ToNR_TDD_FR1_r15>,
    #[asn(optional_idx = 6)]
    pub eutra_epc_ho_to_nr_fdd_fr2_r15:
        Option<IRAT_ParametersNR_v1540Eutra_EPC_HO_ToNR_FDD_FR2_r15>,
    #[asn(optional_idx = 7)]
    pub eutra_epc_ho_to_nr_tdd_fr2_r15:
        Option<IRAT_ParametersNR_v1540Eutra_EPC_HO_ToNR_TDD_FR2_r15>,
    #[asn(optional_idx = 8)]
    pub ims_voice_over_nr_fr1_r15: Option<IRAT_ParametersNR_v1540Ims_VoiceOverNR_FR1_r15>,
    #[asn(optional_idx = 9)]
    pub ims_voice_over_nr_fr2_r15: Option<IRAT_ParametersNR_v1540Ims_VoiceOverNR_FR2_r15>,
    #[asn(optional_idx = 10)]
    pub sa_nr_r15: Option<IRAT_ParametersNR_v1540Sa_NR_r15>,
    #[asn(optional_idx = 11)]
    pub supported_band_list_nr_sa_r15: Option<SupportedBandListNR_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct IRAT_ParametersNR_v1560 {
    #[asn(optional_idx = 0)]
    pub ng_en_dc_r15: Option<IRAT_ParametersNR_v1560Ng_EN_DC_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct IRAT_ParametersNR_v1570 {
    #[asn(optional_idx = 0)]
    pub ss_sinr_meas_nr_fr1_r15: Option<IRAT_ParametersNR_v1570Ss_SINR_Meas_NR_FR1_r15>,
    #[asn(optional_idx = 1)]
    pub ss_sinr_meas_nr_fr2_r15: Option<IRAT_ParametersNR_v1570Ss_SINR_Meas_NR_FR2_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct IRAT_ParametersNR_v1610 {
    #[asn(optional_idx = 0)]
    pub nr_ho_to_en_dc_r16: Option<IRAT_ParametersNR_v1610Nr_HO_ToEN_DC_r16>,
    #[asn(optional_idx = 1)]
    pub ce_eutra_5gc_ho_to_nr_fdd_fr1_r16:
        Option<IRAT_ParametersNR_v1610Ce_EUTRA_5GC_HO_ToNR_FDD_FR1_r16>,
    #[asn(optional_idx = 2)]
    pub ce_eutra_5gc_ho_to_nr_tdd_fr1_r16:
        Option<IRAT_ParametersNR_v1610Ce_EUTRA_5GC_HO_ToNR_TDD_FR1_r16>,
    #[asn(optional_idx = 3)]
    pub ce_eutra_5gc_ho_to_nr_fdd_fr2_r16:
        Option<IRAT_ParametersNR_v1610Ce_EUTRA_5GC_HO_ToNR_FDD_FR2_r16>,
    #[asn(optional_idx = 4)]
    pub ce_eutra_5gc_ho_to_nr_tdd_fr2_r16:
        Option<IRAT_ParametersNR_v1610Ce_EUTRA_5GC_HO_ToNR_TDD_FR2_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct IRAT_ParametersNR_v1660 {
    #[asn(optional_idx = 0)]
    pub extended_band_n77_r16: Option<IRAT_ParametersNR_v1660ExtendedBand_n77_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct IRAT_ParametersNR_v1700 {
    #[asn(optional_idx = 0)]
    pub eutra_5gc_ho_to_nr_tdd_fr2_2_r17:
        Option<IRAT_ParametersNR_v1700Eutra_5GC_HO_ToNR_TDD_FR2_2_r17>,
    #[asn(optional_idx = 1)]
    pub eutra_epc_ho_to_nr_tdd_fr2_2_r17:
        Option<IRAT_ParametersNR_v1700Eutra_EPC_HO_ToNR_TDD_FR2_2_r17>,
    #[asn(optional_idx = 2)]
    pub ce_eutra_5gc_ho_to_nr_tdd_fr2_2_r17:
        Option<IRAT_ParametersNR_v1700Ce_EUTRA_5GC_HO_ToNR_TDD_FR2_2_r17>,
    #[asn(optional_idx = 3)]
    pub ims_voice_over_nr_fr2_2_r17: Option<IRAT_ParametersNR_v1700Ims_VoiceOverNR_FR2_2_r17>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct IRAT_ParametersNR_v1710 {
    #[asn(optional_idx = 0)]
    pub extended_band_n77_2_r17: Option<IRAT_ParametersNR_v1710ExtendedBand_n77_2_r17>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IRAT_ParametersUTRA_FDD {
    pub supported_band_list_utra_fdd: SupportedBandListUTRA_FDD,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IRAT_ParametersUTRA_TDD_v1020 {
    pub e_redirection_utra_tdd_r10: IRAT_ParametersUTRA_TDD_v1020E_RedirectionUTRA_TDD_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IRAT_ParametersUTRA_TDD128 {
    pub supported_band_list_utra_tdd128: SupportedBandListUTRA_TDD128,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IRAT_ParametersUTRA_TDD384 {
    pub supported_band_list_utra_tdd384: SupportedBandListUTRA_TDD384,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IRAT_ParametersUTRA_TDD768 {
    pub supported_band_list_utra_tdd768: SupportedBandListUTRA_TDD768,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IRAT_ParametersUTRA_v920 {
    pub e_redirection_utra_r9: IRAT_ParametersUTRA_v920E_RedirectionUTRA_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct IRAT_ParametersUTRA_v9c0 {
    #[asn(optional_idx = 0)]
    pub voice_over_ps_hs_utra_fdd_r9: Option<IRAT_ParametersUTRA_v9c0VoiceOverPS_HS_UTRA_FDD_r9>,
    #[asn(optional_idx = 1)]
    pub voice_over_ps_hs_utra_tdd128_r9:
        Option<IRAT_ParametersUTRA_v9c0VoiceOverPS_HS_UTRA_TDD128_r9>,
    #[asn(optional_idx = 2)]
    pub srvcc_from_utra_fdd_to_utra_fdd_r9:
        Option<IRAT_ParametersUTRA_v9c0Srvcc_FromUTRA_FDD_ToUTRA_FDD_r9>,
    #[asn(optional_idx = 3)]
    pub srvcc_from_utra_fdd_to_geran_r9:
        Option<IRAT_ParametersUTRA_v9c0Srvcc_FromUTRA_FDD_ToGERAN_r9>,
    #[asn(optional_idx = 4)]
    pub srvcc_from_utra_tdd128_to_utra_tdd128_r9:
        Option<IRAT_ParametersUTRA_v9c0Srvcc_FromUTRA_TDD128_ToUTRA_TDD128_r9>,
    #[asn(optional_idx = 5)]
    pub srvcc_from_utra_tdd128_to_geran_r9:
        Option<IRAT_ParametersUTRA_v9c0Srvcc_FromUTRA_TDD128_ToGERAN_r9>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IRAT_ParametersUTRA_v9h0 {
    pub mfbi_utra_r9: IRAT_ParametersUTRA_v9h0Mfbi_UTRA_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct IRAT_ParametersWLAN_r13 {
    #[asn(optional_idx = 0)]
    pub supported_band_list_wlan_r13: Option<IRAT_ParametersWLAN_r13SupportedBandListWLAN_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 7)]
pub struct IdleModeMobilityControlInfo {
    #[asn(optional_idx = 0)]
    pub freq_priority_list_eutra: Option<FreqPriorityListEUTRA>,
    #[asn(optional_idx = 1)]
    pub freq_priority_list_geran: Option<FreqsPriorityListGERAN>,
    #[asn(optional_idx = 2)]
    pub freq_priority_list_utra_fdd: Option<FreqPriorityListUTRA_FDD>,
    #[asn(optional_idx = 3)]
    pub freq_priority_list_utra_tdd: Option<FreqPriorityListUTRA_TDD>,
    #[asn(optional_idx = 4)]
    pub band_class_priority_list_hrpd: Option<BandClassPriorityListHRPD>,
    #[asn(optional_idx = 5)]
    pub band_class_priority_list1_xrtt: Option<BandClassPriorityList1XRTT>,
    #[asn(optional_idx = 6)]
    pub t320: Option<IdleModeMobilityControlInfoT320>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IdleModeMobilityControlInfo_v9e0 {
    pub freq_priority_list_eutra_v9e0: IdleModeMobilityControlInfo_v9e0FreqPriorityListEUTRA_v9e0,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InDeviceCoexIndication_r11 {
    pub critical_extensions: InDeviceCoexIndication_r11CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct InDeviceCoexIndication_r11_IEs {
    #[asn(optional_idx = 0)]
    pub affected_carrier_freq_list_r11: Option<AffectedCarrierFreqList_r11>,
    #[asn(optional_idx = 1)]
    pub tdm_assistance_info_r11: Option<TDM_AssistanceInfo_r11>,
    #[asn(optional_idx = 2)]
    pub late_non_critical_extension: Option<InDeviceCoexIndication_r11_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 3)]
    pub non_critical_extension: Option<InDeviceCoexIndication_v11d0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct InDeviceCoexIndication_v11d0_IEs {
    #[asn(optional_idx = 0)]
    pub ul_ca_assistance_info_r11: Option<InDeviceCoexIndication_v11d0_IEsUl_CA_AssistanceInfo_r11>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<InDeviceCoexIndication_v1310_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct InDeviceCoexIndication_v1310_IEs {
    #[asn(optional_idx = 0)]
    pub affected_carrier_freq_list_v1310: Option<AffectedCarrierFreqList_v1310>,
    #[asn(optional_idx = 1)]
    pub affected_carrier_freq_comb_list_r13: Option<AffectedCarrierFreqCombList_r13>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<InDeviceCoexIndication_v1360_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct InDeviceCoexIndication_v1360_IEs {
    #[asn(optional_idx = 0)]
    pub hardware_sharing_problem_r13:
        Option<InDeviceCoexIndication_v1360_IEsHardwareSharingProblem_r13>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<InDeviceCoexIndication_v1530_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct InDeviceCoexIndication_v1530_IEs {
    #[asn(optional_idx = 0)]
    pub mrdc_assistance_info_r15: Option<MRDC_AssistanceInfo_r15>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<InDeviceCoexIndication_v1610_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct InDeviceCoexIndication_v1610_IEs {
    #[asn(optional_idx = 0)]
    pub victim_system_type_v1610: Option<VictimSystemType_v1610>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<InDeviceCoexIndication_v1610_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum InitialUE_Identity {
    #[asn(key = 0, extended = false)]
    S_TMSI(S_TMSI),
    #[asn(key = 1, extended = false)]
    RandomValue(InitialUE_Identity_randomValue),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum InitialUE_Identity_5GC_r15 {
    #[asn(key = 0, extended = false)]
    Ng_5G_S_TMSI_Part1(InitialUE_Identity_5GC_r15_ng_5G_S_TMSI_Part1),
    #[asn(key = 1, extended = false)]
    RandomValue(InitialUE_Identity_5GC_r15_randomValue),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InterFreqBandInfo {
    pub inter_freq_need_for_gaps: InterFreqBandInfoInterFreqNeedForGaps,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct InterFreqBandList(pub Vec<InterFreqBandInfo>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 6)]
pub struct InterFreqCarrierFreqInfo {
    pub dl_carrier_freq: ARFCN_ValueEUTRA,
    pub q_rx_lev_min: Q_RxLevMin,
    #[asn(optional_idx = 0)]
    pub p_max: Option<P_Max>,
    pub t_reselection_eutra: T_Reselection,
    #[asn(optional_idx = 1)]
    pub t_reselection_eutra_sf: Option<SpeedStateScaleFactors>,
    pub thresh_x_high: ReselectionThreshold,
    pub thresh_x_low: ReselectionThreshold,
    pub allowed_meas_bandwidth: AllowedMeasBandwidth,
    pub presence_antenna_port1: PresenceAntennaPort1,
    #[asn(optional_idx = 2)]
    pub cell_reselection_priority: Option<CellReselectionPriority>,
    pub neigh_cell_config: NeighCellConfig,
    #[asn(optional_idx = 3)]
    pub q_offset_freq: Option<Q_OffsetRange>,
    #[asn(optional_idx = 4)]
    pub inter_freq_neigh_cell_list: Option<InterFreqNeighCellList>,
    #[asn(optional_idx = 5)]
    pub inter_freq_excluded_cell_list: Option<InterFreqExcludedCellList>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 12)]
pub struct InterFreqCarrierFreqInfo_r12 {
    pub dl_carrier_freq_r12: ARFCN_ValueEUTRA_r9,
    pub q_rx_lev_min_r12: Q_RxLevMin,
    #[asn(optional_idx = 0)]
    pub p_max_r12: Option<P_Max>,
    pub t_reselection_eutra_r12: T_Reselection,
    #[asn(optional_idx = 1)]
    pub t_reselection_eutra_sf_r12: Option<SpeedStateScaleFactors>,
    pub thresh_x_high_r12: ReselectionThreshold,
    pub thresh_x_low_r12: ReselectionThreshold,
    pub allowed_meas_bandwidth_r12: AllowedMeasBandwidth,
    pub presence_antenna_port1_r12: PresenceAntennaPort1,
    #[asn(optional_idx = 2)]
    pub cell_reselection_priority_r12: Option<CellReselectionPriority>,
    pub neigh_cell_config_r12: NeighCellConfig,
    #[asn(optional_idx = 3)]
    pub q_offset_freq_r12: Option<Q_OffsetRange>,
    #[asn(optional_idx = 4)]
    pub inter_freq_neigh_cell_list_r12: Option<InterFreqNeighCellList>,
    #[asn(optional_idx = 5)]
    pub inter_freq_excluded_cell_list_r12: Option<InterFreqExcludedCellList>,
    #[asn(optional_idx = 6)]
    pub q_qual_min_r12: Option<Q_QualMin_r9>,
    #[asn(optional_idx = 7)]
    pub thresh_x_q_r12: Option<InterFreqCarrierFreqInfo_r12ThreshX_Q_r12>,
    #[asn(optional_idx = 8)]
    pub q_qual_min_wb_r12: Option<Q_QualMin_r9>,
    #[asn(optional_idx = 9)]
    pub multi_band_info_list_r12: Option<MultiBandInfoList_r11>,
    #[asn(optional_idx = 10)]
    pub reduced_meas_performance_r12:
        Option<InterFreqCarrierFreqInfo_r12ReducedMeasPerformance_r12>,
    #[asn(optional_idx = 11)]
    pub q_qual_min_rsrq_on_all_symbols_r12: Option<Q_QualMin_r9>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct InterFreqCarrierFreqInfo_v10j0 {
    #[asn(optional_idx = 0)]
    pub freq_band_info_r10: Option<NS_PmaxList_r10>,
    #[asn(optional_idx = 1)]
    pub multi_band_info_list_v10j0: Option<MultiBandInfoList_v10j0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct InterFreqCarrierFreqInfo_v10l0 {
    #[asn(optional_idx = 0)]
    pub freq_band_info_v10l0: Option<NS_PmaxList_v10l0>,
    #[asn(optional_idx = 1)]
    pub multi_band_info_list_v10l0: Option<MultiBandInfoList_v10l0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct InterFreqCarrierFreqInfo_v1250 {
    #[asn(optional_idx = 0)]
    pub reduced_meas_performance_r12:
        Option<InterFreqCarrierFreqInfo_v1250ReducedMeasPerformance_r12>,
    #[asn(optional_idx = 1)]
    pub q_qual_min_rsrq_on_all_symbols_r12: Option<Q_QualMin_r9>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct InterFreqCarrierFreqInfo_v1310 {
    #[asn(optional_idx = 0)]
    pub cell_reselection_sub_priority_r13: Option<CellReselectionSubPriority_r13>,
    #[asn(optional_idx = 1)]
    pub redistribution_inter_freq_info_r13: Option<RedistributionInterFreqInfo_r13>,
    #[asn(optional_idx = 2)]
    pub cell_selection_info_ce_r13: Option<CellSelectionInfoCE_r13>,
    #[asn(optional_idx = 3)]
    pub t_reselection_eutra_ce_r13: Option<T_ReselectionEUTRA_CE_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct InterFreqCarrierFreqInfo_v1350 {
    #[asn(optional_idx = 0)]
    pub cell_selection_info_ce1_r13: Option<CellSelectionInfoCE1_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct InterFreqCarrierFreqInfo_v1360 {
    #[asn(optional_idx = 0)]
    pub cell_selection_info_ce1_v1360: Option<CellSelectionInfoCE1_v1360>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct InterFreqCarrierFreqInfo_v1530 {
    pub hsdn_indication_r15: InterFreqCarrierFreqInfo_v1530Hsdn_Indication_r15,
    #[asn(optional_idx = 0)]
    pub inter_freq_neigh_hsdn_cell_list_r15: Option<InterFreqNeighHSDN_CellList_r15>,
    #[asn(optional_idx = 1)]
    pub cell_selection_info_ce_v1530: Option<CellSelectionInfoCE_v1530>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct InterFreqCarrierFreqInfo_v1610 {
    #[asn(optional_idx = 0)]
    pub alt_cell_reselection_priority_r16: Option<CellReselectionPriority>,
    #[asn(optional_idx = 1)]
    pub alt_cell_reselection_sub_priority_r16: Option<CellReselectionSubPriority_r13>,
    #[asn(optional_idx = 2)]
    pub rss_config_carrier_info_r16: Option<RSS_ConfigCarrierInfo_r16>,
    #[asn(optional_idx = 3)]
    pub inter_freq_neigh_cell_list_v1610: Option<InterFreqNeighCellList_v1610>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct InterFreqCarrierFreqInfo_v8h0 {
    #[asn(optional_idx = 0)]
    pub multi_band_info_list: Option<MultiBandInfoList>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct InterFreqCarrierFreqInfo_v9e0 {
    #[asn(optional_idx = 0)]
    pub dl_carrier_freq_v9e0: Option<ARFCN_ValueEUTRA_v9e0>,
    #[asn(optional_idx = 1)]
    pub multi_band_info_list_v9e0: Option<MultiBandInfoList_v9e0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct InterFreqCarrierFreqList(pub Vec<InterFreqCarrierFreqInfo>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct InterFreqCarrierFreqList_v1250(pub Vec<InterFreqCarrierFreqInfo_v1250>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct InterFreqCarrierFreqList_v1310(pub Vec<InterFreqCarrierFreqInfo_v1310>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct InterFreqCarrierFreqList_v1350(pub Vec<InterFreqCarrierFreqInfo_v1350>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct InterFreqCarrierFreqList_v13a0(pub Vec<InterFreqCarrierFreqInfo_v1360>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct InterFreqCarrierFreqList_v1530(pub Vec<InterFreqCarrierFreqInfo_v1530>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct InterFreqCarrierFreqList_v1610(pub Vec<InterFreqCarrierFreqInfo_v1610>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct InterFreqCarrierFreqListExt_r12(pub Vec<InterFreqCarrierFreqInfo_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct InterFreqCarrierFreqListExt_v1280(pub Vec<InterFreqCarrierFreqInfo_v10j0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct InterFreqCarrierFreqListExt_v1310(pub Vec<InterFreqCarrierFreqInfo_v1310>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct InterFreqCarrierFreqListExt_v1350(pub Vec<InterFreqCarrierFreqInfo_v1350>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct InterFreqCarrierFreqListExt_v1360(pub Vec<InterFreqCarrierFreqInfo_v1360>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct InterFreqCarrierFreqListExt_v1530(pub Vec<InterFreqCarrierFreqInfo_v1530>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct InterFreqCarrierFreqListExt_v1610(pub Vec<InterFreqCarrierFreqInfo_v1610>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct InterFreqExcludedCellList(pub Vec<PhysCellIdRange>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InterFreqNeighCellInfo {
    pub phys_cell_id: PhysCellId,
    pub q_offset_cell: Q_OffsetRange,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InterFreqNeighCellInfo_v1610 {
    pub rss_meas_power_bias_r16: RSS_MeasPowerBias_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct InterFreqNeighCellList(pub Vec<InterFreqNeighCellInfo>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct InterFreqNeighCellList_v1610(pub Vec<InterFreqNeighCellInfo_v1610>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct InterFreqNeighHSDN_CellList_r15(pub Vec<PhysCellIdRange>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InterFreqRSTDMeasurementIndication_r10 {
    pub critical_extensions: InterFreqRSTDMeasurementIndication_r10CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct InterFreqRSTDMeasurementIndication_r10_IEs {
    pub rstd_inter_freq_indication_r10:
        InterFreqRSTDMeasurementIndication_r10_IEsRstd_InterFreqIndication_r10,
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<InterFreqRSTDMeasurementIndication_r10_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension:
        Option<InterFreqRSTDMeasurementIndication_r10_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InterRAT_BandInfo {
    pub inter_rat_need_for_gaps: InterRAT_BandInfoInterRAT_NeedForGaps,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InterRAT_BandInfoNR_r16 {
    pub inter_rat_need_for_gaps_nr_r16: InterRAT_BandInfoNR_r16InterRAT_NeedForGapsNR_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct InterRAT_BandList(pub Vec<InterRAT_BandInfo>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "1024"
)]
pub struct InterRAT_BandListNR_r16(pub Vec<InterRAT_BandInfoNR_r16>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct IntraBandContiguousCC_Info_r12 {
    #[asn(optional_idx = 0)]
    pub four_layer_tm3_tm4_per_cc_r12:
        Option<IntraBandContiguousCC_Info_r12FourLayerTM3_TM4_perCC_r12>,
    #[asn(optional_idx = 1)]
    pub supported_mimo_capability_dl_r12: Option<MIMO_CapabilityDL_r10>,
    #[asn(optional_idx = 2)]
    pub supported_csi_proc_r12: Option<IntraBandContiguousCC_Info_r12SupportedCSI_Proc_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct IntraFreqExcludedCellList(pub Vec<PhysCellIdRange>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct IntraFreqNeighCellInfo {
    pub phys_cell_id: PhysCellId,
    pub q_offset_cell: Q_OffsetRange,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IntraFreqNeighCellInfo_v1610 {
    pub rss_meas_power_bias_r16: RSS_MeasPowerBias_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct IntraFreqNeighCellList(pub Vec<IntraFreqNeighCellInfo>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct IntraFreqNeighCellList_v1610(pub Vec<IntraFreqNeighCellInfo_v1610>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct IntraFreqNeighHSDN_CellList_r15(pub Vec<PhysCellIdRange>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "BITSTRING",
    sz_extensible = false,
    sz_lb = "256",
    sz_ub = "256"
)]
pub struct Key_eNodeB_Star(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 7)]
pub struct LAA_Parameters_r13 {
    #[asn(optional_idx = 0)]
    pub cross_carrier_scheduling_laa_dl_r13:
        Option<LAA_Parameters_r13CrossCarrierSchedulingLAA_DL_r13>,
    #[asn(optional_idx = 1)]
    pub csi_rs_drs_rrm_measurements_laa_r13:
        Option<LAA_Parameters_r13Csi_RS_DRS_RRM_MeasurementsLAA_r13>,
    #[asn(optional_idx = 2)]
    pub downlink_laa_r13: Option<LAA_Parameters_r13DownlinkLAA_r13>,
    #[asn(optional_idx = 3)]
    pub ending_dw_pts_r13: Option<LAA_Parameters_r13EndingDwPTS_r13>,
    #[asn(optional_idx = 4)]
    pub second_slot_starting_position_r13: Option<LAA_Parameters_r13SecondSlotStartingPosition_r13>,
    #[asn(optional_idx = 5)]
    pub tm9_laa_r13: Option<LAA_Parameters_r13Tm9_LAA_r13>,
    #[asn(optional_idx = 6)]
    pub tm10_laa_r13: Option<LAA_Parameters_r13Tm10_LAA_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct LAA_Parameters_v1430 {
    #[asn(optional_idx = 0)]
    pub cross_carrier_scheduling_laa_ul_r14:
        Option<LAA_Parameters_v1430CrossCarrierSchedulingLAA_UL_r14>,
    #[asn(optional_idx = 1)]
    pub uplink_laa_r14: Option<LAA_Parameters_v1430UplinkLAA_r14>,
    #[asn(optional_idx = 2)]
    pub two_step_scheduling_timing_info_r14:
        Option<LAA_Parameters_v1430TwoStepSchedulingTimingInfo_r14>,
    #[asn(optional_idx = 3)]
    pub uss_blind_decoding_adjustment_r14:
        Option<LAA_Parameters_v1430Uss_BlindDecodingAdjustment_r14>,
    #[asn(optional_idx = 4)]
    pub uss_blind_decoding_reduction_r14:
        Option<LAA_Parameters_v1430Uss_BlindDecodingReduction_r14>,
    #[asn(optional_idx = 5)]
    pub out_of_sequence_grant_handling_r14:
        Option<LAA_Parameters_v1430OutOfSequenceGrantHandling_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct LAA_Parameters_v1530 {
    #[asn(optional_idx = 0)]
    pub aul_r15: Option<LAA_Parameters_v1530Aul_r15>,
    #[asn(optional_idx = 1)]
    pub laa_pusch_mode1_r15: Option<LAA_Parameters_v1530Laa_PUSCH_Mode1_r15>,
    #[asn(optional_idx = 2)]
    pub laa_pusch_mode2_r15: Option<LAA_Parameters_v1530Laa_PUSCH_Mode2_r15>,
    #[asn(optional_idx = 3)]
    pub laa_pusch_mode3_r15: Option<LAA_Parameters_v1530Laa_PUSCH_Mode3_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LAA_SCellConfiguration_r13 {
    pub subframe_start_position_r13: LAA_SCellConfiguration_r13SubframeStartPosition_r13,
    pub laa_s_cell_subframe_config_r13: LAA_SCellConfiguration_r13Laa_SCellSubframeConfig_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct LAA_SCellConfiguration_v1430 {
    #[asn(optional_idx = 0)]
    pub cross_carrier_scheduling_config_ul_r14:
        Option<LAA_SCellConfiguration_v1430CrossCarrierSchedulingConfig_UL_r14>,
    #[asn(optional_idx = 1)]
    pub lbt_config_r14: Option<LBT_Config_r14>,
    #[asn(optional_idx = 2)]
    pub pdcch_config_laa_r14: Option<PDCCH_ConfigLAA_r14>,
    #[asn(optional_idx = 3)]
    pub absence_of_any_other_technology_r14:
        Option<LAA_SCellConfiguration_v1430AbsenceOfAnyOtherTechnology_r14>,
    #[asn(optional_idx = 4)]
    pub sounding_rs_ul_config_dedicated_aperiodic_v1430:
        Option<SoundingRS_UL_ConfigDedicatedAperiodic_v1430>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct LAA_SCellConfiguration_v1530 {
    #[asn(optional_idx = 0)]
    pub aul_config_r15: Option<AUL_Config_r15>,
    #[asn(optional_idx = 1)]
    pub pusch_mode_config_laa_r15: Option<PUSCH_ModeConfigLAA_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum LBT_Config_r14 {
    #[asn(key = 0, extended = false)]
    MaxEnergyDetectionThreshold_r14(LBT_Config_r14_maxEnergyDetectionThreshold_r14),
    #[asn(key = 1, extended = false)]
    EnergyDetectionThresholdOffset_r14(LBT_Config_r14_energyDetectionThresholdOffset_r14),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct LWA_Config_r13 {
    #[asn(optional_idx = 0)]
    pub lwa_mobility_config_r13: Option<WLAN_MobilityConfig_r13>,
    #[asn(optional_idx = 1)]
    pub lwa_wt_counter_r13: Option<LWA_Config_r13Lwa_WT_Counter_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum LWA_Configuration_r13 {
    #[asn(key = 0, extended = false)]
    Release(LWA_Configuration_r13_release),
    #[asn(key = 1, extended = false)]
    Setup(LWA_Configuration_r13_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct LWA_Parameters_r13 {
    #[asn(optional_idx = 0)]
    pub lwa_r13: Option<LWA_Parameters_r13Lwa_r13>,
    #[asn(optional_idx = 1)]
    pub lwa_split_bearer_r13: Option<LWA_Parameters_r13Lwa_SplitBearer_r13>,
    #[asn(optional_idx = 2)]
    pub wlan_mac_address_r13: Option<LWA_Parameters_r13Wlan_MAC_Address_r13>,
    #[asn(optional_idx = 3)]
    pub lwa_buffer_size_r13: Option<LWA_Parameters_r13Lwa_BufferSize_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct LWA_Parameters_v1430 {
    #[asn(optional_idx = 0)]
    pub lwa_ho_without_wt_change_r14: Option<LWA_Parameters_v1430Lwa_HO_WithoutWT_Change_r14>,
    #[asn(optional_idx = 1)]
    pub lwa_ul_r14: Option<LWA_Parameters_v1430Lwa_UL_r14>,
    #[asn(optional_idx = 2)]
    pub wlan_periodic_meas_r14: Option<LWA_Parameters_v1430Wlan_PeriodicMeas_r14>,
    #[asn(optional_idx = 3)]
    pub wlan_report_any_wlan_r14: Option<LWA_Parameters_v1430Wlan_ReportAnyWLAN_r14>,
    #[asn(optional_idx = 4)]
    pub wlan_supported_data_rate_r14: Option<LWA_Parameters_v1430Wlan_SupportedDataRate_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct LWA_Parameters_v1440 {
    #[asn(optional_idx = 0)]
    pub lwa_rlc_um_r14: Option<LWA_Parameters_v1440Lwa_RLC_UM_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct LWIP_Config_r13 {
    #[asn(optional_idx = 0)]
    pub lwip_mobility_config_r13: Option<WLAN_MobilityConfig_r13>,
    #[asn(optional_idx = 1)]
    pub tunnel_config_lwip_r13: Option<TunnelConfigLWIP_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum LWIP_Configuration_r13 {
    #[asn(key = 0, extended = false)]
    Release(LWIP_Configuration_r13_release),
    #[asn(key = 1, extended = false)]
    Setup(LWIP_Configuration_r13_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct LWIP_Parameters_r13 {
    #[asn(optional_idx = 0)]
    pub lwip_r13: Option<LWIP_Parameters_r13Lwip_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct LWIP_Parameters_v1430 {
    #[asn(optional_idx = 0)]
    pub lwip_aggregation_dl_r14: Option<LWIP_Parameters_v1430Lwip_Aggregation_DL_r14>,
    #[asn(optional_idx = 1)]
    pub lwip_aggregation_ul_r14: Option<LWIP_Parameters_v1430Lwip_Aggregation_UL_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct LocationInfo_r10 {
    pub location_coordinates_r10: LocationInfo_r10LocationCoordinates_r10,
    #[asn(optional_idx = 0)]
    pub horizontal_velocity_r10: Option<LocationInfo_r10HorizontalVelocity_r10>,
    #[asn(optional_idx = 1)]
    pub gnss_tod_msec_r10: Option<LocationInfo_r10Gnss_TOD_msec_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct LogMeasInfo_r10 {
    #[asn(optional_idx = 0)]
    pub location_info_r10: Option<LocationInfo_r10>,
    pub relative_time_stamp_r10: LogMeasInfo_r10RelativeTimeStamp_r10,
    pub serv_cell_identity_r10: CellGlobalIdEUTRA,
    pub meas_result_serv_cell_r10: LogMeasInfo_r10MeasResultServCell_r10,
    #[asn(optional_idx = 1)]
    pub meas_result_neigh_cells_r10: Option<LogMeasInfo_r10MeasResultNeighCells_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "520"
)]
pub struct LogMeasInfoList_r10(pub Vec<LogMeasInfo_r10>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "4060"
)]
pub struct LogMeasInfoList2_r10(pub Vec<LogMeasInfo_r10>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct LogMeasReport_r10 {
    pub absolute_time_stamp_r10: AbsoluteTimeInfo_r10,
    pub trace_reference_r10: TraceReference_r10,
    pub trace_recording_session_ref_r10: LogMeasReport_r10TraceRecordingSessionRef_r10,
    pub tce_id_r10: LogMeasReport_r10Tce_Id_r10,
    pub log_meas_info_list_r10: LogMeasInfoList_r10,
    #[asn(optional_idx = 0)]
    pub log_meas_available_r10: Option<LogMeasReport_r10LogMeasAvailable_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct LogMeasResultBT_r15 {
    pub bt_addr_r15: LogMeasResultBT_r15Bt_Addr_r15,
    #[asn(optional_idx = 0)]
    pub rssi_bt_r15: Option<LogMeasResultBT_r15Rssi_BT_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct LogMeasResultListBT_r15(pub Vec<LogMeasResultBT_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct LogMeasResultListWLAN_r15(pub Vec<LogMeasResultWLAN_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct LogMeasResultWLAN_r15 {
    pub wlan_identifiers_r15: WLAN_Identifiers_r12,
    #[asn(optional_idx = 0)]
    pub rssi_wlan_r15: Option<WLAN_RSSI_Range_r13>,
    #[asn(optional_idx = 1)]
    pub rtt_wlan_r15: Option<WLAN_RTT_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LoggedEventTriggerConfig_r17 {
    pub event_type_r17: EventType_r17,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LoggedMeasurementConfiguration_r10 {
    pub critical_extensions: LoggedMeasurementConfiguration_r10CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct LoggedMeasurementConfiguration_r10_IEs {
    pub trace_reference_r10: TraceReference_r10,
    pub trace_recording_session_ref_r10:
        LoggedMeasurementConfiguration_r10_IEsTraceRecordingSessionRef_r10,
    pub tce_id_r10: LoggedMeasurementConfiguration_r10_IEsTce_Id_r10,
    pub absolute_time_info_r10: AbsoluteTimeInfo_r10,
    #[asn(optional_idx = 0)]
    pub area_configuration_r10: Option<AreaConfiguration_r10>,
    pub logging_duration_r10: LoggingDuration_r10,
    pub logging_interval_r10: LoggingInterval_r10,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<LoggedMeasurementConfiguration_v1080_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct LoggedMeasurementConfiguration_v1080_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension_r10:
        Option<LoggedMeasurementConfiguration_v1080_IEsLateNonCriticalExtension_r10>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<LoggedMeasurementConfiguration_v1130_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct LoggedMeasurementConfiguration_v1130_IEs {
    #[asn(optional_idx = 0)]
    pub plmn_identity_list_r11: Option<PLMN_IdentityList3_r11>,
    #[asn(optional_idx = 1)]
    pub area_configuration_v1130: Option<AreaConfiguration_v1130>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<LoggedMeasurementConfiguration_v1250_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct LoggedMeasurementConfiguration_v1250_IEs {
    #[asn(optional_idx = 0)]
    pub target_mbsfn_area_list_r12: Option<TargetMBSFN_AreaList_r12>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<LoggedMeasurementConfiguration_v1530_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct LoggedMeasurementConfiguration_v1530_IEs {
    #[asn(optional_idx = 0)]
    pub bt_name_list_r15: Option<BT_NameList_r15>,
    #[asn(optional_idx = 1)]
    pub wlan_name_list_r15: Option<WLAN_NameList_r15>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<LoggedMeasurementConfiguration_v1700_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct LoggedMeasurementConfiguration_v1700_IEs {
    #[asn(optional_idx = 0)]
    pub logged_event_trigger_config_r17: Option<LoggedEventTriggerConfig_r17>,
    #[asn(optional_idx = 1)]
    pub meas_uncom_bar_pre_r17: Option<LoggedMeasurementConfiguration_v1700_IEsMeasUncomBarPre_r17>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension:
        Option<LoggedMeasurementConfiguration_v1700_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct LoggingDuration_r10(pub u8);
impl LoggingDuration_r10 {
    pub const MIN10: u8 = 0u8;
    pub const MIN20: u8 = 1u8;
    pub const MIN40: u8 = 2u8;
    pub const MIN60: u8 = 3u8;
    pub const MIN90: u8 = 4u8;
    pub const MIN120: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct LoggingInterval_r10(pub u8);
impl LoggingInterval_r10 {
    pub const MS1280: u8 = 0u8;
    pub const MS2560: u8 = 1u8;
    pub const MS5120: u8 = 2u8;
    pub const MS10240: u8 = 3u8;
    pub const MS20480: u8 = 4u8;
    pub const MS30720: u8 = 5u8;
    pub const MS40960: u8 = 6u8;
    pub const MS61440: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct LogicalChGroupInfoList_r13(pub Vec<SL_PriorityList_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct LogicalChGroupInfoList_v1530(pub Vec<SL_ReliabilityList_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct LogicalChannelConfig {
    #[asn(optional_idx = 0)]
    pub ul_specific_parameters: Option<LogicalChannelConfigUl_SpecificParameters>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct MAC_MainConfig {
    #[asn(optional_idx = 0)]
    pub ul_sch_config: Option<MAC_MainConfigUl_SCH_Config>,
    #[asn(optional_idx = 1)]
    pub drx_config: Option<DRX_Config>,
    pub time_alignment_timer_dedicated: TimeAlignmentTimer,
    #[asn(optional_idx = 2)]
    pub phr_config: Option<MAC_MainConfigPhr_Config>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct MAC_MainConfigSCell_r11 {
    #[asn(optional_idx = 0)]
    pub stag_id_r11: Option<STAG_Id_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MAC_MainConfigSL_r12 {
    #[asn(optional_idx = 0)]
    pub periodic_bsr_timer_sl: Option<PeriodicBSR_Timer_r12>,
    pub retx_bsr_timer_sl: RetxBSR_Timer_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MAC_Parameters_r12 {
    #[asn(optional_idx = 0)]
    pub logical_channel_sr_prohibit_timer_r12:
        Option<MAC_Parameters_r12LogicalChannelSR_ProhibitTimer_r12>,
    #[asn(optional_idx = 1)]
    pub long_drx_command_r12: Option<MAC_Parameters_r12LongDRX_Command_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MAC_Parameters_v1310 {
    #[asn(optional_idx = 0)]
    pub extended_mac_length_field_r13: Option<MAC_Parameters_v1310ExtendedMAC_LengthField_r13>,
    #[asn(optional_idx = 1)]
    pub extended_long_drx_r13: Option<MAC_Parameters_v1310ExtendedLongDRX_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct MAC_Parameters_v1430 {
    #[asn(optional_idx = 0)]
    pub short_sps_interval_fdd_r14: Option<MAC_Parameters_v1430ShortSPS_IntervalFDD_r14>,
    #[asn(optional_idx = 1)]
    pub short_sps_interval_tdd_r14: Option<MAC_Parameters_v1430ShortSPS_IntervalTDD_r14>,
    #[asn(optional_idx = 2)]
    pub skip_uplink_dynamic_r14: Option<MAC_Parameters_v1430SkipUplinkDynamic_r14>,
    #[asn(optional_idx = 3)]
    pub skip_uplink_sps_r14: Option<MAC_Parameters_v1430SkipUplinkSPS_r14>,
    #[asn(optional_idx = 4)]
    pub multiple_uplink_sps_r14: Option<MAC_Parameters_v1430MultipleUplinkSPS_r14>,
    #[asn(optional_idx = 5)]
    pub data_inact_mon_r14: Option<MAC_Parameters_v1430DataInactMon_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MAC_Parameters_v1440 {
    #[asn(optional_idx = 0)]
    pub rai_support_r14: Option<MAC_Parameters_v1440Rai_Support_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 8)]
pub struct MAC_Parameters_v1530 {
    #[asn(optional_idx = 0)]
    pub min_proc_timeline_subslot_r15: Option<MAC_Parameters_v1530Min_Proc_TimelineSubslot_r15>,
    #[asn(optional_idx = 1)]
    pub skip_subframe_processing_r15: Option<SkipSubframeProcessing_r15>,
    #[asn(optional_idx = 2)]
    pub early_data_up_r15: Option<MAC_Parameters_v1530EarlyData_UP_r15>,
    #[asn(optional_idx = 3)]
    pub dormant_s_cell_state_r15: Option<MAC_Parameters_v1530DormantSCellState_r15>,
    #[asn(optional_idx = 4)]
    pub direct_s_cell_activation_r15: Option<MAC_Parameters_v1530DirectSCellActivation_r15>,
    #[asn(optional_idx = 5)]
    pub direct_s_cell_hibernation_r15: Option<MAC_Parameters_v1530DirectSCellHibernation_r15>,
    #[asn(optional_idx = 6)]
    pub extended_lcid_duplication_r15: Option<MAC_Parameters_v1530ExtendedLCID_Duplication_r15>,
    #[asn(optional_idx = 7)]
    pub sps_serving_cell_r15: Option<MAC_Parameters_v1530Sps_ServingCell_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MAC_Parameters_v1550 {
    #[asn(optional_idx = 0)]
    pub elcid_support_r15: Option<MAC_Parameters_v1550ELCID_Support_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct MAC_Parameters_v1610 {
    #[asn(optional_idx = 0)]
    pub direct_mcg_s_cell_activation_resume_r16:
        Option<MAC_Parameters_v1610DirectMCG_SCellActivationResume_r16>,
    #[asn(optional_idx = 1)]
    pub direct_scg_s_cell_activation_resume_r16:
        Option<MAC_Parameters_v1610DirectSCG_SCellActivationResume_r16>,
    #[asn(optional_idx = 2)]
    pub early_data_up_5gc_r16: Option<MAC_Parameters_v1610EarlyData_UP_5GC_r16>,
    #[asn(optional_idx = 3)]
    pub rai_support_enh_r16: Option<MAC_Parameters_v1610Rai_SupportEnh_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MAC_Parameters_v1630 {
    #[asn(optional_idx = 0)]
    pub direct_scg_s_cell_activation_nedc_r16:
        Option<MAC_Parameters_v1630DirectSCG_SCellActivationNEDC_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MBMS_CarrierType_r14 {
    pub carrier_type_r14: MBMS_CarrierType_r14CarrierType_r14,
    #[asn(optional_idx = 0)]
    pub frame_offset_r14: Option<MBMS_CarrierType_r14FrameOffset_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MBMS_InterFreqCarrierTypeList_r14(pub Vec<MBMS_CarrierType_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MBMS_NotificationConfig_r9 {
    pub notification_repetition_coeff_r9: MBMS_NotificationConfig_r9NotificationRepetitionCoeff_r9,
    pub notification_offset_r9: MBMS_NotificationConfig_r9NotificationOffset_r9,
    pub notification_sf_index_r9: MBMS_NotificationConfig_r9NotificationSF_Index_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MBMS_NotificationConfig_v1430 {
    pub notification_sf_index_v1430: MBMS_NotificationConfig_v1430NotificationSF_Index_v1430,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MBMS_Parameters_r11 {
    #[asn(optional_idx = 0)]
    pub mbms_s_cell_r11: Option<MBMS_Parameters_r11Mbms_SCell_r11>,
    #[asn(optional_idx = 1)]
    pub mbms_non_serving_cell_r11: Option<MBMS_Parameters_r11Mbms_NonServingCell_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MBMS_Parameters_v1250 {
    #[asn(optional_idx = 0)]
    pub mbms_async_dc_r12: Option<MBMS_Parameters_v1250Mbms_AsyncDC_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct MBMS_Parameters_v1430 {
    #[asn(optional_idx = 0)]
    pub fembms_dedicated_cell_r14: Option<MBMS_Parameters_v1430FembmsDedicatedCell_r14>,
    #[asn(optional_idx = 1)]
    pub fembms_mixed_cell_r14: Option<MBMS_Parameters_v1430FembmsMixedCell_r14>,
    #[asn(optional_idx = 2)]
    pub subcarrier_spacing_mbms_khz7dot5_r14:
        Option<MBMS_Parameters_v1430SubcarrierSpacingMBMS_khz7dot5_r14>,
    #[asn(optional_idx = 3)]
    pub subcarrier_spacing_mbms_khz1dot25_r14:
        Option<MBMS_Parameters_v1430SubcarrierSpacingMBMS_khz1dot25_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MBMS_Parameters_v1470 {
    pub mbms_max_bw_r14: MBMS_Parameters_v1470Mbms_MaxBW_r14,
    #[asn(optional_idx = 0)]
    pub mbms_scaling_factor1dot25_r14: Option<MBMS_Parameters_v1470Mbms_ScalingFactor1dot25_r14>,
    #[asn(optional_idx = 1)]
    pub mbms_scaling_factor7dot5_r14: Option<MBMS_Parameters_v1470Mbms_ScalingFactor7dot5_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MBMS_Parameters_v1610 {
    #[asn(optional_idx = 0)]
    pub mbms_scaling_factor2dot5_r16: Option<MBMS_Parameters_v1610Mbms_ScalingFactor2dot5_r16>,
    #[asn(optional_idx = 1)]
    pub mbms_scaling_factor0dot37_r16: Option<MBMS_Parameters_v1610Mbms_ScalingFactor0dot37_r16>,
    pub mbms_supported_band_info_list_r16: MBMS_Parameters_v1610Mbms_SupportedBandInfoList_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MBMS_Parameters_v1700 {
    #[asn(optional_idx = 0)]
    pub mbms_supported_band_info_list_v1700:
        Option<MBMS_Parameters_v1700Mbms_SupportedBandInfoList_v1700>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MBMS_ROM_Info_r15 {
    pub mbms_rom_freq_r15: ARFCN_ValueEUTRA_r9,
    pub mbms_rom_subcarrier_spacing_r15: MBMS_ROM_Info_r15Mbms_ROM_SubcarrierSpacing_r15,
    pub mbms_bandwidth_r15: MBMS_ROM_Info_r15Mbms_Bandwidth_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MBMS_ROM_Info_r16 {
    pub mbms_rom_freq_r16: ARFCN_ValueEUTRA_r9,
    pub mbms_rom_subcarrier_spacing_r16: MBMS_ROM_Info_r16Mbms_ROM_SubcarrierSpacing_r16,
    pub mbms_bandwidth_r16: MBMS_ROM_Info_r16Mbms_Bandwidth_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MBMS_SAI_InterFreq_r11 {
    pub dl_carrier_freq_r11: ARFCN_ValueEUTRA_r9,
    pub mbms_sai_list_r11: MBMS_SAI_List_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MBMS_SAI_InterFreq_v1140 {
    #[asn(optional_idx = 0)]
    pub multi_band_info_list_r11: Option<MultiBandInfoList_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MBMS_SAI_InterFreqList_r11(pub Vec<MBMS_SAI_InterFreq_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MBMS_SAI_InterFreqList_v1140(pub Vec<MBMS_SAI_InterFreq_v1140>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct MBMS_SAI_List_r11(pub Vec<MBMS_SAI_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct MBMS_SAI_r11(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MBMS_ServiceInfo_r13 {
    pub tmgi_r13: TMGI_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "0", sz_ub = "15")]
pub struct MBMS_ServiceList_r13(pub Vec<MBMS_ServiceInfo_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct MBMS_SessionInfo_r9 {
    pub tmgi_r9: TMGI_r9,
    #[asn(optional_idx = 0)]
    pub session_id_r9: Option<MBMS_SessionInfo_r9SessionId_r9>,
    pub logical_channel_identity_r9: MBMS_SessionInfo_r9LogicalChannelIdentity_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "0", sz_ub = "29")]
pub struct MBMS_SessionInfoList_r9(pub Vec<MBMS_SessionInfo_r9>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MBMS_SupportedBandInfo_r16 {
    #[asn(optional_idx = 0)]
    pub subcarrier_spacing_mbms_khz2dot5_r16:
        Option<MBMS_SupportedBandInfo_r16SubcarrierSpacingMBMS_khz2dot5_r16>,
    #[asn(optional_idx = 1)]
    pub subcarrier_spacing_mbms_khz0dot37_r16:
        Option<MBMS_SupportedBandInfo_r16SubcarrierSpacingMBMS_khz0dot37_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct MBMS_SupportedBandInfo_v1700 {
    #[asn(optional_idx = 0)]
    pub pmch_bandwidth_n40_r17: Option<MBMS_SupportedBandInfo_v1700Pmch_Bandwidth_n40_r17>,
    #[asn(optional_idx = 1)]
    pub pmch_bandwidth_n35_r17: Option<MBMS_SupportedBandInfo_v1700Pmch_Bandwidth_n35_r17>,
    #[asn(optional_idx = 2)]
    pub pmch_bandwidth_n30_r17: Option<MBMS_SupportedBandInfo_v1700Pmch_Bandwidth_n30_r17>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MBMSCountingRequest_r10 {
    pub counting_request_list_r10: CountingRequestList_r10,
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<MBMSCountingRequest_r10LateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<MBMSCountingRequest_r10NonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MBMSCountingResponse_r10 {
    pub critical_extensions: MBMSCountingResponse_r10CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct MBMSCountingResponse_r10_IEs {
    #[asn(optional_idx = 0)]
    pub mbsfn_area_index_r10: Option<MBMSCountingResponse_r10_IEsMbsfn_AreaIndex_r10>,
    #[asn(optional_idx = 1)]
    pub counting_response_list_r10: Option<CountingResponseList_r10>,
    #[asn(optional_idx = 2)]
    pub late_non_critical_extension: Option<MBMSCountingResponse_r10_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 3)]
    pub non_critical_extension: Option<MBMSCountingResponse_r10_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MBMSInterestIndication_r11 {
    pub critical_extensions: MBMSInterestIndication_r11CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct MBMSInterestIndication_r11_IEs {
    #[asn(optional_idx = 0)]
    pub mbms_freq_list_r11: Option<CarrierFreqListMBMS_r11>,
    #[asn(optional_idx = 1)]
    pub mbms_priority_r11: Option<MBMSInterestIndication_r11_IEsMbms_Priority_r11>,
    #[asn(optional_idx = 2)]
    pub late_non_critical_extension: Option<MBMSInterestIndication_r11_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 3)]
    pub non_critical_extension: Option<MBMSInterestIndication_v1310_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MBMSInterestIndication_v1310_IEs {
    #[asn(optional_idx = 0)]
    pub mbms_services_r13: Option<MBMS_ServiceList_r13>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<MBMSInterestIndication_v1540_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MBMSInterestIndication_v1540_IEs {
    #[asn(optional_idx = 0)]
    pub mbms_rom_info_list_r15: Option<MBMSInterestIndication_v1540_IEsMbms_ROM_InfoList_r15>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<MBMSInterestIndication_v1610_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MBMSInterestIndication_v1610_IEs {
    #[asn(optional_idx = 0)]
    pub mbms_rom_info_list_r16: Option<MBMSInterestIndication_v1610_IEsMbms_ROM_InfoList_r16>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<MBMSInterestIndication_v1610_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MBMSSessionInfo_r13 {
    pub tmgi_r13: TMGI_r9,
    #[asn(optional_idx = 0)]
    pub session_id_r13: Option<MBMSSessionInfo_r13SessionId_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct MBSFN_AreaId_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct MBSFN_AreaInfo_r16 {
    pub mbsfn_area_id_r16: MBSFN_AreaId_r12,
    pub notification_indicator_r16: MBSFN_AreaInfo_r16NotificationIndicator_r16,
    pub mcch_config_r16: MBSFN_AreaInfo_r16Mcch_Config_r16,
    pub subcarrier_spacing_mbms_r16: MBSFN_AreaInfo_r16SubcarrierSpacingMBMS_r16,
    #[asn(optional_idx = 0)]
    pub time_separation_r16: Option<MBSFN_AreaInfo_r16TimeSeparation_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MBSFN_AreaInfo_r17 {
    pub mbsfn_area_info_r17: MBSFN_AreaInfo_r16,
    pub pmch_bandwidth_r17: MBSFN_AreaInfo_r17Pmch_Bandwidth_r17,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MBSFN_AreaInfo_r9 {
    pub mbsfn_area_id_r9: MBSFN_AreaId_r12,
    pub non_mbsf_nregion_length: MBSFN_AreaInfo_r9Non_MBSFNregionLength,
    pub notification_indicator_r9: MBSFN_AreaInfo_r9NotificationIndicator_r9,
    pub mcch_config_r9: MBSFN_AreaInfo_r9Mcch_Config_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MBSFN_AreaInfoList_r16(pub Vec<MBSFN_AreaInfo_r16>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MBSFN_AreaInfoList_r17(pub Vec<MBSFN_AreaInfo_r17>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MBSFN_AreaInfoList_r9(pub Vec<MBSFN_AreaInfo_r9>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct MBSFN_RSRQ_Range_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MBSFN_SubframeConfig {
    pub radioframe_allocation_period: MBSFN_SubframeConfigRadioframeAllocationPeriod,
    pub radioframe_allocation_offset: MBSFN_SubframeConfigRadioframeAllocationOffset,
    pub subframe_allocation: MBSFN_SubframeConfigSubframeAllocation,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MBSFN_SubframeConfig_v1430 {
    pub subframe_allocation_v1430: MBSFN_SubframeConfig_v1430SubframeAllocation_v1430,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MBSFN_SubframeConfig_v1610 {
    pub subframe_allocation_v1610: MBSFN_SubframeConfig_v1610SubframeAllocation_v1610,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MBSFN_SubframeConfigList(pub Vec<MBSFN_SubframeConfig>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MBSFN_SubframeConfigList_v1430(pub Vec<MBSFN_SubframeConfig_v1430>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MBSFNAreaConfiguration_r9 {
    pub common_sf_alloc_r9: CommonSF_AllocPatternList_r9,
    pub common_sf_alloc_period_r9: MBSFNAreaConfiguration_r9CommonSF_AllocPeriod_r9,
    pub pmch_info_list_r9: PMCH_InfoList_r9,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<MBSFNAreaConfiguration_v930_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MBSFNAreaConfiguration_v1250_IEs {
    #[asn(optional_idx = 0)]
    pub pmch_info_list_ext_r12: Option<PMCH_InfoListExt_r12>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<MBSFNAreaConfiguration_v1430_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MBSFNAreaConfiguration_v1430_IEs {
    pub common_sf_alloc_v1430: CommonSF_AllocPatternList_v1430,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<MBSFNAreaConfiguration_v1610_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MBSFNAreaConfiguration_v1610_IEs {
    #[asn(optional_idx = 0)]
    pub common_sf_alloc_v1610: Option<CommonSF_AllocPatternList_v1610>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<MBSFNAreaConfiguration_v1610_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MBSFNAreaConfiguration_v930_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<MBSFNAreaConfiguration_v930_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<MBSFNAreaConfiguration_v1250_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct MCC(pub Vec<MCC_MNC_Digit>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "9")]
pub struct MCC_MNC_Digit(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MCCH_Message {
    pub message: MCCH_MessageType,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MCCH_MessageType {
    #[asn(key = 0, extended = false)]
    C1(MCCH_MessageType_c1),
    #[asn(key = 1, extended = false)]
    Later(MCCH_MessageType_later),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MCGFailureInformation_r16 {
    pub critical_extensions: MCGFailureInformation_r16CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct MCGFailureInformation_r16_IEs {
    #[asn(optional_idx = 0)]
    pub failure_report_mcg_r16: Option<FailureReportMCG_r16>,
    #[asn(optional_idx = 1)]
    pub late_non_critical_extension: Option<MCGFailureInformation_r16_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<MCGFailureInformation_r16_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MCS_PSSCH_Range_r15 {
    pub min_mcs_pssch_r15: MCS_PSSCH_Range_r15MinMCS_PSSCH_r15,
    pub max_mcs_pssch_r15: MCS_PSSCH_Range_r15MaxMCS_PSSCH_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MIMO_BeamformedCapabilities_r13 {
    pub k_max_r13: MIMO_BeamformedCapabilities_r13K_Max_r13,
    #[asn(optional_idx = 0)]
    pub n_max_list_r13: Option<MIMO_BeamformedCapabilities_r13N_MaxList_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct MIMO_BeamformedCapabilityList_r13(pub Vec<MIMO_BeamformedCapabilities_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MIMO_CA_ParametersPerBoBC_r13 {
    #[asn(optional_idx = 0)]
    pub parameters_tm9_r13: Option<MIMO_CA_ParametersPerBoBCPerTM_r13>,
    #[asn(optional_idx = 1)]
    pub parameters_tm10_r13: Option<MIMO_CA_ParametersPerBoBCPerTM_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MIMO_CA_ParametersPerBoBC_r15 {
    #[asn(optional_idx = 0)]
    pub parameters_tm9_r15: Option<MIMO_CA_ParametersPerBoBCPerTM_r15>,
    #[asn(optional_idx = 1)]
    pub parameters_tm10_r15: Option<MIMO_CA_ParametersPerBoBCPerTM_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MIMO_CA_ParametersPerBoBC_v1430 {
    #[asn(optional_idx = 0)]
    pub parameters_tm9_v1430: Option<MIMO_CA_ParametersPerBoBCPerTM_v1430>,
    #[asn(optional_idx = 1)]
    pub parameters_tm10_v1430: Option<MIMO_CA_ParametersPerBoBCPerTM_v1430>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MIMO_CA_ParametersPerBoBC_v1470 {
    pub parameters_tm9_v1470: MIMO_CA_ParametersPerBoBCPerTM_v1470,
    pub parameters_tm10_v1470: MIMO_CA_ParametersPerBoBCPerTM_v1470,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct MIMO_CA_ParametersPerBoBCPerTM_r13 {
    #[asn(optional_idx = 0)]
    pub non_precoded_r13: Option<MIMO_NonPrecodedCapabilities_r13>,
    #[asn(optional_idx = 1)]
    pub beamformed_r13: Option<MIMO_BeamformedCapabilityList_r13>,
    #[asn(optional_idx = 2)]
    pub dmrs_enhancements_r13: Option<MIMO_CA_ParametersPerBoBCPerTM_r13Dmrs_Enhancements_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct MIMO_CA_ParametersPerBoBCPerTM_r15 {
    #[asn(optional_idx = 0)]
    pub non_precoded_r13: Option<MIMO_NonPrecodedCapabilities_r13>,
    #[asn(optional_idx = 1)]
    pub beamformed_r13: Option<MIMO_BeamformedCapabilityList_r13>,
    #[asn(optional_idx = 2)]
    pub dmrs_enhancements_r13: Option<MIMO_CA_ParametersPerBoBCPerTM_r15Dmrs_Enhancements_r13>,
    #[asn(optional_idx = 3)]
    pub csi_reporting_np_r14: Option<MIMO_CA_ParametersPerBoBCPerTM_r15Csi_ReportingNP_r14>,
    #[asn(optional_idx = 4)]
    pub csi_reporting_advanced_r14:
        Option<MIMO_CA_ParametersPerBoBCPerTM_r15Csi_ReportingAdvanced_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MIMO_CA_ParametersPerBoBCPerTM_v1430 {
    #[asn(optional_idx = 0)]
    pub csi_reporting_np_r14: Option<MIMO_CA_ParametersPerBoBCPerTM_v1430Csi_ReportingNP_r14>,
    #[asn(optional_idx = 1)]
    pub csi_reporting_advanced_r14:
        Option<MIMO_CA_ParametersPerBoBCPerTM_v1430Csi_ReportingAdvanced_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MIMO_CA_ParametersPerBoBCPerTM_v1470 {
    #[asn(optional_idx = 0)]
    pub csi_reporting_advanced_max_ports_r14:
        Option<MIMO_CA_ParametersPerBoBCPerTM_v1470Csi_ReportingAdvancedMaxPorts_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct MIMO_CapabilityDL_r10(pub u8);
impl MIMO_CapabilityDL_r10 {
    pub const TWO_LAYERS: u8 = 0u8;
    pub const FOUR_LAYERS: u8 = 1u8;
    pub const EIGHT_LAYERS: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct MIMO_CapabilityUL_r10(pub u8);
impl MIMO_CapabilityUL_r10 {
    pub const TWO_LAYERS: u8 = 0u8;
    pub const FOUR_LAYERS: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct MIMO_NonPrecodedCapabilities_r13 {
    #[asn(optional_idx = 0)]
    pub config1_r13: Option<MIMO_NonPrecodedCapabilities_r13Config1_r13>,
    #[asn(optional_idx = 1)]
    pub config2_r13: Option<MIMO_NonPrecodedCapabilities_r13Config2_r13>,
    #[asn(optional_idx = 2)]
    pub config3_r13: Option<MIMO_NonPrecodedCapabilities_r13Config3_r13>,
    #[asn(optional_idx = 3)]
    pub config4_r13: Option<MIMO_NonPrecodedCapabilities_r13Config4_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MIMO_UE_BeamformedCapabilities_r13 {
    #[asn(optional_idx = 0)]
    pub alt_codebook_r13: Option<MIMO_UE_BeamformedCapabilities_r13AltCodebook_r13>,
    pub mimo_beamformed_capabilities_r13: MIMO_BeamformedCapabilityList_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct MIMO_UE_Parameters_r13 {
    #[asn(optional_idx = 0)]
    pub parameters_tm9_r13: Option<MIMO_UE_ParametersPerTM_r13>,
    #[asn(optional_idx = 1)]
    pub parameters_tm10_r13: Option<MIMO_UE_ParametersPerTM_r13>,
    #[asn(optional_idx = 2)]
    pub srs_enhancements_tdd_r13: Option<MIMO_UE_Parameters_r13Srs_EnhancementsTDD_r13>,
    #[asn(optional_idx = 3)]
    pub srs_enhancements_r13: Option<MIMO_UE_Parameters_r13Srs_Enhancements_r13>,
    #[asn(optional_idx = 4)]
    pub interference_meas_restriction_r13:
        Option<MIMO_UE_Parameters_r13InterferenceMeasRestriction_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MIMO_UE_Parameters_v13e0 {
    #[asn(optional_idx = 0)]
    pub mimo_weighted_layers_capabilities_r13: Option<MIMO_WeightedLayersCapabilities_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MIMO_UE_Parameters_v1430 {
    #[asn(optional_idx = 0)]
    pub parameters_tm9_v1430: Option<MIMO_UE_ParametersPerTM_v1430>,
    #[asn(optional_idx = 1)]
    pub parameters_tm10_v1430: Option<MIMO_UE_ParametersPerTM_v1430>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MIMO_UE_Parameters_v1470 {
    pub parameters_tm9_v1470: MIMO_UE_ParametersPerTM_v1470,
    pub parameters_tm10_v1470: MIMO_UE_ParametersPerTM_v1470,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct MIMO_UE_ParametersPerTM_r13 {
    #[asn(optional_idx = 0)]
    pub non_precoded_r13: Option<MIMO_NonPrecodedCapabilities_r13>,
    #[asn(optional_idx = 1)]
    pub beamformed_r13: Option<MIMO_UE_BeamformedCapabilities_r13>,
    #[asn(optional_idx = 2)]
    pub channel_meas_restriction_r13: Option<MIMO_UE_ParametersPerTM_r13ChannelMeasRestriction_r13>,
    #[asn(optional_idx = 3)]
    pub dmrs_enhancements_r13: Option<MIMO_UE_ParametersPerTM_r13Dmrs_Enhancements_r13>,
    #[asn(optional_idx = 4)]
    pub csi_rs_enhancements_tdd_r13: Option<MIMO_UE_ParametersPerTM_r13Csi_RS_EnhancementsTDD_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 10)]
pub struct MIMO_UE_ParametersPerTM_v1430 {
    #[asn(optional_idx = 0)]
    pub nzp_csi_rs_aperiodic_info_r14:
        Option<MIMO_UE_ParametersPerTM_v1430Nzp_CSI_RS_AperiodicInfo_r14>,
    #[asn(optional_idx = 1)]
    pub nzp_csi_rs_periodic_info_r14:
        Option<MIMO_UE_ParametersPerTM_v1430Nzp_CSI_RS_PeriodicInfo_r14>,
    #[asn(optional_idx = 2)]
    pub zp_csi_rs_aperiodic_info_r14:
        Option<MIMO_UE_ParametersPerTM_v1430Zp_CSI_RS_AperiodicInfo_r14>,
    #[asn(optional_idx = 3)]
    pub ul_dmrs_enhancements_r14: Option<MIMO_UE_ParametersPerTM_v1430Ul_dmrs_Enhancements_r14>,
    #[asn(optional_idx = 4)]
    pub density_reduction_np_r14: Option<MIMO_UE_ParametersPerTM_v1430DensityReductionNP_r14>,
    #[asn(optional_idx = 5)]
    pub density_reduction_bf_r14: Option<MIMO_UE_ParametersPerTM_v1430DensityReductionBF_r14>,
    #[asn(optional_idx = 6)]
    pub hybrid_csi_r14: Option<MIMO_UE_ParametersPerTM_v1430HybridCSI_r14>,
    #[asn(optional_idx = 7)]
    pub semi_ol_r14: Option<MIMO_UE_ParametersPerTM_v1430SemiOL_r14>,
    #[asn(optional_idx = 8)]
    pub csi_reporting_np_r14: Option<MIMO_UE_ParametersPerTM_v1430Csi_ReportingNP_r14>,
    #[asn(optional_idx = 9)]
    pub csi_reporting_advanced_r14: Option<MIMO_UE_ParametersPerTM_v1430Csi_ReportingAdvanced_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MIMO_UE_ParametersPerTM_v1470 {
    #[asn(optional_idx = 0)]
    pub csi_reporting_advanced_max_ports_r14:
        Option<MIMO_UE_ParametersPerTM_v1470Csi_ReportingAdvancedMaxPorts_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MIMO_WeightedLayersCapabilities_r13 {
    pub rel_weight_two_layers_r13: MIMO_WeightedLayersCapabilities_r13RelWeightTwoLayers_r13,
    #[asn(optional_idx = 0)]
    pub rel_weight_four_layers_r13:
        Option<MIMO_WeightedLayersCapabilities_r13RelWeightFourLayers_r13>,
    #[asn(optional_idx = 1)]
    pub rel_weight_eight_layers_r13:
        Option<MIMO_WeightedLayersCapabilities_r13RelWeightEightLayers_r13>,
    pub total_weighted_layers_r13: MIMO_WeightedLayersCapabilities_r13TotalWeightedLayers_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct MMEC(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct MMTEL_Parameters_r14 {
    #[asn(optional_idx = 0)]
    pub delay_budget_reporting_r14: Option<MMTEL_Parameters_r14DelayBudgetReporting_r14>,
    #[asn(optional_idx = 1)]
    pub pusch_enhancements_r14: Option<MMTEL_Parameters_r14Pusch_Enhancements_r14>,
    #[asn(optional_idx = 2)]
    pub recommended_bit_rate_r14: Option<MMTEL_Parameters_r14RecommendedBitRate_r14>,
    #[asn(optional_idx = 3)]
    pub recommended_bit_rate_query_r14: Option<MMTEL_Parameters_r14RecommendedBitRateQuery_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MMTEL_Parameters_v1610 {
    #[asn(optional_idx = 0)]
    pub recommended_bit_rate_multiplier_r16:
        Option<MMTEL_Parameters_v1610RecommendedBitRateMultiplier_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "2", sz_ub = "3")]
pub struct MNC(pub Vec<MCC_MNC_Digit>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MRDC_AssistanceInfo_r15 {
    pub affected_carrier_freq_comb_info_list_mrdc_r15:
        MRDC_AssistanceInfo_r15AffectedCarrierFreqCombInfoListMRDC_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MTC_SSB_NR_r15 {
    pub periodicity_and_offset_r15: MTC_SSB_NR_r15PeriodicityAndOffset_r15,
    pub ssb_duration_r15: MTC_SSB_NR_r15Ssb_Duration_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MTC_SSB2_LP_NR_r16 {
    #[asn(optional_idx = 0)]
    pub pci_list_r16: Option<MTC_SSB2_LP_NR_r16Pci_List_r16>,
    pub periodicity_r16: MTC_SSB2_LP_NR_r16Periodicity_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct MUST_Parameters_r14 {
    #[asn(optional_idx = 0)]
    pub must_tm234_up_to2_tx_r14: Option<MUST_Parameters_r14Must_TM234_UpTo2Tx_r14>,
    #[asn(optional_idx = 1)]
    pub must_tm89_up_to_one_interfering_layer_r14:
        Option<MUST_Parameters_r14Must_TM89_UpToOneInterferingLayer_r14>,
    #[asn(optional_idx = 2)]
    pub must_tm10_up_to_one_interfering_layer_r14:
        Option<MUST_Parameters_r14Must_TM10_UpToOneInterferingLayer_r14>,
    #[asn(optional_idx = 3)]
    pub must_tm89_up_to_three_interfering_layers_r14:
        Option<MUST_Parameters_r14Must_TM89_UpToThreeInterferingLayers_r14>,
    #[asn(optional_idx = 4)]
    pub must_tm10_up_to_three_interfering_layers_r14:
        Option<MUST_Parameters_r14Must_TM10_UpToThreeInterferingLayers_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MasterInformationBlock {
    pub dl_bandwidth: MasterInformationBlockDl_Bandwidth,
    pub phich_config: PHICH_Config,
    pub system_frame_number: MasterInformationBlockSystemFrameNumber,
    pub scheduling_info_sib1_br_r13: MasterInformationBlockSchedulingInfoSIB1_BR_r13,
    pub system_info_unchanged_br_r15: MasterInformationBlockSystemInfoUnchanged_BR_r15,
    pub part_earfcn_17: MasterInformationBlockPartEARFCN_17,
    pub spare: MasterInformationBlockSpare,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MasterInformationBlock_MBMS_r14 {
    pub dl_bandwidth_mbms_r14: MasterInformationBlock_MBMS_r14Dl_Bandwidth_MBMS_r14,
    pub system_frame_number_r14: MasterInformationBlock_MBMS_r14SystemFrameNumber_r14,
    pub additional_non_mbsfn_subframes_r14:
        MasterInformationBlock_MBMS_r14AdditionalNonMBSFNSubframes_r14,
    pub semi_static_cfi_mbms_r16: MasterInformationBlock_MBMS_r14SemiStaticCFI_MBMS_r16,
    pub spare: MasterInformationBlock_MBMS_r14Spare,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MasterInformationBlock_SL {
    pub sl_bandwidth_r12: MasterInformationBlock_SLSl_Bandwidth_r12,
    pub tdd_config_sl_r12: TDD_ConfigSL_r12,
    pub direct_frame_number_r12: MasterInformationBlock_SLDirectFrameNumber_r12,
    pub direct_subframe_number_r12: MasterInformationBlock_SLDirectSubframeNumber_r12,
    pub in_coverage_r12: MasterInformationBlock_SLInCoverage_r12,
    pub reserved_r12: MasterInformationBlock_SLReserved_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MasterInformationBlock_SL_V2X_r14 {
    pub sl_bandwidth_r14: MasterInformationBlock_SL_V2X_r14Sl_Bandwidth_r14,
    pub tdd_config_sl_r14: TDD_ConfigSL_r12,
    pub direct_frame_number_r14: MasterInformationBlock_SL_V2X_r14DirectFrameNumber_r14,
    pub direct_subframe_number_r14: MasterInformationBlock_SL_V2X_r14DirectSubframeNumber_r14,
    pub in_coverage_r14: MasterInformationBlock_SL_V2X_r14InCoverage_r14,
    pub reserved_r14: MasterInformationBlock_SL_V2X_r14Reserved_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct MaxRS_IndexCellQualNR_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MeasCSI_RS_Config_r12 {
    pub meas_csi_rs_id_r12: MeasCSI_RS_Id_r12,
    pub phys_cell_id_r12: MeasCSI_RS_Config_r12PhysCellId_r12,
    pub scrambling_identity_r12: MeasCSI_RS_Config_r12ScramblingIdentity_r12,
    pub resource_config_r12: MeasCSI_RS_Config_r12ResourceConfig_r12,
    pub subframe_offset_r12: MeasCSI_RS_Config_r12SubframeOffset_r12,
    pub csi_rs_individual_offset_r12: Q_OffsetRange,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "96")]
pub struct MeasCSI_RS_Id_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "96")]
pub struct MeasCSI_RS_ToAddModList_r12(pub Vec<MeasCSI_RS_Config_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "96")]
pub struct MeasCSI_RS_ToRemoveList_r12(pub Vec<MeasCSI_RS_Id_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 11)]
pub struct MeasConfig {
    #[asn(optional_idx = 0)]
    pub meas_object_to_remove_list: Option<MeasObjectToRemoveList>,
    #[asn(optional_idx = 1)]
    pub meas_object_to_add_mod_list: Option<MeasObjectToAddModList>,
    #[asn(optional_idx = 2)]
    pub report_config_to_remove_list: Option<ReportConfigToRemoveList>,
    #[asn(optional_idx = 3)]
    pub report_config_to_add_mod_list: Option<ReportConfigToAddModList>,
    #[asn(optional_idx = 4)]
    pub meas_id_to_remove_list: Option<MeasIdToRemoveList>,
    #[asn(optional_idx = 5)]
    pub meas_id_to_add_mod_list: Option<MeasIdToAddModList>,
    #[asn(optional_idx = 6)]
    pub quantity_config: Option<QuantityConfig>,
    #[asn(optional_idx = 7)]
    pub meas_gap_config: Option<MeasGapConfig>,
    #[asn(optional_idx = 8)]
    pub s_measure: Option<RSRP_Range>,
    #[asn(optional_idx = 9)]
    pub pre_registration_info_hrpd: Option<PreRegistrationInfoHRPD>,
    #[asn(optional_idx = 10)]
    pub speed_state_pars: Option<MeasConfigSpeedStatePars>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct MeasCycleSCell_r10(pub u8);
impl MeasCycleSCell_r10 {
    pub const SF160: u8 = 0u8;
    pub const SF256: u8 = 1u8;
    pub const SF320: u8 = 2u8;
    pub const SF512: u8 = 3u8;
    pub const SF640: u8 = 4u8;
    pub const SF1024: u8 = 5u8;
    pub const SF1280: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MeasDS_Config_r12 {
    #[asn(key = 0, extended = false)]
    Release(MeasDS_Config_r12_release),
    #[asn(key = 1, extended = false)]
    Setup(MeasDS_Config_r12_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MeasGapConfig {
    #[asn(key = 0, extended = false)]
    Release(MeasGapConfig_release),
    #[asn(key = 1, extended = false)]
    Setup(MeasGapConfig_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MeasGapConfigDensePRS_r15 {
    #[asn(key = 0, extended = false)]
    Release(MeasGapConfigDensePRS_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(MeasGapConfigDensePRS_r15_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MeasGapConfigPerCC_List_r14 {
    #[asn(key = 0, extended = false)]
    Release(MeasGapConfigPerCC_List_r14_release),
    #[asn(key = 1, extended = false)]
    Setup(MeasGapConfigPerCC_List_r14_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasGapConfigPerCC_r14 {
    pub serv_cell_id_r14: ServCellIndex_r13,
    pub meas_gap_config_cc_r14: MeasGapConfig,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct MeasGapConfigToAddModList_r14(pub Vec<MeasGapConfigPerCC_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct MeasGapConfigToRemoveList_r14(pub Vec<ServCellIndex_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MeasGapInfoNR_r16 {
    #[asn(optional_idx = 0)]
    pub inter_rat_band_list_nr_en_dc_r16: Option<InterRAT_BandListNR_r16>,
    #[asn(optional_idx = 1)]
    pub inter_rat_band_list_nr_sa_r16: Option<InterRAT_BandListNR_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MeasGapSharingConfig_r14 {
    #[asn(key = 0, extended = false)]
    Release(MeasGapSharingConfig_r14_release),
    #[asn(key = 1, extended = false)]
    Setup(MeasGapSharingConfig_r14_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct MeasId(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "33", ub = "64")]
pub struct MeasId_v1250(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasIdToAddMod {
    pub meas_id: MeasId,
    pub meas_object_id: MeasObjectId,
    pub report_config_id: ReportConfigId,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MeasIdToAddMod_v1310 {
    #[asn(optional_idx = 0)]
    pub meas_object_id_v1310: Option<MeasObjectId_v1310>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasIdToAddModExt_r12 {
    pub meas_id_v1250: MeasId_v1250,
    pub meas_object_id_r12: MeasObjectId,
    pub report_config_id_r12: ReportConfigId,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct MeasIdToAddModList(pub Vec<MeasIdToAddMod>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct MeasIdToAddModList_v1310(pub Vec<MeasIdToAddMod_v1310>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct MeasIdToAddModListExt_r12(pub Vec<MeasIdToAddModExt_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct MeasIdToAddModListExt_v1310(pub Vec<MeasIdToAddMod_v1310>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct MeasIdToRemoveList(pub Vec<MeasId>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct MeasIdToRemoveListExt_r12(pub Vec<MeasId_v1250>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct MeasIdleCarrierEUTRA_r15 {
    pub carrier_freq_r15: ARFCN_ValueEUTRA_r9,
    pub allowed_meas_bandwidth_r15: AllowedMeasBandwidth,
    #[asn(optional_idx = 0)]
    pub validity_area_r15: Option<CellList_r15>,
    #[asn(optional_idx = 1)]
    pub meas_cell_list_r15: Option<CellList_r15>,
    pub report_quantities: MeasIdleCarrierEUTRA_r15ReportQuantities,
    #[asn(optional_idx = 2)]
    pub quality_threshold_r15: Option<MeasIdleCarrierEUTRA_r15QualityThreshold_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct MeasIdleCarrierNR_r16 {
    pub carrier_freq_nr_r16: ARFCN_ValueNR_r15,
    pub subcarrier_spacing_ssb_r16: MeasIdleCarrierNR_r16SubcarrierSpacingSSB_r16,
    #[asn(optional_idx = 0)]
    pub frequency_band_list: Option<MultiFrequencyBandListNR_r15>,
    #[asn(optional_idx = 1)]
    pub meas_cell_list_nr_r16: Option<CellListNR_r16>,
    pub report_quantities_nr_r16: MeasIdleCarrierNR_r16ReportQuantitiesNR_r16,
    #[asn(optional_idx = 2)]
    pub quality_threshold_nr_r16: Option<MeasIdleCarrierNR_r16QualityThresholdNR_r16>,
    #[asn(optional_idx = 3)]
    pub ssb_meas_config_r16: Option<MeasIdleCarrierNR_r16Ssb_MeasConfig_r16>,
    #[asn(optional_idx = 4)]
    pub beam_meas_config_idle_r16: Option<BeamMeasConfigIdleNR_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct MeasIdleConfigDedicated_r15 {
    #[asn(optional_idx = 0)]
    pub meas_idle_carrier_list_eutra_r15: Option<EUTRA_CarrierList_r15>,
    pub meas_idle_duration_r15: MeasIdleConfigDedicated_r15MeasIdleDuration_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MeasIdleConfigSIB_NR_r16 {
    pub meas_idle_carrier_list_nr_r16: NR_CarrierList_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MeasIdleConfigSIB_r15 {
    pub meas_idle_carrier_list_eutra_r15: EUTRA_CarrierList_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct MeasObjectCDMA2000 {
    pub cdma2000_type: CDMA2000_Type,
    pub carrier_freq: CarrierFreqCDMA2000,
    #[asn(optional_idx = 0)]
    pub search_window_size: Option<MeasObjectCDMA2000SearchWindowSize>,
    #[asn(optional_idx = 1)]
    pub offset_freq: Option<Q_OffsetRangeInterRAT>,
    #[asn(optional_idx = 2)]
    pub cells_to_remove_list: Option<CellIndexList>,
    #[asn(optional_idx = 3)]
    pub cells_to_add_mod_list: Option<CellsToAddModListCDMA2000>,
    #[asn(optional_idx = 4)]
    pub cell_for_which_to_report_cgi: Option<PhysCellIdCDMA2000>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 6)]
pub struct MeasObjectEUTRA {
    pub carrier_freq: ARFCN_ValueEUTRA,
    pub allowed_meas_bandwidth: AllowedMeasBandwidth,
    pub presence_antenna_port1: PresenceAntennaPort1,
    pub neigh_cell_config: NeighCellConfig,
    #[asn(optional_idx = 0)]
    pub offset_freq: Option<Q_OffsetRange>,
    #[asn(optional_idx = 1)]
    pub cells_to_remove_list: Option<CellIndexList>,
    #[asn(optional_idx = 2)]
    pub cells_to_add_mod_list: Option<CellsToAddModList>,
    #[asn(optional_idx = 3)]
    pub excluded_cells_to_remove_list: Option<CellIndexList>,
    #[asn(optional_idx = 4)]
    pub excluded_cells_to_add_mod_list: Option<ExcludedCellsToAddModList>,
    #[asn(optional_idx = 5)]
    pub cell_for_which_to_report_cgi: Option<PhysCellId>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasObjectEUTRA_v9e0 {
    pub carrier_freq_v9e0: ARFCN_ValueEUTRA_v9e0,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct MeasObjectGERAN {
    pub carrier_freqs: CarrierFreqsGERAN,
    #[asn(optional_idx = 0)]
    pub offset_freq: Option<Q_OffsetRangeInterRAT>,
    #[asn(optional_idx = 1)]
    pub ncc_permitted: Option<MeasObjectGERANNcc_Permitted>,
    #[asn(optional_idx = 2)]
    pub cell_for_which_to_report_cgi: Option<PhysCellIdGERAN>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct MeasObjectId(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "64")]
pub struct MeasObjectId_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "33", ub = "64")]
pub struct MeasObjectId_v1310(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 6)]
pub struct MeasObjectNR_r15 {
    pub carrier_freq_r15: ARFCN_ValueNR_r15,
    pub rs_config_ssb_r15: RS_ConfigSSB_NR_r15,
    #[asn(optional_idx = 0)]
    pub thresh_rs_index_r15: Option<ThresholdListNR_r15>,
    #[asn(optional_idx = 1)]
    pub max_rs_index_cell_qual_r15: Option<MaxRS_IndexCellQualNR_r15>,
    #[asn(optional_idx = 2)]
    pub offset_freq_r15: Option<Q_OffsetRangeInterRAT>,
    #[asn(optional_idx = 3)]
    pub excluded_cells_to_remove_list_r15: Option<CellIndexList>,
    #[asn(optional_idx = 4)]
    pub excluded_cells_to_add_mod_list_r15: Option<CellsToAddModListNR_r15>,
    pub quantity_config_set_r15: MeasObjectNR_r15QuantityConfigSet_r15,
    #[asn(optional_idx = 5)]
    pub cells_for_which_to_report_sftd_r15: Option<MeasObjectNR_r15CellsForWhichToReportSFTD_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasObjectToAddMod {
    pub meas_object_id: MeasObjectId,
    pub meas_object: MeasObjectToAddModMeasObject,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MeasObjectToAddMod_v9e0 {
    #[asn(optional_idx = 0)]
    pub meas_object_eutra_v9e0: Option<MeasObjectEUTRA_v9e0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasObjectToAddModExt_r13 {
    pub meas_object_id_r13: MeasObjectId_v1310,
    pub meas_object_r13: MeasObjectToAddModExt_r13MeasObject_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct MeasObjectToAddModList(pub Vec<MeasObjectToAddMod>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct MeasObjectToAddModList_v9e0(pub Vec<MeasObjectToAddMod_v9e0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct MeasObjectToAddModListExt_r13(pub Vec<MeasObjectToAddModExt_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct MeasObjectToRemoveList(pub Vec<MeasObjectId>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct MeasObjectToRemoveListExt_r13(pub Vec<MeasObjectId_v1310>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct MeasObjectUTRA {
    pub carrier_freq: ARFCN_ValueUTRA,
    #[asn(optional_idx = 0)]
    pub offset_freq: Option<Q_OffsetRangeInterRAT>,
    #[asn(optional_idx = 1)]
    pub cells_to_remove_list: Option<CellIndexList>,
    #[asn(optional_idx = 2)]
    pub cells_to_add_mod_list: Option<MeasObjectUTRACellsToAddModList>,
    #[asn(optional_idx = 3)]
    pub cell_for_which_to_report_cgi: Option<MeasObjectUTRACellForWhichToReportCGI>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct MeasObjectWLAN_r13 {
    #[asn(optional_idx = 0)]
    pub carrier_freq_r13: Option<MeasObjectWLAN_r13CarrierFreq_r13>,
    #[asn(optional_idx = 1)]
    pub wlan_to_add_mod_list_r13: Option<WLAN_Id_List_r13>,
    #[asn(optional_idx = 2)]
    pub wlan_to_remove_list_r13: Option<WLAN_Id_List_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasParameters {
    pub band_list_eutra: BandListEUTRA,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasParameters_v1020 {
    pub band_combination_list_eutra_r10: BandCombinationListEUTRA_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MeasParameters_v1130 {
    #[asn(optional_idx = 0)]
    pub rsrq_meas_wideband_r11: Option<MeasParameters_v1130RsrqMeasWideband_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MeasParameters_v11a0 {
    #[asn(optional_idx = 0)]
    pub benefits_from_interruption_r11: Option<MeasParameters_v11a0BenefitsFromInterruption_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 9)]
pub struct MeasParameters_v1250 {
    #[asn(optional_idx = 0)]
    pub timer_t312_r12: Option<MeasParameters_v1250TimerT312_r12>,
    #[asn(optional_idx = 1)]
    pub alternative_time_to_trigger_r12: Option<MeasParameters_v1250AlternativeTimeToTrigger_r12>,
    #[asn(optional_idx = 2)]
    pub inc_mon_eutra_r12: Option<MeasParameters_v1250IncMonEUTRA_r12>,
    #[asn(optional_idx = 3)]
    pub inc_mon_utra_r12: Option<MeasParameters_v1250IncMonUTRA_r12>,
    #[asn(optional_idx = 4)]
    pub extended_max_meas_id_r12: Option<MeasParameters_v1250ExtendedMaxMeasId_r12>,
    #[asn(optional_idx = 5)]
    pub extended_rsrq_lower_range_r12: Option<MeasParameters_v1250ExtendedRSRQ_LowerRange_r12>,
    #[asn(optional_idx = 6)]
    pub rsrq_on_all_symbols_r12: Option<MeasParameters_v1250Rsrq_OnAllSymbols_r12>,
    #[asn(optional_idx = 7)]
    pub crs_discovery_signals_meas_r12: Option<MeasParameters_v1250Crs_DiscoverySignalsMeas_r12>,
    #[asn(optional_idx = 8)]
    pub csi_rs_discovery_signals_meas_r12:
        Option<MeasParameters_v1250Csi_RS_DiscoverySignalsMeas_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 7)]
pub struct MeasParameters_v1310 {
    #[asn(optional_idx = 0)]
    pub rs_sinr_meas_r13: Option<MeasParameters_v1310Rs_SINR_Meas_r13>,
    #[asn(optional_idx = 1)]
    pub allowed_cell_list_r13: Option<MeasParameters_v1310AllowedCellList_r13>,
    #[asn(optional_idx = 2)]
    pub extended_max_object_id_r13: Option<MeasParameters_v1310ExtendedMaxObjectId_r13>,
    #[asn(optional_idx = 3)]
    pub ul_pdcp_delay_r13: Option<MeasParameters_v1310Ul_PDCP_Delay_r13>,
    #[asn(optional_idx = 4)]
    pub extended_freq_priorities_r13: Option<MeasParameters_v1310ExtendedFreqPriorities_r13>,
    #[asn(optional_idx = 5)]
    pub multi_band_info_report_r13: Option<MeasParameters_v1310MultiBandInfoReport_r13>,
    #[asn(optional_idx = 6)]
    pub rssi_and_channel_occupancy_reporting_r13:
        Option<MeasParameters_v1310Rssi_AndChannelOccupancyReporting_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct MeasParameters_v1430 {
    #[asn(optional_idx = 0)]
    pub ce_measurements_r14: Option<MeasParameters_v1430CeMeasurements_r14>,
    #[asn(optional_idx = 1)]
    pub ncsg_r14: Option<MeasParameters_v1430Ncsg_r14>,
    #[asn(optional_idx = 2)]
    pub short_measurement_gap_r14: Option<MeasParameters_v1430ShortMeasurementGap_r14>,
    #[asn(optional_idx = 3)]
    pub per_serving_cell_measurement_gap_r14:
        Option<MeasParameters_v1430PerServingCellMeasurementGap_r14>,
    #[asn(optional_idx = 4)]
    pub non_uniform_gap_r14: Option<MeasParameters_v1430NonUniformGap_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MeasParameters_v1520 {
    #[asn(optional_idx = 0)]
    pub meas_gap_patterns_r15: Option<MeasParameters_v1520MeasGapPatterns_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct MeasParameters_v1530 {
    #[asn(optional_idx = 0)]
    pub qoe_meas_report_r15: Option<MeasParameters_v1530Qoe_MeasReport_r15>,
    #[asn(optional_idx = 1)]
    pub qoe_mtsi_meas_report_r15: Option<MeasParameters_v1530Qoe_MTSI_MeasReport_r15>,
    #[asn(optional_idx = 2)]
    pub ca_idle_mode_measurements_r15: Option<MeasParameters_v1530Ca_IdleModeMeasurements_r15>,
    #[asn(optional_idx = 3)]
    pub ca_idle_mode_validity_area_r15: Option<MeasParameters_v1530Ca_IdleModeValidityArea_r15>,
    #[asn(optional_idx = 4)]
    pub height_meas_r15: Option<MeasParameters_v1530HeightMeas_r15>,
    #[asn(optional_idx = 5)]
    pub multiple_cells_meas_extension_r15:
        Option<MeasParameters_v1530MultipleCellsMeasExtension_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 10)]
pub struct MeasParameters_v1610 {
    #[asn(optional_idx = 0)]
    pub band_info_nr_v1610: Option<MeasParameters_v1610BandInfoNR_v1610>,
    #[asn(optional_idx = 1)]
    pub alt_freq_priority_r16: Option<MeasParameters_v1610AltFreqPriority_r16>,
    #[asn(optional_idx = 2)]
    pub ce_dl_channel_quality_reporting_r16:
        Option<MeasParameters_v1610Ce_DL_ChannelQualityReporting_r16>,
    #[asn(optional_idx = 3)]
    pub ce_meas_rss_dedicated_r16: Option<MeasParameters_v1610Ce_MeasRSS_Dedicated_r16>,
    #[asn(optional_idx = 4)]
    pub eutra_idle_inactive_measurements_r16:
        Option<MeasParameters_v1610Eutra_IdleInactiveMeasurements_r16>,
    #[asn(optional_idx = 5)]
    pub nr_idle_inactive_meas_fr1_r16: Option<MeasParameters_v1610Nr_IdleInactiveMeasFR1_r16>,
    #[asn(optional_idx = 6)]
    pub nr_idle_inactive_meas_fr2_r16: Option<MeasParameters_v1610Nr_IdleInactiveMeasFR2_r16>,
    #[asn(optional_idx = 7)]
    pub idle_inactive_validity_area_list_r16:
        Option<MeasParameters_v1610IdleInactiveValidityAreaList_r16>,
    #[asn(optional_idx = 8)]
    pub meas_gap_patterns_n_ronly_r16: Option<MeasParameters_v1610MeasGapPatterns_NRonly_r16>,
    #[asn(optional_idx = 9)]
    pub meas_gap_patterns_n_ronly_endc_r16:
        Option<MeasParameters_v1610MeasGapPatterns_NRonly_ENDC_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct MeasParameters_v1630 {
    #[asn(optional_idx = 0)]
    pub nr_idle_inactive_beam_meas_fr1_r16:
        Option<MeasParameters_v1630Nr_IdleInactiveBeamMeasFR1_r16>,
    #[asn(optional_idx = 1)]
    pub nr_idle_inactive_beam_meas_fr2_r16:
        Option<MeasParameters_v1630Nr_IdleInactiveBeamMeasFR2_r16>,
    #[asn(optional_idx = 2)]
    pub ce_meas_rss_dedicated_same_r_bs_r16:
        Option<MeasParameters_v1630Ce_MeasRSS_DedicatedSameRBs_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MeasParameters_v16c0 {
    #[asn(optional_idx = 0)]
    pub nr_cell_individual_offset_r16: Option<MeasParameters_v16c0Nr_CellIndividualOffset_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MeasParameters_v1700 {
    #[asn(optional_idx = 0)]
    pub shared_spectrum_meas_nr_en_dc_r17:
        Option<MeasParameters_v1700SharedSpectrumMeasNR_EN_DC_r17>,
    #[asn(optional_idx = 1)]
    pub shared_spectrum_meas_nr_sa_r17: Option<MeasParameters_v1700SharedSpectrumMeasNR_SA_r17>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MeasRSS_DedicatedConfig_r16 {
    #[asn(optional_idx = 0)]
    pub rss_config_carrier_info_r16: Option<RSS_ConfigCarrierInfo_r16>,
    #[asn(optional_idx = 1)]
    pub cells_to_add_mod_list_v1610: Option<CellsToAddModList_v1610>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MeasRSSI_ReportConfig_r13 {
    #[asn(optional_idx = 0)]
    pub channel_occupancy_threshold_r13: Option<RSSI_Range_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasReportAppLayer_r15 {
    pub critical_extensions: MeasReportAppLayer_r15CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct MeasReportAppLayer_r15_IEs {
    #[asn(optional_idx = 0)]
    pub meas_report_app_layer_container_r15:
        Option<MeasReportAppLayer_r15_IEsMeasReportAppLayerContainer_r15>,
    #[asn(optional_idx = 1)]
    pub service_type_r15: Option<MeasReportAppLayer_r15_IEsServiceType_r15>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<MeasReportAppLayer_v1590_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MeasReportAppLayer_v1590_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<MeasReportAppLayer_v1590_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<MeasReportAppLayer_v1590_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasResult2CDMA2000_r9 {
    pub carrier_freq_r9: CarrierFreqCDMA2000,
    pub meas_result_list_r9: MeasResultsCDMA2000,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasResult2EUTRA_r9 {
    pub carrier_freq_r9: ARFCN_ValueEUTRA,
    pub meas_result_list_r9: MeasResultListEUTRA,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MeasResult2EUTRA_v1250 {
    #[asn(optional_idx = 0)]
    pub rsrq_type_r12: Option<RSRQ_Type_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MeasResult2EUTRA_v9e0 {
    #[asn(optional_idx = 0)]
    pub carrier_freq_v9e0: Option<ARFCN_ValueEUTRA_v9e0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasResult2UTRA_r9 {
    pub carrier_freq_r9: ARFCN_ValueUTRA,
    pub meas_result_list_r9: MeasResultListUTRA,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct MeasResult3EUTRA_r15 {
    pub carrier_freq_r15: ARFCN_ValueEUTRA_r9,
    #[asn(optional_idx = 0)]
    pub meas_result_serving_cell_r15: Option<MeasResultEUTRA>,
    #[asn(optional_idx = 1)]
    pub meas_result_neigh_cell_list_r15: Option<MeasResultListEUTRA>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MeasResultCBR_r14 {
    pub pool_identity_r14: SL_V2X_TxPoolReportIdentity_r14,
    pub cbr_pssch_r14: SL_CBR_r14,
    #[asn(optional_idx = 0)]
    pub cbr_pscch_r14: Option<SL_CBR_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MeasResultCDMA2000 {
    pub phys_cell_id: PhysCellIdCDMA2000,
    #[asn(optional_idx = 0)]
    pub cgi_info: Option<CellGlobalIdCDMA2000>,
    pub meas_result: MeasResultCDMA2000MeasResult,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MeasResultCSI_RS_List_r12(pub Vec<MeasResultCSI_RS_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MeasResultCSI_RS_r12 {
    pub meas_csi_rs_id_r12: MeasCSI_RS_Id_r12,
    pub csi_rsrp_result_r12: CSI_RSRP_Range_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MeasResultCellListNR_r15(pub Vec<MeasResultCellNR_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct MeasResultCellListSFTD_r15(pub Vec<MeasResultCellSFTD_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct MeasResultCellNR_r15 {
    pub pci_r15: PhysCellIdNR_r15,
    pub meas_result_cell_r15: MeasResultNR_r15,
    #[asn(optional_idx = 0)]
    pub meas_result_rs_index_list_r15: Option<MeasResultSSB_IndexList_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MeasResultCellSFTD_r15 {
    pub phys_cell_id_r15: PhysCellIdNR_r15,
    pub sfn_offset_result_r15: MeasResultCellSFTD_r15Sfn_OffsetResult_r15,
    pub frame_boundary_offset_result_r15: MeasResultCellSFTD_r15FrameBoundaryOffsetResult_r15,
    #[asn(optional_idx = 0)]
    pub rsrp_result_r15: Option<RSRP_RangeNR_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MeasResultEUTRA {
    pub phys_cell_id: PhysCellId,
    #[asn(optional_idx = 0)]
    pub cgi_info: Option<MeasResultEUTRACgi_Info>,
    pub meas_result: MeasResultEUTRAMeasResult,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasResultForECID_r9 {
    pub ue_rx_tx_time_diff_result_r9: MeasResultForECID_r9Ue_RxTxTimeDiffResult_r9,
    pub current_sfn_r9: MeasResultForECID_r9CurrentSFN_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MeasResultForRSSI_NR_r16 {
    pub rssi_result_nr_r16: RSSI_Range_r13,
    pub channel_occupancy_nr_r16: MeasResultForRSSI_NR_r16ChannelOccupancyNR_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MeasResultForRSSI_r13 {
    pub rssi_result_r13: RSSI_Range_r13,
    pub channel_occupancy_r13: MeasResultForRSSI_r13ChannelOccupancy_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct MeasResultFreqFailNR_r15 {
    pub carrier_freq_r15: ARFCN_ValueNR_r15,
    #[asn(optional_idx = 0)]
    pub meas_result_cell_list_r15: Option<MeasResultCellListNR_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "5")]
pub struct MeasResultFreqListFailNR_r15(pub Vec<MeasResultFreqFailNR_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "7")]
pub struct MeasResultFreqListNR_r16(pub Vec<MeasResultFreqFailNR_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MeasResultGERAN {
    pub carrier_freq: CarrierFreqGERAN,
    pub phys_cell_id: PhysCellIdGERAN,
    #[asn(optional_idx = 0)]
    pub cgi_info: Option<MeasResultGERANCgi_Info>,
    pub meas_result: MeasResultGERANMeasResult,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct MeasResultIdle_r15 {
    pub meas_result_serving_cell_r15: MeasResultIdle_r15MeasResultServingCell_r15,
    #[asn(optional_idx = 0)]
    pub meas_result_neigh_cells_r15: Option<MeasResultIdle_r15MeasResultNeighCells_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MeasResultIdleEUTRA_r15 {
    pub carrier_freq_r15: ARFCN_ValueEUTRA_r9,
    pub phys_cell_id_r15: PhysCellId,
    pub meas_result_r15: MeasResultIdleEUTRA_r15MeasResult_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MeasResultIdleListEUTRA_r15(pub Vec<MeasResultIdleEUTRA_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MeasResultIdleNR_r16 {
    pub carrier_freq_nr_r16: ARFCN_ValueNR_r15,
    pub meas_results_per_cell_list_idle_nr_r16:
        MeasResultIdleNR_r16MeasResultsPerCellListIdleNR_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MeasResultList2CDMA2000_r9(pub Vec<MeasResult2CDMA2000_r9>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MeasResultList2EUTRA_r9(pub Vec<MeasResult2EUTRA_r9>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MeasResultList2EUTRA_v1250(pub Vec<MeasResult2EUTRA_v1250>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MeasResultList2EUTRA_v9e0(pub Vec<MeasResult2EUTRA_v9e0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct MeasResultList2GERAN_r10(pub Vec<MeasResultListGERAN>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MeasResultList2UTRA_r9(pub Vec<MeasResult2UTRA_r9>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MeasResultList3EUTRA_r15(pub Vec<MeasResult3EUTRA_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "72")]
pub struct MeasResultListCBR_r14(pub Vec<MeasResultCBR_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MeasResultListCDMA2000(pub Vec<MeasResultCDMA2000>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MeasResultListEUTRA(pub Vec<MeasResultEUTRA>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "5")]
pub struct MeasResultListExtIdle_r16(pub Vec<MeasResultIdleListEUTRA_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MeasResultListGERAN(pub Vec<MeasResultGERAN>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct MeasResultListIdle_r15(pub Vec<MeasResultIdle_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MeasResultListIdleNR_r16(pub Vec<MeasResultIdleNR_r16>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MeasResultListMBSFN_r12(pub Vec<MeasResultMBSFN_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct MeasResultListRSSI_SCG_r13(pub Vec<MeasResultRSSI_SCG_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MeasResultListUTRA(pub Vec<MeasResultUTRA>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MeasResultListWLAN_r13(pub Vec<MeasResultWLAN_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct MeasResultListWLAN_r14(pub Vec<MeasResultWLAN_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct MeasResultMBSFN_r12 {
    pub mbsfn_area_r12: MeasResultMBSFN_r12Mbsfn_Area_r12,
    pub rsrp_result_mbsfn_r12: RSRP_Range,
    pub rsrq_result_mbsfn_r12: MBSFN_RSRQ_Range_r12,
    #[asn(optional_idx = 0)]
    pub signalling_bler_result_r12: Option<BLER_Result_r12>,
    #[asn(optional_idx = 1)]
    pub data_bler_mch_result_list_r12: Option<DataBLER_MCH_ResultList_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct MeasResultNR_r15 {
    #[asn(optional_idx = 0)]
    pub rsrp_result_r15: Option<RSRP_RangeNR_r15>,
    #[asn(optional_idx = 1)]
    pub rsrq_result_r15: Option<RSRQ_RangeNR_r15>,
    #[asn(optional_idx = 2)]
    pub rs_sinr_result_r15: Option<RS_SINR_RangeNR_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasResultRSSI_SCG_r13 {
    pub serv_cell_id_r13: ServCellIndex_r13,
    pub meas_result_for_rssi_r13: MeasResultForRSSI_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MeasResultSCG_FailureMRDC_r15 {
    pub meas_result_freq_list_eutra_r15: MeasResultList3EUTRA_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct MeasResultSSB_Index_r15 {
    pub ssb_index_r15: RS_IndexNR_r15,
    #[asn(optional_idx = 0)]
    pub meas_result_ssb_index_r15: Option<MeasResultNR_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct MeasResultSSB_IndexList_r15(pub Vec<MeasResultSSB_Index_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasResultSSTD_r13 {
    pub sfn_offset_result_r13: MeasResultSSTD_r13Sfn_OffsetResult_r13,
    pub frame_boundary_offset_result_r13: MeasResultSSTD_r13FrameBoundaryOffsetResult_r13,
    pub subframe_boundary_offset_result_r13: MeasResultSSTD_r13SubframeBoundaryOffsetResult_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasResultSensing_r15 {
    pub sl_subframe_ref_r15: MeasResultSensing_r15Sl_SubframeRef_r15,
    pub sensing_result_r15: MeasResultSensing_r15SensingResult_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct MeasResultServCellListSCG_Ext_r13(pub Vec<MeasResultServCellSCG_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "5")]
pub struct MeasResultServCellListSCG_r12(pub Vec<MeasResultServCellSCG_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MeasResultServCellSCG_r12 {
    pub serv_cell_id_r12: ServCellIndex_r10,
    pub meas_result_s_cell_r12: MeasResultServCellSCG_r12MeasResultSCell_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct MeasResultServFreq_r10 {
    pub serv_freq_id_r10: ServCellIndex_r10,
    #[asn(optional_idx = 0)]
    pub meas_result_s_cell_r10: Option<MeasResultServFreq_r10MeasResultSCell_r10>,
    #[asn(optional_idx = 1)]
    pub meas_result_best_neigh_cell_r10: Option<MeasResultServFreq_r10MeasResultBestNeighCell_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct MeasResultServFreq_r13 {
    pub serv_freq_id_r13: ServCellIndex_r13,
    #[asn(optional_idx = 0)]
    pub meas_result_s_cell_r13: Option<MeasResultServFreq_r13MeasResultSCell_r13>,
    #[asn(optional_idx = 1)]
    pub meas_result_best_neigh_cell_r13: Option<MeasResultServFreq_r13MeasResultBestNeighCell_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "5")]
pub struct MeasResultServFreqList_r10(pub Vec<MeasResultServFreq_r10>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct MeasResultServFreqListExt_r13(pub Vec<MeasResultServFreq_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct MeasResultServFreqListNR_r15(pub Vec<MeasResultServFreqNR_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct MeasResultServFreqNR_r15 {
    pub carrier_freq_r15: ARFCN_ValueNR_r15,
    #[asn(optional_idx = 0)]
    pub meas_result_s_cell_r15: Option<MeasResultCellNR_r15>,
    #[asn(optional_idx = 1)]
    pub meas_result_best_neigh_cell_r15: Option<MeasResultCellNR_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MeasResultUTRA {
    pub phys_cell_id: MeasResultUTRAPhysCellId,
    #[asn(optional_idx = 0)]
    pub cgi_info: Option<MeasResultUTRACgi_Info>,
    pub meas_result: MeasResultUTRAMeasResult,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 8)]
pub struct MeasResultWLAN_r13 {
    pub wlan_identifiers_r13: WLAN_Identifiers_r12,
    #[asn(optional_idx = 0)]
    pub carrier_info_wlan_r13: Option<WLAN_CarrierInfo_r13>,
    #[asn(optional_idx = 1)]
    pub band_wlan_r13: Option<WLAN_BandIndicator_r13>,
    pub rssi_wlan_r13: WLAN_RSSI_Range_r13,
    #[asn(optional_idx = 2)]
    pub available_admission_capacity_wlan_r13:
        Option<MeasResultWLAN_r13AvailableAdmissionCapacityWLAN_r13>,
    #[asn(optional_idx = 3)]
    pub backhaul_dl_bandwidth_wlan_r13: Option<WLAN_backhaulRate_r12>,
    #[asn(optional_idx = 4)]
    pub backhaul_ul_bandwidth_wlan_r13: Option<WLAN_backhaulRate_r12>,
    #[asn(optional_idx = 5)]
    pub channel_utilization_wlan_r13: Option<MeasResultWLAN_r13ChannelUtilizationWLAN_r13>,
    #[asn(optional_idx = 6)]
    pub station_count_wlan_r13: Option<MeasResultWLAN_r13StationCountWLAN_r13>,
    #[asn(optional_idx = 7)]
    pub connected_wlan_r13: Option<MeasResultWLAN_r13ConnectedWLAN_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct MeasResults {
    pub meas_id: MeasId,
    pub meas_result_p_cell: MeasResultsMeasResultPCell,
    #[asn(optional_idx = 0)]
    pub meas_result_neigh_cells: Option<MeasResultsMeasResultNeighCells>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasResultsCDMA2000 {
    pub pre_registration_status_hrpd: MeasResultsCDMA2000PreRegistrationStatusHRPD,
    pub meas_result_list_cdma2000: MeasResultListCDMA2000,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MeasResultsPerCellIdleNR_r16 {
    pub phys_cell_id_nr_r16: PhysCellIdNR_r15,
    pub meas_idle_result_nr_r16: MeasResultsPerCellIdleNR_r16MeasIdleResultNR_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct MeasScaleFactor_r12(pub u8);
impl MeasScaleFactor_r12 {
    pub const SF_EUTRA_CF1: u8 = 0u8;
    pub const SF_EUTRA_CF2: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasSensing_Config_r15 {
    pub sensing_subchannel_number_r15: MeasSensing_Config_r15SensingSubchannelNumber_r15,
    pub sensing_periodicity_r15: MeasSensing_Config_r15SensingPeriodicity_r15,
    pub sensing_reselection_counter_r15: MeasSensing_Config_r15SensingReselectionCounter_r15,
    pub sensing_priority_r15: MeasSensing_Config_r15SensingPriority_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct MeasSubframeCellList_r10(pub Vec<PhysCellIdRange>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum MeasSubframePattern_r10 {
    #[asn(key = 0, extended = false)]
    SubframePatternFDD_r10(MeasSubframePattern_r10_subframePatternFDD_r10),
    #[asn(key = 1, extended = false)]
    SubframePatternTDD_r10(MeasSubframePattern_r10_subframePatternTDD_r10),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MeasSubframePatternConfigNeigh_r10 {
    #[asn(key = 0, extended = false)]
    Release(MeasSubframePatternConfigNeigh_r10_release),
    #[asn(key = 1, extended = false)]
    Setup(MeasSubframePatternConfigNeigh_r10_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MeasSubframePatternPCell_r10 {
    #[asn(key = 0, extended = false)]
    Release(MeasSubframePatternPCell_r10_release),
    #[asn(key = 1, extended = false)]
    Setup(MeasSubframePattern_r10),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasurementReport {
    pub critical_extensions: MeasurementReportCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MeasurementReport_r8_IEs {
    pub meas_results: MeasResults,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<MeasurementReport_v8a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MeasurementReport_v8a0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<MeasurementReport_v8a0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<MeasurementReport_v8a0_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct MobilityControlInfo {
    pub target_phys_cell_id: PhysCellId,
    #[asn(optional_idx = 0)]
    pub carrier_freq: Option<CarrierFreqEUTRA>,
    #[asn(optional_idx = 1)]
    pub carrier_bandwidth: Option<CarrierBandwidthEUTRA>,
    #[asn(optional_idx = 2)]
    pub additional_spectrum_emission: Option<AdditionalSpectrumEmission>,
    pub t304: MobilityControlInfoT304,
    pub new_ue_identity: C_RNTI,
    pub radio_resource_config_common: RadioResourceConfigCommon,
    #[asn(optional_idx = 3)]
    pub rach_config_dedicated: Option<RACH_ConfigDedicated>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MobilityControlInfo_v10l0 {
    #[asn(optional_idx = 0)]
    pub additional_spectrum_emission_v10l0: Option<AdditionalSpectrumEmission_v10l0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct MobilityControlInfoSCG_r12 {
    pub t307_r12: MobilityControlInfoSCG_r12T307_r12,
    #[asn(optional_idx = 0)]
    pub ue_identity_scg_r12: Option<C_RNTI>,
    #[asn(optional_idx = 1)]
    pub rach_config_dedicated_r12: Option<RACH_ConfigDedicated>,
    #[asn(optional_idx = 2)]
    pub ciphering_algorithm_scg_r12: Option<CipheringAlgorithm_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct MobilityControlInfoV2X_r14 {
    #[asn(optional_idx = 0)]
    pub v2x_comm_tx_pool_exceptional_r14: Option<SL_CommResourcePoolV2X_r14>,
    #[asn(optional_idx = 1)]
    pub v2x_comm_rx_pool_r14: Option<SL_CommRxPoolListV2X_r14>,
    #[asn(optional_idx = 2)]
    pub v2x_comm_sync_config_r14: Option<SL_SyncConfigListV2X_r14>,
    #[asn(optional_idx = 3)]
    pub cbr_mobility_tx_config_list_r14: Option<SL_CBR_CommonTxConfigList_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MobilityFromEUTRACommand {
    pub rrc_transaction_identifier: RRC_TransactionIdentifier,
    pub critical_extensions: MobilityFromEUTRACommandCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MobilityFromEUTRACommand_r8_IEs {
    pub cs_fallback_indicator: MobilityFromEUTRACommand_r8_IEsCs_FallbackIndicator,
    pub purpose: MobilityFromEUTRACommand_r8_IEsPurpose,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<MobilityFromEUTRACommand_v8a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MobilityFromEUTRACommand_r9_IEs {
    pub cs_fallback_indicator: MobilityFromEUTRACommand_r9_IEsCs_FallbackIndicator,
    pub purpose: MobilityFromEUTRACommand_r9_IEsPurpose,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<MobilityFromEUTRACommand_v930_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MobilityFromEUTRACommand_v1530_IEs {
    #[asn(optional_idx = 0)]
    pub smtc_r15: Option<MTC_SSB_NR_r15>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<MobilityFromEUTRACommand_v1530_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MobilityFromEUTRACommand_v8a0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<MobilityFromEUTRACommand_v8a0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<MobilityFromEUTRACommand_v8d0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MobilityFromEUTRACommand_v8d0_IEs {
    #[asn(optional_idx = 0)]
    pub band_indicator: Option<BandIndicatorGERAN>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<MobilityFromEUTRACommand_v8d0_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MobilityFromEUTRACommand_v930_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<MobilityFromEUTRACommand_v930_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<MobilityFromEUTRACommand_v960_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MobilityFromEUTRACommand_v960_IEs {
    #[asn(optional_idx = 0)]
    pub band_indicator: Option<BandIndicatorGERAN>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<MobilityFromEUTRACommand_v1530_IEs>,
}

pub type MobilityHistoryReport_r12 = VisitedCellInfoList_r12;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MobilityParameters_r14 {
    #[asn(optional_idx = 0)]
    pub make_before_break_r14: Option<MobilityParameters_r14MakeBeforeBreak_r14>,
    #[asn(optional_idx = 1)]
    pub rach_less_r14: Option<MobilityParameters_r14Rach_Less_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct MobilityParameters_v1610 {
    #[asn(optional_idx = 0)]
    pub cho_r16: Option<MobilityParameters_v1610Cho_r16>,
    #[asn(optional_idx = 1)]
    pub cho_fdd_tdd_r16: Option<MobilityParameters_v1610Cho_FDD_TDD_r16>,
    #[asn(optional_idx = 2)]
    pub cho_failure_r16: Option<MobilityParameters_v1610Cho_Failure_r16>,
    #[asn(optional_idx = 3)]
    pub cho_two_trigger_events_r16: Option<MobilityParameters_v1610Cho_TwoTriggerEvents_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct MobilityParametersCDMA2000(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MobilityStateParameters {
    pub t_evaluation: MobilityStateParametersT_Evaluation,
    pub t_hyst_normal: MobilityStateParametersT_HystNormal,
    pub n_cell_change_medium: MobilityStateParametersN_CellChangeMedium,
    pub n_cell_change_high: MobilityStateParametersN_CellChangeHigh,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MultiBandInfo_v9e0 {
    #[asn(optional_idx = 0)]
    pub freq_band_indicator_v9e0: Option<FreqBandIndicator_v9e0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MultiBandInfoList(pub Vec<FreqBandIndicator>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MultiBandInfoList_r11(pub Vec<FreqBandIndicator_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MultiBandInfoList_v10j0(pub Vec<NS_PmaxList_r10>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MultiBandInfoList_v10l0(pub Vec<NS_PmaxList_v10l0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MultiBandInfoList_v9e0(pub Vec<MultiBandInfo_v9e0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "31")]
pub struct MultiBandNsPmaxListNR_1_v1550(pub Vec<NS_PmaxListNR_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "31")]
pub struct MultiBandNsPmaxListNR_1_v1760(pub Vec<NS_PmaxListNR_v1760>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct MultiBandNsPmaxListNR_v1550(pub Vec<NS_PmaxListNR_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct MultiBandNsPmaxListNR_v1760(pub Vec<NS_PmaxListNR_v1760>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct MultiFrequencyBandListNR_r15(pub Vec<FreqBandIndicatorNR_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct N1PUCCH_AN_CS_r10(pub Vec<N1PUCCH_AN_CS_r10_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct N1PUCCH_AN_InfoList_r13(pub Vec<N1PUCCH_AN_InfoList_r13_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct N1PUCCH_AN_PersistentList(pub Vec<N1PUCCH_AN_PersistentList_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct N1SPUCCH_AN_PersistentList_r15(pub Vec<N1SPUCCH_AN_PersistentList_r15_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct N4SPUCCH_Resource_r15 {
    pub n4starting_prb_r15: N4SPUCCH_Resource_r15N4startingPRB_r15,
    pub n4number_of_prb_r15: N4SPUCCH_Resource_r15N4numberOfPRB_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum NAICS_AssistanceInfo_r12 {
    #[asn(key = 0, extended = false)]
    Release(NAICS_AssistanceInfo_r12_release),
    #[asn(key = 1, extended = false)]
    Setup(NAICS_AssistanceInfo_r12_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct NAICS_Capability_Entry_r12 {
    pub number_of_naics_capable_cc_r12: NAICS_Capability_Entry_r12NumberOfNAICS_CapableCC_r12,
    pub number_of_aggregated_prb_r12: NAICS_Capability_Entry_r12NumberOfAggregatedPRB_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct NAICS_Capability_List_r12(pub Vec<NAICS_Capability_Entry_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "48", sz_ub = "48")]
pub struct NG_5G_S_TMSI_r15(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct NR_CarrierList_r16(pub Vec<MeasIdleCarrierNR_r16>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct NR_FreqNeighHSDN_CellList_r17(pub Vec<PhysCellIdRangeNR_r16>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct NS_PmaxList_r10(pub Vec<NS_PmaxValue_r10>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct NS_PmaxList_v10l0(pub Vec<NS_PmaxValue_v10l0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct NS_PmaxListNR_r15(pub Vec<NS_PmaxValueNR_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct NS_PmaxListNR_v1760(pub Vec<NS_PmaxValueNR_v1760>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct NS_PmaxValue_r10 {
    #[asn(optional_idx = 0)]
    pub additional_pmax_r10: Option<P_Max>,
    pub additional_spectrum_emission: AdditionalSpectrumEmission,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct NS_PmaxValue_v10l0 {
    #[asn(optional_idx = 0)]
    pub additional_spectrum_emission_v10l0: Option<AdditionalSpectrumEmission_v10l0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct NS_PmaxValueNR_r15 {
    #[asn(optional_idx = 0)]
    pub additional_pmax_nr_r15: Option<P_MaxNR_r15>,
    pub additional_spectrum_emission_nr_r15: AdditionalSpectrumEmissionNR_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct NS_PmaxValueNR_v1760 {
    #[asn(optional_idx = 0)]
    pub additional_spectrum_emission_nr_v1760: Option<AdditionalSpectrumEmissionNR_v1760>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct NTN_Parameters_r17 {
    #[asn(optional_idx = 0)]
    pub ntn_connectivity_epc_r17: Option<NTN_Parameters_r17Ntn_Connectivity_EPC_r17>,
    #[asn(optional_idx = 1)]
    pub ntn_ta_report_r17: Option<NTN_Parameters_r17Ntn_TA_Report_r17>,
    #[asn(optional_idx = 2)]
    pub ntn_pur_timer_delay_r17: Option<NTN_Parameters_r17Ntn_PUR_TimerDelay_r17>,
    #[asn(optional_idx = 3)]
    pub ntn_offset_timing_enh_r17: Option<NTN_Parameters_r17Ntn_OffsetTimingEnh_r17>,
    #[asn(optional_idx = 4)]
    pub ntn_scenario_support_r17: Option<NTN_Parameters_r17Ntn_ScenarioSupport_r17>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct NTN_Parameters_v1720 {
    #[asn(optional_idx = 0)]
    pub ntn_segmented_precompensation_gaps_r17:
        Option<NTN_Parameters_v1720Ntn_SegmentedPrecompensationGaps_r17>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct NZP_FrequencyDensity_r14(pub u8);
impl NZP_FrequencyDensity_r14 {
    pub const D1: u8 = 0u8;
    pub const D2: u8 = 1u8;
    pub const D3: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct NZP_ResourceConfig_r13 {
    pub resource_config_r13: ResourceConfig_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2")]
pub struct NZP_TransmissionComb_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NeighCellCDMA2000 {
    pub band_class: BandclassCDMA2000,
    pub neigh_cells_per_freq_list: NeighCellsPerBandclassListCDMA2000,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NeighCellCDMA2000_r11 {
    pub band_class: BandclassCDMA2000,
    pub neigh_freq_info_list_r11: NeighCellCDMA2000_r11NeighFreqInfoList_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NeighCellCDMA2000_v920 {
    pub neigh_cells_per_freq_list_v920: NeighCellsPerBandclassListCDMA2000_v920,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct NeighCellConfig(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct NeighCellListCDMA2000(pub Vec<NeighCellCDMA2000>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct NeighCellListCDMA2000_v920(pub Vec<NeighCellCDMA2000_v920>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct NeighCellSI_AcquisitionParameters_r9 {
    #[asn(optional_idx = 0)]
    pub intra_freq_si_acquisition_for_ho_r9:
        Option<NeighCellSI_AcquisitionParameters_r9IntraFreqSI_AcquisitionForHO_r9>,
    #[asn(optional_idx = 1)]
    pub inter_freq_si_acquisition_for_ho_r9:
        Option<NeighCellSI_AcquisitionParameters_r9InterFreqSI_AcquisitionForHO_r9>,
    #[asn(optional_idx = 2)]
    pub utran_si_acquisition_for_ho_r9:
        Option<NeighCellSI_AcquisitionParameters_r9Utran_SI_AcquisitionForHO_r9>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct NeighCellSI_AcquisitionParameters_v1530 {
    #[asn(optional_idx = 0)]
    pub report_cgi_nr_en_dc_r15:
        Option<NeighCellSI_AcquisitionParameters_v1530ReportCGI_NR_EN_DC_r15>,
    #[asn(optional_idx = 1)]
    pub report_cgi_nr_no_en_dc_r15:
        Option<NeighCellSI_AcquisitionParameters_v1530ReportCGI_NR_NoEN_DC_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct NeighCellSI_AcquisitionParameters_v1550 {
    #[asn(optional_idx = 0)]
    pub eutra_cgi_reporting_endc_r15:
        Option<NeighCellSI_AcquisitionParameters_v1550Eutra_CGI_Reporting_ENDC_r15>,
    #[asn(optional_idx = 1)]
    pub utra_geran_cgi_reporting_endc_r15:
        Option<NeighCellSI_AcquisitionParameters_v1550Utra_GERAN_CGI_Reporting_ENDC_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct NeighCellSI_AcquisitionParameters_v15a0 {
    #[asn(optional_idx = 0)]
    pub eutra_cgi_reporting_nedc_r15:
        Option<NeighCellSI_AcquisitionParameters_v15a0Eutra_CGI_Reporting_NEDC_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct NeighCellSI_AcquisitionParameters_v1610 {
    #[asn(optional_idx = 0)]
    pub eutra_si_acquisition_for_ho_endc_r16:
        Option<NeighCellSI_AcquisitionParameters_v1610Eutra_SI_AcquisitionForHO_ENDC_r16>,
    #[asn(optional_idx = 1)]
    pub nr_autonomous_gaps_endc_fr1_r16:
        Option<NeighCellSI_AcquisitionParameters_v1610Nr_AutonomousGaps_ENDC_FR1_r16>,
    #[asn(optional_idx = 2)]
    pub nr_autonomous_gaps_endc_fr2_r16:
        Option<NeighCellSI_AcquisitionParameters_v1610Nr_AutonomousGaps_ENDC_FR2_r16>,
    #[asn(optional_idx = 3)]
    pub nr_autonomous_gaps_fr1_r16:
        Option<NeighCellSI_AcquisitionParameters_v1610Nr_AutonomousGaps_FR1_r16>,
    #[asn(optional_idx = 4)]
    pub nr_autonomous_gaps_fr2_r16:
        Option<NeighCellSI_AcquisitionParameters_v1610Nr_AutonomousGaps_FR2_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct NeighCellSI_AcquisitionParameters_v1710 {
    #[asn(optional_idx = 0)]
    pub gnb_id_length_reporting_nr_en_dc_r17:
        Option<NeighCellSI_AcquisitionParameters_v1710GNB_ID_Length_Reporting_NR_EN_DC_r17>,
    #[asn(optional_idx = 1)]
    pub gnb_id_length_reporting_nr_no_en_dc_r17:
        Option<NeighCellSI_AcquisitionParameters_v1710GNB_ID_Length_Reporting_NR_NoEN_DC_r17>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum NeighCellsCRS_Info_r11 {
    #[asn(key = 0, extended = false)]
    Release(NeighCellsCRS_Info_r11_release),
    #[asn(key = 1, extended = false)]
    Setup(CRS_AssistanceInfoList_r11),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum NeighCellsCRS_Info_r13 {
    #[asn(key = 0, extended = false)]
    Release(NeighCellsCRS_Info_r13_release),
    #[asn(key = 1, extended = false)]
    Setup(CRS_AssistanceInfoList_r13),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum NeighCellsCRS_Info_r15 {
    #[asn(key = 0, extended = false)]
    Release(NeighCellsCRS_Info_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(CRS_AssistanceInfoList_r15),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct NeighCellsInfo_r12 {
    pub phys_cell_id_r12: PhysCellId,
    pub p_b_r12: NeighCellsInfo_r12P_b_r12,
    pub crs_ports_count_r12: NeighCellsInfo_r12Crs_PortsCount_r12,
    #[asn(optional_idx = 0)]
    pub mbsfn_subframe_config_r12: Option<MBSFN_SubframeConfigList>,
    pub p_a_list_r12: NeighCellsInfo_r12P_aList_r12,
    pub transmission_mode_list_r12: NeighCellsInfo_r12TransmissionModeList_r12,
    pub res_alloc_granularity_r12: NeighCellsInfo_r12ResAllocGranularity_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NeighCellsPerBandclassCDMA2000 {
    pub arfcn: ARFCN_ValueCDMA2000,
    pub phys_cell_id_list: PhysCellIdListCDMA2000,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NeighCellsPerBandclassCDMA2000_r11 {
    pub arfcn: ARFCN_ValueCDMA2000,
    pub phys_cell_id_list_r11: NeighCellsPerBandclassCDMA2000_r11PhysCellIdList_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NeighCellsPerBandclassCDMA2000_v920 {
    pub phys_cell_id_list_v920: PhysCellIdListCDMA2000_v920,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct NeighCellsPerBandclassListCDMA2000(pub Vec<NeighCellsPerBandclassCDMA2000>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct NeighCellsPerBandclassListCDMA2000_v920(pub Vec<NeighCellsPerBandclassCDMA2000_v920>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct NeighCellsToAddModList_r12(pub Vec<NeighCellsInfo_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct NeighCellsToReleaseList_r12(pub Vec<PhysCellId>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct NextHopChainingCount(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct NonContiguousUL_RA_WithinCC_List_r10(pub Vec<NonContiguousUL_RA_WithinCC_r10>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct NonContiguousUL_RA_WithinCC_r10 {
    #[asn(optional_idx = 0)]
    pub non_contiguous_ul_ra_within_cc_info_r10:
        Option<NonContiguousUL_RA_WithinCC_r10NonContiguousUL_RA_WithinCC_Info_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NonMBSFN_SubframeConfig_r14 {
    pub radio_frame_allocation_period_r14:
        NonMBSFN_SubframeConfig_r14RadioFrameAllocationPeriod_r14,
    pub radio_frame_allocation_offset_r14:
        NonMBSFN_SubframeConfig_r14RadioFrameAllocationOffset_r14,
    pub subframe_allocation_r14: NonMBSFN_SubframeConfig_r14SubframeAllocation_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "200")]
pub struct NumberOfPreamblesSent_r11(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct OTDOA_PositioningCapabilities_r10 {
    pub otdoa_ue_assisted_r10: OTDOA_PositioningCapabilities_r10Otdoa_UE_Assisted_r10,
    #[asn(optional_idx = 0)]
    pub inter_freq_rstd_measurement_r10:
        Option<OTDOA_PositioningCapabilities_r10InterFreqRSTD_Measurement_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct ObtainLocationConfig_r11 {
    #[asn(optional_idx = 0)]
    pub obtain_location_r11: Option<ObtainLocationConfig_r11ObtainLocation_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct OffsetThresholdTA_r17(pub u8);
impl OffsetThresholdTA_r17 {
    pub const MS0DOT5: u8 = 0u8;
    pub const MS1: u8 = 1u8;
    pub const MS2: u8 = 2u8;
    pub const MS3: u8 = 3u8;
    pub const MS4: u8 = 4u8;
    pub const MS5: u8 = 5u8;
    pub const MS6: u8 = 6u8;
    pub const MS7: u8 = 7u8;
    pub const MS8: u8 = 8u8;
    pub const MS9: u8 = 9u8;
    pub const MS10: u8 = 10u8;
    pub const MS11: u8 = 11u8;
    pub const MS12: u8 = 12u8;
    pub const MS13: u8 = 13u8;
    pub const MS14: u8 = 14u8;
    pub const MS15: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct Other_Parameters_r11 {
    #[asn(optional_idx = 0)]
    pub in_device_coex_ind_r11: Option<Other_Parameters_r11InDeviceCoexInd_r11>,
    #[asn(optional_idx = 1)]
    pub power_pref_ind_r11: Option<Other_Parameters_r11PowerPrefInd_r11>,
    #[asn(optional_idx = 2)]
    pub ue_rx_tx_time_diff_measurements_r11:
        Option<Other_Parameters_r11Ue_Rx_TxTimeDiffMeasurements_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct Other_Parameters_v11d0 {
    #[asn(optional_idx = 0)]
    pub in_device_coex_ind_ul_ca_r11: Option<Other_Parameters_v11d0InDeviceCoexInd_UL_CA_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct Other_Parameters_v1360 {
    #[asn(optional_idx = 0)]
    pub in_device_coex_ind_hardware_sharing_ind_r13:
        Option<Other_Parameters_v1360InDeviceCoexInd_HardwareSharingInd_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct Other_Parameters_v1430 {
    #[asn(optional_idx = 0)]
    pub bw_pref_ind_r14: Option<Other_Parameters_v1430BwPrefInd_r14>,
    #[asn(optional_idx = 1)]
    pub rlm_report_support_r14: Option<Other_Parameters_v1430Rlm_ReportSupport_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct Other_Parameters_v1460 {
    #[asn(optional_idx = 0)]
    pub non_csg_si_reporting_r14: Option<Other_Parameters_v1460NonCSG_SI_Reporting_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct Other_Parameters_v1530 {
    #[asn(optional_idx = 0)]
    pub assist_info_bit_for_lc_r15: Option<Other_Parameters_v1530AssistInfoBitForLC_r15>,
    #[asn(optional_idx = 1)]
    pub time_reference_provision_r15: Option<Other_Parameters_v1530TimeReferenceProvision_r15>,
    #[asn(optional_idx = 2)]
    pub flight_path_plan_r15: Option<Other_Parameters_v1530FlightPathPlan_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct Other_Parameters_v1540 {
    #[asn(optional_idx = 0)]
    pub in_device_coex_ind_endc_r15: Option<Other_Parameters_v1540InDeviceCoexInd_ENDC_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct Other_Parameters_v1610 {
    #[asn(optional_idx = 0)]
    pub resume_with_stored_mcg_s_cells_r16:
        Option<Other_Parameters_v1610ResumeWithStoredMCG_SCells_r16>,
    #[asn(optional_idx = 1)]
    pub resume_with_mcg_s_cell_config_r16:
        Option<Other_Parameters_v1610ResumeWithMCG_SCellConfig_r16>,
    #[asn(optional_idx = 2)]
    pub resume_with_stored_scg_r16: Option<Other_Parameters_v1610ResumeWithStoredSCG_r16>,
    #[asn(optional_idx = 3)]
    pub resume_with_scg_config_r16: Option<Other_Parameters_v1610ResumeWithSCG_Config_r16>,
    #[asn(optional_idx = 4)]
    pub mcg_rlf_recovery_via_scg_r16: Option<Other_Parameters_v1610McgRLF_RecoveryViaSCG_r16>,
    #[asn(optional_idx = 5)]
    pub overheating_ind_for_scg_r16: Option<Other_Parameters_v1610OverheatingIndForSCG_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct Other_Parameters_v1650 {
    #[asn(optional_idx = 0)]
    pub mps_priority_indication_r16: Option<Other_Parameters_v1650MpsPriorityIndication_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct Other_Parameters_v1690 {
    #[asn(optional_idx = 0)]
    pub ul_rrc_segmentation_r16: Option<Other_Parameters_v1690Ul_RRC_Segmentation_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct OtherConfig_r9 {
    #[asn(optional_idx = 0)]
    pub report_proximity_config_r9: Option<ReportProximityConfig_r9>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct OtherParameters_v1450 {
    #[asn(optional_idx = 0)]
    pub overheating_ind_r14: Option<OtherParameters_v1450OverheatingInd_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct OverheatingAssistance_r14 {
    #[asn(optional_idx = 0)]
    pub reduced_ue_category: Option<OverheatingAssistance_r14ReducedUE_Category>,
    #[asn(optional_idx = 1)]
    pub reduced_max_c_cs: Option<OverheatingAssistance_r14ReducedMaxCCs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct OverheatingAssistance_v1610 {
    pub overheating_assistance_for_scg_r16:
        OverheatingAssistance_v1610OverheatingAssistanceForSCG_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct OverheatingAssistance_v1710 {
    pub overheating_assistance_for_scg_fr2_2_r17:
        OverheatingAssistance_v1710OverheatingAssistanceForSCG_FR2_2_r17,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct P_C_AndCBSR_Pair_r13(pub Vec<P_C_AndCBSR_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct P_C_AndCBSR_Pair_r13a(pub Vec<P_C_AndCBSR_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct P_C_AndCBSR_Pair_r15(pub Vec<P_C_AndCBSR_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct P_C_AndCBSR_r11 {
    pub p_c_r11: P_C_AndCBSR_r11P_C_r11,
    pub codebook_subset_restriction_r11: P_C_AndCBSR_r11CodebookSubsetRestriction_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct P_C_AndCBSR_r13 {
    pub p_c_r13: P_C_AndCBSR_r13P_C_r13,
    pub cbsr_selection_r13: P_C_AndCBSR_r13Cbsr_Selection_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct P_C_AndCBSR_r15 {
    pub p_c_r15: P_C_AndCBSR_r15P_C_r15,
    pub codebook_subset_restriction4_r15: P_C_AndCBSR_r15CodebookSubsetRestriction4_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-30", ub = "33")]
pub struct P_Max(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-30", ub = "33")]
pub struct P_MaxNR_r15(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct P_a(pub u8);
impl P_a {
    pub const D_B_6: u8 = 0u8;
    pub const D_B_4DOT77: u8 = 1u8;
    pub const D_B_3: u8 = 2u8;
    pub const D_B_1DOT77: u8 = 3u8;
    pub const D_B0: u8 = 4u8;
    pub const D_B1: u8 = 5u8;
    pub const D_B2: u8 = 6u8;
    pub const D_B3: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-126", ub = "31")]
pub struct P0_SL_r12(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PCCH_Config {
    pub default_paging_cycle: PCCH_ConfigDefaultPagingCycle,
    pub nb: PCCH_ConfigNB,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PCCH_Config_v1310 {
    pub paging_narrow_bands_r13: PCCH_Config_v1310Paging_narrowBands_r13,
    pub mpdcch_num_repetition_paging_r13: PCCH_Config_v1310Mpdcch_NumRepetition_Paging_r13,
    #[asn(optional_idx = 0)]
    pub nb_v1310: Option<PCCH_Config_v1310NB_v1310>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PCCH_Config_v1700 {
    pub ran_paging_in_idle_po_r17: PCCH_Config_v1700RanPagingInIdlePO_r17,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PCCH_Message {
    pub message: PCCH_MessageType,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PCCH_MessageType {
    #[asn(key = 0, extended = false)]
    C1(PCCH_MessageType_c1),
    #[asn(key = 1, extended = false)]
    MessageClassExtension(PCCH_MessageType_messageClassExtension),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PCI_ARFCN_r13 {
    pub phys_cell_id_r13: PhysCellId,
    #[asn(optional_idx = 0)]
    pub carrier_freq_r13: Option<ARFCN_ValueEUTRA_r9>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct PDCCH_CandidateReductionValue_r13(pub u8);
impl PDCCH_CandidateReductionValue_r13 {
    pub const N0: u8 = 0u8;
    pub const N33: u8 = 1u8;
    pub const N66: u8 = 2u8;
    pub const N100: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct PDCCH_CandidateReductionValue_r14(pub u8);
impl PDCCH_CandidateReductionValue_r14 {
    pub const N0: u8 = 0u8;
    pub const N50: u8 = 1u8;
    pub const N100: u8 = 2u8;
    pub const N150: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PDCCH_CandidateReductions_r13 {
    #[asn(key = 0, extended = false)]
    Release(PDCCH_CandidateReductions_r13_release),
    #[asn(key = 1, extended = false)]
    Setup(PDCCH_CandidateReductions_r13_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PDCCH_CandidateReductionsLAA_UL_r14 {
    #[asn(key = 0, extended = false)]
    Release(PDCCH_CandidateReductionsLAA_UL_r14_release),
    #[asn(key = 1, extended = false)]
    Setup(PDCCH_CandidateReductionsLAA_UL_r14_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 8)]
pub struct PDCCH_ConfigLAA_r14 {
    #[asn(optional_idx = 0)]
    pub max_number_of_sched_subframes_format0_b_r14:
        Option<PDCCH_ConfigLAA_r14MaxNumberOfSchedSubframes_Format0B_r14>,
    #[asn(optional_idx = 1)]
    pub max_number_of_sched_subframes_format4_b_r14:
        Option<PDCCH_ConfigLAA_r14MaxNumberOfSchedSubframes_Format4B_r14>,
    #[asn(optional_idx = 2)]
    pub skip_monitoring_dci_format0_a_r14:
        Option<PDCCH_ConfigLAA_r14SkipMonitoringDCI_Format0A_r14>,
    #[asn(optional_idx = 3)]
    pub skip_monitoring_dci_format4_a_r14:
        Option<PDCCH_ConfigLAA_r14SkipMonitoringDCI_Format4A_r14>,
    #[asn(optional_idx = 4)]
    pub pdcch_candidate_reductions_format0_a_r14: Option<PDCCH_CandidateReductions_r13>,
    #[asn(optional_idx = 5)]
    pub pdcch_candidate_reductions_format4_a_r14: Option<PDCCH_CandidateReductionsLAA_UL_r14>,
    #[asn(optional_idx = 6)]
    pub pdcch_candidate_reductions_format0_b_r14: Option<PDCCH_CandidateReductionsLAA_UL_r14>,
    #[asn(optional_idx = 7)]
    pub pdcch_candidate_reductions_format4_b_r14: Option<PDCCH_CandidateReductionsLAA_UL_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PDCCH_ConfigSCell_r13 {
    #[asn(optional_idx = 0)]
    pub skip_monitoring_dci_format0_1a_r13:
        Option<PDCCH_ConfigSCell_r13SkipMonitoringDCI_format0_1A_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct PDCP_Config {
    #[asn(optional_idx = 0)]
    pub discard_timer: Option<PDCP_ConfigDiscardTimer>,
    #[asn(optional_idx = 1)]
    pub rlc_am: Option<PDCP_ConfigRlc_AM>,
    #[asn(optional_idx = 2)]
    pub rlc_um: Option<PDCP_ConfigRlc_UM>,
    pub header_compression: PDCP_ConfigHeaderCompression,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDCP_Parameters {
    pub supported_rohc_profiles: ROHC_ProfileSupportList_r15,
    #[asn(optional_idx = 0)]
    pub max_number_rohc_context_sessions: Option<PDCP_ParametersMaxNumberROHC_ContextSessions>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct PDCP_Parameters_v1130 {
    #[asn(optional_idx = 0)]
    pub pdcp_sn_extension_r11: Option<PDCP_Parameters_v1130Pdcp_SN_Extension_r11>,
    #[asn(optional_idx = 1)]
    pub support_rohc_context_continue_r11:
        Option<PDCP_Parameters_v1130SupportRohcContextContinue_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PDCP_Parameters_v1310 {
    #[asn(optional_idx = 0)]
    pub pdcp_sn_extension_18bits_r13: Option<PDCP_Parameters_v1310Pdcp_SN_Extension_18bits_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PDCP_Parameters_v1430 {
    pub supported_uplink_only_rohc_profiles_r14:
        PDCP_Parameters_v1430SupportedUplinkOnlyROHC_Profiles_r14,
    #[asn(optional_idx = 0)]
    pub max_number_rohc_context_sessions_r14:
        Option<PDCP_Parameters_v1430MaxNumberROHC_ContextSessions_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct PDCP_Parameters_v1530 {
    #[asn(optional_idx = 0)]
    pub supported_udc_r15: Option<SupportedUDC_r15>,
    #[asn(optional_idx = 1)]
    pub pdcp_duplication_r15: Option<PDCP_Parameters_v1530Pdcp_Duplication_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct PDCP_Parameters_v1610 {
    #[asn(optional_idx = 0)]
    pub pdcp_version_change_without_ho_r16:
        Option<PDCP_Parameters_v1610Pdcp_VersionChangeWithoutHO_r16>,
    #[asn(optional_idx = 1)]
    pub ehc_r16: Option<PDCP_Parameters_v1610Ehc_r16>,
    #[asn(optional_idx = 2)]
    pub continue_ehc_context_r16: Option<PDCP_Parameters_v1610ContinueEHC_Context_r16>,
    #[asn(optional_idx = 3)]
    pub max_number_ehc_contexts_r16: Option<PDCP_Parameters_v1610MaxNumberEHC_Contexts_r16>,
    #[asn(optional_idx = 4)]
    pub joint_ehc_rohc_config_r16: Option<PDCP_Parameters_v1610JointEHC_ROHC_Config_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct PDCP_ParametersNR_r15 {
    pub rohc_profiles_r15: ROHC_ProfileSupportList_r15,
    #[asn(optional_idx = 0)]
    pub rohc_context_max_sessions_r15: Option<PDCP_ParametersNR_r15Rohc_ContextMaxSessions_r15>,
    pub rohc_profiles_ul_only_r15: PDCP_ParametersNR_r15Rohc_ProfilesUL_Only_r15,
    #[asn(optional_idx = 1)]
    pub rohc_context_continue_r15: Option<PDCP_ParametersNR_r15Rohc_ContextContinue_r15>,
    #[asn(optional_idx = 2)]
    pub out_of_order_delivery_r15: Option<PDCP_ParametersNR_r15OutOfOrderDelivery_r15>,
    #[asn(optional_idx = 3)]
    pub sn_size_lo_r15: Option<PDCP_ParametersNR_r15Sn_SizeLo_r15>,
    #[asn(optional_idx = 4)]
    pub ims_voice_over_nr_pdcp_mcg_bearer_r15:
        Option<PDCP_ParametersNR_r15Ims_VoiceOverNR_PDCP_MCG_Bearer_r15>,
    #[asn(optional_idx = 5)]
    pub ims_voice_over_nr_pdcp_scg_bearer_r15:
        Option<PDCP_ParametersNR_r15Ims_VoiceOverNR_PDCP_SCG_Bearer_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PDCP_ParametersNR_v1560 {
    #[asn(optional_idx = 0)]
    pub ims_vo_nr_pdcp_scg_ngendc_r15: Option<PDCP_ParametersNR_v1560Ims_VoNR_PDCP_SCG_NGENDC_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDSCH_ConfigCommon {
    pub reference_signal_power: PDSCH_ConfigCommonReferenceSignalPower,
    pub p_b: PDSCH_ConfigCommonP_b,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct PDSCH_ConfigCommon_v1310 {
    #[asn(optional_idx = 0)]
    pub pdsch_max_num_repetition_c_emode_a_r13:
        Option<PDSCH_ConfigCommon_v1310Pdsch_maxNumRepetitionCEmodeA_r13>,
    #[asn(optional_idx = 1)]
    pub pdsch_max_num_repetition_c_emode_b_r13:
        Option<PDSCH_ConfigCommon_v1310Pdsch_maxNumRepetitionCEmodeB_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDSCH_ConfigDedicated {
    pub p_a: PDSCH_ConfigDedicatedP_a,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct PDSCH_ConfigDedicated_v1130 {
    #[asn(optional_idx = 0)]
    pub dmrs_config_pdsch_r11: Option<DMRS_Config_r11>,
    #[asn(optional_idx = 1)]
    pub qcl_operation: Option<PDSCH_ConfigDedicated_v1130Qcl_Operation>,
    #[asn(optional_idx = 2)]
    pub re_mapping_qcl_config_to_release_list_r11: Option<RE_MappingQCLConfigToReleaseList_r11>,
    #[asn(optional_idx = 3)]
    pub re_mapping_qcl_config_to_add_mod_list_r11: Option<RE_MappingQCLConfigToAddModList_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PDSCH_ConfigDedicated_v1280 {
    #[asn(optional_idx = 0)]
    pub tbs_index_alt_r12: Option<PDSCH_ConfigDedicated_v1280TbsIndexAlt_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PDSCH_ConfigDedicated_v1310 {
    #[asn(optional_idx = 0)]
    pub dmrs_config_pdsch_v1310: Option<DMRS_Config_v1310>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct PDSCH_ConfigDedicated_v1430 {
    #[asn(optional_idx = 0)]
    pub ce_pdsch_max_bandwidth_r14: Option<PDSCH_ConfigDedicated_v1430Ce_PDSCH_MaxBandwidth_r14>,
    #[asn(optional_idx = 1)]
    pub ce_pdsch_ten_processes_r14: Option<PDSCH_ConfigDedicated_v1430Ce_PDSCH_TenProcesses_r14>,
    #[asn(optional_idx = 2)]
    pub ce_harq_ack_bundling_r14: Option<PDSCH_ConfigDedicated_v1430Ce_HARQ_AckBundling_r14>,
    #[asn(optional_idx = 3)]
    pub ce_scheduling_enhancement_r14:
        Option<PDSCH_ConfigDedicated_v1430Ce_SchedulingEnhancement_r14>,
    #[asn(optional_idx = 4)]
    pub tbs_index_alt2_r14: Option<PDSCH_ConfigDedicated_v1430TbsIndexAlt2_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct PDSCH_ConfigDedicated_v1530 {
    #[asn(optional_idx = 0)]
    pub qcl_operation_v1530: Option<PDSCH_ConfigDedicated_v1530Qcl_Operation_v1530>,
    #[asn(optional_idx = 1)]
    pub tbs_index_alt3_r15: Option<PDSCH_ConfigDedicated_v1530Tbs_IndexAlt3_r15>,
    #[asn(optional_idx = 2)]
    pub ce_cqi_alternative_table_config_r15:
        Option<PDSCH_ConfigDedicated_v1530Ce_CQI_AlternativeTableConfig_r15>,
    #[asn(optional_idx = 3)]
    pub ce_pdsch_64qam_config_r15: Option<PDSCH_ConfigDedicated_v1530Ce_PDSCH_64QAM_Config_r15>,
    #[asn(optional_idx = 4)]
    pub ce_pdsch_flexible_start_prb_alloc_config_r15:
        Option<PDSCH_ConfigDedicated_v1530Ce_PDSCH_FlexibleStartPRB_AllocConfig_r15>,
    #[asn(optional_idx = 5)]
    pub alt_mcs_table_scaling_config_r15:
        Option<PDSCH_ConfigDedicated_v1530AltMCS_TableScalingConfig_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDSCH_ConfigDedicated_v1610 {
    pub ce_pdsch_multi_tb_config_r16: PDSCH_ConfigDedicated_v1610Ce_PDSCH_MultiTB_Config_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct PDSCH_ConfigDedicated_v1700 {
    #[asn(optional_idx = 0)]
    pub ce_pdsch_14harq_config_r17: Option<PDSCH_ConfigDedicated_v1700Ce_PDSCH_14HARQ_Config_r17>,
    #[asn(optional_idx = 1)]
    pub ce_pdsch_max_tbs_r17: Option<PDSCH_ConfigDedicated_v1700Ce_PDSCH_maxTBS_r17>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PDSCH_ConfigDedicatedSCell_v1430 {
    #[asn(optional_idx = 0)]
    pub tbs_index_alt2_r14: Option<PDSCH_ConfigDedicatedSCell_v1430TbsIndexAlt2_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PDSCH_RE_MappingQCL_Config_r11 {
    pub pdsch_re_mapping_qcl_config_id_r11: PDSCH_RE_MappingQCL_ConfigId_r11,
    #[asn(optional_idx = 0)]
    pub optional_set_of_fields_r11: Option<PDSCH_RE_MappingQCL_Config_r11OptionalSetOfFields_r11>,
    pub csi_rs_config_zp_id_r11: CSI_RS_ConfigZPId_r11,
    #[asn(optional_idx = 1)]
    pub qcl_csi_rs_config_nzp_id_r11: Option<CSI_RS_ConfigNZPId_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4")]
pub struct PDSCH_RE_MappingQCL_ConfigId_r11(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PHICH_Config {
    pub phich_duration: PHICH_ConfigPhich_Duration,
    pub phich_resource: PHICH_ConfigPhich_Resource,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PLMN_Identity {
    #[asn(optional_idx = 0)]
    pub mcc: Option<MCC>,
    pub mnc: MNC,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PLMN_IdentityInfo {
    pub plmn_identity: PLMN_Identity,
    pub cell_reserved_for_operator_use: PLMN_IdentityInfoCellReservedForOperatorUse,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PLMN_IdentityInfo_r15 {
    pub plmn_identity_5gc_r15: PLMN_IdentityInfo_r15Plmn_Identity_5GC_r15,
    pub cell_reserved_for_operator_use_r15: PLMN_IdentityInfo_r15CellReservedForOperatorUse_r15,
    pub cell_reserved_for_operator_use_crs_r15:
        PLMN_IdentityInfo_r15CellReservedForOperatorUse_CRS_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PLMN_IdentityInfo_v1530 {
    pub cell_reserved_for_operator_use_crs_r15:
        PLMN_IdentityInfo_v1530CellReservedForOperatorUse_CRS_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct PLMN_IdentityInfo_v1610 {
    #[asn(optional_idx = 0)]
    pub cp_c_io_t_5gs_optimisation_r16: Option<PLMN_IdentityInfo_v1610Cp_CIoT_5GS_Optimisation_r16>,
    #[asn(optional_idx = 1)]
    pub up_c_io_t_5gs_optimisation_r16: Option<PLMN_IdentityInfo_v1610Up_CIoT_5GS_Optimisation_r16>,
    #[asn(optional_idx = 2)]
    pub iab_support_r16: Option<PLMN_IdentityInfo_v1610Iab_Support_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PLMN_IdentityInfo_v1700 {
    #[asn(optional_idx = 0)]
    pub tracking_area_list_r17: Option<TrackingAreaList_r17>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PLMN_IdentityInfo2_r12 {
    #[asn(key = 0, extended = false)]
    Plmn_Index_r12(PLMN_IdentityInfo2_r12_plmn_Index_r12),
    #[asn(key = 1, extended = false)]
    PlmnIdentity_r12(PLMN_Identity),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "12")]
pub struct PLMN_IdentityInfoListNR_r15(pub Vec<PLMN_IdentityInfoNR_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "12")]
pub struct PLMN_IdentityInfoListNR_v1710(pub Vec<PLMN_IdentityInfoNR_v1710>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct PLMN_IdentityInfoNR_r15 {
    pub plmn_identity_list_r15: PLMN_IdentityListNR_r15,
    #[asn(optional_idx = 0)]
    pub tracking_area_code_r15: Option<TrackingAreaCodeNR_r15>,
    #[asn(optional_idx = 1)]
    pub ran_area_code_r15: Option<RAN_AreaCode_r15>,
    pub cell_identity_r15: CellIdentityNR_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PLMN_IdentityInfoNR_v1710 {
    #[asn(optional_idx = 0)]
    pub gnb_id_length_r17: Option<PLMN_IdentityInfoNR_v1710GNB_ID_Length_r17>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct PLMN_IdentityList(pub Vec<PLMN_IdentityInfo>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct PLMN_IdentityList_MBMS_r14(pub Vec<PLMN_Identity>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct PLMN_IdentityList_r15(pub Vec<PLMN_IdentityInfo_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct PLMN_IdentityList_v1530(pub Vec<PLMN_IdentityInfo_v1530>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct PLMN_IdentityList_v1610(pub Vec<PLMN_IdentityInfo_v1610>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct PLMN_IdentityList_v1700(pub Vec<PLMN_IdentityInfo_v1700>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "5")]
pub struct PLMN_IdentityList2(pub Vec<PLMN_Identity>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct PLMN_IdentityList3_r11(pub Vec<PLMN_Identity>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct PLMN_IdentityList4_r12(pub Vec<PLMN_IdentityInfo2_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "12")]
pub struct PLMN_IdentityListNR_r15(pub Vec<PLMN_Identity>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PLMN_Info_r15 {
    #[asn(optional_idx = 0)]
    pub upper_layer_indication_r15: Option<PLMN_Info_r15UpperLayerIndication_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PLMN_Info_r16 {
    #[asn(optional_idx = 0)]
    pub nr_band_list_r16: Option<PLMN_Info_r16Nr_BandList_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct PLMN_InfoList_r15(pub Vec<PLMN_Info_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "0", sz_ub = "6")]
pub struct PLMN_InfoList_r16(pub Vec<PLMN_Info_r16>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PLMN_RAN_AreaCell_r15 {
    #[asn(optional_idx = 0)]
    pub plmn_identity_r15: Option<PLMN_Identity>,
    pub ran_area_cells_r15: PLMN_RAN_AreaCell_r15Ran_AreaCells_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct PLMN_RAN_AreaCellList_r15(pub Vec<PLMN_RAN_AreaCell_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PLMN_RAN_AreaConfig_r15 {
    #[asn(optional_idx = 0)]
    pub plmn_identity_r15: Option<PLMN_Identity>,
    pub ran_area_r15: PLMN_RAN_AreaConfig_r15Ran_Area_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct PLMN_RAN_AreaConfigList_r15(pub Vec<PLMN_RAN_AreaConfig_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PMCH_Config_r12 {
    pub sf_alloc_end_r12: PMCH_Config_r12Sf_AllocEnd_r12,
    pub data_mcs_r12: PMCH_Config_r12DataMCS_r12,
    pub mch_scheduling_period_r12: PMCH_Config_r12Mch_SchedulingPeriod_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PMCH_Config_r9 {
    pub sf_alloc_end_r9: PMCH_Config_r9Sf_AllocEnd_r9,
    pub data_mcs_r9: PMCH_Config_r9DataMCS_r9,
    pub mch_scheduling_period_r9: PMCH_Config_r9Mch_SchedulingPeriod_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PMCH_Info_r9 {
    pub pmch_config_r9: PMCH_Config_r9,
    pub mbms_session_info_list_r9: MBMS_SessionInfoList_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PMCH_InfoExt_r12 {
    pub pmch_config_r12: PMCH_Config_r12,
    pub mbms_session_info_list_r12: MBMS_SessionInfoList_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "0", sz_ub = "15")]
pub struct PMCH_InfoList_r9(pub Vec<PMCH_Info_r9>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "0", sz_ub = "15")]
pub struct PMCH_InfoListExt_r12(pub Vec<PMCH_InfoExt_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PRACH_Config {
    pub root_sequence_index: PRACH_ConfigRootSequenceIndex,
    #[asn(optional_idx = 0)]
    pub prach_config_info: Option<PRACH_ConfigInfo>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct PRACH_Config_v1310 {
    #[asn(optional_idx = 0)]
    pub rsrp_thresholds_prach_info_list_r13: Option<RSRP_ThresholdsPrachInfoList_r13>,
    #[asn(optional_idx = 1)]
    pub mpdcch_start_sf_css_ra_r13: Option<PRACH_Config_v1310Mpdcch_startSF_CSS_RA_r13>,
    #[asn(optional_idx = 2)]
    pub prach_hopping_offset_r13: Option<PRACH_Config_v1310Prach_HoppingOffset_r13>,
    #[asn(optional_idx = 3)]
    pub prach_parameters_list_ce_r13: Option<PRACH_ParametersListCE_r13>,
    #[asn(optional_idx = 4)]
    pub initial_ce_level_r13: Option<PRACH_Config_v1310Initial_CE_level_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PRACH_Config_v1430 {
    pub root_sequence_index_high_speed_r14: PRACH_Config_v1430RootSequenceIndexHighSpeed_r14,
    pub zero_correlation_zone_config_high_speed_r14:
        PRACH_Config_v1430ZeroCorrelationZoneConfigHighSpeed_r14,
    pub prach_config_index_high_speed_r14: PRACH_Config_v1430Prach_ConfigIndexHighSpeed_r14,
    pub prach_freq_offset_high_speed_r14: PRACH_Config_v1430Prach_FreqOffsetHighSpeed_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PRACH_ConfigInfo {
    pub prach_config_index: PRACH_ConfigInfoPrach_ConfigIndex,
    pub high_speed_flag: PRACH_ConfigInfoHighSpeedFlag,
    pub zero_correlation_zone_config: PRACH_ConfigInfoZeroCorrelationZoneConfig,
    pub prach_freq_offset: PRACH_ConfigInfoPrach_FreqOffset,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PRACH_ConfigSCell_r10 {
    pub prach_config_index_r10: PRACH_ConfigSCell_r10Prach_ConfigIndex_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PRACH_ConfigSIB {
    pub root_sequence_index: PRACH_ConfigSIBRootSequenceIndex,
    pub prach_config_info: PRACH_ConfigInfo,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct PRACH_ConfigSIB_v1310 {
    pub rsrp_thresholds_prach_info_list_r13: RSRP_ThresholdsPrachInfoList_r13,
    #[asn(optional_idx = 0)]
    pub mpdcch_start_sf_css_ra_r13: Option<PRACH_ConfigSIB_v1310Mpdcch_startSF_CSS_RA_r13>,
    #[asn(optional_idx = 1)]
    pub prach_hopping_offset_r13: Option<PRACH_ConfigSIB_v1310Prach_HoppingOffset_r13>,
    pub prach_parameters_list_ce_r13: PRACH_ParametersListCE_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PRACH_ConfigSIB_v1530 {
    pub edt_prach_parameters_list_ce_r15: PRACH_ConfigSIB_v1530Edt_PRACH_ParametersListCE_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct PRACH_ParametersCE_r13 {
    pub prach_config_index_r13: PRACH_ParametersCE_r13Prach_ConfigIndex_r13,
    pub prach_freq_offset_r13: PRACH_ParametersCE_r13Prach_FreqOffset_r13,
    #[asn(optional_idx = 0)]
    pub prach_starting_subframe_r13: Option<PRACH_ParametersCE_r13Prach_StartingSubframe_r13>,
    #[asn(optional_idx = 1)]
    pub max_num_preamble_attempt_ce_r13: Option<PRACH_ParametersCE_r13MaxNumPreambleAttemptCE_r13>,
    pub num_repetition_per_preamble_attempt_r13:
        PRACH_ParametersCE_r13NumRepetitionPerPreambleAttempt_r13,
    pub mpdcch_narrowbands_to_monitor_r13: PRACH_ParametersCE_r13Mpdcch_NarrowbandsToMonitor_r13,
    pub mpdcch_num_repetition_ra_r13: PRACH_ParametersCE_r13Mpdcch_NumRepetition_RA_r13,
    pub prach_hopping_config_r13: PRACH_ParametersCE_r13Prach_HoppingConfig_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct PRACH_ParametersListCE_r13(pub Vec<PRACH_ParametersCE_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PRACH_TxDuration_r17 {
    pub prach_tx_duration_r17: PRACH_TxDuration_r17Prach_TxDuration_r17,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct PSCellToAddMod_r12 {
    pub s_cell_index_r12: SCellIndex_r10,
    #[asn(optional_idx = 0)]
    pub cell_identification_r12: Option<PSCellToAddMod_r12CellIdentification_r12>,
    #[asn(optional_idx = 1)]
    pub radio_resource_config_common_ps_cell_r12: Option<RadioResourceConfigCommonPSCell_r12>,
    #[asn(optional_idx = 2)]
    pub radio_resource_config_dedicated_ps_cell_r12: Option<RadioResourceConfigDedicatedPSCell_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PSCellToAddMod_v12f0 {
    #[asn(optional_idx = 0)]
    pub radio_resource_config_common_ps_cell_r12: Option<RadioResourceConfigCommonPSCell_v12f0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PSCellToAddMod_v1440 {
    #[asn(optional_idx = 0)]
    pub radio_resource_config_common_ps_cell_r14: Option<RadioResourceConfigCommonPSCell_v1440>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUCCH_ConfigCommon {
    pub delta_pucch_shift: PUCCH_ConfigCommonDeltaPUCCH_Shift,
    pub nrb_cqi: PUCCH_ConfigCommonNRB_CQI,
    pub ncs_an: PUCCH_ConfigCommonNCS_AN,
    pub n1pucch_an: PUCCH_ConfigCommonN1PUCCH_AN,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct PUCCH_ConfigCommon_v1310 {
    #[asn(optional_idx = 0)]
    pub n1pucch_an_info_list_r13: Option<N1PUCCH_AN_InfoList_r13>,
    #[asn(optional_idx = 1)]
    pub pucch_num_repetition_ce_msg4_level0_r13:
        Option<PUCCH_ConfigCommon_v1310Pucch_NumRepetitionCE_Msg4_Level0_r13>,
    #[asn(optional_idx = 2)]
    pub pucch_num_repetition_ce_msg4_level1_r13:
        Option<PUCCH_ConfigCommon_v1310Pucch_NumRepetitionCE_Msg4_Level1_r13>,
    #[asn(optional_idx = 3)]
    pub pucch_num_repetition_ce_msg4_level2_r13:
        Option<PUCCH_ConfigCommon_v1310Pucch_NumRepetitionCE_Msg4_Level2_r13>,
    #[asn(optional_idx = 4)]
    pub pucch_num_repetition_ce_msg4_level3_r13:
        Option<PUCCH_ConfigCommon_v1310Pucch_NumRepetitionCE_Msg4_Level3_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PUCCH_ConfigCommon_v1430 {
    #[asn(optional_idx = 0)]
    pub pucch_num_repetition_ce_msg4_level3_r14:
        Option<PUCCH_ConfigCommon_v1430Pucch_NumRepetitionCE_Msg4_Level3_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PUCCH_ConfigDedicated {
    pub ack_nack_repetition: PUCCH_ConfigDedicatedAckNackRepetition,
    #[asn(optional_idx = 0)]
    pub tdd_ack_nack_feedback_mode: Option<PUCCH_ConfigDedicatedTdd_AckNackFeedbackMode>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 10)]
pub struct PUCCH_ConfigDedicated_r13 {
    pub ack_nack_repetition_r13: PUCCH_ConfigDedicated_r13AckNackRepetition_r13,
    #[asn(optional_idx = 0)]
    pub tdd_ack_nack_feedback_mode_r13:
        Option<PUCCH_ConfigDedicated_r13Tdd_AckNackFeedbackMode_r13>,
    #[asn(optional_idx = 1)]
    pub pucch_format_r13: Option<PUCCH_ConfigDedicated_r13Pucch_Format_r13>,
    #[asn(optional_idx = 2)]
    pub two_antenna_port_activated_pucch_format1a1b_r13:
        Option<PUCCH_ConfigDedicated_r13TwoAntennaPortActivatedPUCCH_Format1a1b_r13>,
    #[asn(optional_idx = 3)]
    pub simultaneous_pucch_pusch_r13: Option<PUCCH_ConfigDedicated_r13SimultaneousPUCCH_PUSCH_r13>,
    #[asn(optional_idx = 4)]
    pub n1pucch_an_rep_p1_r13: Option<PUCCH_ConfigDedicated_r13N1PUCCH_AN_RepP1_r13>,
    #[asn(optional_idx = 5)]
    pub npucch_param_r13: Option<PUCCH_ConfigDedicated_r13NPUCCH_Param_r13>,
    #[asn(optional_idx = 6)]
    pub nka_pucch_param_r13: Option<PUCCH_ConfigDedicated_r13NkaPUCCH_Param_r13>,
    pub spatial_bundling_pucch_r13: PUCCH_ConfigDedicated_r13SpatialBundlingPUCCH_r13,
    pub spatial_bundling_pusch_r13: PUCCH_ConfigDedicated_r13SpatialBundlingPUSCH_r13,
    pub harq_timing_tdd_r13: PUCCH_ConfigDedicated_r13Harq_TimingTDD_r13,
    #[asn(optional_idx = 7)]
    pub codebooksize_determination_r13:
        Option<PUCCH_ConfigDedicated_r13CodebooksizeDetermination_r13>,
    #[asn(optional_idx = 8)]
    pub maximum_payload_coderate_r13: Option<PUCCH_ConfigDedicated_r13MaximumPayloadCoderate_r13>,
    #[asn(optional_idx = 9)]
    pub pucch_num_repetition_ce_r13: Option<PUCCH_ConfigDedicated_r13Pucch_NumRepetitionCE_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct PUCCH_ConfigDedicated_v1020 {
    #[asn(optional_idx = 0)]
    pub pucch_format_r10: Option<PUCCH_ConfigDedicated_v1020Pucch_Format_r10>,
    #[asn(optional_idx = 1)]
    pub two_antenna_port_activated_pucch_format1a1b_r10:
        Option<PUCCH_ConfigDedicated_v1020TwoAntennaPortActivatedPUCCH_Format1a1b_r10>,
    #[asn(optional_idx = 2)]
    pub simultaneous_pucch_pusch_r10:
        Option<PUCCH_ConfigDedicated_v1020SimultaneousPUCCH_PUSCH_r10>,
    #[asn(optional_idx = 3)]
    pub n1pucch_an_rep_p1_r10: Option<PUCCH_ConfigDedicated_v1020N1PUCCH_AN_RepP1_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct PUCCH_ConfigDedicated_v1130 {
    #[asn(optional_idx = 0)]
    pub n1pucch_an_cs_v1130: Option<PUCCH_ConfigDedicated_v1130N1PUCCH_AN_CS_v1130>,
    #[asn(optional_idx = 1)]
    pub npucch_param_r11: Option<PUCCH_ConfigDedicated_v1130NPUCCH_Param_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUCCH_ConfigDedicated_v1250 {
    pub nka_pucch_param_r12: PUCCH_ConfigDedicated_v1250NkaPUCCH_Param_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUCCH_ConfigDedicated_v1370 {
    pub pucch_format_v1370: PUCCH_ConfigDedicated_v1370Pucch_Format_v1370,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUCCH_ConfigDedicated_v13c0 {
    pub channel_selection_v13c0: PUCCH_ConfigDedicated_v13c0ChannelSelection_v13c0,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PUCCH_ConfigDedicated_v1430 {
    #[asn(optional_idx = 0)]
    pub pucch_num_repetition_ce_format1_r14:
        Option<PUCCH_ConfigDedicated_v1430Pucch_NumRepetitionCE_format1_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct PUCCH_ConfigDedicated_v1530 {
    #[asn(optional_idx = 0)]
    pub n1pucch_an_spt_r15: Option<PUCCH_ConfigDedicated_v1530N1PUCCH_AN_SPT_r15>,
    #[asn(optional_idx = 1)]
    pub codebooksize_determination_stti_r15:
        Option<PUCCH_ConfigDedicated_v1530CodebooksizeDeterminationSTTI_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct PUCCH_Format3_Conf_r13 {
    #[asn(optional_idx = 0)]
    pub n3pucch_an_list_r13: Option<PUCCH_Format3_Conf_r13N3PUCCH_AN_List_r13>,
    #[asn(optional_idx = 1)]
    pub two_antenna_port_activated_pucch_format3_r13:
        Option<PUCCH_Format3_Conf_r13TwoAntennaPortActivatedPUCCH_Format3_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUCCH_TxDuration_r17 {
    pub pucch_tx_duration_r17: PUCCH_TxDuration_r17Pucch_TxDuration_r17,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 10)]
pub struct PUR_Config_r16 {
    #[asn(optional_idx = 0)]
    pub pur_config_id_r16: Option<PUR_ConfigID_r16>,
    #[asn(optional_idx = 1)]
    pub pur_implicit_release_after_r16: Option<PUR_Config_r16Pur_ImplicitReleaseAfter_r16>,
    #[asn(optional_idx = 2)]
    pub pur_start_time_parameters_r16: Option<PUR_Config_r16Pur_StartTimeParameters_r16>,
    pub pur_num_occasions_r16: PUR_Config_r16Pur_NumOccasions_r16,
    #[asn(optional_idx = 3)]
    pub pur_rnti_r16: Option<C_RNTI>,
    #[asn(optional_idx = 4)]
    pub pur_time_alignment_timer_r16: Option<PUR_Config_r16Pur_TimeAlignmentTimer_r16>,
    #[asn(optional_idx = 5)]
    pub pur_rsrp_change_threshold_r16: Option<PUR_Config_r16Pur_RSRP_ChangeThreshold_r16>,
    #[asn(optional_idx = 6)]
    pub pur_response_window_timer_r16: Option<PUR_Config_r16Pur_ResponseWindowTimer_r16>,
    #[asn(optional_idx = 7)]
    pub pur_mpdcch_config_r16: Option<PUR_MPDCCH_Config_r16>,
    pub pur_pdsch_freq_hopping_r16: PUR_Config_r16Pur_PDSCH_FreqHopping_r16,
    #[asn(optional_idx = 8)]
    pub pur_pucch_config_r16: Option<PUR_PUCCH_Config_r16>,
    #[asn(optional_idx = 9)]
    pub pur_pusch_config_r16: Option<PUR_PUSCH_Config_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "20", sz_ub = "20")]
pub struct PUR_ConfigID_r16(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUR_MPDCCH_Config_r16 {
    pub mpdcch_freq_hopping_r16: PUR_MPDCCH_Config_r16Mpdcch_FreqHopping_r16,
    pub mpdcch_narrowband_r16: PUR_MPDCCH_Config_r16Mpdcch_Narrowband_r16,
    pub mpdcch_prb_pairs_config_r16: PUR_MPDCCH_Config_r16Mpdcch_PRB_PairsConfig_r16,
    pub mpdcch_num_repetition_r16: PUR_MPDCCH_Config_r16Mpdcch_NumRepetition_r16,
    pub mpdcch_start_sf_uess_r16: PUR_MPDCCH_Config_r16Mpdcch_StartSF_UESS_r16,
    pub mpdcch_offset_pur_ss_r16: PUR_MPDCCH_Config_r16Mpdcch_Offset_PUR_SS_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct PUR_PUCCH_Config_r16 {
    #[asn(optional_idx = 0)]
    pub n1pucch_an_r16: Option<PUR_PUCCH_Config_r16N1PUCCH_AN_r16>,
    #[asn(optional_idx = 1)]
    pub pucch_num_repetition_ce_format1_r16:
        Option<PUR_PUCCH_Config_r16Pucch_NumRepetitionCE_Format1_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct PUR_PUSCH_Config_r16 {
    #[asn(optional_idx = 0)]
    pub pur_grant_info_r16: Option<PUR_PUSCH_Config_r16Pur_GrantInfo_r16>,
    pub pur_pusch_freq_hopping_r16: PUR_PUSCH_Config_r16Pur_PUSCH_FreqHopping_r16,
    pub p0_ue_pusch_r16: PUR_PUSCH_Config_r16P0_UE_PUSCH_r16,
    pub alpha_r16: Alpha_r12,
    pub pusch_cyclic_shift_r16: PUR_PUSCH_Config_r16Pusch_CyclicShift_r16,
    pub pusch_nb_max_tbs_r16: PUR_PUSCH_Config_r16Pusch_NB_MaxTBS_r16,
    #[asn(optional_idx = 1)]
    pub location_ce_mode_b_r16: Option<PUR_PUSCH_Config_r16LocationCE_ModeB_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 14)]
pub struct PUR_Parameters_r16 {
    #[asn(optional_idx = 0)]
    pub pur_cp_5gc_ce_mode_a_r16: Option<PUR_Parameters_r16Pur_CP_5GC_CE_ModeA_r16>,
    #[asn(optional_idx = 1)]
    pub pur_cp_5gc_ce_mode_b_r16: Option<PUR_Parameters_r16Pur_CP_5GC_CE_ModeB_r16>,
    #[asn(optional_idx = 2)]
    pub pur_up_5gc_ce_mode_a_r16: Option<PUR_Parameters_r16Pur_UP_5GC_CE_ModeA_r16>,
    #[asn(optional_idx = 3)]
    pub pur_up_5gc_ce_mode_b_r16: Option<PUR_Parameters_r16Pur_UP_5GC_CE_ModeB_r16>,
    #[asn(optional_idx = 4)]
    pub pur_cp_epc_ce_mode_a_r16: Option<PUR_Parameters_r16Pur_CP_EPC_CE_ModeA_r16>,
    #[asn(optional_idx = 5)]
    pub pur_cp_epc_ce_mode_b_r16: Option<PUR_Parameters_r16Pur_CP_EPC_CE_ModeB_r16>,
    #[asn(optional_idx = 6)]
    pub pur_up_epc_ce_mode_a_r16: Option<PUR_Parameters_r16Pur_UP_EPC_CE_ModeA_r16>,
    #[asn(optional_idx = 7)]
    pub pur_up_epc_ce_mode_b_r16: Option<PUR_Parameters_r16Pur_UP_EPC_CE_ModeB_r16>,
    #[asn(optional_idx = 8)]
    pub pur_cp_l1_ack_r16: Option<PUR_Parameters_r16Pur_CP_L1Ack_r16>,
    #[asn(optional_idx = 9)]
    pub pur_frequency_hopping_r16: Option<PUR_Parameters_r16Pur_FrequencyHopping_r16>,
    #[asn(optional_idx = 10)]
    pub pur_pusch_nb_max_tbs_r16: Option<PUR_Parameters_r16Pur_PUSCH_NB_MaxTBS_r16>,
    #[asn(optional_idx = 11)]
    pub pur_rsrp_validation_r16: Option<PUR_Parameters_r16Pur_RSRP_Validation_r16>,
    #[asn(optional_idx = 12)]
    pub pur_sub_prb_ce_mode_a_r16: Option<PUR_Parameters_r16Pur_SubPRB_CE_ModeA_r16>,
    #[asn(optional_idx = 13)]
    pub pur_sub_prb_ce_mode_b_r16: Option<PUR_Parameters_r16Pur_SubPRB_CE_ModeB_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "10", extensible = false)]
pub enum PUR_PeriodicityAndOffset_r16 {
    #[asn(key = 0, extended = false)]
    Periodicity8(PUR_PeriodicityAndOffset_r16_periodicity8),
    #[asn(key = 1, extended = false)]
    Periodicity16(PUR_PeriodicityAndOffset_r16_periodicity16),
    #[asn(key = 2, extended = false)]
    Periodicity32(PUR_PeriodicityAndOffset_r16_periodicity32),
    #[asn(key = 3, extended = false)]
    Periodicity64(PUR_PeriodicityAndOffset_r16_periodicity64),
    #[asn(key = 4, extended = false)]
    Periodicity128(PUR_PeriodicityAndOffset_r16_periodicity128),
    #[asn(key = 5, extended = false)]
    Periodicity256(PUR_PeriodicityAndOffset_r16_periodicity256),
    #[asn(key = 6, extended = false)]
    Periodicity512(PUR_PeriodicityAndOffset_r16_periodicity512),
    #[asn(key = 7, extended = false)]
    Periodicity1024(PUR_PeriodicityAndOffset_r16_periodicity1024),
    #[asn(key = 8, extended = false)]
    Periodicity2048(PUR_PeriodicityAndOffset_r16_periodicity2048),
    #[asn(key = 9, extended = false)]
    Periodicity4096(PUR_PeriodicityAndOffset_r16_periodicity4096),
    #[asn(key = 10, extended = false)]
    Periodicity8192(PUR_PeriodicityAndOffset_r16_periodicity8192),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PUR_RSRP_ChangeThreshold_r16 {
    pub increase_thresh_r16: RSRP_ChangeThresh_r16,
    #[asn(optional_idx = 0)]
    pub decrease_thresh_r16: Option<RSRP_ChangeThresh_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PURConfigurationRequest_r16 {
    pub critical_extensions: PURConfigurationRequest_r16CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct PURConfigurationRequest_r16_IEs {
    #[asn(optional_idx = 0)]
    pub pur_config_request_r16: Option<PURConfigurationRequest_r16_IEsPur_ConfigRequest_r16>,
    #[asn(optional_idx = 1)]
    pub late_non_critical_extension:
        Option<PURConfigurationRequest_r16_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<PURConfigurationRequest_r16_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUSCH_ConfigCommon {
    pub pusch_config_basic: PUSCH_ConfigCommonPusch_ConfigBasic,
    pub ul_reference_signals_pusch: UL_ReferenceSignalsPUSCH,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUSCH_ConfigCommon_v1270 {
    pub enable64_qam_v1270: PUSCH_ConfigCommon_v1270Enable64QAM_v1270,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct PUSCH_ConfigCommon_v1310 {
    #[asn(optional_idx = 0)]
    pub pusch_max_num_repetition_c_emode_a_r13:
        Option<PUSCH_ConfigCommon_v1310Pusch_maxNumRepetitionCEmodeA_r13>,
    #[asn(optional_idx = 1)]
    pub pusch_max_num_repetition_c_emode_b_r13:
        Option<PUSCH_ConfigCommon_v1310Pusch_maxNumRepetitionCEmodeB_r13>,
    #[asn(optional_idx = 2)]
    pub pusch_hopping_offset_v1310: Option<PUSCH_ConfigCommon_v1310Pusch_HoppingOffset_v1310>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUSCH_ConfigDedicated {
    pub beta_offset_ack_index: PUSCH_ConfigDedicatedBetaOffset_ACK_Index,
    pub beta_offset_ri_index: PUSCH_ConfigDedicatedBetaOffset_RI_Index,
    pub beta_offset_cqi_index: PUSCH_ConfigDedicatedBetaOffset_CQI_Index,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 7)]
pub struct PUSCH_ConfigDedicated_r13 {
    pub beta_offset_ack_index_r13: PUSCH_ConfigDedicated_r13BetaOffset_ACK_Index_r13,
    #[asn(optional_idx = 0)]
    pub beta_offset2_ack_index_r13: Option<PUSCH_ConfigDedicated_r13BetaOffset2_ACK_Index_r13>,
    pub beta_offset_ri_index_r13: PUSCH_ConfigDedicated_r13BetaOffset_RI_Index_r13,
    pub beta_offset_cqi_index_r13: PUSCH_ConfigDedicated_r13BetaOffset_CQI_Index_r13,
    #[asn(optional_idx = 1)]
    pub beta_offset_mc_r13: Option<PUSCH_ConfigDedicated_r13BetaOffsetMC_r13>,
    #[asn(optional_idx = 2)]
    pub group_hopping_disabled_r13: Option<PUSCH_ConfigDedicated_r13GroupHoppingDisabled_r13>,
    #[asn(optional_idx = 3)]
    pub dmrs_with_occ_activated_r13: Option<PUSCH_ConfigDedicated_r13Dmrs_WithOCC_Activated_r13>,
    #[asn(optional_idx = 4)]
    pub pusch_dmrs_r11: Option<PUSCH_ConfigDedicated_r13Pusch_DMRS_r11>,
    #[asn(optional_idx = 5)]
    pub uci_on_pusch: Option<PUSCH_ConfigDedicated_r13UciOnPUSCH>,
    #[asn(optional_idx = 6)]
    pub pusch_hopping_config_r13: Option<PUSCH_ConfigDedicated_r13Pusch_HoppingConfig_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct PUSCH_ConfigDedicated_v1020 {
    #[asn(optional_idx = 0)]
    pub beta_offset_mc_r10: Option<PUSCH_ConfigDedicated_v1020BetaOffsetMC_r10>,
    #[asn(optional_idx = 1)]
    pub group_hopping_disabled_r10: Option<PUSCH_ConfigDedicated_v1020GroupHoppingDisabled_r10>,
    #[asn(optional_idx = 2)]
    pub dmrs_with_occ_activated_r10: Option<PUSCH_ConfigDedicated_v1020Dmrs_WithOCC_Activated_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUSCH_ConfigDedicated_v1130 {
    pub pusch_dmrs_r11: PUSCH_ConfigDedicated_v1130Pusch_DMRS_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUSCH_ConfigDedicated_v1250 {
    pub uci_on_pusch: PUSCH_ConfigDedicated_v1250UciOnPUSCH,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct PUSCH_ConfigDedicated_v1430 {
    #[asn(optional_idx = 0)]
    pub ce_pusch_nb_max_tbs_r14: Option<PUSCH_ConfigDedicated_v1430Ce_PUSCH_NB_MaxTBS_r14>,
    #[asn(optional_idx = 1)]
    pub ce_pusch_max_bandwidth_r14: Option<PUSCH_ConfigDedicated_v1430Ce_PUSCH_MaxBandwidth_r14>,
    #[asn(optional_idx = 2)]
    pub tdd_pusch_up_pts_r14: Option<TDD_PUSCH_UpPTS_r14>,
    pub ul_dmrs_ifdma_r14: PUSCH_ConfigDedicated_v1430Ul_DMRS_IFDMA_r14,
    #[asn(optional_idx = 3)]
    pub enable256_qam_r14: Option<Enable256QAM_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PUSCH_ConfigDedicated_v1530 {
    pub ce_pusch_flexible_start_prb_alloc_config_r15:
        PUSCH_ConfigDedicated_v1530Ce_PUSCH_FlexibleStartPRB_AllocConfig_r15,
    #[asn(optional_idx = 0)]
    pub ce_pusch_sub_prb_config_r15: Option<PUSCH_ConfigDedicated_v1530Ce_PUSCH_SubPRB_Config_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUSCH_ConfigDedicated_v1610 {
    pub ce_pusch_multi_tb_config_r16: PUSCH_ConfigDedicated_v1610Ce_PUSCH_MultiTB_Config_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct PUSCH_ConfigDedicatedSCell_r10 {
    #[asn(optional_idx = 0)]
    pub group_hopping_disabled_r10: Option<PUSCH_ConfigDedicatedSCell_r10GroupHoppingDisabled_r10>,
    #[asn(optional_idx = 1)]
    pub dmrs_with_occ_activated_r10:
        Option<PUSCH_ConfigDedicatedSCell_r10Dmrs_WithOCC_Activated_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PUSCH_ConfigDedicatedSCell_v1430 {
    #[asn(optional_idx = 0)]
    pub enable256_qam_r14: Option<Enable256QAM_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUSCH_ConfigDedicatedScell_v1530 {
    pub uci_on_pusch_r15: PUSCH_ConfigDedicatedScell_v1530Uci_OnPUSCH_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUSCH_EnhancementsConfig_r14 {
    #[asn(key = 0, extended = false)]
    Release(PUSCH_EnhancementsConfig_r14_release),
    #[asn(key = 1, extended = false)]
    Setup(PUSCH_EnhancementsConfig_r14_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUSCH_ModeConfigLAA_r15 {
    pub laa_pusch_mode1: PUSCH_ModeConfigLAA_r15Laa_PUSCH_Mode1,
    pub laa_pusch_mode2: PUSCH_ModeConfigLAA_r15Laa_PUSCH_Mode2,
    pub laa_pusch_mode3: PUSCH_ModeConfigLAA_r15Laa_PUSCH_Mode3,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUSCH_TxDuration_r17 {
    pub pusch_tx_duration_r17: PUSCH_TxDuration_r17Pusch_TxDuration_r17,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct Paging {
    #[asn(optional_idx = 0)]
    pub paging_record_list: Option<PagingRecordList>,
    #[asn(optional_idx = 1)]
    pub system_info_modification: Option<PagingSystemInfoModification>,
    #[asn(optional_idx = 2)]
    pub etws_indication: Option<PagingEtws_Indication>,
    #[asn(optional_idx = 3)]
    pub non_critical_extension: Option<Paging_v890_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct Paging_v1130_IEs {
    #[asn(optional_idx = 0)]
    pub eab_param_modification_r11: Option<Paging_v1130_IEsEab_ParamModification_r11>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<Paging_v1310_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct Paging_v1310_IEs {
    #[asn(optional_idx = 0)]
    pub redistribution_indication_r13: Option<Paging_v1310_IEsRedistributionIndication_r13>,
    #[asn(optional_idx = 1)]
    pub system_info_modification_e_drx_r13: Option<Paging_v1310_IEsSystemInfoModification_eDRX_r13>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<Paging_v1530_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct Paging_v1530_IEs {
    #[asn(optional_idx = 0)]
    pub access_type: Option<Paging_v1530_IEsAccessType>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<Paging_v1610_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct Paging_v1610_IEs {
    #[asn(optional_idx = 0)]
    pub paging_record_list_v1610: Option<PagingRecordList_v1610>,
    #[asn(optional_idx = 1)]
    pub uac_param_modification_r16: Option<Paging_v1610_IEsUac_ParamModification_r16>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<Paging_v1700_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct Paging_v1700_IEs {
    #[asn(optional_idx = 0)]
    pub paging_record_list_v1700: Option<PagingRecordList_v1700>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<Paging_v1700_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct Paging_v890_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<Paging_v890_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<Paging_v920_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct Paging_v920_IEs {
    #[asn(optional_idx = 0)]
    pub cmas_indication_r9: Option<Paging_v920_IEsCmas_Indication_r9>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<Paging_v1130_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PagingRecord {
    pub ue_identity: PagingUE_Identity,
    pub cn_domain: PagingRecordCn_Domain,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct PagingRecord_v1610 {
    #[asn(optional_idx = 0)]
    pub access_type_r16: Option<PagingRecord_v1610AccessType_r16>,
    #[asn(optional_idx = 1)]
    pub mt_edt_r16: Option<PagingRecord_v1610Mt_EDT_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PagingRecord_v1700 {
    #[asn(optional_idx = 0)]
    pub paging_cause_r17: Option<PagingRecord_v1700PagingCause_r17>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct PagingRecordList(pub Vec<PagingRecord>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct PagingRecordList_v1610(pub Vec<PagingRecord_v1610>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct PagingRecordList_v1700(pub Vec<PagingRecord_v1700>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum PagingUE_Identity {
    #[asn(key = 0, extended = false)]
    S_TMSI(S_TMSI),
    #[asn(key = 1, extended = false)]
    Imsi(IMSI),
    #[asn(key = 0, extended = true)]
    Ng_5G_S_TMSI_r15(NG_5G_S_TMSI_r15),
    #[asn(key = 1, extended = true)]
    FullI_RNTI_r15(I_RNTI_r15),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct ParametersCDMA2000_r11 {
    #[asn(optional_idx = 0)]
    pub system_time_info_r11: Option<ParametersCDMA2000_r11SystemTimeInfo_r11>,
    pub search_window_size_r11: ParametersCDMA2000_r11SearchWindowSize_r11,
    #[asn(optional_idx = 1)]
    pub parameters_hrpd_r11: Option<ParametersCDMA2000_r11ParametersHRPD_r11>,
    #[asn(optional_idx = 2)]
    pub parameters1_xrtt_r11: Option<ParametersCDMA2000_r11Parameters1XRTT_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PerCC_GapIndication_r14 {
    pub serv_cell_id_r14: ServCellIndex_r13,
    pub gap_indication_r14: PerCC_GapIndication_r14GapIndication_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct PerCC_GapIndicationList_r14(pub Vec<PerCC_GapIndication_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct PeriodicBSR_Timer_r12(pub u8);
impl PeriodicBSR_Timer_r12 {
    pub const SF5: u8 = 0u8;
    pub const SF10: u8 = 1u8;
    pub const SF16: u8 = 2u8;
    pub const SF20: u8 = 3u8;
    pub const SF32: u8 = 4u8;
    pub const SF40: u8 = 5u8;
    pub const SF64: u8 = 6u8;
    pub const SF80: u8 = 7u8;
    pub const SF128: u8 = 8u8;
    pub const SF160: u8 = 9u8;
    pub const SF320: u8 = 10u8;
    pub const SF640: u8 = 11u8;
    pub const SF1280: u8 = 12u8;
    pub const SF2560: u8 = 13u8;
    pub const INFINITY: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "7", extensible = false)]
pub enum PeriodicityStartPos_r16 {
    #[asn(key = 0, extended = false)]
    Periodicity10ms(PeriodicityStartPos_r16_periodicity10ms),
    #[asn(key = 1, extended = false)]
    Periodicity20ms(PeriodicityStartPos_r16_periodicity20ms),
    #[asn(key = 2, extended = false)]
    Periodicity40ms(PeriodicityStartPos_r16_periodicity40ms),
    #[asn(key = 3, extended = false)]
    Periodicity80ms(PeriodicityStartPos_r16_periodicity80ms),
    #[asn(key = 4, extended = false)]
    Periodicity160ms(PeriodicityStartPos_r16_periodicity160ms),
    #[asn(key = 5, extended = false)]
    Spare3(PeriodicityStartPos_r16_spare3),
    #[asn(key = 6, extended = false)]
    Spare2(PeriodicityStartPos_r16_spare2),
    #[asn(key = 7, extended = false)]
    Spare1(PeriodicityStartPos_r16_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PhyLayerParameters {
    pub ue_tx_antenna_selection_supported: PhyLayerParametersUe_TxAntennaSelectionSupported,
    pub ue_specific_ref_sigs_supported: PhyLayerParametersUe_SpecificRefSigsSupported,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 7)]
pub struct PhyLayerParameters_v1020 {
    #[asn(optional_idx = 0)]
    pub two_antenna_ports_for_pucch_r10:
        Option<PhyLayerParameters_v1020TwoAntennaPortsForPUCCH_r10>,
    #[asn(optional_idx = 1)]
    pub tm9_with_8tx_fdd_r10: Option<PhyLayerParameters_v1020Tm9_With_8Tx_FDD_r10>,
    #[asn(optional_idx = 2)]
    pub pmi_disabling_r10: Option<PhyLayerParameters_v1020Pmi_Disabling_r10>,
    #[asn(optional_idx = 3)]
    pub cross_carrier_scheduling_r10: Option<PhyLayerParameters_v1020CrossCarrierScheduling_r10>,
    #[asn(optional_idx = 4)]
    pub simultaneous_pucch_pusch_r10: Option<PhyLayerParameters_v1020SimultaneousPUCCH_PUSCH_r10>,
    #[asn(optional_idx = 5)]
    pub multi_cluster_pusch_within_cc_r10:
        Option<PhyLayerParameters_v1020MultiClusterPUSCH_WithinCC_r10>,
    #[asn(optional_idx = 6)]
    pub non_contiguous_ul_ra_within_cc_list_r10: Option<NonContiguousUL_RA_WithinCC_List_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 7)]
pub struct PhyLayerParameters_v1130 {
    #[asn(optional_idx = 0)]
    pub crs_interf_handl_r11: Option<PhyLayerParameters_v1130Crs_InterfHandl_r11>,
    #[asn(optional_idx = 1)]
    pub epdcch_r11: Option<PhyLayerParameters_v1130EPDCCH_r11>,
    #[asn(optional_idx = 2)]
    pub multi_ack_csi_reporting_r11: Option<PhyLayerParameters_v1130MultiACK_CSI_Reporting_r11>,
    #[asn(optional_idx = 3)]
    pub ss_cch_interf_handl_r11: Option<PhyLayerParameters_v1130Ss_CCH_InterfHandl_r11>,
    #[asn(optional_idx = 4)]
    pub tdd_special_subframe_r11: Option<PhyLayerParameters_v1130Tdd_SpecialSubframe_r11>,
    #[asn(optional_idx = 5)]
    pub tx_div_pucch1b_ch_select_r11: Option<PhyLayerParameters_v1130TxDiv_PUCCH1b_ChSelect_r11>,
    #[asn(optional_idx = 6)]
    pub ul_co_mp_r11: Option<PhyLayerParameters_v1130Ul_CoMP_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PhyLayerParameters_v1170 {
    #[asn(optional_idx = 0)]
    pub inter_band_tdd_ca_with_different_config_r11:
        Option<PhyLayerParameters_v1170InterBandTDD_CA_WithDifferentConfig_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 11)]
pub struct PhyLayerParameters_v1250 {
    #[asn(optional_idx = 0)]
    pub e_harq_pattern_fdd_r12: Option<PhyLayerParameters_v1250E_HARQ_Pattern_FDD_r12>,
    #[asn(optional_idx = 1)]
    pub enhanced_4tx_codebook_r12: Option<PhyLayerParameters_v1250Enhanced_4TxCodebook_r12>,
    #[asn(optional_idx = 2)]
    pub tdd_fdd_ca_p_cell_duplex_r12: Option<PhyLayerParameters_v1250Tdd_FDD_CA_PCellDuplex_r12>,
    #[asn(optional_idx = 3)]
    pub phy_tdd_re_config_tdd_p_cell_r12:
        Option<PhyLayerParameters_v1250Phy_TDD_ReConfig_TDD_PCell_r12>,
    #[asn(optional_idx = 4)]
    pub phy_tdd_re_config_fdd_p_cell_r12:
        Option<PhyLayerParameters_v1250Phy_TDD_ReConfig_FDD_PCell_r12>,
    #[asn(optional_idx = 5)]
    pub pusch_feedback_mode_r12: Option<PhyLayerParameters_v1250Pusch_FeedbackMode_r12>,
    #[asn(optional_idx = 6)]
    pub pusch_srs_power_control_subframe_set_r12:
        Option<PhyLayerParameters_v1250Pusch_SRS_PowerControl_SubframeSet_r12>,
    #[asn(optional_idx = 7)]
    pub csi_subframe_set_r12: Option<PhyLayerParameters_v1250Csi_SubframeSet_r12>,
    #[asn(optional_idx = 8)]
    pub no_resource_restriction_for_tti_bundling_r12:
        Option<PhyLayerParameters_v1250NoResourceRestrictionForTTIBundling_r12>,
    #[asn(optional_idx = 9)]
    pub discovery_signals_in_deact_s_cell_r12:
        Option<PhyLayerParameters_v1250DiscoverySignalsInDeactSCell_r12>,
    #[asn(optional_idx = 10)]
    pub naics_capability_list_r12: Option<NAICS_Capability_List_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PhyLayerParameters_v1280 {
    #[asn(optional_idx = 0)]
    pub alternative_tbs_indices_r12: Option<PhyLayerParameters_v1280AlternativeTBS_Indices_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 13)]
pub struct PhyLayerParameters_v1310 {
    #[asn(optional_idx = 0)]
    pub aperiodic_csi_reporting_r13: Option<PhyLayerParameters_v1310AperiodicCSI_Reporting_r13>,
    #[asn(optional_idx = 1)]
    pub codebook_harq_ack_r13: Option<PhyLayerParameters_v1310Codebook_HARQ_ACK_r13>,
    #[asn(optional_idx = 2)]
    pub cross_carrier_scheduling_b5c_r13:
        Option<PhyLayerParameters_v1310CrossCarrierScheduling_B5C_r13>,
    #[asn(optional_idx = 3)]
    pub fdd_harq_timing_tdd_r13: Option<PhyLayerParameters_v1310Fdd_HARQ_TimingTDD_r13>,
    #[asn(optional_idx = 4)]
    pub max_number_updated_csi_proc_r13:
        Option<PhyLayerParameters_v1310MaxNumberUpdatedCSI_Proc_r13>,
    #[asn(optional_idx = 5)]
    pub pucch_format4_r13: Option<PhyLayerParameters_v1310Pucch_Format4_r13>,
    #[asn(optional_idx = 6)]
    pub pucch_format5_r13: Option<PhyLayerParameters_v1310Pucch_Format5_r13>,
    #[asn(optional_idx = 7)]
    pub pucch_s_cell_r13: Option<PhyLayerParameters_v1310Pucch_SCell_r13>,
    #[asn(optional_idx = 8)]
    pub spatial_bundling_harq_ack_r13: Option<PhyLayerParameters_v1310SpatialBundling_HARQ_ACK_r13>,
    #[asn(optional_idx = 9)]
    pub supported_blind_decoding_r13: Option<PhyLayerParameters_v1310SupportedBlindDecoding_r13>,
    #[asn(optional_idx = 10)]
    pub uci_pusch_ext_r13: Option<PhyLayerParameters_v1310Uci_PUSCH_Ext_r13>,
    #[asn(optional_idx = 11)]
    pub crs_interf_mitigation_tm10_r13:
        Option<PhyLayerParameters_v1310Crs_InterfMitigationTM10_r13>,
    #[asn(optional_idx = 12)]
    pub pdsch_collision_handling_r13: Option<PhyLayerParameters_v1310Pdsch_CollisionHandling_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PhyLayerParameters_v1320 {
    #[asn(optional_idx = 0)]
    pub mimo_ue_parameters_r13: Option<MIMO_UE_Parameters_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct PhyLayerParameters_v1330 {
    #[asn(optional_idx = 0)]
    pub cch_interf_mitigation_ref_rec_type_a_r13:
        Option<PhyLayerParameters_v1330Cch_InterfMitigation_RefRecTypeA_r13>,
    #[asn(optional_idx = 1)]
    pub cch_interf_mitigation_ref_rec_type_b_r13:
        Option<PhyLayerParameters_v1330Cch_InterfMitigation_RefRecTypeB_r13>,
    #[asn(optional_idx = 2)]
    pub cch_interf_mitigation_max_num_c_cs_r13:
        Option<PhyLayerParameters_v1330Cch_InterfMitigation_MaxNumCCs_r13>,
    #[asn(optional_idx = 3)]
    pub crs_interf_mitigation_tm1to_tm9_r13:
        Option<PhyLayerParameters_v1330Crs_InterfMitigationTM1toTM9_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PhyLayerParameters_v13e0 {
    pub mimo_ue_parameters_v13e0: MIMO_UE_Parameters_v13e0,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 16)]
pub struct PhyLayerParameters_v1430 {
    #[asn(optional_idx = 0)]
    pub ce_pusch_nb_max_tbs_r14: Option<PhyLayerParameters_v1430Ce_PUSCH_NB_MaxTBS_r14>,
    #[asn(optional_idx = 1)]
    pub ce_pdsch_pusch_max_bandwidth_r14:
        Option<PhyLayerParameters_v1430Ce_PDSCH_PUSCH_MaxBandwidth_r14>,
    #[asn(optional_idx = 2)]
    pub ce_harq_ack_bundling_r14: Option<PhyLayerParameters_v1430Ce_HARQ_AckBundling_r14>,
    #[asn(optional_idx = 3)]
    pub ce_pdsch_ten_processes_r14: Option<PhyLayerParameters_v1430Ce_PDSCH_TenProcesses_r14>,
    #[asn(optional_idx = 4)]
    pub ce_retuning_symbols_r14: Option<PhyLayerParameters_v1430Ce_RetuningSymbols_r14>,
    #[asn(optional_idx = 5)]
    pub ce_pdsch_pusch_enhancement_r14:
        Option<PhyLayerParameters_v1430Ce_PDSCH_PUSCH_Enhancement_r14>,
    #[asn(optional_idx = 6)]
    pub ce_scheduling_enhancement_r14: Option<PhyLayerParameters_v1430Ce_SchedulingEnhancement_r14>,
    #[asn(optional_idx = 7)]
    pub ce_srs_enhancement_r14: Option<PhyLayerParameters_v1430Ce_SRS_Enhancement_r14>,
    #[asn(optional_idx = 8)]
    pub ce_pucch_enhancement_r14: Option<PhyLayerParameters_v1430Ce_PUCCH_Enhancement_r14>,
    #[asn(optional_idx = 9)]
    pub ce_closed_loop_tx_antenna_selection_r14:
        Option<PhyLayerParameters_v1430Ce_ClosedLoopTxAntennaSelection_r14>,
    #[asn(optional_idx = 10)]
    pub tdd_special_subframe_r14: Option<PhyLayerParameters_v1430Tdd_SpecialSubframe_r14>,
    #[asn(optional_idx = 11)]
    pub tdd_tti_bundling_r14: Option<PhyLayerParameters_v1430Tdd_TTI_Bundling_r14>,
    #[asn(optional_idx = 12)]
    pub dmrs_less_up_pts_r14: Option<PhyLayerParameters_v1430Dmrs_LessUpPTS_r14>,
    #[asn(optional_idx = 13)]
    pub mimo_ue_parameters_v1430: Option<MIMO_UE_Parameters_v1430>,
    #[asn(optional_idx = 14)]
    pub alternative_tbs_index_r14: Option<PhyLayerParameters_v1430AlternativeTBS_Index_r14>,
    #[asn(optional_idx = 15)]
    pub fe_mbms_unicast_parameters_r14: Option<FeMBMS_Unicast_Parameters_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct PhyLayerParameters_v1450 {
    #[asn(optional_idx = 0)]
    pub ce_srs_enhancement_without_comb4_r14:
        Option<PhyLayerParameters_v1450Ce_SRS_EnhancementWithoutComb4_r14>,
    #[asn(optional_idx = 1)]
    pub crs_less_dw_pts_r14: Option<PhyLayerParameters_v1450Crs_LessDwPTS_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct PhyLayerParameters_v1470 {
    #[asn(optional_idx = 0)]
    pub mimo_ue_parameters_v1470: Option<MIMO_UE_Parameters_v1470>,
    #[asn(optional_idx = 1)]
    pub srs_up_pts_6sym_r14: Option<PhyLayerParameters_v1470Srs_UpPTS_6sym_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PhyLayerParameters_v14a0 {
    #[asn(optional_idx = 0)]
    pub ssp10_tdd_only_r14: Option<PhyLayerParameters_v14a0Ssp10_TDD_Only_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 8)]
pub struct PhyLayerParameters_v1530 {
    #[asn(optional_idx = 0)]
    pub stti_spt_capabilities_r15: Option<PhyLayerParameters_v1530Stti_SPT_Capabilities_r15>,
    #[asn(optional_idx = 1)]
    pub ce_capabilities_r15: Option<PhyLayerParameters_v1530Ce_Capabilities_r15>,
    #[asn(optional_idx = 2)]
    pub short_cqi_for_s_cell_activation_r15:
        Option<PhyLayerParameters_v1530ShortCQI_ForSCellActivation_r15>,
    #[asn(optional_idx = 3)]
    pub mimo_cbsr_advanced_csi_r15: Option<PhyLayerParameters_v1530Mimo_CBSR_AdvancedCSI_r15>,
    #[asn(optional_idx = 4)]
    pub crs_intf_mitig_r15: Option<PhyLayerParameters_v1530Crs_IntfMitig_r15>,
    #[asn(optional_idx = 5)]
    pub ul_power_control_enhancements_r15:
        Option<PhyLayerParameters_v1530Ul_PowerControlEnhancements_r15>,
    #[asn(optional_idx = 6)]
    pub urllc_capabilities_r15: Option<PhyLayerParameters_v1530Urllc_Capabilities_r15>,
    #[asn(optional_idx = 7)]
    pub alt_mcs_table_r15: Option<PhyLayerParameters_v1530AltMCS_Table_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct PhyLayerParameters_v1540 {
    #[asn(optional_idx = 0)]
    pub stti_spt_capabilities_v1540: Option<PhyLayerParameters_v1540Stti_SPT_Capabilities_v1540>,
    #[asn(optional_idx = 1)]
    pub crs_im_tm1_to_tm9_one_rx_port_v1540:
        Option<PhyLayerParameters_v1540Crs_IM_TM1_toTM9_OneRX_Port_v1540>,
    #[asn(optional_idx = 2)]
    pub cch_im_ref_rec_type_a_one_rx_port_v1540:
        Option<PhyLayerParameters_v1540Cch_IM_RefRecTypeA_OneRX_Port_v1540>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PhyLayerParameters_v1550 {
    #[asn(optional_idx = 0)]
    pub dmrs_overhead_reduction_r15: Option<PhyLayerParameters_v1550Dmrs_OverheadReduction_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 7)]
pub struct PhyLayerParameters_v1610 {
    #[asn(optional_idx = 0)]
    pub ce_capabilities_v1610: Option<PhyLayerParameters_v1610Ce_Capabilities_v1610>,
    #[asn(optional_idx = 1)]
    pub wideband_prg_slot_r16: Option<PhyLayerParameters_v1610WidebandPRG_Slot_r16>,
    #[asn(optional_idx = 2)]
    pub wideband_prg_subslot_r16: Option<PhyLayerParameters_v1610WidebandPRG_Subslot_r16>,
    #[asn(optional_idx = 3)]
    pub wideband_prg_subframe_r16: Option<PhyLayerParameters_v1610WidebandPRG_Subframe_r16>,
    #[asn(optional_idx = 4)]
    pub add_srs_r16: Option<PhyLayerParameters_v1610AddSRS_r16>,
    #[asn(optional_idx = 5)]
    pub virtual_cell_id_basic_srs_r16: Option<PhyLayerParameters_v1610VirtualCellID_BasicSRS_r16>,
    #[asn(optional_idx = 6)]
    pub virtual_cell_id_add_srs_r16: Option<PhyLayerParameters_v1610VirtualCellID_AddSRS_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PhyLayerParameters_v1700 {
    #[asn(optional_idx = 0)]
    pub ce_capabilities_v1700: Option<PhyLayerParameters_v1700Ce_Capabilities_v1700>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PhyLayerParameters_v1730 {
    #[asn(optional_idx = 0)]
    pub csi_subframe_set2_for_dormant_s_cell_r17:
        Option<PhyLayerParameters_v1730Csi_SubframeSet2ForDormantSCell_r17>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct PhyLayerParameters_v920 {
    #[asn(optional_idx = 0)]
    pub enhanced_dual_layer_fdd_r9: Option<PhyLayerParameters_v920EnhancedDualLayerFDD_r9>,
    #[asn(optional_idx = 1)]
    pub enhanced_dual_layer_tdd_r9: Option<PhyLayerParameters_v920EnhancedDualLayerTDD_r9>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct PhyLayerParameters_v9d0 {
    #[asn(optional_idx = 0)]
    pub tm5_fdd_r9: Option<PhyLayerParameters_v9d0Tm5_FDD_r9>,
    #[asn(optional_idx = 1)]
    pub tm5_tdd_r9: Option<PhyLayerParameters_v9d0Tm5_TDD_r9>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "503")]
pub struct PhysCellId(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "511")]
pub struct PhysCellIdCDMA2000(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PhysCellIdGERAN {
    pub network_colour_code: PhysCellIdGERANNetworkColourCode,
    pub base_station_colour_code: PhysCellIdGERANBaseStationColourCode,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct PhysCellIdList_r13(pub Vec<PhysCellId>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct PhysCellIdListCDMA2000(pub Vec<PhysCellIdCDMA2000>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "0", sz_ub = "24")]
pub struct PhysCellIdListCDMA2000_v920(pub Vec<PhysCellIdCDMA2000>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1007")]
pub struct PhysCellIdNR_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PhysCellIdRange {
    pub start: PhysCellId,
    #[asn(optional_idx = 0)]
    pub range: Option<PhysCellIdRangeRange>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PhysCellIdRangeNR_r16 {
    pub start: PhysCellIdNR_r15,
    #[asn(optional_idx = 0)]
    pub range: Option<PhysCellIdRangeNR_r16Range>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PhysCellIdRangeUTRA_FDD_r9 {
    pub start_r9: PhysCellIdUTRA_FDD,
    #[asn(optional_idx = 0)]
    pub range_r9: Option<PhysCellIdRangeUTRA_FDD_r9Range_r9>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct PhysCellIdRangeUTRA_FDDList_r9(pub Vec<PhysCellIdRangeUTRA_FDD_r9>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "511")]
pub struct PhysCellIdUTRA_FDD(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "127")]
pub struct PhysCellIdUTRA_TDD(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 10)]
pub struct PhysicalConfigDedicated {
    #[asn(optional_idx = 0)]
    pub pdsch_config_dedicated: Option<PDSCH_ConfigDedicated>,
    #[asn(optional_idx = 1)]
    pub pucch_config_dedicated: Option<PUCCH_ConfigDedicated>,
    #[asn(optional_idx = 2)]
    pub pusch_config_dedicated: Option<PUSCH_ConfigDedicated>,
    #[asn(optional_idx = 3)]
    pub uplink_power_control_dedicated: Option<UplinkPowerControlDedicated>,
    #[asn(optional_idx = 4)]
    pub tpc_pdcch_config_pucch: Option<TPC_PDCCH_Config>,
    #[asn(optional_idx = 5)]
    pub tpc_pdcch_config_pusch: Option<TPC_PDCCH_Config>,
    #[asn(optional_idx = 6)]
    pub cqi_report_config: Option<CQI_ReportConfig>,
    #[asn(optional_idx = 7)]
    pub sounding_rs_ul_config_dedicated: Option<SoundingRS_UL_ConfigDedicated>,
    #[asn(optional_idx = 8)]
    pub antenna_info: Option<PhysicalConfigDedicatedAntennaInfo>,
    #[asn(optional_idx = 9)]
    pub scheduling_request_config: Option<SchedulingRequestConfig>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PhysicalConfigDedicated_v1370 {
    #[asn(optional_idx = 0)]
    pub pucch_config_dedicated_v1370: Option<PUCCH_ConfigDedicated_v1370>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PhysicalConfigDedicated_v13c0 {
    pub pucch_config_dedicated_v13c0: PUCCH_ConfigDedicated_v13c0,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PhysicalConfigDedicatedSCell_r10 {
    #[asn(optional_idx = 0)]
    pub non_ul_configuration_r10: Option<PhysicalConfigDedicatedSCell_r10NonUL_Configuration_r10>,
    #[asn(optional_idx = 1)]
    pub ul_configuration_r10: Option<PhysicalConfigDedicatedSCell_r10Ul_Configuration_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PhysicalConfigDedicatedSCell_v1370 {
    pub pucch_s_cell_v1370: PhysicalConfigDedicatedSCell_v1370Pucch_SCell_v1370,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PhysicalConfigDedicatedSCell_v13c0 {
    pub pucch_s_cell_v13c0: PhysicalConfigDedicatedSCell_v13c0Pucch_SCell_v13c0,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PhysicalConfigDedicatedSCell_v1730 {
    pub cqi_report_periodic_s_cell_v1730:
        PhysicalConfigDedicatedSCell_v1730Cqi_ReportPeriodicSCell_v1730,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PhysicalConfigDedicatedSTTI_r15 {
    #[asn(key = 0, extended = false)]
    Release(PhysicalConfigDedicatedSTTI_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(PhysicalConfigDedicatedSTTI_r15_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct PollByte(pub u8);
impl PollByte {
    pub const K_B25: u8 = 0u8;
    pub const K_B50: u8 = 1u8;
    pub const K_B75: u8 = 2u8;
    pub const K_B100: u8 = 3u8;
    pub const K_B125: u8 = 4u8;
    pub const K_B250: u8 = 5u8;
    pub const K_B375: u8 = 6u8;
    pub const K_B500: u8 = 7u8;
    pub const K_B750: u8 = 8u8;
    pub const K_B1000: u8 = 9u8;
    pub const K_B1250: u8 = 10u8;
    pub const K_B1500: u8 = 11u8;
    pub const K_B2000: u8 = 12u8;
    pub const K_B3000: u8 = 13u8;
    pub const K_BINFINITY: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "31")]
pub struct PollByte_r14(pub u8);
impl PollByte_r14 {
    pub const K_B1: u8 = 0u8;
    pub const K_B2: u8 = 1u8;
    pub const K_B5: u8 = 2u8;
    pub const K_B8: u8 = 3u8;
    pub const K_B10: u8 = 4u8;
    pub const K_B15: u8 = 5u8;
    pub const K_B3500: u8 = 6u8;
    pub const K_B4000: u8 = 7u8;
    pub const K_B4500: u8 = 8u8;
    pub const K_B5000: u8 = 9u8;
    pub const K_B5500: u8 = 10u8;
    pub const K_B6000: u8 = 11u8;
    pub const K_B6500: u8 = 12u8;
    pub const K_B7000: u8 = 13u8;
    pub const K_B7500: u8 = 14u8;
    pub const K_B8000: u8 = 15u8;
    pub const K_B9000: u8 = 16u8;
    pub const K_B10000: u8 = 17u8;
    pub const K_B11000: u8 = 18u8;
    pub const K_B12000: u8 = 19u8;
    pub const K_B13000: u8 = 20u8;
    pub const K_B14000: u8 = 21u8;
    pub const K_B15000: u8 = 22u8;
    pub const K_B16000: u8 = 23u8;
    pub const K_B17000: u8 = 24u8;
    pub const K_B18000: u8 = 25u8;
    pub const K_B19000: u8 = 26u8;
    pub const K_B20000: u8 = 27u8;
    pub const K_B25000: u8 = 28u8;
    pub const K_B30000: u8 = 29u8;
    pub const K_B35000: u8 = 30u8;
    pub const K_B40000: u8 = 31u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct PollPDU(pub u8);
impl PollPDU {
    pub const P4: u8 = 0u8;
    pub const P8: u8 = 1u8;
    pub const P16: u8 = 2u8;
    pub const P32: u8 = 3u8;
    pub const P64: u8 = 4u8;
    pub const P128: u8 = 5u8;
    pub const P256: u8 = 6u8;
    pub const P_INFINITY: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct PollPDU_r15(pub u8);
impl PollPDU_r15 {
    pub const P4: u8 = 0u8;
    pub const P8: u8 = 1u8;
    pub const P16: u8 = 2u8;
    pub const P32: u8 = 3u8;
    pub const P64: u8 = 4u8;
    pub const P128: u8 = 5u8;
    pub const P256: u8 = 6u8;
    pub const P512: u8 = 7u8;
    pub const P1024: u8 = 8u8;
    pub const P2048_R15: u8 = 9u8;
    pub const P4096_R15: u8 = 10u8;
    pub const P6144_R15: u8 = 11u8;
    pub const P8192_R15: u8 = 12u8;
    pub const P12288_R15: u8 = 13u8;
    pub const P16384_R15: u8 = 14u8;
    pub const P_INFINITY: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct PollPDU_v1310(pub u8);
impl PollPDU_v1310 {
    pub const P512: u8 = 0u8;
    pub const P1024: u8 = 1u8;
    pub const P2048: u8 = 2u8;
    pub const P4096: u8 = 3u8;
    pub const P6144: u8 = 4u8;
    pub const P8192: u8 = 5u8;
    pub const P12288: u8 = 6u8;
    pub const P16384: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct PosSIB_MappingInfo_r15(pub Vec<PosSIB_Type_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct PosSIB_Type_r15 {
    #[asn(optional_idx = 0)]
    pub encrypted_r15: Option<PosSIB_Type_r15Encrypted_r15>,
    #[asn(optional_idx = 1)]
    pub gnss_id_r15: Option<GNSS_ID_r15>,
    #[asn(optional_idx = 2)]
    pub sbas_id_r15: Option<SBAS_ID_r15>,
    pub pos_sib_type_r15: PosSIB_Type_r15PosSibType_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PosSchedulingInfo_r15 {
    pub pos_si_periodicity_r15: PosSchedulingInfo_r15PosSI_Periodicity_r15,
    pub pos_sib_mapping_info_r15: PosSIB_MappingInfo_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct PosSchedulingInfoList_r15(pub Vec<PosSchedulingInfo_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct PosSystemInformation_r15_IEs {
    pub pos_sib_type_and_info_r15: PosSystemInformation_r15_IEsPosSIB_TypeAndInfo_r15,
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<PosSystemInformation_r15_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<PosSystemInformation_r15_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-33554432", ub = "33554431")]
pub struct PositionStateVector_r17(pub i32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PowerCoordinationInfo_r12 {
    pub p_me_nb_r12: PowerCoordinationInfo_r12P_MeNB_r12,
    pub p_se_nb_r12: PowerCoordinationInfo_r12P_SeNB_r12,
    pub power_control_mode_r12: PowerCoordinationInfo_r12PowerControlMode_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PowerPrefIndicationConfig_r11 {
    #[asn(key = 0, extended = false)]
    Release(PowerPrefIndicationConfig_r11_release),
    #[asn(key = 1, extended = false)]
    Setup(PowerPrefIndicationConfig_r11_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PowerRampingParameters {
    pub power_ramping_step: PowerRampingParametersPowerRampingStep,
    pub preamble_initial_received_target_power:
        PowerRampingParametersPreambleInitialReceivedTargetPower,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct PreRegistrationInfoHRPD {
    pub pre_registration_allowed: PreRegistrationInfoHRPDPreRegistrationAllowed,
    #[asn(optional_idx = 0)]
    pub pre_registration_zone_id: Option<PreRegistrationZoneIdHRPD>,
    #[asn(optional_idx = 1)]
    pub secondary_pre_registration_zone_id_list: Option<SecondaryPreRegistrationZoneIdListHRPD>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct PreRegistrationZoneIdHRPD(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "10")]
pub struct PreambleTransMax(pub u8);
impl PreambleTransMax {
    pub const N3: u8 = 0u8;
    pub const N4: u8 = 1u8;
    pub const N5: u8 = 2u8;
    pub const N6: u8 = 3u8;
    pub const N7: u8 = 4u8;
    pub const N8: u8 = 5u8;
    pub const N10: u8 = 6u8;
    pub const N20: u8 = 7u8;
    pub const N50: u8 = 8u8;
    pub const N100: u8 = 9u8;
    pub const N200: u8 = 10u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PresenceAntennaPort1(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct ProcessingTimelineSet_r15(pub u8);
impl ProcessingTimelineSet_r15 {
    pub const SET1: u8 = 0u8;
    pub const SET2: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ProximityIndication_r9 {
    pub critical_extensions: ProximityIndication_r9CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct ProximityIndication_r9_IEs {
    pub type_r9: ProximityIndication_r9_IEsType_r9,
    pub carrier_freq_r9: ProximityIndication_r9_IEsCarrierFreq_r9,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<ProximityIndication_v930_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct ProximityIndication_v930_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<ProximityIndication_v930_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<ProximityIndication_v930_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "30")]
pub struct Q_OffsetRange(pub u8);
impl Q_OffsetRange {
    pub const D_B_24: u8 = 0u8;
    pub const D_B_22: u8 = 1u8;
    pub const D_B_20: u8 = 2u8;
    pub const D_B_18: u8 = 3u8;
    pub const D_B_16: u8 = 4u8;
    pub const D_B_14: u8 = 5u8;
    pub const D_B_12: u8 = 6u8;
    pub const D_B_10: u8 = 7u8;
    pub const D_B_8: u8 = 8u8;
    pub const D_B_6: u8 = 9u8;
    pub const D_B_5: u8 = 10u8;
    pub const D_B_4: u8 = 11u8;
    pub const D_B_3: u8 = 12u8;
    pub const D_B_2: u8 = 13u8;
    pub const D_B_1: u8 = 14u8;
    pub const D_B0: u8 = 15u8;
    pub const D_B1: u8 = 16u8;
    pub const D_B2: u8 = 17u8;
    pub const D_B3: u8 = 18u8;
    pub const D_B4: u8 = 19u8;
    pub const D_B5: u8 = 20u8;
    pub const D_B6: u8 = 21u8;
    pub const D_B8: u8 = 22u8;
    pub const D_B10: u8 = 23u8;
    pub const D_B12: u8 = 24u8;
    pub const D_B14: u8 = 25u8;
    pub const D_B16: u8 = 26u8;
    pub const D_B18: u8 = 27u8;
    pub const D_B20: u8 = 28u8;
    pub const D_B22: u8 = 29u8;
    pub const D_B24: u8 = 30u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-15", ub = "15")]
pub struct Q_OffsetRangeInterRAT(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-34", ub = "-3")]
pub struct Q_QualMin_r9(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-70", ub = "-22")]
pub struct Q_RxLevMin(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct QuantityConfig {
    #[asn(optional_idx = 0)]
    pub quantity_config_eutra: Option<QuantityConfigEUTRA>,
    #[asn(optional_idx = 1)]
    pub quantity_config_utra: Option<QuantityConfigUTRA>,
    #[asn(optional_idx = 2)]
    pub quantity_config_geran: Option<QuantityConfigGERAN>,
    #[asn(optional_idx = 3)]
    pub quantity_config_cdma2000: Option<QuantityConfigCDMA2000>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QuantityConfigCDMA2000 {
    pub meas_quantity_cdma2000: QuantityConfigCDMA2000MeasQuantityCDMA2000,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct QuantityConfigEUTRA {
    #[asn(optional_idx = 0)]
    pub filter_coefficient_rsrp: Option<FilterCoefficient>,
    #[asn(optional_idx = 1)]
    pub filter_coefficient_rsrq: Option<FilterCoefficient>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct QuantityConfigEUTRA_v1250 {
    #[asn(optional_idx = 0)]
    pub filter_coefficient_csi_rsrp_r12: Option<FilterCoefficient>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct QuantityConfigEUTRA_v1310 {
    #[asn(optional_idx = 0)]
    pub filter_coefficient_rs_sinr_r13: Option<FilterCoefficient>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct QuantityConfigGERAN {
    pub meas_quantity_geran: QuantityConfigGERANMeasQuantityGERAN,
    #[asn(optional_idx = 0)]
    pub filter_coefficient: Option<FilterCoefficient>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct QuantityConfigNR_r15 {
    pub meas_quantity_cell_nr_r15: QuantityConfigRS_NR_r15,
    #[asn(optional_idx = 0)]
    pub meas_quantity_rs_index_nr_r15: Option<QuantityConfigRS_NR_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct QuantityConfigNRList_r15(pub Vec<QuantityConfigNR_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct QuantityConfigRS_NR_r15 {
    #[asn(optional_idx = 0)]
    pub filter_coeff_rsrp_r15: Option<FilterCoefficient>,
    #[asn(optional_idx = 1)]
    pub filter_coeff_rsrq_r15: Option<FilterCoefficient>,
    #[asn(optional_idx = 2)]
    pub filter_coefficient_sinr_r13: Option<FilterCoefficient>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct QuantityConfigUTRA {
    pub meas_quantity_utra_fdd: QuantityConfigUTRAMeasQuantityUTRA_FDD,
    pub meas_quantity_utra_tdd: QuantityConfigUTRAMeasQuantityUTRA_TDD,
    #[asn(optional_idx = 0)]
    pub filter_coefficient: Option<FilterCoefficient>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct QuantityConfigUTRA_v1020 {
    #[asn(optional_idx = 0)]
    pub filter_coefficient2_fdd_r10: Option<FilterCoefficient>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct QuantityConfigWLAN_r13 {
    pub meas_quantity_wlan_r13: QuantityConfigWLAN_r13MeasQuantityWLAN_r13,
    #[asn(optional_idx = 0)]
    pub filter_coefficient_r13: Option<FilterCoefficient>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RACH_CE_LevelInfo_r13 {
    pub preamble_mapping_info_r13: RACH_CE_LevelInfo_r13PreambleMappingInfo_r13,
    pub ra_response_window_size_r13: RACH_CE_LevelInfo_r13Ra_ResponseWindowSize_r13,
    pub mac_contention_resolution_timer_r13: RACH_CE_LevelInfo_r13Mac_ContentionResolutionTimer_r13,
    pub rar_hopping_config_r13: RACH_CE_LevelInfo_r13Rar_HoppingConfig_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct RACH_CE_LevelInfoList_r13(pub Vec<RACH_CE_LevelInfo_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RACH_ConfigCommon {
    pub preamble_info: RACH_ConfigCommonPreambleInfo,
    pub power_ramping_parameters: PowerRampingParameters,
    pub ra_supervision_info: RACH_ConfigCommonRa_SupervisionInfo,
    pub max_harq_msg3_tx: RACH_ConfigCommonMaxHARQ_Msg3Tx,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RACH_ConfigCommon_v1250 {
    pub tx_fail_params_r12: RACH_ConfigCommon_v1250TxFailParams_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RACH_ConfigCommonSCell_r11 {
    pub power_ramping_parameters_r11: PowerRampingParameters,
    pub ra_supervision_info_r11: RACH_ConfigCommonSCell_r11Ra_SupervisionInfo_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RACH_ConfigDedicated {
    pub ra_preamble_index: RACH_ConfigDedicatedRa_PreambleIndex,
    pub ra_prach_mask_index: RACH_ConfigDedicatedRa_PRACH_MaskIndex,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RACH_Report_r16 {
    pub number_of_preambles_sent_r16: NumberOfPreamblesSent_r11,
    pub contention_detected_r16: RACH_Report_r16ContentionDetected_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RACH_Report_v1610 {
    pub initial_cel_r16: RACH_Report_v1610InitialCEL_r16,
    pub edt_fallback_r16: RACH_Report_v1610Edt_Fallback_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RACH_Skip_r14 {
    pub target_ta_r14: RACH_Skip_r14TargetTA_r14,
    #[asn(optional_idx = 0)]
    pub ul_config_info_r14: Option<RACH_Skip_r14Ul_ConfigInfo_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct RAN_AreaCode_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RAN_AreaConfig_r15 {
    pub tracking_area_code_5gc_r15: TrackingAreaCode_5GC_r15,
    #[asn(optional_idx = 0)]
    pub ran_area_code_list_r15: Option<RAN_AreaConfig_r15Ran_AreaCodeList_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RAN_NotificationAreaInfo_r15 {
    #[asn(key = 0, extended = false)]
    CellList(PLMN_RAN_AreaCellList_r15),
    #[asn(key = 1, extended = false)]
    Ran_AreaConfigList(PLMN_RAN_AreaConfigList_r15),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct RAND_CDMA2000(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "7")]
pub struct RAT_Type(pub u8);
impl RAT_Type {
    pub const EUTRA: u8 = 0u8;
    pub const UTRA: u8 = 1u8;
    pub const GERAN_CS: u8 = 2u8;
    pub const GERAN_PS: u8 = 3u8;
    pub const CDMA2000_1XRTT: u8 = 4u8;
    pub const NR: u8 = 5u8;
    pub const EUTRA_NR: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RCLWI_Config_r13 {
    pub command: RCLWI_Config_r13Command,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RCLWI_Configuration_r13 {
    #[asn(key = 0, extended = false)]
    Release(RCLWI_Configuration_r13_release),
    #[asn(key = 1, extended = false)]
    Setup(RCLWI_Configuration_r13_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct RE_MappingQCLConfigToAddModList_r11(pub Vec<PDSCH_RE_MappingQCL_Config_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct RE_MappingQCLConfigToReleaseList_r11(pub Vec<PDSCH_RE_MappingQCL_ConfigId_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RF_Parameters {
    pub supported_band_list_eutra: SupportedBandListEUTRA,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RF_Parameters_v1020 {
    pub supported_band_combination_r10: SupportedBandCombination_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RF_Parameters_v1060 {
    pub supported_band_combination_ext_r10: SupportedBandCombinationExt_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RF_Parameters_v1090 {
    #[asn(optional_idx = 0)]
    pub supported_band_combination_v1090: Option<SupportedBandCombination_v1090>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RF_Parameters_v10f0 {
    #[asn(optional_idx = 0)]
    pub modified_mpr_behavior_r10: Option<RF_Parameters_v10f0ModifiedMPR_Behavior_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RF_Parameters_v10i0 {
    #[asn(optional_idx = 0)]
    pub supported_band_combination_v10i0: Option<SupportedBandCombination_v10i0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RF_Parameters_v10j0 {
    #[asn(optional_idx = 0)]
    pub multi_ns_pmax_r10: Option<RF_Parameters_v10j0MultiNS_Pmax_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RF_Parameters_v1130 {
    #[asn(optional_idx = 0)]
    pub supported_band_combination_v1130: Option<SupportedBandCombination_v1130>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct RF_Parameters_v1180 {
    #[asn(optional_idx = 0)]
    pub freq_band_retrieval_r11: Option<RF_Parameters_v1180FreqBandRetrieval_r11>,
    #[asn(optional_idx = 1)]
    pub requested_bands_r11: Option<RF_Parameters_v1180RequestedBands_r11>,
    #[asn(optional_idx = 2)]
    pub supported_band_combination_add_r11: Option<SupportedBandCombinationAdd_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RF_Parameters_v11d0 {
    #[asn(optional_idx = 0)]
    pub supported_band_combination_add_v11d0: Option<SupportedBandCombinationAdd_v11d0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct RF_Parameters_v1250 {
    #[asn(optional_idx = 0)]
    pub supported_band_list_eutra_v1250: Option<SupportedBandListEUTRA_v1250>,
    #[asn(optional_idx = 1)]
    pub supported_band_combination_v1250: Option<SupportedBandCombination_v1250>,
    #[asn(optional_idx = 2)]
    pub supported_band_combination_add_v1250: Option<SupportedBandCombinationAdd_v1250>,
    #[asn(optional_idx = 3)]
    pub freq_band_priority_adjustment_r12:
        Option<RF_Parameters_v1250FreqBandPriorityAdjustment_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RF_Parameters_v1270 {
    #[asn(optional_idx = 0)]
    pub supported_band_combination_v1270: Option<SupportedBandCombination_v1270>,
    #[asn(optional_idx = 1)]
    pub supported_band_combination_add_v1270: Option<SupportedBandCombinationAdd_v1270>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RF_Parameters_v12b0 {
    #[asn(optional_idx = 0)]
    pub max_layers_mimo_indication_r12: Option<RF_Parameters_v12b0MaxLayersMIMO_Indication_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct RF_Parameters_v1310 {
    #[asn(optional_idx = 0)]
    pub enb_requested_parameters_r13: Option<RF_Parameters_v1310ENB_RequestedParameters_r13>,
    #[asn(optional_idx = 1)]
    pub maximum_c_cs_retrieval_r13: Option<RF_Parameters_v1310MaximumCCsRetrieval_r13>,
    #[asn(optional_idx = 2)]
    pub skip_fallback_combinations_r13: Option<RF_Parameters_v1310SkipFallbackCombinations_r13>,
    #[asn(optional_idx = 3)]
    pub reduced_int_non_cont_comb_r13: Option<RF_Parameters_v1310ReducedIntNonContComb_r13>,
    #[asn(optional_idx = 4)]
    pub supported_band_list_eutra_v1310: Option<SupportedBandListEUTRA_v1310>,
    #[asn(optional_idx = 5)]
    pub supported_band_combination_reduced_r13: Option<SupportedBandCombinationReduced_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct RF_Parameters_v1320 {
    #[asn(optional_idx = 0)]
    pub supported_band_list_eutra_v1320: Option<SupportedBandListEUTRA_v1320>,
    #[asn(optional_idx = 1)]
    pub supported_band_combination_v1320: Option<SupportedBandCombination_v1320>,
    #[asn(optional_idx = 2)]
    pub supported_band_combination_add_v1320: Option<SupportedBandCombinationAdd_v1320>,
    #[asn(optional_idx = 3)]
    pub supported_band_combination_reduced_v1320: Option<SupportedBandCombinationReduced_v1320>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct RF_Parameters_v1380 {
    #[asn(optional_idx = 0)]
    pub supported_band_combination_v1380: Option<SupportedBandCombination_v1380>,
    #[asn(optional_idx = 1)]
    pub supported_band_combination_add_v1380: Option<SupportedBandCombinationAdd_v1380>,
    #[asn(optional_idx = 2)]
    pub supported_band_combination_reduced_v1380: Option<SupportedBandCombinationReduced_v1380>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct RF_Parameters_v1390 {
    #[asn(optional_idx = 0)]
    pub supported_band_combination_v1390: Option<SupportedBandCombination_v1390>,
    #[asn(optional_idx = 1)]
    pub supported_band_combination_add_v1390: Option<SupportedBandCombinationAdd_v1390>,
    #[asn(optional_idx = 2)]
    pub supported_band_combination_reduced_v1390: Option<SupportedBandCombinationReduced_v1390>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct RF_Parameters_v1430 {
    #[asn(optional_idx = 0)]
    pub supported_band_combination_v1430: Option<SupportedBandCombination_v1430>,
    #[asn(optional_idx = 1)]
    pub supported_band_combination_add_v1430: Option<SupportedBandCombinationAdd_v1430>,
    #[asn(optional_idx = 2)]
    pub supported_band_combination_reduced_v1430: Option<SupportedBandCombinationReduced_v1430>,
    #[asn(optional_idx = 3)]
    pub enb_requested_parameters_v1430: Option<RF_Parameters_v1430ENB_RequestedParameters_v1430>,
    #[asn(optional_idx = 4)]
    pub diff_fallback_comb_report_r14: Option<RF_Parameters_v1430DiffFallbackCombReport_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct RF_Parameters_v1450 {
    #[asn(optional_idx = 0)]
    pub supported_band_combination_v1450: Option<SupportedBandCombination_v1450>,
    #[asn(optional_idx = 1)]
    pub supported_band_combination_add_v1450: Option<SupportedBandCombinationAdd_v1450>,
    #[asn(optional_idx = 2)]
    pub supported_band_combination_reduced_v1450: Option<SupportedBandCombinationReduced_v1450>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct RF_Parameters_v1470 {
    #[asn(optional_idx = 0)]
    pub supported_band_combination_v1470: Option<SupportedBandCombination_v1470>,
    #[asn(optional_idx = 1)]
    pub supported_band_combination_add_v1470: Option<SupportedBandCombinationAdd_v1470>,
    #[asn(optional_idx = 2)]
    pub supported_band_combination_reduced_v1470: Option<SupportedBandCombinationReduced_v1470>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct RF_Parameters_v14b0 {
    #[asn(optional_idx = 0)]
    pub supported_band_combination_v14b0: Option<SupportedBandCombination_v14b0>,
    #[asn(optional_idx = 1)]
    pub supported_band_combination_add_v14b0: Option<SupportedBandCombinationAdd_v14b0>,
    #[asn(optional_idx = 2)]
    pub supported_band_combination_reduced_v14b0: Option<SupportedBandCombinationReduced_v14b0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct RF_Parameters_v1530 {
    #[asn(optional_idx = 0)]
    pub stti_spt_supported_r15: Option<RF_Parameters_v1530STTI_SPT_Supported_r15>,
    #[asn(optional_idx = 1)]
    pub supported_band_combination_v1530: Option<SupportedBandCombination_v1530>,
    #[asn(optional_idx = 2)]
    pub supported_band_combination_add_v1530: Option<SupportedBandCombinationAdd_v1530>,
    #[asn(optional_idx = 3)]
    pub supported_band_combination_reduced_v1530: Option<SupportedBandCombinationReduced_v1530>,
    #[asn(optional_idx = 4)]
    pub power_class_14d_bm_r15: Option<RF_Parameters_v1530PowerClass_14dBm_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RF_Parameters_v1570 {
    pub dl_1024qam_scaling_factor_r15: RF_Parameters_v1570Dl_1024QAM_ScalingFactor_r15,
    pub dl_1024qam_total_weighted_layers_r15: RF_Parameters_v1570Dl_1024QAM_TotalWeightedLayers_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct RF_Parameters_v1610 {
    #[asn(optional_idx = 0)]
    pub supported_band_combination_v1610: Option<SupportedBandCombination_v1610>,
    #[asn(optional_idx = 1)]
    pub supported_band_combination_add_v1610: Option<SupportedBandCombinationAdd_v1610>,
    #[asn(optional_idx = 2)]
    pub supported_band_combination_reduced_v1610: Option<SupportedBandCombinationReduced_v1610>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct RF_Parameters_v1630 {
    #[asn(optional_idx = 0)]
    pub supported_band_combination_v1630: Option<SupportedBandCombination_v1630>,
    #[asn(optional_idx = 1)]
    pub supported_band_combination_add_v1630: Option<SupportedBandCombinationAdd_v1630>,
    #[asn(optional_idx = 2)]
    pub supported_band_combination_reduced_v1630: Option<SupportedBandCombinationReduced_v1630>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RF_Parameters_v9e0 {
    #[asn(optional_idx = 0)]
    pub supported_band_list_eutra_v9e0: Option<SupportedBandListEUTRA_v9e0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RLC_BearerConfig_r15 {
    #[asn(key = 0, extended = false)]
    Release(RLC_BearerConfig_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(RLC_BearerConfig_r15_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = true)]
pub enum RLC_Config {
    #[asn(key = 0, extended = false)]
    Am(RLC_Config_am),
    #[asn(key = 1, extended = false)]
    Um_Bi_Directional(RLC_Config_um_Bi_Directional),
    #[asn(key = 2, extended = false)]
    Um_Uni_Directional_UL(RLC_Config_um_Uni_Directional_UL),
    #[asn(key = 3, extended = false)]
    Um_Uni_Directional_DL(RLC_Config_um_Uni_Directional_DL),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct RLC_Config_r15 {
    pub mode_r15: RLC_Config_r15Mode_r15,
    #[asn(optional_idx = 0)]
    pub reestablish_rlc_r15: Option<RLC_Config_r15ReestablishRLC_r15>,
    #[asn(optional_idx = 1)]
    pub rlc_out_of_order_delivery_r15: Option<RLC_Config_r15Rlc_OutOfOrderDelivery_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RLC_Config_v1250 {
    pub ul_extended_rlc_li_field_r12: RLC_Config_v1250Ul_extended_RLC_LI_Field_r12,
    pub dl_extended_rlc_li_field_r12: RLC_Config_v1250Dl_extended_RLC_LI_Field_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RLC_Config_v1310 {
    pub ul_extended_rlc_am_sn_r13: RLC_Config_v1310Ul_extended_RLC_AM_SN_r13,
    pub dl_extended_rlc_am_sn_r13: RLC_Config_v1310Dl_extended_RLC_AM_SN_r13,
    #[asn(optional_idx = 0)]
    pub poll_pdu_v1310: Option<PollPDU_v1310>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RLC_Config_v1430 {
    #[asn(key = 0, extended = false)]
    Release(RLC_Config_v1430_release),
    #[asn(key = 1, extended = false)]
    Setup(RLC_Config_v1430_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RLC_Config_v1510 {
    pub reestablish_rlc_r15: RLC_Config_v1510ReestablishRLC_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RLC_Config_v1530 {
    #[asn(key = 0, extended = false)]
    Release(RLC_Config_v1530_release),
    #[asn(key = 1, extended = false)]
    Setup(RLC_Config_v1530_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RLC_Config_v1700 {
    pub t_reordering_ext_r17: RLC_Config_v1700T_ReorderingExt_r17,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RLC_Parameters_r12 {
    pub extended_rlc_li_field_r12: RLC_Parameters_r12Extended_RLC_LI_Field_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RLC_Parameters_v1310 {
    #[asn(optional_idx = 0)]
    pub extended_rlc_sn_so_field_r13: Option<RLC_Parameters_v1310ExtendedRLC_SN_SO_Field_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RLC_Parameters_v1430 {
    #[asn(optional_idx = 0)]
    pub extended_poll_byte_r14: Option<RLC_Parameters_v1430ExtendedPollByte_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct RLC_Parameters_v1530 {
    #[asn(optional_idx = 0)]
    pub flexible_um_am_combinations_r15: Option<RLC_Parameters_v1530FlexibleUM_AM_Combinations_r15>,
    #[asn(optional_idx = 1)]
    pub rlc_am_ooo_delivery_r15: Option<RLC_Parameters_v1530Rlc_AM_Ooo_Delivery_r15>,
    #[asn(optional_idx = 2)]
    pub rlc_um_ooo_delivery_r15: Option<RLC_Parameters_v1530Rlc_UM_Ooo_Delivery_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RLF_Report_r9 {
    pub meas_result_last_serv_cell_r9: RLF_Report_r9MeasResultLastServCell_r9,
    #[asn(optional_idx = 0)]
    pub meas_result_neigh_cells_r9: Option<RLF_Report_r9MeasResultNeighCells_r9>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RLF_Report_v9e0 {
    pub meas_result_list_eutra_v9e0: MeasResultList2EUTRA_v9e0,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RLF_TimersAndConstants_r13 {
    #[asn(key = 0, extended = false)]
    Release(RLF_TimersAndConstants_r13_release),
    #[asn(key = 1, extended = false)]
    Setup(RLF_TimersAndConstants_r13_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RLF_TimersAndConstants_r9 {
    #[asn(key = 0, extended = false)]
    Release(RLF_TimersAndConstants_r9_release),
    #[asn(key = 1, extended = false)]
    Setup(RLF_TimersAndConstants_r9_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RLF_TimersAndConstantsMCG_Failure_r16 {
    #[asn(key = 0, extended = false)]
    Release(RLF_TimersAndConstantsMCG_Failure_r16_release),
    #[asn(key = 1, extended = false)]
    Setup(RLF_TimersAndConstantsMCG_Failure_r16_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RLF_TimersAndConstantsSCG_r12 {
    #[asn(key = 0, extended = false)]
    Release(RLF_TimersAndConstantsSCG_r12_release),
    #[asn(key = 1, extended = false)]
    Setup(RLF_TimersAndConstantsSCG_r12_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RMTC_Config_r13 {
    #[asn(key = 0, extended = false)]
    Release(RMTC_Config_r13_release),
    #[asn(key = 1, extended = false)]
    Setup(RMTC_Config_r13_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RMTC_ConfigNR_r16 {
    pub rmtc_periodicity_nr_r16: RMTC_ConfigNR_r16Rmtc_PeriodicityNR_r16,
    #[asn(optional_idx = 0)]
    pub rmtc_subframe_offset_nr_r16: Option<RMTC_ConfigNR_r16Rmtc_SubframeOffsetNR_r16>,
    pub meas_duration_nr_r16: RMTC_ConfigNR_r16MeasDurationNR_r16,
    pub rmtc_frequency_nr_r16: ARFCN_ValueNR_r15,
    pub ref_scs_cp_nr_r16: RMTC_ConfigNR_r16RefSCS_CP_NR_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct RN_SubframeConfig_r10 {
    #[asn(optional_idx = 0)]
    pub subframe_config_pattern_r10: Option<RN_SubframeConfig_r10SubframeConfigPattern_r10>,
    #[asn(optional_idx = 1)]
    pub rpdcch_config_r10: Option<RN_SubframeConfig_r10Rpdcch_Config_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct RN_SystemInfo_r10 {
    #[asn(optional_idx = 0)]
    pub system_information_block_type1_r10:
        Option<RN_SystemInfo_r10SystemInformationBlockType1_r10>,
    #[asn(optional_idx = 1)]
    pub system_information_block_type2_r10: Option<SystemInformationBlockType2>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RNReconfiguration_r10 {
    pub rrc_transaction_identifier: RRC_TransactionIdentifier,
    pub critical_extensions: RNReconfiguration_r10CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct RNReconfiguration_r10_IEs {
    #[asn(optional_idx = 0)]
    pub rn_system_info_r10: Option<RN_SystemInfo_r10>,
    #[asn(optional_idx = 1)]
    pub rn_subframe_config_r10: Option<RN_SubframeConfig_r10>,
    #[asn(optional_idx = 2)]
    pub late_non_critical_extension: Option<RNReconfiguration_r10_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 3)]
    pub non_critical_extension: Option<RNReconfiguration_r10_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RNReconfigurationComplete_r10 {
    pub rrc_transaction_identifier: RRC_TransactionIdentifier,
    pub critical_extensions: RNReconfigurationComplete_r10CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RNReconfigurationComplete_r10_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<RNReconfigurationComplete_r10_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RNReconfigurationComplete_r10_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ROHC_ProfileSupportList_r15 {
    pub profile0x0001_r15: ROHC_ProfileSupportList_r15Profile0x0001_r15,
    pub profile0x0002_r15: ROHC_ProfileSupportList_r15Profile0x0002_r15,
    pub profile0x0003_r15: ROHC_ProfileSupportList_r15Profile0x0003_r15,
    pub profile0x0004_r15: ROHC_ProfileSupportList_r15Profile0x0004_r15,
    pub profile0x0006_r15: ROHC_ProfileSupportList_r15Profile0x0006_r15,
    pub profile0x0101_r15: ROHC_ProfileSupportList_r15Profile0x0101_r15,
    pub profile0x0102_r15: ROHC_ProfileSupportList_r15Profile0x0102_r15,
    pub profile0x0103_r15: ROHC_ProfileSupportList_r15Profile0x0103_r15,
    pub profile0x0104_r15: ROHC_ProfileSupportList_r15Profile0x0104_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct RRC_InactiveConfig_r15 {
    pub full_i_rnti_r15: I_RNTI_r15,
    pub short_i_rnti_r15: ShortI_RNTI_r15,
    #[asn(optional_idx = 0)]
    pub ran_paging_cycle_r15: Option<RRC_InactiveConfig_r15Ran_PagingCycle_r15>,
    #[asn(optional_idx = 1)]
    pub ran_notification_area_info_r15: Option<RAN_NotificationAreaInfo_r15>,
    #[asn(optional_idx = 2)]
    pub periodic_rnau_timer_r15: Option<RRC_InactiveConfig_r15Periodic_RNAU_timer_r15>,
    #[asn(optional_idx = 3)]
    pub next_hop_chaining_count_r15: Option<NextHopChainingCount>,
    #[asn(optional_idx = 4)]
    pub dummy: Option<RRC_InactiveConfig_r15Dummy>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRC_InactiveConfig_v1610 {
    pub ran_paging_cycle_v1610: RRC_InactiveConfig_v1610Ran_PagingCycle_v1610,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct RRC_TransactionIdentifier(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionReconfiguration {
    pub rrc_transaction_identifier: RRC_TransactionIdentifier,
    pub critical_extensions: RRCConnectionReconfigurationCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct RRCConnectionReconfiguration_r8_IEs {
    #[asn(optional_idx = 0)]
    pub meas_config: Option<MeasConfig>,
    #[asn(optional_idx = 1)]
    pub mobility_control_info: Option<MobilityControlInfo>,
    #[asn(optional_idx = 2)]
    pub dedicated_info_nas_list: Option<RRCConnectionReconfiguration_r8_IEsDedicatedInfoNASList>,
    #[asn(optional_idx = 3)]
    pub radio_resource_config_dedicated: Option<RadioResourceConfigDedicated>,
    #[asn(optional_idx = 4)]
    pub security_config_ho: Option<SecurityConfigHO>,
    #[asn(optional_idx = 5)]
    pub non_critical_extension: Option<RRCConnectionReconfiguration_v890_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct RRCConnectionReconfiguration_v1020_IEs {
    #[asn(optional_idx = 0)]
    pub s_cell_to_release_list_r10: Option<SCellToReleaseList_r10>,
    #[asn(optional_idx = 1)]
    pub s_cell_to_add_mod_list_r10: Option<SCellToAddModList_r10>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<RRCConnectionReconfiguration_v1130_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionReconfiguration_v10i0_IEs {
    #[asn(optional_idx = 0)]
    pub antenna_info_dedicated_p_cell_v10i0: Option<AntennaInfoDedicated_v10i0>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionReconfiguration_v10l0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct RRCConnectionReconfiguration_v10l0_IEs {
    #[asn(optional_idx = 0)]
    pub mobility_control_info_v10l0: Option<MobilityControlInfo_v10l0>,
    #[asn(optional_idx = 1)]
    pub s_cell_to_add_mod_list_v10l0: Option<SCellToAddModList_v10l0>,
    #[asn(optional_idx = 2)]
    pub late_non_critical_extension:
        Option<RRCConnectionReconfiguration_v10l0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 3)]
    pub non_critical_extension: Option<RRCConnectionReconfiguration_v12f0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionReconfiguration_v1130_IEs {
    #[asn(optional_idx = 0)]
    pub system_information_block_type1_dedicated_r11:
        Option<RRCConnectionReconfiguration_v1130_IEsSystemInformationBlockType1Dedicated_r11>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionReconfiguration_v1250_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct RRCConnectionReconfiguration_v1250_IEs {
    #[asn(optional_idx = 0)]
    pub wlan_offload_info_r12: Option<RRCConnectionReconfiguration_v1250_IEsWlan_OffloadInfo_r12>,
    #[asn(optional_idx = 1)]
    pub scg_configuration_r12: Option<SCG_Configuration_r12>,
    #[asn(optional_idx = 2)]
    pub sl_sync_tx_control_r12: Option<SL_SyncTxControl_r12>,
    #[asn(optional_idx = 3)]
    pub sl_disc_config_r12: Option<SL_DiscConfig_r12>,
    #[asn(optional_idx = 4)]
    pub sl_comm_config_r12: Option<SL_CommConfig_r12>,
    #[asn(optional_idx = 5)]
    pub non_critical_extension: Option<RRCConnectionReconfiguration_v1310_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct RRCConnectionReconfiguration_v12f0_IEs {
    #[asn(optional_idx = 0)]
    pub scg_configuration_v12f0: Option<SCG_Configuration_v12f0>,
    #[asn(optional_idx = 1)]
    pub late_non_critical_extension:
        Option<RRCConnectionReconfiguration_v12f0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<RRCConnectionReconfiguration_v1370_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct RRCConnectionReconfiguration_v1310_IEs {
    #[asn(optional_idx = 0)]
    pub s_cell_to_release_list_ext_r13: Option<SCellToReleaseListExt_r13>,
    #[asn(optional_idx = 1)]
    pub s_cell_to_add_mod_list_ext_r13: Option<SCellToAddModListExt_r13>,
    #[asn(optional_idx = 2)]
    pub lwa_configuration_r13: Option<LWA_Configuration_r13>,
    #[asn(optional_idx = 3)]
    pub lwip_configuration_r13: Option<LWIP_Configuration_r13>,
    #[asn(optional_idx = 4)]
    pub rclwi_configuration_r13: Option<RCLWI_Configuration_r13>,
    #[asn(optional_idx = 5)]
    pub non_critical_extension: Option<RRCConnectionReconfiguration_v1430_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct RRCConnectionReconfiguration_v1370_IEs {
    #[asn(optional_idx = 0)]
    pub radio_resource_config_dedicated_v1370: Option<RadioResourceConfigDedicated_v1370>,
    #[asn(optional_idx = 1)]
    pub s_cell_to_add_mod_list_ext_v1370: Option<SCellToAddModListExt_v1370>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<RRCConnectionReconfiguration_v13c0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct RRCConnectionReconfiguration_v13c0_IEs {
    #[asn(optional_idx = 0)]
    pub radio_resource_config_dedicated_v13c0: Option<RadioResourceConfigDedicated_v13c0>,
    #[asn(optional_idx = 1)]
    pub s_cell_to_add_mod_list_v13c0: Option<SCellToAddModList_v13c0>,
    #[asn(optional_idx = 2)]
    pub s_cell_to_add_mod_list_ext_v13c0: Option<SCellToAddModListExt_v13c0>,
    #[asn(optional_idx = 3)]
    pub scg_configuration_v13c0: Option<SCG_Configuration_v13c0>,
    #[asn(optional_idx = 4)]
    pub non_critical_extension: Option<RRCConnectionReconfiguration_v13c0_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct RRCConnectionReconfiguration_v1430_IEs {
    #[asn(optional_idx = 0)]
    pub sl_v2x_config_dedicated_r14: Option<SL_V2X_ConfigDedicated_r14>,
    #[asn(optional_idx = 1)]
    pub s_cell_to_add_mod_list_ext_v1430: Option<SCellToAddModListExt_v1430>,
    #[asn(optional_idx = 2)]
    pub per_cc_gap_indication_request_r14:
        Option<RRCConnectionReconfiguration_v1430_IEsPerCC_GapIndicationRequest_r14>,
    #[asn(optional_idx = 3)]
    pub system_information_block_type2_dedicated_r14:
        Option<RRCConnectionReconfiguration_v1430_IEsSystemInformationBlockType2Dedicated_r14>,
    #[asn(optional_idx = 4)]
    pub non_critical_extension: Option<RRCConnectionReconfiguration_v1510_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct RRCConnectionReconfiguration_v1510_IEs {
    #[asn(optional_idx = 0)]
    pub nr_config_r15: Option<RRCConnectionReconfiguration_v1510_IEsNr_Config_r15>,
    #[asn(optional_idx = 1)]
    pub sk_counter_r15: Option<RRCConnectionReconfiguration_v1510_IEsSk_Counter_r15>,
    #[asn(optional_idx = 2)]
    pub nr_radio_bearer_config1_r15:
        Option<RRCConnectionReconfiguration_v1510_IEsNr_RadioBearerConfig1_r15>,
    #[asn(optional_idx = 3)]
    pub nr_radio_bearer_config2_r15:
        Option<RRCConnectionReconfiguration_v1510_IEsNr_RadioBearerConfig2_r15>,
    #[asn(optional_idx = 4)]
    pub tdm_pattern_config_r15: Option<TDM_PatternConfig_r15>,
    #[asn(optional_idx = 5)]
    pub non_critical_extension: Option<RRCConnectionReconfiguration_v1530_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 7)]
pub struct RRCConnectionReconfiguration_v1530_IEs {
    #[asn(optional_idx = 0)]
    pub security_config_ho_v1530: Option<SecurityConfigHO_v1530>,
    #[asn(optional_idx = 1)]
    pub s_cell_group_to_release_list_r15: Option<SCellGroupToReleaseList_r15>,
    #[asn(optional_idx = 2)]
    pub s_cell_group_to_add_mod_list_r15: Option<SCellGroupToAddModList_r15>,
    #[asn(optional_idx = 3)]
    pub dedicated_info_nas_list_r15:
        Option<RRCConnectionReconfiguration_v1530_IEsDedicatedInfoNASList_r15>,
    #[asn(optional_idx = 4)]
    pub p_max_ue_fr1_r15: Option<P_Max>,
    #[asn(optional_idx = 5)]
    pub smtc_r15: Option<MTC_SSB_NR_r15>,
    #[asn(optional_idx = 6)]
    pub non_critical_extension: Option<RRCConnectionReconfiguration_v1610_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct RRCConnectionReconfiguration_v1610_IEs {
    #[asn(optional_idx = 0)]
    pub conditional_reconfiguration_r16: Option<ConditionalReconfiguration_r16>,
    #[asn(optional_idx = 1)]
    pub daps_source_release_r16:
        Option<RRCConnectionReconfiguration_v1610_IEsDaps_SourceRelease_r16>,
    #[asn(optional_idx = 2)]
    pub tdm_pattern_config2_r16: Option<TDM_PatternConfig_r15>,
    #[asn(optional_idx = 3)]
    pub sl_config_dedicated_for_nr_r16:
        Option<RRCConnectionReconfiguration_v1610_IEsSl_ConfigDedicatedForNR_r16>,
    #[asn(optional_idx = 4)]
    pub sl_ssb_priority_eutra_r16:
        Option<RRCConnectionReconfiguration_v1610_IEsSl_SSB_PriorityEUTRA_r16>,
    #[asn(optional_idx = 5)]
    pub non_critical_extension: Option<RRCConnectionReconfiguration_v1700_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct RRCConnectionReconfiguration_v1700_IEs {
    #[asn(optional_idx = 0)]
    pub system_information_block_type31_dedicated_r17:
        Option<RRCConnectionReconfiguration_v1700_IEsSystemInformationBlockType31Dedicated_r17>,
    #[asn(optional_idx = 1)]
    pub scg_state_r17: Option<RRCConnectionReconfiguration_v1700_IEsScg_State_r17>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<RRCConnectionReconfiguration_v1700_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionReconfiguration_v890_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<RRCConnectionReconfiguration_v890_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionReconfiguration_v920_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionReconfiguration_v8m0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<RRCConnectionReconfiguration_v8m0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionReconfiguration_v10i0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct RRCConnectionReconfiguration_v920_IEs {
    #[asn(optional_idx = 0)]
    pub other_config_r9: Option<OtherConfig_r9>,
    #[asn(optional_idx = 1)]
    pub full_config_r9: Option<RRCConnectionReconfiguration_v920_IEsFullConfig_r9>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<RRCConnectionReconfiguration_v1020_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionReconfigurationComplete {
    pub rrc_transaction_identifier: RRC_TransactionIdentifier,
    pub critical_extensions: RRCConnectionReconfigurationCompleteCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RRCConnectionReconfigurationComplete_r8_IEs {
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<RRCConnectionReconfigurationComplete_v8a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct RRCConnectionReconfigurationComplete_v1020_IEs {
    #[asn(optional_idx = 0)]
    pub rlf_info_available_r10:
        Option<RRCConnectionReconfigurationComplete_v1020_IEsRlf_InfoAvailable_r10>,
    #[asn(optional_idx = 1)]
    pub log_meas_available_r10:
        Option<RRCConnectionReconfigurationComplete_v1020_IEsLogMeasAvailable_r10>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<RRCConnectionReconfigurationComplete_v1130_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionReconfigurationComplete_v1130_IEs {
    #[asn(optional_idx = 0)]
    pub conn_est_fail_info_available_r11:
        Option<RRCConnectionReconfigurationComplete_v1130_IEsConnEstFailInfoAvailable_r11>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionReconfigurationComplete_v1250_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionReconfigurationComplete_v1250_IEs {
    #[asn(optional_idx = 0)]
    pub log_meas_available_mbsfn_r12:
        Option<RRCConnectionReconfigurationComplete_v1250_IEsLogMeasAvailableMBSFN_r12>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionReconfigurationComplete_v1430_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct RRCConnectionReconfigurationComplete_v1430_IEs {
    #[asn(optional_idx = 0)]
    pub per_cc_gap_indication_list_r14: Option<PerCC_GapIndicationList_r14>,
    #[asn(optional_idx = 1)]
    pub num_freq_effective_r14:
        Option<RRCConnectionReconfigurationComplete_v1430_IEsNumFreqEffective_r14>,
    #[asn(optional_idx = 2)]
    pub num_freq_effective_reduced_r14:
        Option<RRCConnectionReconfigurationComplete_v1430_IEsNumFreqEffectiveReduced_r14>,
    #[asn(optional_idx = 3)]
    pub non_critical_extension: Option<RRCConnectionReconfigurationComplete_v1510_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionReconfigurationComplete_v1510_IEs {
    #[asn(optional_idx = 0)]
    pub scg_config_response_nr_r15:
        Option<RRCConnectionReconfigurationComplete_v1510_IEsScg_ConfigResponseNR_r15>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionReconfigurationComplete_v1530_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct RRCConnectionReconfigurationComplete_v1530_IEs {
    #[asn(optional_idx = 0)]
    pub log_meas_available_bt_r15:
        Option<RRCConnectionReconfigurationComplete_v1530_IEsLogMeasAvailableBT_r15>,
    #[asn(optional_idx = 1)]
    pub log_meas_available_wlan_r15:
        Option<RRCConnectionReconfigurationComplete_v1530_IEsLogMeasAvailableWLAN_r15>,
    #[asn(optional_idx = 2)]
    pub flight_path_info_available_r15:
        Option<RRCConnectionReconfigurationComplete_v1530_IEsFlightPathInfoAvailable_r15>,
    #[asn(optional_idx = 3)]
    pub non_critical_extension: Option<RRCConnectionReconfigurationComplete_v1700_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionReconfigurationComplete_v1700_IEs {
    #[asn(optional_idx = 0)]
    pub selected_cond_reconfiguration_to_apply_r17: Option<CondReconfigurationId_r16>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionReconfigurationComplete_v1710_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionReconfigurationComplete_v1710_IEs {
    #[asn(optional_idx = 0)]
    pub gnss_validity_duration_r17: Option<GNSS_ValidityDuration_r17>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension:
        Option<RRCConnectionReconfigurationComplete_v1710_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionReconfigurationComplete_v8a0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<RRCConnectionReconfigurationComplete_v8a0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionReconfigurationComplete_v1020_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionReestablishment {
    pub rrc_transaction_identifier: RRC_TransactionIdentifier,
    pub critical_extensions: RRCConnectionReestablishmentCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RRCConnectionReestablishment_r8_IEs {
    pub radio_resource_config_dedicated: RadioResourceConfigDedicated,
    pub next_hop_chaining_count: NextHopChainingCount,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<RRCConnectionReestablishment_v8a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionReestablishment_v8a0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<RRCConnectionReestablishment_v8a0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionReestablishment_v8a0_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionReestablishmentComplete {
    pub rrc_transaction_identifier: RRC_TransactionIdentifier,
    pub critical_extensions: RRCConnectionReestablishmentCompleteCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RRCConnectionReestablishmentComplete_r8_IEs {
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<RRCConnectionReestablishmentComplete_v920_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionReestablishmentComplete_v1020_IEs {
    #[asn(optional_idx = 0)]
    pub log_meas_available_r10:
        Option<RRCConnectionReestablishmentComplete_v1020_IEsLogMeasAvailable_r10>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionReestablishmentComplete_v1130_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionReestablishmentComplete_v1130_IEs {
    #[asn(optional_idx = 0)]
    pub conn_est_fail_info_available_r11:
        Option<RRCConnectionReestablishmentComplete_v1130_IEsConnEstFailInfoAvailable_r11>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionReestablishmentComplete_v1250_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionReestablishmentComplete_v1250_IEs {
    #[asn(optional_idx = 0)]
    pub log_meas_available_mbsfn_r12:
        Option<RRCConnectionReestablishmentComplete_v1250_IEsLogMeasAvailableMBSFN_r12>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionReestablishmentComplete_v1530_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct RRCConnectionReestablishmentComplete_v1530_IEs {
    #[asn(optional_idx = 0)]
    pub log_meas_available_bt_r15:
        Option<RRCConnectionReestablishmentComplete_v1530_IEsLogMeasAvailableBT_r15>,
    #[asn(optional_idx = 1)]
    pub log_meas_available_wlan_r15:
        Option<RRCConnectionReestablishmentComplete_v1530_IEsLogMeasAvailableWLAN_r15>,
    #[asn(optional_idx = 2)]
    pub flight_path_info_available_r15:
        Option<RRCConnectionReestablishmentComplete_v1530_IEsFlightPathInfoAvailable_r15>,
    #[asn(optional_idx = 3)]
    pub non_critical_extension: Option<RRCConnectionReestablishmentComplete_v1710_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionReestablishmentComplete_v1710_IEs {
    #[asn(optional_idx = 0)]
    pub gnss_validity_duration_r17: Option<GNSS_ValidityDuration_r17>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension:
        Option<RRCConnectionReestablishmentComplete_v1710_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionReestablishmentComplete_v8a0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<RRCConnectionReestablishmentComplete_v8a0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionReestablishmentComplete_v1020_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionReestablishmentComplete_v920_IEs {
    #[asn(optional_idx = 0)]
    pub rlf_info_available_r9:
        Option<RRCConnectionReestablishmentComplete_v920_IEsRlf_InfoAvailable_r9>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionReestablishmentComplete_v8a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionReestablishmentReject {
    pub critical_extensions: RRCConnectionReestablishmentRejectCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RRCConnectionReestablishmentReject_r8_IEs {
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<RRCConnectionReestablishmentReject_v8a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionReestablishmentReject_v8a0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<RRCConnectionReestablishmentReject_v8a0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension:
        Option<RRCConnectionReestablishmentReject_v8a0_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionReestablishmentRequest {
    pub critical_extensions: RRCConnectionReestablishmentRequestCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionReestablishmentRequest_r8_IEs {
    pub ue_identity: ReestabUE_Identity,
    pub reestablishment_cause: ReestablishmentCause,
    pub spare: RRCConnectionReestablishmentRequest_r8_IEsSpare,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionReject {
    pub critical_extensions: RRCConnectionRejectCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RRCConnectionReject_r8_IEs {
    pub wait_time: RRCConnectionReject_r8_IEsWaitTime,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<RRCConnectionReject_v8a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionReject_v1020_IEs {
    #[asn(optional_idx = 0)]
    pub extended_wait_time_r10: Option<RRCConnectionReject_v1020_IEsExtendedWaitTime_r10>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionReject_v1130_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionReject_v1130_IEs {
    #[asn(optional_idx = 0)]
    pub deprioritisation_req_r11: Option<RRCConnectionReject_v1130_IEsDeprioritisationReq_r11>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionReject_v1320_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionReject_v1320_IEs {
    #[asn(optional_idx = 0)]
    pub rrc_suspend_indication_r13: Option<RRCConnectionReject_v1320_IEsRrc_SuspendIndication_r13>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionReject_v1320_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionReject_v8a0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<RRCConnectionReject_v8a0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionReject_v1020_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionRelease {
    pub rrc_transaction_identifier: RRC_TransactionIdentifier,
    pub critical_extensions: RRCConnectionReleaseCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct RRCConnectionRelease_r8_IEs {
    pub release_cause: ReleaseCause,
    #[asn(optional_idx = 0)]
    pub redirected_carrier_info: Option<RedirectedCarrierInfo>,
    #[asn(optional_idx = 1)]
    pub idle_mode_mobility_control_info: Option<IdleModeMobilityControlInfo>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<RRCConnectionRelease_v890_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionRelease_v1020_IEs {
    #[asn(optional_idx = 0)]
    pub extended_wait_time_r10: Option<RRCConnectionRelease_v1020_IEsExtendedWaitTime_r10>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionRelease_v1320_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionRelease_v1320_IEs {
    #[asn(optional_idx = 0)]
    pub resume_identity_r13: Option<ResumeIdentity_r13>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionRelease_v1530_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct RRCConnectionRelease_v1530_IEs {
    #[asn(optional_idx = 0)]
    pub drb_continue_rohc_r15: Option<RRCConnectionRelease_v1530_IEsDrb_ContinueROHC_r15>,
    #[asn(optional_idx = 1)]
    pub next_hop_chaining_count_r15: Option<NextHopChainingCount>,
    #[asn(optional_idx = 2)]
    pub meas_idle_config_r15: Option<MeasIdleConfigDedicated_r15>,
    #[asn(optional_idx = 3)]
    pub rrc_inactive_config_r15: Option<RRC_InactiveConfig_r15>,
    #[asn(optional_idx = 4)]
    pub cn_type_r15: Option<RRCConnectionRelease_v1530_IEsCn_Type_r15>,
    #[asn(optional_idx = 5)]
    pub non_critical_extension: Option<RRCConnectionRelease_v1540_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionRelease_v1540_IEs {
    #[asn(optional_idx = 0)]
    pub wait_time: Option<RRCConnectionRelease_v1540_IEsWaitTime>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionRelease_v15b0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionRelease_v15b0_IEs {
    #[asn(optional_idx = 0)]
    pub no_last_cell_update_r15: Option<RRCConnectionRelease_v15b0_IEsNoLastCellUpdate_r15>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionRelease_v1610_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 8)]
pub struct RRCConnectionRelease_v1610_IEs {
    #[asn(optional_idx = 0)]
    pub full_i_rnti_r16: Option<I_RNTI_r15>,
    #[asn(optional_idx = 1)]
    pub short_i_rnti_r16: Option<ShortI_RNTI_r15>,
    #[asn(optional_idx = 2)]
    pub pur_config_r16: Option<RRCConnectionRelease_v1610_IEsPur_Config_r16>,
    #[asn(optional_idx = 3)]
    pub rrc_inactive_config_v1610: Option<RRC_InactiveConfig_v1610>,
    #[asn(optional_idx = 4)]
    pub release_idle_meas_config_r16:
        Option<RRCConnectionRelease_v1610_IEsReleaseIdleMeasConfig_r16>,
    #[asn(optional_idx = 5)]
    pub alt_freq_priorities_r16: Option<RRCConnectionRelease_v1610_IEsAltFreqPriorities_r16>,
    #[asn(optional_idx = 6)]
    pub t323_r16: Option<RRCConnectionRelease_v1610_IEsT323_r16>,
    #[asn(optional_idx = 7)]
    pub non_critical_extension: Option<RRCConnectionRelease_v1650_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionRelease_v1650_IEs {
    #[asn(optional_idx = 0)]
    pub mps_priority_indication_r16:
        Option<RRCConnectionRelease_v1650_IEsMpsPriorityIndication_r16>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionRelease_v1650_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionRelease_v890_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<RRCConnectionRelease_v890_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionRelease_v920_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionRelease_v920_IEs {
    #[asn(optional_idx = 0)]
    pub cell_info_list_r9: Option<RRCConnectionRelease_v920_IEsCellInfoList_r9>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionRelease_v1020_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct RRCConnectionRelease_v9e0_IEs {
    #[asn(optional_idx = 0)]
    pub redirected_carrier_info_v9e0: Option<RedirectedCarrierInfo_v9e0>,
    #[asn(optional_idx = 1)]
    pub idle_mode_mobility_control_info_v9e0: Option<IdleModeMobilityControlInfo_v9e0>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<RRCConnectionRelease_v9e0_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionRequest {
    pub critical_extensions: RRCConnectionRequestCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionRequest_5GC_r15_IEs {
    pub ue_identity_r15: InitialUE_Identity_5GC_r15,
    pub establishment_cause_r15: EstablishmentCause_5GC_r15,
    pub spare: RRCConnectionRequest_5GC_r15_IEsSpare,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionRequest_r8_IEs {
    pub ue_identity: InitialUE_Identity,
    pub establishment_cause: EstablishmentCause,
    pub spare: RRCConnectionRequest_r8_IEsSpare,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionResume_r13 {
    pub rrc_transaction_identifier: RRC_TransactionIdentifier,
    pub critical_extensions: RRCConnectionResume_r13CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct RRCConnectionResume_r13_IEs {
    #[asn(optional_idx = 0)]
    pub radio_resource_config_dedicated_r13: Option<RadioResourceConfigDedicated>,
    pub next_hop_chaining_count_r13: NextHopChainingCount,
    #[asn(optional_idx = 1)]
    pub meas_config_r13: Option<MeasConfig>,
    #[asn(optional_idx = 2)]
    pub antenna_info_dedicated_p_cell_r13: Option<AntennaInfoDedicated_v10i0>,
    #[asn(optional_idx = 3)]
    pub drb_continue_rohc_r13: Option<RRCConnectionResume_r13_IEsDrb_ContinueROHC_r13>,
    #[asn(optional_idx = 4)]
    pub late_non_critical_extension: Option<RRCConnectionResume_r13_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 5)]
    pub rrc_connection_resume_v1430_i_es: Option<RRCConnectionResume_v1430_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionResume_v1430_IEs {
    #[asn(optional_idx = 0)]
    pub other_config_r14: Option<OtherConfig_r9>,
    #[asn(optional_idx = 1)]
    pub rrc_connection_resume_v1510_i_es: Option<RRCConnectionResume_v1510_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct RRCConnectionResume_v1510_IEs {
    #[asn(optional_idx = 0)]
    pub sk_counter_r15: Option<RRCConnectionResume_v1510_IEsSk_Counter_r15>,
    #[asn(optional_idx = 1)]
    pub nr_radio_bearer_config1_r15: Option<RRCConnectionResume_v1510_IEsNr_RadioBearerConfig1_r15>,
    #[asn(optional_idx = 2)]
    pub nr_radio_bearer_config2_r15: Option<RRCConnectionResume_v1510_IEsNr_RadioBearerConfig2_r15>,
    #[asn(optional_idx = 3)]
    pub non_critical_extension: Option<RRCConnectionResume_v1530_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionResume_v1530_IEs {
    #[asn(optional_idx = 0)]
    pub full_config_r15: Option<RRCConnectionResume_v1530_IEsFullConfig_r15>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionResume_v1610_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 13)]
pub struct RRCConnectionResume_v1610_IEs {
    #[asn(optional_idx = 0)]
    pub idle_mode_measurement_req_r16:
        Option<RRCConnectionResume_v1610_IEsIdleModeMeasurementReq_r16>,
    #[asn(optional_idx = 1)]
    pub restore_mcg_s_cells_r16: Option<RRCConnectionResume_v1610_IEsRestoreMCG_SCells_r16>,
    #[asn(optional_idx = 2)]
    pub restore_scg_r16: Option<RRCConnectionResume_v1610_IEsRestoreSCG_r16>,
    #[asn(optional_idx = 3)]
    pub s_cell_to_add_mod_list_r16: Option<SCellToAddModList_r16>,
    #[asn(optional_idx = 4)]
    pub s_cell_to_release_list_r16: Option<SCellToReleaseListExt_r13>,
    #[asn(optional_idx = 5)]
    pub s_cell_group_to_release_list_r16: Option<SCellGroupToReleaseList_r15>,
    #[asn(optional_idx = 6)]
    pub s_cell_group_to_add_mod_list_r16: Option<SCellGroupToAddModList_r15>,
    #[asn(optional_idx = 7)]
    pub nr_secondary_cell_group_config_r16:
        Option<RRCConnectionResume_v1610_IEsNr_SecondaryCellGroupConfig_r16>,
    #[asn(optional_idx = 8)]
    pub p_max_eutra_r16: Option<P_Max>,
    #[asn(optional_idx = 9)]
    pub p_max_ue_fr1_r16: Option<P_Max>,
    #[asn(optional_idx = 10)]
    pub tdm_pattern_config_r16: Option<TDM_PatternConfig_r15>,
    #[asn(optional_idx = 11)]
    pub tdm_pattern_config2_r16: Option<TDM_PatternConfig_r15>,
    #[asn(optional_idx = 12)]
    pub non_critical_extension: Option<RRCConnectionResume_v1700_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionResume_v1700_IEs {
    #[asn(optional_idx = 0)]
    pub scg_state_r17: Option<RRCConnectionResume_v1700_IEsScg_State_r17>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionResume_v1700_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionResumeComplete_r13 {
    pub rrc_transaction_identifier: RRC_TransactionIdentifier,
    pub critical_extensions: RRCConnectionResumeComplete_r13CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 10)]
pub struct RRCConnectionResumeComplete_r13_IEs {
    #[asn(optional_idx = 0)]
    pub selected_plmn_identity_r13:
        Option<RRCConnectionResumeComplete_r13_IEsSelectedPLMN_Identity_r13>,
    #[asn(optional_idx = 1)]
    pub dedicated_info_nas_r13: Option<DedicatedInfoNAS>,
    #[asn(optional_idx = 2)]
    pub rlf_info_available_r13: Option<RRCConnectionResumeComplete_r13_IEsRlf_InfoAvailable_r13>,
    #[asn(optional_idx = 3)]
    pub log_meas_available_r13: Option<RRCConnectionResumeComplete_r13_IEsLogMeasAvailable_r13>,
    #[asn(optional_idx = 4)]
    pub conn_est_fail_info_available_r13:
        Option<RRCConnectionResumeComplete_r13_IEsConnEstFailInfoAvailable_r13>,
    #[asn(optional_idx = 5)]
    pub mobility_state_r13: Option<RRCConnectionResumeComplete_r13_IEsMobilityState_r13>,
    #[asn(optional_idx = 6)]
    pub mobility_history_avail_r13:
        Option<RRCConnectionResumeComplete_r13_IEsMobilityHistoryAvail_r13>,
    #[asn(optional_idx = 7)]
    pub log_meas_available_mbsfn_r13:
        Option<RRCConnectionResumeComplete_r13_IEsLogMeasAvailableMBSFN_r13>,
    #[asn(optional_idx = 8)]
    pub late_non_critical_extension:
        Option<RRCConnectionResumeComplete_r13_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 9)]
    pub non_critical_extension: Option<RRCConnectionResumeComplete_v1530_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct RRCConnectionResumeComplete_v1530_IEs {
    #[asn(optional_idx = 0)]
    pub log_meas_available_bt_r15:
        Option<RRCConnectionResumeComplete_v1530_IEsLogMeasAvailableBT_r15>,
    #[asn(optional_idx = 1)]
    pub log_meas_available_wlan_r15:
        Option<RRCConnectionResumeComplete_v1530_IEsLogMeasAvailableWLAN_r15>,
    #[asn(optional_idx = 2)]
    pub idle_meas_available_r15: Option<RRCConnectionResumeComplete_v1530_IEsIdleMeasAvailable_r15>,
    #[asn(optional_idx = 3)]
    pub flight_path_info_available_r15:
        Option<RRCConnectionResumeComplete_v1530_IEsFlightPathInfoAvailable_r15>,
    #[asn(optional_idx = 4)]
    pub non_critical_extension: Option<RRCConnectionResumeComplete_v1610_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct RRCConnectionResumeComplete_v1610_IEs {
    #[asn(optional_idx = 0)]
    pub meas_result_list_idle_r16: Option<MeasResultListIdle_r15>,
    #[asn(optional_idx = 1)]
    pub meas_result_list_ext_idle_r16: Option<MeasResultListExtIdle_r16>,
    #[asn(optional_idx = 2)]
    pub meas_result_list_idle_nr_r16: Option<MeasResultListIdleNR_r16>,
    #[asn(optional_idx = 3)]
    pub scg_config_response_nr_r16:
        Option<RRCConnectionResumeComplete_v1610_IEsScg_ConfigResponseNR_r16>,
    #[asn(optional_idx = 4)]
    pub non_critical_extension: Option<RRCConnectionResumeComplete_v1710_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionResumeComplete_v1710_IEs {
    #[asn(optional_idx = 0)]
    pub gnss_validity_duration_r17: Option<GNSS_ValidityDuration_r17>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionResumeComplete_v1710_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionResumeRequest_5GC_r15_IEs {
    pub resume_identity_r15: RRCConnectionResumeRequest_5GC_r15_IEsResumeIdentity_r15,
    pub short_resume_mac_i_r15: RRCConnectionResumeRequest_5GC_r15_IEsShortResumeMAC_I_r15,
    pub resume_cause_r15: ResumeCause_r15,
    pub spare: RRCConnectionResumeRequest_5GC_r15_IEsSpare,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionResumeRequest_r13 {
    pub critical_extensions: RRCConnectionResumeRequest_r13CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionResumeRequest_r13_IEs {
    pub resume_identity_r13: RRCConnectionResumeRequest_r13_IEsResumeIdentity_r13,
    pub short_resume_mac_i_r13: RRCConnectionResumeRequest_r13_IEsShortResumeMAC_I_r13,
    pub resume_cause_r13: ResumeCause,
    pub spare: RRCConnectionResumeRequest_r13_IEsSpare,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionSetup {
    pub rrc_transaction_identifier: RRC_TransactionIdentifier,
    pub critical_extensions: RRCConnectionSetupCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RRCConnectionSetup_r8_IEs {
    pub radio_resource_config_dedicated: RadioResourceConfigDedicated,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<RRCConnectionSetup_v8a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionSetup_v1610_IEs {
    #[asn(optional_idx = 0)]
    pub dedicated_info_nas_r16: Option<DedicatedInfoNAS>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionSetup_v1610_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionSetup_v8a0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<RRCConnectionSetup_v8a0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionSetup_v1610_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionSetupComplete {
    pub rrc_transaction_identifier: RRC_TransactionIdentifier,
    pub critical_extensions: RRCConnectionSetupCompleteCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionSetupComplete_r8_IEs {
    pub selected_plmn_identity: RRCConnectionSetupComplete_r8_IEsSelectedPLMN_Identity,
    #[asn(optional_idx = 0)]
    pub registered_mme: Option<RegisteredMME>,
    pub dedicated_info_nas: DedicatedInfoNAS,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionSetupComplete_v8a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct RRCConnectionSetupComplete_v1020_IEs {
    #[asn(optional_idx = 0)]
    pub gummei_type_r10: Option<RRCConnectionSetupComplete_v1020_IEsGummei_Type_r10>,
    #[asn(optional_idx = 1)]
    pub rlf_info_available_r10: Option<RRCConnectionSetupComplete_v1020_IEsRlf_InfoAvailable_r10>,
    #[asn(optional_idx = 2)]
    pub log_meas_available_r10: Option<RRCConnectionSetupComplete_v1020_IEsLogMeasAvailable_r10>,
    #[asn(optional_idx = 3)]
    pub rn_subframe_config_req_r10:
        Option<RRCConnectionSetupComplete_v1020_IEsRn_SubframeConfigReq_r10>,
    #[asn(optional_idx = 4)]
    pub non_critical_extension: Option<RRCConnectionSetupComplete_v1130_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionSetupComplete_v1130_IEs {
    #[asn(optional_idx = 0)]
    pub conn_est_fail_info_available_r11:
        Option<RRCConnectionSetupComplete_v1130_IEsConnEstFailInfoAvailable_r11>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionSetupComplete_v1250_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct RRCConnectionSetupComplete_v1250_IEs {
    #[asn(optional_idx = 0)]
    pub mobility_state_r12: Option<RRCConnectionSetupComplete_v1250_IEsMobilityState_r12>,
    #[asn(optional_idx = 1)]
    pub mobility_history_avail_r12:
        Option<RRCConnectionSetupComplete_v1250_IEsMobilityHistoryAvail_r12>,
    #[asn(optional_idx = 2)]
    pub log_meas_available_mbsfn_r12:
        Option<RRCConnectionSetupComplete_v1250_IEsLogMeasAvailableMBSFN_r12>,
    #[asn(optional_idx = 3)]
    pub non_critical_extension: Option<RRCConnectionSetupComplete_v1320_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct RRCConnectionSetupComplete_v1320_IEs {
    #[asn(optional_idx = 0)]
    pub ce_mode_b_r13: Option<RRCConnectionSetupComplete_v1320_IEsCe_ModeB_r13>,
    #[asn(optional_idx = 1)]
    pub s_tmsi_r13: Option<S_TMSI>,
    #[asn(optional_idx = 2)]
    pub attach_without_pdn_connectivity_r13:
        Option<RRCConnectionSetupComplete_v1320_IEsAttachWithoutPDN_Connectivity_r13>,
    #[asn(optional_idx = 3)]
    pub up_c_io_t_eps_optimisation_r13:
        Option<RRCConnectionSetupComplete_v1320_IEsUp_CIoT_EPS_Optimisation_r13>,
    #[asn(optional_idx = 4)]
    pub cp_c_io_t_eps_optimisation_r13:
        Option<RRCConnectionSetupComplete_v1320_IEsCp_CIoT_EPS_Optimisation_r13>,
    #[asn(optional_idx = 5)]
    pub non_critical_extension: Option<RRCConnectionSetupComplete_v1330_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionSetupComplete_v1330_IEs {
    #[asn(optional_idx = 0)]
    pub ue_ce_need_ul_gaps_r13: Option<RRCConnectionSetupComplete_v1330_IEsUe_CE_NeedULGaps_r13>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionSetupComplete_v1430_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionSetupComplete_v1430_IEs {
    #[asn(optional_idx = 0)]
    pub dcn_id_r14: Option<RRCConnectionSetupComplete_v1430_IEsDcn_ID_r14>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionSetupComplete_v1530_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 9)]
pub struct RRCConnectionSetupComplete_v1530_IEs {
    #[asn(optional_idx = 0)]
    pub log_meas_available_bt_r15:
        Option<RRCConnectionSetupComplete_v1530_IEsLogMeasAvailableBT_r15>,
    #[asn(optional_idx = 1)]
    pub log_meas_available_wlan_r15:
        Option<RRCConnectionSetupComplete_v1530_IEsLogMeasAvailableWLAN_r15>,
    #[asn(optional_idx = 2)]
    pub idle_meas_available_r15: Option<RRCConnectionSetupComplete_v1530_IEsIdleMeasAvailable_r15>,
    #[asn(optional_idx = 3)]
    pub flight_path_info_available_r15:
        Option<RRCConnectionSetupComplete_v1530_IEsFlightPathInfoAvailable_r15>,
    #[asn(optional_idx = 4)]
    pub connect_to5_gc_r15: Option<RRCConnectionSetupComplete_v1530_IEsConnectTo5GC_r15>,
    #[asn(optional_idx = 5)]
    pub registered_amf_r15: Option<RegisteredAMF_r15>,
    #[asn(optional_idx = 6)]
    pub s_nssai_list_r15: Option<RRCConnectionSetupComplete_v1530_IEsS_NSSAI_list_r15>,
    #[asn(optional_idx = 7)]
    pub ng_5g_s_tmsi_bits_r15: Option<RRCConnectionSetupComplete_v1530_IEsNg_5G_S_TMSI_Bits_r15>,
    #[asn(optional_idx = 8)]
    pub non_critical_extension: Option<RRCConnectionSetupComplete_v1540_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct RRCConnectionSetupComplete_v1540_IEs {
    #[asn(optional_idx = 0)]
    pub gummei_type_v1540: Option<RRCConnectionSetupComplete_v1540_IEsGummei_Type_v1540>,
    #[asn(optional_idx = 1)]
    pub guami_type_r15: Option<RRCConnectionSetupComplete_v1540_IEsGuami_Type_r15>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<RRCConnectionSetupComplete_v1610_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 7)]
pub struct RRCConnectionSetupComplete_v1610_IEs {
    #[asn(optional_idx = 0)]
    pub rlos_request_r16: Option<RRCConnectionSetupComplete_v1610_IEsRlos_Request_r16>,
    #[asn(optional_idx = 1)]
    pub cp_c_io_t_5gs_optimisation_r16:
        Option<RRCConnectionSetupComplete_v1610_IEsCp_CIoT_5GS_Optimisation_r16>,
    #[asn(optional_idx = 2)]
    pub up_c_io_t_5gs_optimisation_r16:
        Option<RRCConnectionSetupComplete_v1610_IEsUp_CIoT_5GS_Optimisation_r16>,
    #[asn(optional_idx = 3)]
    pub pur_config_id_r16: Option<PUR_ConfigID_r16>,
    #[asn(optional_idx = 4)]
    pub lte_m_r16: Option<RRCConnectionSetupComplete_v1610_IEsLte_M_r16>,
    #[asn(optional_idx = 5)]
    pub iab_node_indication_r16: Option<RRCConnectionSetupComplete_v1610_IEsIab_NodeIndication_r16>,
    #[asn(optional_idx = 6)]
    pub non_critical_extension: Option<RRCConnectionSetupComplete_v1690_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionSetupComplete_v1690_IEs {
    #[asn(optional_idx = 0)]
    pub ul_rrc_segmentation_r16:
        Option<RRCConnectionSetupComplete_v1690_IEsUl_RRC_Segmentation_r16>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionSetupComplete_v1710_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionSetupComplete_v1710_IEs {
    #[asn(optional_idx = 0)]
    pub gnss_validity_duration_r17: Option<GNSS_ValidityDuration_r17>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionSetupComplete_v1710_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionSetupComplete_v8a0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<RRCConnectionSetupComplete_v8a0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCConnectionSetupComplete_v1020_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCEarlyDataComplete_r15 {
    pub critical_extensions: RRCEarlyDataComplete_r15CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct RRCEarlyDataComplete_r15_IEs {
    #[asn(optional_idx = 0)]
    pub dedicated_info_nas_r15: Option<DedicatedInfoNAS>,
    #[asn(optional_idx = 1)]
    pub extended_wait_time_r15: Option<RRCEarlyDataComplete_r15_IEsExtendedWaitTime_r15>,
    #[asn(optional_idx = 2)]
    pub idle_mode_mobility_control_info_r15: Option<IdleModeMobilityControlInfo>,
    #[asn(optional_idx = 3)]
    pub idle_mode_mobility_control_info_ext_r15: Option<IdleModeMobilityControlInfo_v9e0>,
    #[asn(optional_idx = 4)]
    pub redirected_carrier_info_r15: Option<RedirectedCarrierInfo_r15_IEs>,
    #[asn(optional_idx = 5)]
    pub non_critical_extension: Option<RRCEarlyDataComplete_v1590_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCEarlyDataComplete_v1590_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<RRCEarlyDataComplete_v1590_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCEarlyDataComplete_v1590_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCEarlyDataRequest_5GC_r16_IEs {
    pub ng_5g_s_tmsi_r16: NG_5G_S_TMSI_r15,
    pub establishment_cause_r16: RRCEarlyDataRequest_5GC_r16_IEsEstablishmentCause_r16,
    pub dedicated_info_nas_r16: DedicatedInfoNAS,
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<RRCEarlyDataRequest_5GC_r16_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCEarlyDataRequest_5GC_r16_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCEarlyDataRequest_r15 {
    pub critical_extensions: RRCEarlyDataRequest_r15CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RRCEarlyDataRequest_r15_IEs {
    pub s_tmsi_r15: S_TMSI,
    pub establishment_cause_r15: RRCEarlyDataRequest_r15_IEsEstablishmentCause_r15,
    pub dedicated_info_nas_r15: DedicatedInfoNAS,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<RRCEarlyDataRequest_v1590_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCEarlyDataRequest_v1590_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<RRCEarlyDataRequest_v1590_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<RRCEarlyDataRequest_v1610_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RRCEarlyDataRequest_v1610_IEs {
    pub establishment_cause_v1610: RRCEarlyDataRequest_v1610_IEsEstablishmentCause_v1610,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<RRCEarlyDataRequest_v1610_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RRM_Config {
    #[asn(optional_idx = 0)]
    pub ue_inactive_time: Option<RRM_ConfigUe_InactiveTime>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RS_ConfigSSB_NR_r15 {
    pub meas_timing_config_r15: MTC_SSB_NR_r15,
    pub subcarrier_spacing_ssb_r15: RS_ConfigSSB_NR_r15SubcarrierSpacingSSB_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63")]
pub struct RS_IndexNR_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "127")]
pub struct RS_SINR_Range_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "127")]
pub struct RS_SINR_RangeNR_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct RSRP_ChangeThresh_r16(pub u8);
impl RSRP_ChangeThresh_r16 {
    pub const D_B4: u8 = 0u8;
    pub const D_B6: u8 = 1u8;
    pub const D_B8: u8 = 2u8;
    pub const D_B10: u8 = 3u8;
    pub const D_B14: u8 = 4u8;
    pub const D_B18: u8 = 5u8;
    pub const D_B22: u8 = 6u8;
    pub const D_B26: u8 = 7u8;
    pub const D_B30: u8 = 8u8;
    pub const D_B34: u8 = 9u8;
    pub const SPARE6: u8 = 10u8;
    pub const SPARE5: u8 = 11u8;
    pub const SPARE4: u8 = 12u8;
    pub const SPARE3: u8 = 13u8;
    pub const SPARE2: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "97")]
pub struct RSRP_Range(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-17", ub = "-1")]
pub struct RSRP_Range_v1360(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "127")]
pub struct RSRP_RangeNR_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "13")]
pub struct RSRP_RangeSL_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct RSRP_RangeSL2_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "11")]
pub struct RSRP_RangeSL3_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "49")]
pub struct RSRP_RangeSL4_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct RSRP_ThresholdsPrachInfoList_r13(pub Vec<RSRP_Range>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "34")]
pub struct RSRQ_Range(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-30", ub = "46")]
pub struct RSRQ_Range_r13(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-30", ub = "46")]
pub struct RSRQ_Range_v1250(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RSRQ_RangeConfig_r12 {
    #[asn(key = 0, extended = false)]
    Release(RSRQ_RangeConfig_r12_release),
    #[asn(key = 1, extended = false)]
    Setup(RSRQ_Range_v1250),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "127")]
pub struct RSRQ_RangeNR_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RSRQ_Type_r12 {
    pub all_symbols_r12: RSRQ_Type_r12AllSymbols_r12,
    pub wide_band_r12: RSRQ_Type_r12WideBand_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RSS_Config_r15 {
    pub duration_r15: RSS_Config_r15Duration_r15,
    pub freq_location_r15: RSS_Config_r15FreqLocation_r15,
    pub periodicity_r15: RSS_Config_r15Periodicity_r15,
    pub power_boost_r15: RSS_Config_r15PowerBoost_r15,
    pub time_offset_r15: RSS_Config_r15TimeOffset_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RSS_ConfigCarrierInfo_r16 {
    pub narrowband_index_r16: RSS_ConfigCarrierInfo_r16NarrowbandIndex_r16,
    pub time_offset_granularity_r16: RSS_ConfigCarrierInfo_r16TimeOffsetGranularity_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct RSS_MeasPowerBias_r16(pub u8);
impl RSS_MeasPowerBias_r16 {
    pub const D_B_6: u8 = 0u8;
    pub const D_B_3: u8 = 1u8;
    pub const D_B0: u8 = 2u8;
    pub const D_B3: u8 = 3u8;
    pub const D_B6: u8 = 4u8;
    pub const D_B9: u8 = 5u8;
    pub const D_B12: u8 = 6u8;
    pub const RSS_NOT_USED: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "76")]
pub struct RSSI_Range_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RSTD_InterFreqInfo_r10 {
    pub carrier_freq_r10: ARFCN_ValueEUTRA,
    pub meas_prs_offset_r10: RSTD_InterFreqInfo_r10MeasPRS_Offset_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct RSTD_InterFreqInfoList_r10(pub Vec<RSTD_InterFreqInfo_r10>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 9)]
pub struct RadioResourceConfigCommon {
    #[asn(optional_idx = 0)]
    pub rach_config_common: Option<RACH_ConfigCommon>,
    pub prach_config: PRACH_Config,
    #[asn(optional_idx = 1)]
    pub pdsch_config_common: Option<PDSCH_ConfigCommon>,
    pub pusch_config_common: PUSCH_ConfigCommon,
    #[asn(optional_idx = 2)]
    pub phich_config: Option<PHICH_Config>,
    #[asn(optional_idx = 3)]
    pub pucch_config_common: Option<PUCCH_ConfigCommon>,
    #[asn(optional_idx = 4)]
    pub sounding_rs_ul_config_common: Option<SoundingRS_UL_ConfigCommon>,
    #[asn(optional_idx = 5)]
    pub uplink_power_control_common: Option<UplinkPowerControlCommon>,
    #[asn(optional_idx = 6)]
    pub antenna_info_common: Option<AntennaInfoCommon>,
    #[asn(optional_idx = 7)]
    pub p_max: Option<P_Max>,
    #[asn(optional_idx = 8)]
    pub tdd_config: Option<TDD_Config>,
    pub ul_cyclic_prefix_length: UL_CyclicPrefixLength,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RadioResourceConfigCommonPSCell_r12 {
    pub basic_fields_r12: RadioResourceConfigCommonSCell_r10,
    pub pucch_config_common_r12: PUCCH_ConfigCommon,
    pub rach_config_common_r12: RACH_ConfigCommon,
    pub uplink_power_control_common_ps_cell_r12: UplinkPowerControlCommonPSCell_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RadioResourceConfigCommonPSCell_v12f0 {
    pub basic_fields_v12f0: RadioResourceConfigCommonSCell_v10l0,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RadioResourceConfigCommonPSCell_v1440 {
    pub basic_fields_v1440: RadioResourceConfigCommonSCell_v1440,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RadioResourceConfigCommonSCell_r10 {
    pub non_ul_configuration_r10: RadioResourceConfigCommonSCell_r10NonUL_Configuration_r10,
    #[asn(optional_idx = 0)]
    pub ul_configuration_r10: Option<RadioResourceConfigCommonSCell_r10Ul_Configuration_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RadioResourceConfigCommonSCell_v10l0 {
    pub ul_configuration_v10l0: RadioResourceConfigCommonSCell_v10l0Ul_Configuration_v10l0,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RadioResourceConfigCommonSCell_v1440 {
    pub ul_configuration_v1440: RadioResourceConfigCommonSCell_v1440Ul_Configuration_v1440,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RadioResourceConfigCommonSIB {
    pub rach_config_common: RACH_ConfigCommon,
    pub bcch_config: BCCH_Config,
    pub pcch_config: PCCH_Config,
    pub prach_config: PRACH_ConfigSIB,
    pub pdsch_config_common: PDSCH_ConfigCommon,
    pub pusch_config_common: PUSCH_ConfigCommon,
    pub pucch_config_common: PUCCH_ConfigCommon,
    pub sounding_rs_ul_config_common: SoundingRS_UL_ConfigCommon,
    pub uplink_power_control_common: UplinkPowerControlCommon,
    pub ul_cyclic_prefix_length: UL_CyclicPrefixLength,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 6)]
pub struct RadioResourceConfigDedicated {
    #[asn(optional_idx = 0)]
    pub srb_to_add_mod_list: Option<SRB_ToAddModList>,
    #[asn(optional_idx = 1)]
    pub drb_to_add_mod_list: Option<DRB_ToAddModList>,
    #[asn(optional_idx = 2)]
    pub drb_to_release_list: Option<DRB_ToReleaseList>,
    #[asn(optional_idx = 3)]
    pub mac_main_config: Option<RadioResourceConfigDedicatedMac_MainConfig>,
    #[asn(optional_idx = 4)]
    pub sps_config: Option<SPS_Config>,
    #[asn(optional_idx = 5)]
    pub physical_config_dedicated: Option<PhysicalConfigDedicated>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RadioResourceConfigDedicated_v1370 {
    #[asn(optional_idx = 0)]
    pub physical_config_dedicated_v1370: Option<PhysicalConfigDedicated_v1370>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RadioResourceConfigDedicated_v13c0 {
    pub physical_config_dedicated_v13c0: PhysicalConfigDedicated_v13c0,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct RadioResourceConfigDedicatedPSCell_r12 {
    #[asn(optional_idx = 0)]
    pub physical_config_dedicated_ps_cell_r12: Option<PhysicalConfigDedicated>,
    #[asn(optional_idx = 1)]
    pub sps_config_r12: Option<SPS_Config>,
    #[asn(optional_idx = 2)]
    pub naics_info_r12: Option<NAICS_AssistanceInfo_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RadioResourceConfigDedicatedPSCell_v1370 {
    #[asn(optional_idx = 0)]
    pub physical_config_dedicated_ps_cell_v1370: Option<PhysicalConfigDedicated_v1370>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RadioResourceConfigDedicatedPSCell_v13c0 {
    pub physical_config_dedicated_ps_cell_v13c0: PhysicalConfigDedicated_v13c0,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct RadioResourceConfigDedicatedSCG_r12 {
    #[asn(optional_idx = 0)]
    pub drb_to_add_mod_list_scg_r12: Option<DRB_ToAddModListSCG_r12>,
    #[asn(optional_idx = 1)]
    pub mac_main_config_scg_r12: Option<MAC_MainConfig>,
    #[asn(optional_idx = 2)]
    pub rlf_timers_and_constants_scg_r12: Option<RLF_TimersAndConstantsSCG_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RadioResourceConfigDedicatedSCell_r10 {
    #[asn(optional_idx = 0)]
    pub physical_config_dedicated_s_cell_r10: Option<PhysicalConfigDedicatedSCell_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RadioResourceConfigDedicatedSCell_v13c0 {
    pub physical_config_dedicated_s_cell_v13c0: PhysicalConfigDedicatedSCell_v13c0,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "5", extensible = true)]
pub enum RedirectedCarrierInfo {
    #[asn(key = 0, extended = false)]
    Eutra(ARFCN_ValueEUTRA),
    #[asn(key = 1, extended = false)]
    Geran(CarrierFreqsGERAN),
    #[asn(key = 2, extended = false)]
    Utra_FDD(ARFCN_ValueUTRA),
    #[asn(key = 3, extended = false)]
    Utra_TDD(ARFCN_ValueUTRA),
    #[asn(key = 4, extended = false)]
    Cdma2000_HRPD(CarrierFreqCDMA2000),
    #[asn(key = 5, extended = false)]
    Cdma2000_1xRTT(CarrierFreqCDMA2000),
    #[asn(key = 0, extended = true)]
    Utra_TDD_r10(CarrierFreqListUTRA_TDD_r10),
    #[asn(key = 1, extended = true)]
    Nr_r15(CarrierInfoNR_r15),
    #[asn(key = 2, extended = true)]
    Nr_r17(CarrierInfoNR_r17),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "5", extensible = false)]
pub enum RedirectedCarrierInfo_r15_IEs {
    #[asn(key = 0, extended = false)]
    Eutra(ARFCN_ValueEUTRA_r9),
    #[asn(key = 1, extended = false)]
    Geran(CarrierFreqsGERAN),
    #[asn(key = 2, extended = false)]
    Utra_FDD(ARFCN_ValueUTRA),
    #[asn(key = 3, extended = false)]
    Cdma2000_HRPD(CarrierFreqCDMA2000),
    #[asn(key = 4, extended = false)]
    Cdma2000_1xRTT(CarrierFreqCDMA2000),
    #[asn(key = 5, extended = false)]
    Utra_TDD(CarrierFreqListUTRA_TDD_r10),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RedirectedCarrierInfo_v9e0 {
    pub eutra_v9e0: ARFCN_ValueEUTRA_v9e0,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "10")]
pub struct RedistributionFactor_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RedistributionInterFreqInfo_r13 {
    #[asn(optional_idx = 0)]
    pub redistribution_factor_freq_r13: Option<RedistributionFactor_r13>,
    #[asn(optional_idx = 1)]
    pub redistribution_neigh_cell_list_r13: Option<RedistributionNeighCellList_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RedistributionNeighCell_r13 {
    pub phys_cell_id_r13: PhysCellId,
    pub redistribution_factor_cell_r13: RedistributionFactor_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct RedistributionNeighCellList_r13(pub Vec<RedistributionNeighCell_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RedistributionServingInfo_r13 {
    pub redistribution_factor_serving_r13:
        RedistributionServingInfo_r13RedistributionFactorServing_r13,
    #[asn(optional_idx = 0)]
    pub redistribution_factor_cell_r13:
        Option<RedistributionServingInfo_r13RedistributionFactorCell_r13>,
    pub t360_r13: RedistributionServingInfo_r13T360_r13,
    #[asn(optional_idx = 1)]
    pub redistr_on_paging_only_r13: Option<RedistributionServingInfo_r13RedistrOnPagingOnly_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReestabUE_Identity {
    pub c_rnti: C_RNTI,
    pub phys_cell_id: PhysCellId,
    pub short_mac_i: ShortMAC_I,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct ReestablishmentCause(pub u8);
impl ReestablishmentCause {
    pub const RECONFIGURATION_FAILURE: u8 = 0u8;
    pub const HANDOVER_FAILURE: u8 = 1u8;
    pub const OTHER_FAILURE: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ReestablishmentInfo {
    pub source_phys_cell_id: PhysCellId,
    pub target_cell_short_mac_i: ShortMAC_I,
    #[asn(optional_idx = 0)]
    pub additional_reestab_info_list: Option<AdditionalReestabInfoList>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReferenceTime_r15 {
    pub ref_days_r15: ReferenceTime_r15RefDays_r15,
    pub ref_seconds_r15: ReferenceTime_r15RefSeconds_r15,
    pub ref_milli_seconds_r15: ReferenceTime_r15RefMilliSeconds_r15,
    pub ref_quarter_micro_seconds_r15: ReferenceTime_r15RefQuarterMicroSeconds_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RegisteredAMF_r15 {
    #[asn(optional_idx = 0)]
    pub plmn_identity_r15: Option<PLMN_Identity>,
    pub amf_identifier_r15: AMF_Identifier_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RegisteredMME {
    #[asn(optional_idx = 0)]
    pub plmn_identity: Option<PLMN_Identity>,
    pub mmegi: RegisteredMMEMmegi,
    pub mmec: MMEC,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct ReleaseCause(pub u8);
impl ReleaseCause {
    pub const LOAD_BALANCING_TA_UREQUIRED: u8 = 0u8;
    pub const OTHER: u8 = 1u8;
    pub const CS_FALLBACK_HIGH_PRIORITY_V1020: u8 = 2u8;
    pub const RRC_SUSPEND_V1320: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ReportConfigEUTRA {
    pub trigger_type: ReportConfigEUTRATriggerType,
    pub trigger_quantity: ReportConfigEUTRATriggerQuantity,
    pub report_quantity: ReportConfigEUTRAReportQuantity,
    pub max_report_cells: ReportConfigEUTRAMaxReportCells,
    pub report_interval: ReportInterval,
    pub report_amount: ReportConfigEUTRAReportAmount,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct ReportConfigId(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ReportConfigInterRAT {
    pub trigger_type: ReportConfigInterRATTriggerType,
    pub max_report_cells: ReportConfigInterRATMaxReportCells,
    pub report_interval: ReportInterval,
    pub report_amount: ReportConfigInterRATReportAmount,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReportConfigToAddMod {
    pub report_config_id: ReportConfigId,
    pub report_config: ReportConfigToAddModReportConfig,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct ReportConfigToAddModList(pub Vec<ReportConfigToAddMod>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct ReportConfigToRemoveList(pub Vec<ReportConfigId>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct ReportInterval(pub u8);
impl ReportInterval {
    pub const MS120: u8 = 0u8;
    pub const MS240: u8 = 1u8;
    pub const MS480: u8 = 2u8;
    pub const MS640: u8 = 3u8;
    pub const MS1024: u8 = 4u8;
    pub const MS2048: u8 = 5u8;
    pub const MS5120: u8 = 6u8;
    pub const MS10240: u8 = 7u8;
    pub const MIN1: u8 = 8u8;
    pub const MIN6: u8 = 9u8;
    pub const MIN12: u8 = 10u8;
    pub const MIN30: u8 = 11u8;
    pub const MIN60: u8 = 12u8;
    pub const SPARE3: u8 = 13u8;
    pub const SPARE2: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct ReportProximityConfig_r9 {
    #[asn(optional_idx = 0)]
    pub proximity_indication_eutra_r9: Option<ReportProximityConfig_r9ProximityIndicationEUTRA_r9>,
    #[asn(optional_idx = 1)]
    pub proximity_indication_utra_r9: Option<ReportProximityConfig_r9ProximityIndicationUTRA_r9>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReportQuantityNR_r15 {
    pub ss_rsrp: ReportQuantityNR_r15Ss_rsrp,
    pub ss_rsrq: ReportQuantityNR_r15Ss_rsrq,
    pub ss_sinr: ReportQuantityNR_r15Ss_sinr,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 7)]
pub struct ReportQuantityWLAN_r13 {
    #[asn(optional_idx = 0)]
    pub band_request_wlan_r13: Option<ReportQuantityWLAN_r13BandRequestWLAN_r13>,
    #[asn(optional_idx = 1)]
    pub carrier_info_request_wlan_r13: Option<ReportQuantityWLAN_r13CarrierInfoRequestWLAN_r13>,
    #[asn(optional_idx = 2)]
    pub available_admission_capacity_request_wlan_r13:
        Option<ReportQuantityWLAN_r13AvailableAdmissionCapacityRequestWLAN_r13>,
    #[asn(optional_idx = 3)]
    pub backhaul_dl_bandwidth_request_wlan_r13:
        Option<ReportQuantityWLAN_r13BackhaulDL_BandwidthRequestWLAN_r13>,
    #[asn(optional_idx = 4)]
    pub backhaul_ul_bandwidth_request_wlan_r13:
        Option<ReportQuantityWLAN_r13BackhaulUL_BandwidthRequestWLAN_r13>,
    #[asn(optional_idx = 5)]
    pub channel_utilization_request_wlan_r13:
        Option<ReportQuantityWLAN_r13ChannelUtilizationRequestWLAN_r13>,
    #[asn(optional_idx = 6)]
    pub station_count_request_wlan_r13: Option<ReportQuantityWLAN_r13StationCountRequestWLAN_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct ReselectionInfoRelay_r13 {
    pub q_rx_lev_min_r13: Q_RxLevMin,
    pub filter_coefficient_r13: FilterCoefficient,
    #[asn(optional_idx = 0)]
    pub min_hyst_r13: Option<ReselectionInfoRelay_r13MinHyst_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct ReselectionThreshold(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct ReselectionThresholdQ_r9(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct ResourceConfig_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct ResourceReservationConfigDL_r16 {
    pub periodicity_start_pos_r16: PeriodicityStartPos_r16,
    #[asn(optional_idx = 0)]
    pub resource_reservation_freq_r16:
        Option<ResourceReservationConfigDL_r16ResourceReservationFreq_r16>,
    pub slot_bitmap_r16: ResourceReservationConfigDL_r16SlotBitmap_r16,
    #[asn(optional_idx = 1)]
    pub symbol_bitmap1_r16: Option<ResourceReservationConfigDL_r16SymbolBitmap1_r16>,
    #[asn(optional_idx = 2)]
    pub symbol_bitmap2_r16: Option<ResourceReservationConfigDL_r16SymbolBitmap2_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct ResourceReservationConfigDedicatedDL_r16 {
    #[asn(optional_idx = 0)]
    pub resource_reservation_dedicated_dl_r16: Option<ResourceReservationConfigDL_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct ResourceReservationConfigDedicatedUL_r16 {
    #[asn(optional_idx = 0)]
    pub resource_reservation_dedicated_ul_r16: Option<ResourceReservationConfigUL_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct ResourceReservationConfigUL_r16 {
    pub periodicity_start_pos_r16: PeriodicityStartPos_r16,
    #[asn(optional_idx = 0)]
    pub slot_bitmap_r16: Option<ResourceReservationConfigUL_r16SlotBitmap_r16>,
    #[asn(optional_idx = 1)]
    pub symbol_bitmap1_r16: Option<ResourceReservationConfigUL_r16SymbolBitmap1_r16>,
    #[asn(optional_idx = 2)]
    pub symbol_bitmap2_r16: Option<ResourceReservationConfigUL_r16SymbolBitmap2_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct ResultsPerSSB_IndexIdle_r16 {
    pub ssb_index_r16: RS_IndexNR_r15,
    #[asn(optional_idx = 0)]
    pub ssb_results_r16: Option<ResultsPerSSB_IndexIdle_r16Ssb_Results_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct ResultsPerSSB_IndexList_r16(pub Vec<ResultsPerSSB_IndexIdle_r16>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct ResumeCause(pub u8);
impl ResumeCause {
    pub const EMERGENCY: u8 = 0u8;
    pub const HIGH_PRIORITY_ACCESS: u8 = 1u8;
    pub const MT_ACCESS: u8 = 2u8;
    pub const MO_SIGNALLING: u8 = 3u8;
    pub const MO_DATA: u8 = 4u8;
    pub const DELAY_TOLERANT_ACCESS_V1020: u8 = 5u8;
    pub const MO_VOICE_CALL_V1280: u8 = 6u8;
    pub const MT_EDT_V1610: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct ResumeCause_r15(pub u8);
impl ResumeCause_r15 {
    pub const EMERGENCY: u8 = 0u8;
    pub const HIGH_PRIORITY_ACCESS: u8 = 1u8;
    pub const MT_ACCESS: u8 = 2u8;
    pub const MO_SIGNALLING: u8 = 3u8;
    pub const MO_DATA: u8 = 4u8;
    pub const RNA_UPDATE: u8 = 5u8;
    pub const MO_VOICE_CALL: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "40", sz_ub = "40")]
pub struct ResumeIdentity_r13(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct RetxBSR_Timer_r12(pub u8);
impl RetxBSR_Timer_r12 {
    pub const SF320: u8 = 0u8;
    pub const SF640: u8 = 1u8;
    pub const SF1280: u8 = 2u8;
    pub const SF2560: u8 = 3u8;
    pub const SF5120: u8 = 4u8;
    pub const SF10240: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum S_NSSAI_r15 {
    #[asn(key = 0, extended = false)]
    Sst(S_NSSAI_r15_sst),
    #[asn(key = 1, extended = false)]
    Sst_SD(S_NSSAI_r15_sst_SD),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct S_TMSI {
    pub mmec: MMEC,
    pub m_tmsi: S_TMSIM_TMSI,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SBAS_ID_r15 {
    pub sbas_id_r15: SBAS_ID_r15Sbas_id_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SBCCH_SL_BCH_Message {
    pub message: SBCCH_SL_BCH_MessageType,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SBCCH_SL_BCH_Message_V2X_r14 {
    pub message: SBCCH_SL_BCH_MessageType_V2X_r14,
}

pub type SBCCH_SL_BCH_MessageType = MasterInformationBlock_SL;

pub type SBCCH_SL_BCH_MessageType_V2X_r14 = MasterInformationBlock_SL_V2X_r14;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SC_MCCH_Message_r13 {
    pub message: SC_MCCH_MessageType_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SC_MCCH_MessageType_r13 {
    #[asn(key = 0, extended = false)]
    C1(SC_MCCH_MessageType_r13_c1),
    #[asn(key = 1, extended = false)]
    MessageClassExtension(SC_MCCH_MessageType_r13_messageClassExtension),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SC_MCCH_SchedulingInfo_r14 {
    pub on_duration_timer_scptm_r14: SC_MCCH_SchedulingInfo_r14OnDurationTimerSCPTM_r14,
    pub drx_inactivity_timer_scptm_r14: SC_MCCH_SchedulingInfo_r14Drx_InactivityTimerSCPTM_r14,
    pub scheduling_period_start_offset_scptm_r14:
        SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct SC_MTCH_Info_BR_r14 {
    pub sc_mtch_carrier_freq_r14: ARFCN_ValueEUTRA_r9,
    pub mbms_session_info_r14: MBMSSessionInfo_r13,
    pub g_rnti_r14: SC_MTCH_Info_BR_r14G_RNTI_r14,
    #[asn(optional_idx = 0)]
    pub sc_mtch_scheduling_info_r14: Option<SC_MTCH_SchedulingInfo_BR_r14>,
    #[asn(optional_idx = 1)]
    pub sc_mtch_neighbour_cell_r14: Option<SC_MTCH_Info_BR_r14Sc_mtch_neighbourCell_r14>,
    pub mpdcch_narrowband_sc_mtch_r14: SC_MTCH_Info_BR_r14Mpdcch_Narrowband_SC_MTCH_r14,
    pub mpdcch_num_repetition_sc_mtch_r14: SC_MTCH_Info_BR_r14Mpdcch_NumRepetition_SC_MTCH_r14,
    pub mpdcch_start_sf_sc_mtch_r14: SC_MTCH_Info_BR_r14Mpdcch_StartSF_SC_MTCH_r14,
    pub mpdcch_pdsch_hopping_config_sc_mtch_r14:
        SC_MTCH_Info_BR_r14Mpdcch_PDSCH_HoppingConfig_SC_MTCH_r14,
    pub mpdcch_pdsch_c_emode_config_sc_mtch_r14:
        SC_MTCH_Info_BR_r14Mpdcch_PDSCH_CEmodeConfig_SC_MTCH_r14,
    pub mpdcch_pdsch_max_bandwidth_sc_mtch_r14:
        SC_MTCH_Info_BR_r14Mpdcch_PDSCH_MaxBandwidth_SC_MTCH_r14,
    pub mpdcch_offset_sc_mtch_r14: SC_MTCH_Info_BR_r14Mpdcch_Offset_SC_MTCH_r14,
    #[asn(optional_idx = 2)]
    pub p_a_r14: Option<SC_MTCH_Info_BR_r14P_a_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SC_MTCH_Info_r13 {
    pub mbms_session_info_r13: MBMSSessionInfo_r13,
    pub g_rnti_r13: SC_MTCH_Info_r13G_RNTI_r13,
    #[asn(optional_idx = 0)]
    pub sc_mtch_scheduling_info_r13: Option<SC_MTCH_SchedulingInfo_r13>,
    #[asn(optional_idx = 1)]
    pub sc_mtch_neighbour_cell_r13: Option<SC_MTCH_Info_r13Sc_mtch_neighbourCell_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "128"
)]
pub struct SC_MTCH_InfoList_BR_r14(pub Vec<SC_MTCH_Info_BR_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "1023"
)]
pub struct SC_MTCH_InfoList_r13(pub Vec<SC_MTCH_Info_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SC_MTCH_SchedulingInfo_BR_r14 {
    pub on_duration_timer_scptm_r14: SC_MTCH_SchedulingInfo_BR_r14OnDurationTimerSCPTM_r14,
    pub drx_inactivity_timer_scptm_r14: SC_MTCH_SchedulingInfo_BR_r14Drx_InactivityTimerSCPTM_r14,
    pub scheduling_period_start_offset_scptm_r14:
        SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SC_MTCH_SchedulingInfo_r13 {
    pub on_duration_timer_scptm_r13: SC_MTCH_SchedulingInfo_r13OnDurationTimerSCPTM_r13,
    pub drx_inactivity_timer_scptm_r13: SC_MTCH_SchedulingInfo_r13Drx_InactivityTimerSCPTM_r13,
    pub scheduling_period_start_offset_scptm_r13:
        SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SCG_Config_r12 {
    pub critical_extensions: SCG_Config_r12CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SCG_Config_r12_IEs {
    #[asn(optional_idx = 0)]
    pub scg_radio_config_r12: Option<SCG_ConfigPartSCG_r12>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SCG_Config_v12i0a_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SCG_Config_v12i0a_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<SCG_Config_v12i0a_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SCG_Config_v13c0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SCG_Config_v12i0b_IEs {
    #[asn(optional_idx = 0)]
    pub scg_radio_config_v12i0: Option<SCG_ConfigPartSCG_v12f0>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SCG_Config_v12i0b_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SCG_Config_v13c0_IEs {
    #[asn(optional_idx = 0)]
    pub scg_radio_config_v13c0: Option<SCG_ConfigPartSCG_v13c0>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SCG_Config_v13c0_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SCG_ConfigInfo_r12 {
    pub critical_extensions: SCG_ConfigInfo_r12CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 15)]
pub struct SCG_ConfigInfo_r12_IEs {
    #[asn(optional_idx = 0)]
    pub radio_resource_config_ded_mcg_r12: Option<RadioResourceConfigDedicated>,
    #[asn(optional_idx = 1)]
    pub s_cell_to_add_mod_list_mcg_r12: Option<SCellToAddModList_r10>,
    #[asn(optional_idx = 2)]
    pub meas_gap_config_r12: Option<MeasGapConfig>,
    #[asn(optional_idx = 3)]
    pub power_coordination_info_r12: Option<PowerCoordinationInfo_r12>,
    #[asn(optional_idx = 4)]
    pub scg_radio_config_r12: Option<SCG_ConfigPartSCG_r12>,
    #[asn(optional_idx = 5)]
    pub eutra_capability_info_r12: Option<SCG_ConfigInfo_r12_IEsEutra_CapabilityInfo_r12>,
    #[asn(optional_idx = 6)]
    pub scg_config_restrict_info_r12: Option<SCG_ConfigRestrictInfo_r12>,
    #[asn(optional_idx = 7)]
    pub mbms_interest_indication_r12: Option<SCG_ConfigInfo_r12_IEsMbmsInterestIndication_r12>,
    #[asn(optional_idx = 8)]
    pub meas_result_serv_cell_list_scg_r12: Option<MeasResultServCellListSCG_r12>,
    #[asn(optional_idx = 9)]
    pub drb_to_add_mod_list_scg_r12: Option<DRB_InfoListSCG_r12>,
    #[asn(optional_idx = 10)]
    pub drb_to_release_list_scg_r12: Option<DRB_ToReleaseList>,
    #[asn(optional_idx = 11)]
    pub s_cell_to_add_mod_list_scg_r12: Option<SCellToAddModListSCG_r12>,
    #[asn(optional_idx = 12)]
    pub s_cell_to_release_list_scg_r12: Option<SCellToReleaseList_r10>,
    #[asn(optional_idx = 13)]
    pub p_max_r12: Option<P_Max>,
    #[asn(optional_idx = 14)]
    pub non_critical_extension: Option<SCG_ConfigInfo_v1310_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct SCG_ConfigInfo_v1310_IEs {
    #[asn(optional_idx = 0)]
    pub meas_result_sstd_r13: Option<MeasResultSSTD_r13>,
    #[asn(optional_idx = 1)]
    pub s_cell_to_add_mod_list_mcg_ext_r13: Option<SCellToAddModListExt_r13>,
    #[asn(optional_idx = 2)]
    pub meas_result_serv_cell_list_scg_ext_r13: Option<MeasResultServCellListSCG_Ext_r13>,
    #[asn(optional_idx = 3)]
    pub s_cell_to_add_mod_list_scg_ext_r13: Option<SCellToAddModListSCG_Ext_r13>,
    #[asn(optional_idx = 4)]
    pub s_cell_to_release_list_scg_ext_r13: Option<SCellToReleaseListExt_r13>,
    #[asn(optional_idx = 5)]
    pub non_critical_extension: Option<SCG_ConfigInfo_v1330_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SCG_ConfigInfo_v1330_IEs {
    #[asn(optional_idx = 0)]
    pub meas_result_list_rssi_scg_r13: Option<MeasResultListRSSI_SCG_r13>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SCG_ConfigInfo_v1430_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SCG_ConfigInfo_v1430_IEs {
    #[asn(optional_idx = 0)]
    pub make_before_break_scg_req_r14: Option<SCG_ConfigInfo_v1430_IEsMakeBeforeBreakSCG_Req_r14>,
    #[asn(optional_idx = 1)]
    pub meas_gap_config_per_cc_list: Option<MeasGapConfigPerCC_List_r14>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<SCG_ConfigInfo_v1530_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SCG_ConfigInfo_v1530_IEs {
    #[asn(optional_idx = 0)]
    pub drb_to_add_mod_list_scg_r15: Option<DRB_InfoListSCG_r15>,
    #[asn(optional_idx = 1)]
    pub drb_to_release_list_scg_r15: Option<DRB_ToReleaseList_r15>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<SCG_ConfigInfo_v1530_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct SCG_ConfigPartSCG_r12 {
    #[asn(optional_idx = 0)]
    pub radio_resource_config_dedicated_scg_r12: Option<RadioResourceConfigDedicatedSCG_r12>,
    #[asn(optional_idx = 1)]
    pub s_cell_to_release_list_scg_r12: Option<SCellToReleaseList_r10>,
    #[asn(optional_idx = 2)]
    pub ps_cell_to_add_mod_r12: Option<PSCellToAddMod_r12>,
    #[asn(optional_idx = 3)]
    pub s_cell_to_add_mod_list_scg_r12: Option<SCellToAddModList_r10>,
    #[asn(optional_idx = 4)]
    pub mobility_control_info_scg_r12: Option<MobilityControlInfoSCG_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SCG_ConfigPartSCG_v12f0 {
    #[asn(optional_idx = 0)]
    pub ps_cell_to_add_mod_v12f0: Option<PSCellToAddMod_v12f0>,
    #[asn(optional_idx = 1)]
    pub s_cell_to_add_mod_list_scg_v12f0: Option<SCellToAddModList_v10l0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SCG_ConfigPartSCG_v13c0 {
    #[asn(optional_idx = 0)]
    pub s_cell_to_add_mod_list_scg_v13c0: Option<SCellToAddModList_v13c0>,
    #[asn(optional_idx = 1)]
    pub s_cell_to_add_mod_list_scg_ext_v13c0: Option<SCellToAddModListExt_v13c0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SCG_ConfigRestrictInfo_r12 {
    pub max_sch_tb_bits_dl_r12: SCG_ConfigRestrictInfo_r12MaxSCH_TB_BitsDL_r12,
    pub max_sch_tb_bits_ul_r12: SCG_ConfigRestrictInfo_r12MaxSCH_TB_BitsUL_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SCG_Configuration_r12 {
    #[asn(key = 0, extended = false)]
    Release(SCG_Configuration_r12_release),
    #[asn(key = 1, extended = false)]
    Setup(SCG_Configuration_r12_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SCG_Configuration_v12f0 {
    #[asn(key = 0, extended = false)]
    Release(SCG_Configuration_v12f0_release),
    #[asn(key = 1, extended = false)]
    Setup(SCG_Configuration_v12f0_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SCG_Configuration_v13c0 {
    #[asn(key = 0, extended = false)]
    Release(SCG_Configuration_v13c0_release),
    #[asn(key = 1, extended = false)]
    Setup(SCG_Configuration_v13c0_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SCG_DeactivationPreferenceConfig_r17 {
    pub scg_deactivation_preference_prohibit_timer_r17:
        SCG_DeactivationPreferenceConfig_r17Scg_DeactivationPreferenceProhibitTimer_r17,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SCGFailureInformation_r12 {
    pub critical_extensions: SCGFailureInformation_r12CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SCGFailureInformation_r12_IEs {
    #[asn(optional_idx = 0)]
    pub failure_report_scg_r12: Option<FailureReportSCG_r12>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SCGFailureInformation_v12d0a_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SCGFailureInformation_v12d0a_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<SCGFailureInformation_v12d0a_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SCGFailureInformation_v12d0a_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SCGFailureInformation_v12d0b_IEs {
    #[asn(optional_idx = 0)]
    pub failure_report_scg_v12d0: Option<FailureReportSCG_v12d0>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SCGFailureInformation_v12d0b_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SCGFailureInformationNR_r15 {
    pub critical_extensions: SCGFailureInformationNR_r15CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SCGFailureInformationNR_r15_IEs {
    #[asn(optional_idx = 0)]
    pub failure_report_scg_nr_r15: Option<FailureReportSCG_NR_r15>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SCGFailureInformationNR_v1590_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SCGFailureInformationNR_v1590_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<SCGFailureInformationNR_v1590_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SCGFailureInformationNR_v1590_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SCPTM_NeighbourCellList_r13(pub Vec<PCI_ARFCN_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct SCPTM_Parameters_r13 {
    #[asn(optional_idx = 0)]
    pub scptm_parallel_reception_r13: Option<SCPTM_Parameters_r13Scptm_ParallelReception_r13>,
    #[asn(optional_idx = 1)]
    pub scptm_s_cell_r13: Option<SCPTM_Parameters_r13Scptm_SCell_r13>,
    #[asn(optional_idx = 2)]
    pub scptm_non_serving_cell_r13: Option<SCPTM_Parameters_r13Scptm_NonServingCell_r13>,
    #[asn(optional_idx = 3)]
    pub scptm_async_dc_r13: Option<SCPTM_Parameters_r13Scptm_AsyncDC_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct SCPTMConfiguration_BR_r14 {
    pub sc_mtch_info_list_r14: SC_MTCH_InfoList_BR_r14,
    #[asn(optional_idx = 0)]
    pub scptm_neighbour_cell_list_r14: Option<SCPTM_NeighbourCellList_r13>,
    #[asn(optional_idx = 1)]
    pub p_b_r14: Option<SCPTMConfiguration_BR_r14P_b_r14>,
    #[asn(optional_idx = 2)]
    pub late_non_critical_extension: Option<SCPTMConfiguration_BR_r14LateNonCriticalExtension>,
    #[asn(optional_idx = 3)]
    pub non_critical_extension: Option<SCPTMConfiguration_BR_v1610>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SCPTMConfiguration_BR_v1610 {
    pub sc_mtch_info_list_multi_tb_r16: SC_MTCH_InfoList_BR_r14,
    #[asn(optional_idx = 0)]
    pub multi_tb_gap_r16: Option<SCPTMConfiguration_BR_v1610MultiTB_Gap_r16>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SCPTMConfiguration_BR_v1610NonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SCPTMConfiguration_r13 {
    pub sc_mtch_info_list_r13: SC_MTCH_InfoList_r13,
    #[asn(optional_idx = 0)]
    pub scptm_neighbour_cell_list_r13: Option<SCPTM_NeighbourCellList_r13>,
    #[asn(optional_idx = 1)]
    pub late_non_critical_extension: Option<SCPTMConfiguration_r13LateNonCriticalExtension>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<SCPTMConfiguration_v1340>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SCPTMConfiguration_v1340 {
    #[asn(optional_idx = 0)]
    pub p_b_r13: Option<SCPTMConfiguration_v1340P_b_r13>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SCPTMConfiguration_v1340NonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SCellConfigCommon_r15 {
    #[asn(optional_idx = 0)]
    pub radio_resource_config_common_s_cell_r15: Option<RadioResourceConfigCommonSCell_r10>,
    #[asn(optional_idx = 1)]
    pub radio_resource_config_dedicated_s_cell_r15: Option<RadioResourceConfigDedicatedSCell_r10>,
    #[asn(optional_idx = 2)]
    pub antenna_info_dedicated_s_cell_r15: Option<AntennaInfoDedicated_v10i0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4")]
pub struct SCellGroupIndex_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SCellGroupToAddMod_r15 {
    pub s_cell_group_index_r15: SCellGroupIndex_r15,
    #[asn(optional_idx = 0)]
    pub s_cell_config_common_r15: Option<SCellConfigCommon_r15>,
    #[asn(optional_idx = 1)]
    pub s_cell_to_release_list_r15: Option<SCellToReleaseListExt_r13>,
    #[asn(optional_idx = 2)]
    pub s_cell_to_add_mod_list_r15: Option<SCellToAddModListExt_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SCellGroupToAddModList_r15(pub Vec<SCellGroupToAddMod_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SCellGroupToReleaseList_r15(pub Vec<SCellGroupIndex_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "7")]
pub struct SCellIndex_r10(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "31")]
pub struct SCellIndex_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct SCellToAddMod_r10 {
    pub s_cell_index_r10: SCellIndex_r10,
    #[asn(optional_idx = 0)]
    pub cell_identification_r10: Option<SCellToAddMod_r10CellIdentification_r10>,
    #[asn(optional_idx = 1)]
    pub radio_resource_config_common_s_cell_r10: Option<RadioResourceConfigCommonSCell_r10>,
    #[asn(optional_idx = 2)]
    pub radio_resource_config_dedicated_s_cell_r10: Option<RadioResourceConfigDedicatedSCell_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 6)]
pub struct SCellToAddMod_r16 {
    pub s_cell_index_r16: SCellIndex_r13,
    #[asn(optional_idx = 0)]
    pub cell_identification_r16: Option<SCellToAddMod_r16CellIdentification_r16>,
    #[asn(optional_idx = 1)]
    pub radio_resource_config_common_s_cell_r16: Option<RadioResourceConfigCommonSCell_r10>,
    #[asn(optional_idx = 2)]
    pub radio_resource_config_dedicated_s_cell_r16: Option<RadioResourceConfigDedicatedSCell_r10>,
    #[asn(optional_idx = 3)]
    pub antenna_info_dedicated_s_cell_r16: Option<AntennaInfoDedicated_v10i0>,
    #[asn(optional_idx = 4)]
    pub srs_switch_from_serv_cell_index_r16:
        Option<SCellToAddMod_r16Srs_SwitchFromServCellIndex_r16>,
    #[asn(optional_idx = 5)]
    pub s_cell_state_r16: Option<SCellToAddMod_r16SCellState_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SCellToAddMod_v10l0 {
    #[asn(optional_idx = 0)]
    pub radio_resource_config_common_s_cell_v10l0: Option<RadioResourceConfigCommonSCell_v10l0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SCellToAddMod_v13c0 {
    #[asn(optional_idx = 0)]
    pub radio_resource_config_dedicated_s_cell_v13c0:
        Option<RadioResourceConfigDedicatedSCell_v13c0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct SCellToAddModExt_r13 {
    pub s_cell_index_r13: SCellIndex_r13,
    #[asn(optional_idx = 0)]
    pub cell_identification_r13: Option<SCellToAddModExt_r13CellIdentification_r13>,
    #[asn(optional_idx = 1)]
    pub radio_resource_config_common_s_cell_r13: Option<RadioResourceConfigCommonSCell_r10>,
    #[asn(optional_idx = 2)]
    pub radio_resource_config_dedicated_s_cell_r13: Option<RadioResourceConfigDedicatedSCell_r10>,
    #[asn(optional_idx = 3)]
    pub antenna_info_dedicated_s_cell_r13: Option<AntennaInfoDedicated_v10i0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SCellToAddModExt_v1370 {
    #[asn(optional_idx = 0)]
    pub radio_resource_config_common_s_cell_v1370: Option<RadioResourceConfigCommonSCell_v10l0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SCellToAddModExt_v1430 {
    #[asn(optional_idx = 0)]
    pub srs_switch_from_serv_cell_index_r14:
        Option<SCellToAddModExt_v1430Srs_SwitchFromServCellIndex_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SCellToAddModList_r10(pub Vec<SCellToAddMod_r10>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "31")]
pub struct SCellToAddModList_r16(pub Vec<SCellToAddMod_r16>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SCellToAddModList_v10l0(pub Vec<SCellToAddMod_v10l0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SCellToAddModList_v13c0(pub Vec<SCellToAddMod_v13c0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "31")]
pub struct SCellToAddModListExt_r13(pub Vec<SCellToAddModExt_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "31")]
pub struct SCellToAddModListExt_v1370(pub Vec<SCellToAddModExt_v1370>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "31")]
pub struct SCellToAddModListExt_v13c0(pub Vec<SCellToAddMod_v13c0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "31")]
pub struct SCellToAddModListExt_v1430(pub Vec<SCellToAddModExt_v1430>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "31")]
pub struct SCellToAddModListSCG_Ext_r13(pub Vec<Cell_ToAddMod_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SCellToAddModListSCG_r12(pub Vec<Cell_ToAddMod_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SCellToReleaseList_r10(pub Vec<SCellIndex_r10>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "31")]
pub struct SCellToReleaseListExt_r13(pub Vec<SCellIndex_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SI_OrPSI_GERAN {
    #[asn(key = 0, extended = false)]
    Si(SystemInfoListGERAN),
    #[asn(key = 1, extended = false)]
    Psi(SystemInfoListGERAN),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "6")]
pub struct SI_Periodicity_r12(pub u8);
impl SI_Periodicity_r12 {
    pub const RF8: u8 = 0u8;
    pub const RF16: u8 = 1u8;
    pub const RF32: u8 = 2u8;
    pub const RF64: u8 = 3u8;
    pub const RF128: u8 = 4u8;
    pub const RF256: u8 = 5u8;
    pub const RF512: u8 = 6u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "0", sz_ub = "31")]
pub struct SIB_MappingInfo(pub Vec<SIB_Type>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "0", sz_ub = "31")]
pub struct SIB_MappingInfo_MBMS_r14(pub Vec<SIB_Type_MBMS_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "31")]
pub struct SIB_MappingInfo_v12j0(pub Vec<SIB_Type_v12j0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "15")]
pub struct SIB_Type(pub u8);
impl SIB_Type {
    pub const SIB_TYPE3: u8 = 0u8;
    pub const SIB_TYPE4: u8 = 1u8;
    pub const SIB_TYPE5: u8 = 2u8;
    pub const SIB_TYPE6: u8 = 3u8;
    pub const SIB_TYPE7: u8 = 4u8;
    pub const SIB_TYPE8: u8 = 5u8;
    pub const SIB_TYPE9: u8 = 6u8;
    pub const SIB_TYPE10: u8 = 7u8;
    pub const SIB_TYPE11: u8 = 8u8;
    pub const SIB_TYPE12_V920: u8 = 9u8;
    pub const SIB_TYPE13_V920: u8 = 10u8;
    pub const SIB_TYPE14_V1130: u8 = 11u8;
    pub const SIB_TYPE15_V1130: u8 = 12u8;
    pub const SIB_TYPE16_V1130: u8 = 13u8;
    pub const SIB_TYPE17_V1250: u8 = 14u8;
    pub const SIB_TYPE18_V1250: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct SIB_Type_MBMS_r14(pub u8);
impl SIB_Type_MBMS_r14 {
    pub const SIB_TYPE10: u8 = 0u8;
    pub const SIB_TYPE11: u8 = 1u8;
    pub const SIB_TYPE12_V920: u8 = 2u8;
    pub const SIB_TYPE13_V920: u8 = 3u8;
    pub const SIB_TYPE15_V1130: u8 = 4u8;
    pub const SIB_TYPE16_V1130: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "15")]
pub struct SIB_Type_v12j0(pub u8);
impl SIB_Type_v12j0 {
    pub const SIB_TYPE19_V1250: u8 = 0u8;
    pub const SIB_TYPE20_V1310: u8 = 1u8;
    pub const SIB_TYPE21_V1430: u8 = 2u8;
    pub const SIB_TYPE24_V1530: u8 = 3u8;
    pub const SIB_TYPE25_V1530: u8 = 4u8;
    pub const SIB_TYPE26_V1530: u8 = 5u8;
    pub const SIB_TYPE26A_V1610: u8 = 6u8;
    pub const SIB_TYPE27_V1610: u8 = 7u8;
    pub const SIB_TYPE28_V1610: u8 = 8u8;
    pub const SIB_TYPE29_V1610: u8 = 9u8;
    pub const SIB_TYPE30_V1700: u8 = 10u8;
    pub const SIB_TYPE31_V1700: u8 = 11u8;
    pub const SIB_TYPE32_V1700: u8 = 12u8;
    pub const SPARE3: u8 = 13u8;
    pub const SPARE2: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct SIB8_PerPLMN_List_r11(pub Vec<SIB8_PerPLMN_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SIB8_PerPLMN_r11 {
    pub plmn_identity_r11: SIB8_PerPLMN_r11Plmn_Identity_r11,
    pub parameters_cdma2000_r11: SIB8_PerPLMN_r11ParametersCDMA2000_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_AllowedCarrierFreqList_r15 {
    pub allowed_carrier_freq_set1: SL_AllowedCarrierFreqList_r15AllowedCarrierFreqSet1,
    pub allowed_carrier_freq_set2: SL_AllowedCarrierFreqList_r15AllowedCarrierFreqSet2,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_AnchorCarrierFreqList_V2X_r14(pub Vec<ARFCN_ValueEUTRA_r9>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_CBR_CommonTxConfigList_r14 {
    pub cbr_range_common_config_list_r14:
        SL_CBR_CommonTxConfigList_r14Cbr_RangeCommonConfigList_r14,
    pub sl_cbr_pssch_tx_config_list_r14: SL_CBR_CommonTxConfigList_r14Sl_CBR_PSSCH_TxConfigList_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct SL_CBR_Levels_Config_r14(pub Vec<SL_CBR_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_CBR_PPPP_TxConfigList_r14(pub Vec<SL_PPPP_TxConfigIndex_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_CBR_PPPP_TxConfigList_r15(pub Vec<SL_PPPP_TxConfigIndex_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_CBR_PPPP_TxConfigList_v1530(pub Vec<SL_PPPP_TxConfigIndex_v1530>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_CBR_PPPP_TxPreconfigList_r14(pub Vec<SL_PPPP_TxPreconfigIndex_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_CBR_PPPP_TxPreconfigList_v1530(pub Vec<SL_PPPP_TxPreconfigIndex_v1530>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_CBR_PSSCH_TxConfig_r14 {
    pub cr_limit_r14: SL_CBR_PSSCH_TxConfig_r14Cr_Limit_r14,
    pub tx_parameters_r14: SL_PSSCH_TxParameters_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_CBR_PreconfigTxConfigList_r14 {
    pub cbr_range_common_config_list_r14:
        SL_CBR_PreconfigTxConfigList_r14Cbr_RangeCommonConfigList_r14,
    pub sl_cbr_pssch_tx_config_list_r14:
        SL_CBR_PreconfigTxConfigList_r14Sl_CBR_PSSCH_TxConfigList_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct SL_CBR_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SL_CP_Len_r12(pub u8);
impl SL_CP_Len_r12 {
    pub const NORMAL: u8 = 0u8;
    pub const EXTENDED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SL_CarrierFreqInfo_r12 {
    pub carrier_freq_r12: ARFCN_ValueEUTRA_r9,
    #[asn(optional_idx = 0)]
    pub plmn_identity_list_r12: Option<PLMN_IdentityList4_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct SL_CarrierFreqInfo_v1310 {
    #[asn(optional_idx = 0)]
    pub disc_resources_non_ps_r13: Option<SL_ResourcesInterFreq_r13>,
    #[asn(optional_idx = 1)]
    pub disc_resources_ps_r13: Option<SL_ResourcesInterFreq_r13>,
    #[asn(optional_idx = 2)]
    pub disc_config_other_r13: Option<SL_DiscConfigOtherInterFreq_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_CarrierFreqInfoList_r12(pub Vec<SL_CarrierFreqInfo_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_CarrierFreqInfoList_v1310(pub Vec<SL_CarrierFreqInfo_v1310>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SL_CommConfig_r12 {
    #[asn(optional_idx = 0)]
    pub comm_tx_resources_r12: Option<SL_CommConfig_r12CommTxResources_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct SL_CommResourcePool_r12 {
    pub sc_cp_len_r12: SL_CP_Len_r12,
    pub sc_period_r12: SL_PeriodComm_r12,
    pub sc_tf_resource_config_r12: SL_TF_ResourceConfig_r12,
    pub data_cp_len_r12: SL_CP_Len_r12,
    pub data_hopping_config_r12: SL_HoppingConfigComm_r12,
    #[asn(optional_idx = 0)]
    pub ue_selected_resource_config_r12:
        Option<SL_CommResourcePool_r12Ue_SelectedResourceConfig_r12>,
    #[asn(optional_idx = 1)]
    pub rx_parameters_n_cell_r12: Option<SL_CommResourcePool_r12RxParametersNCell_r12>,
    #[asn(optional_idx = 2)]
    pub tx_parameters_r12: Option<SL_CommResourcePool_r12TxParameters_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 11)]
pub struct SL_CommResourcePoolV2X_r14 {
    #[asn(optional_idx = 0)]
    pub sl_offset_indicator_r14: Option<SL_OffsetIndicator_r12>,
    pub sl_subframe_r14: SubframeBitmapSL_r14,
    pub adjacency_pscch_pssch_r14: SL_CommResourcePoolV2X_r14AdjacencyPSCCH_PSSCH_r14,
    pub size_subchannel_r14: SL_CommResourcePoolV2X_r14SizeSubchannel_r14,
    pub num_subchannel_r14: SL_CommResourcePoolV2X_r14NumSubchannel_r14,
    pub start_rb_subchannel_r14: SL_CommResourcePoolV2X_r14StartRB_Subchannel_r14,
    #[asn(optional_idx = 1)]
    pub start_rb_pscch_pool_r14: Option<SL_CommResourcePoolV2X_r14StartRB_PSCCH_Pool_r14>,
    #[asn(optional_idx = 2)]
    pub rx_parameters_n_cell_r14: Option<SL_CommResourcePoolV2X_r14RxParametersNCell_r14>,
    #[asn(optional_idx = 3)]
    pub data_tx_parameters_r14: Option<SL_TxParameters_r12>,
    #[asn(optional_idx = 4)]
    pub zone_id_r14: Option<SL_CommResourcePoolV2X_r14ZoneID_r14>,
    #[asn(optional_idx = 5)]
    pub thresh_s_rssi_cbr_r14: Option<SL_CommResourcePoolV2X_r14ThreshS_RSSI_CBR_r14>,
    #[asn(optional_idx = 6)]
    pub pool_report_id_r14: Option<SL_V2X_TxPoolReportIdentity_r14>,
    #[asn(optional_idx = 7)]
    pub cbr_pssch_tx_config_list_r14: Option<SL_CBR_PPPP_TxConfigList_r14>,
    #[asn(optional_idx = 8)]
    pub resource_selection_config_p2x_r14: Option<SL_P2X_ResourceSelectionConfig_r14>,
    #[asn(optional_idx = 9)]
    pub sync_allowed_r14: Option<SL_SyncAllowed_r14>,
    #[asn(optional_idx = 10)]
    pub restrict_resource_reservation_period_r14:
        Option<SL_RestrictResourceReservationPeriodList_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct SL_CommRxPoolList_r12(pub Vec<SL_CommResourcePool_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct SL_CommRxPoolListV2X_r14(pub Vec<SL_CommResourcePoolV2X_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SL_CommTxPoolList_r12(pub Vec<SL_CommResourcePool_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SL_CommTxPoolListExt_r13(pub Vec<SL_CommResourcePool_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_CommTxPoolListV2X_r14(pub Vec<SL_CommResourcePoolV2X_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SL_CommTxPoolSensingConfig_r14 {
    pub pssch_tx_config_list_r14: SL_PSSCH_TxConfigList_r14,
    pub thres_pssch_rsrp_list_r14: SL_ThresPSSCH_RSRP_List_r14,
    #[asn(optional_idx = 0)]
    pub restrict_resource_reservation_period_r14:
        Option<SL_RestrictResourceReservationPeriodList_r14>,
    pub prob_resource_keep_r14: SL_CommTxPoolSensingConfig_r14ProbResourceKeep_r14,
    #[asn(optional_idx = 1)]
    pub p2x_sensing_config_r14: Option<SL_CommTxPoolSensingConfig_r14P2x_SensingConfig_r14>,
    #[asn(optional_idx = 2)]
    pub sl_reselect_after_r14: Option<SL_CommTxPoolSensingConfig_r14Sl_ReselectAfter_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_CommTxPoolToAddMod_r12 {
    pub pool_identity_r12: SL_TxPoolIdentity_r12,
    pub pool_r12: SL_CommResourcePool_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_CommTxPoolToAddModExt_r13 {
    pub pool_identity_v1310: SL_TxPoolIdentity_v1310,
    pub pool_r13: SL_CommResourcePool_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SL_CommTxPoolToAddModList_r12(pub Vec<SL_CommTxPoolToAddMod_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SL_CommTxPoolToAddModListExt_r13(pub Vec<SL_CommTxPoolToAddModExt_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SL_CommTxResourceReq_r12 {
    #[asn(optional_idx = 0)]
    pub carrier_freq_r12: Option<ARFCN_ValueEUTRA_r9>,
    pub destination_info_list_r12: SL_DestinationInfoList_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "24", sz_ub = "24")]
pub struct SL_DestinationIdentity_r12(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct SL_DestinationInfoList_r12(pub Vec<SL_DestinationIdentity_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SL_DiscConfig_r12 {
    #[asn(optional_idx = 0)]
    pub disc_tx_resources_r12: Option<SL_DiscConfig_r12DiscTxResources_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct SL_DiscConfigOtherInterFreq_r13 {
    #[asn(optional_idx = 0)]
    pub tx_power_info_r13: Option<SL_DiscTxPowerInfoList_r12>,
    #[asn(optional_idx = 1)]
    pub ref_carrier_common_r13: Option<SL_DiscConfigOtherInterFreq_r13RefCarrierCommon_r13>,
    #[asn(optional_idx = 2)]
    pub disc_sync_config_r13: Option<SL_SyncConfigListNFreq_r13>,
    #[asn(optional_idx = 3)]
    pub disc_cell_selection_info_r13: Option<CellSelectionInfoNFreq_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct SL_DiscConfigRelayUE_r13 {
    #[asn(optional_idx = 0)]
    pub thresh_high_r13: Option<RSRP_RangeSL4_r13>,
    #[asn(optional_idx = 1)]
    pub thresh_low_r13: Option<RSRP_RangeSL4_r13>,
    #[asn(optional_idx = 2)]
    pub hyst_max_r13: Option<SL_DiscConfigRelayUE_r13HystMax_r13>,
    #[asn(optional_idx = 3)]
    pub hyst_min_r13: Option<SL_DiscConfigRelayUE_r13HystMin_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SL_DiscConfigRemoteUE_r13 {
    #[asn(optional_idx = 0)]
    pub thresh_high_r13: Option<RSRP_RangeSL4_r13>,
    #[asn(optional_idx = 1)]
    pub hyst_max_r13: Option<SL_DiscConfigRemoteUE_r13HystMax_r13>,
    pub reselection_info_ic_r13: ReselectionInfoRelay_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SL_DiscResourcePool_r12 {
    pub cp_len_r12: SL_CP_Len_r12,
    pub disc_period_r12: SL_DiscResourcePool_r12DiscPeriod_r12,
    pub num_retx_r12: SL_DiscResourcePool_r12NumRetx_r12,
    pub num_repetition_r12: SL_DiscResourcePool_r12NumRepetition_r12,
    pub tf_resource_config_r12: SL_TF_ResourceConfig_r12,
    #[asn(optional_idx = 0)]
    pub tx_parameters_r12: Option<SL_DiscResourcePool_r12TxParameters_r12>,
    #[asn(optional_idx = 1)]
    pub rx_parameters_r12: Option<SL_DiscResourcePool_r12RxParameters_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct SL_DiscRxPoolList_r12(pub Vec<SL_DiscResourcePool_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 13)]
pub struct SL_DiscSysInfoReport_r13 {
    #[asn(optional_idx = 0)]
    pub plmn_identity_list_r13: Option<PLMN_IdentityList>,
    #[asn(optional_idx = 1)]
    pub cell_identity_13: Option<CellIdentity>,
    #[asn(optional_idx = 2)]
    pub carrier_freq_info_13: Option<ARFCN_ValueEUTRA_r9>,
    #[asn(optional_idx = 3)]
    pub disc_rx_resources_r13: Option<SL_DiscRxPoolList_r12>,
    #[asn(optional_idx = 4)]
    pub disc_tx_pool_common_r13: Option<SL_DiscTxPoolList_r12>,
    #[asn(optional_idx = 5)]
    pub disc_tx_power_info_r13: Option<SL_DiscTxPowerInfoList_r12>,
    #[asn(optional_idx = 6)]
    pub disc_sync_config_r13: Option<SL_SyncConfigNFreq_r13>,
    #[asn(optional_idx = 7)]
    pub disc_cell_selection_info_r13: Option<SL_DiscSysInfoReport_r13DiscCellSelectionInfo_r13>,
    #[asn(optional_idx = 8)]
    pub cell_reselection_info_r13: Option<SL_DiscSysInfoReport_r13CellReselectionInfo_r13>,
    #[asn(optional_idx = 9)]
    pub tdd_config_r13: Option<TDD_Config>,
    #[asn(optional_idx = 10)]
    pub freq_info_r13: Option<SL_DiscSysInfoReport_r13FreqInfo_r13>,
    #[asn(optional_idx = 11)]
    pub p_max_r13: Option<P_Max>,
    #[asn(optional_idx = 12)]
    pub reference_signal_power_r13: Option<SL_DiscSysInfoReport_r13ReferenceSignalPower_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_DiscSysInfoReportFreqList_r13(pub Vec<SL_DiscSysInfoReport_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_DiscSysInfoToReportFreqList_r13(pub Vec<ARFCN_ValueEUTRA_r9>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct SL_DiscTxConfigScheduled_r13 {
    #[asn(optional_idx = 0)]
    pub disc_tx_config_r13: Option<SL_DiscResourcePool_r12>,
    #[asn(optional_idx = 1)]
    pub disc_tf_index_list_r13: Option<SL_TF_IndexPairList_r12b>,
    #[asn(optional_idx = 2)]
    pub disc_hopping_config_r13: Option<SL_HoppingConfigDisc_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SL_DiscTxInfoInterFreqListAdd_r13 {
    #[asn(optional_idx = 0)]
    pub disc_tx_freq_to_add_mod_list_r13:
        Option<SL_DiscTxInfoInterFreqListAdd_r13DiscTxFreqToAddModList_r13>,
    #[asn(optional_idx = 1)]
    pub disc_tx_freq_to_release_list_r13:
        Option<SL_DiscTxInfoInterFreqListAdd_r13DiscTxFreqToReleaseList_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SL_DiscTxPoolDedicated_r13 {
    #[asn(optional_idx = 0)]
    pub pool_to_release_list_r13: Option<SL_TxPoolToReleaseList_r12>,
    #[asn(optional_idx = 1)]
    pub pool_to_add_mod_list_r13: Option<SL_DiscTxPoolToAddModList_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SL_DiscTxPoolList_r12(pub Vec<SL_DiscResourcePool_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_DiscTxPoolToAddMod_r12 {
    pub pool_identity_r12: SL_TxPoolIdentity_r12,
    pub pool_r12: SL_DiscResourcePool_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SL_DiscTxPoolToAddModList_r12(pub Vec<SL_DiscTxPoolToAddMod_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SL_DiscTxPowerInfo_r12 {
    pub disc_max_tx_power_r12: P_Max,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct SL_DiscTxPowerInfoList_r12(pub Vec<SL_DiscTxPowerInfo_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SL_DiscTxRefCarrierDedicated_r13 {
    #[asn(key = 0, extended = false)]
    PCell(SL_DiscTxRefCarrierDedicated_r13_pCell),
    #[asn(key = 1, extended = false)]
    SCell(SCellIndex_r10),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SL_DiscTxResource_r13 {
    #[asn(key = 0, extended = false)]
    Release(SL_DiscTxResource_r13_release),
    #[asn(key = 1, extended = false)]
    Setup(SL_DiscTxResource_r13_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct SL_DiscTxResourceInfoPerFreq_r13 {
    pub disc_tx_carrier_freq_r13: ARFCN_ValueEUTRA_r9,
    #[asn(optional_idx = 0)]
    pub disc_tx_resources_r13: Option<SL_DiscTxResource_r13>,
    #[asn(optional_idx = 1)]
    pub disc_tx_resources_ps_r13: Option<SL_DiscTxResource_r13>,
    #[asn(optional_idx = 2)]
    pub disc_tx_ref_carrier_dedicated_r13: Option<SL_DiscTxRefCarrierDedicated_r13>,
    #[asn(optional_idx = 3)]
    pub disc_cell_selection_info_r13: Option<CellSelectionInfoNFreq_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SL_DiscTxResourceReq_r13 {
    #[asn(optional_idx = 0)]
    pub carrier_freq_disc_tx_r13: Option<SL_DiscTxResourceReq_r13CarrierFreqDiscTx_r13>,
    pub disc_tx_resource_req_r13: SL_DiscTxResourceReq_r13DiscTxResourceReq_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_DiscTxResourceReqPerFreqList_r13(pub Vec<SL_DiscTxResourceReq_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum SL_DiscTxResourcesInterFreq_r13 {
    #[asn(key = 0, extended = false)]
    AcquireSI_FromCarrier_r13(SL_DiscTxResourcesInterFreq_r13_acquireSI_FromCarrier_r13),
    #[asn(key = 1, extended = false)]
    DiscTxPoolCommon_r13(SL_DiscTxPoolList_r12),
    #[asn(key = 2, extended = false)]
    RequestDedicated_r13(SL_DiscTxResourcesInterFreq_r13_requestDedicated_r13),
    #[asn(key = 3, extended = false)]
    NoTxOnCarrier_r13(SL_DiscTxResourcesInterFreq_r13_noTxOnCarrier_r13),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_GapConfig_r13 {
    pub gap_pattern_list_r13: SL_GapPatternList_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SL_GapFreqInfo_r13 {
    #[asn(optional_idx = 0)]
    pub carrier_freq_r13: Option<ARFCN_ValueEUTRA_r9>,
    pub gap_pattern_list_r13: SL_GapPatternList_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SL_GapPattern_r13 {
    pub gap_period_r13: SL_GapPattern_r13GapPeriod_r13,
    pub gap_offset_r12: SL_OffsetIndicator_r12,
    pub gap_subframe_bitmap_r13: SL_GapPattern_r13GapSubframeBitmap_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_GapPatternList_r13(pub Vec<SL_GapPattern_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_GapRequest_r13(pub Vec<SL_GapFreqInfo_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_HoppingConfigComm_r12 {
    pub hopping_parameter_r12: SL_HoppingConfigComm_r12HoppingParameter_r12,
    pub num_subbands_r12: SL_HoppingConfigComm_r12NumSubbands_r12,
    pub rb_offset_r12: SL_HoppingConfigComm_r12Rb_Offset_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_HoppingConfigDisc_r12 {
    pub a_r12: SL_HoppingConfigDisc_r12A_r12,
    pub b_r12: SL_HoppingConfigDisc_r12B_r12,
    pub c_r12: SL_HoppingConfigDisc_r12C_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "0", sz_ub = "7")]
pub struct SL_InterFreqInfoListV2X_r14(pub Vec<SL_InterFreqInfoV2X_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct SL_InterFreqInfoV2X_r14 {
    #[asn(optional_idx = 0)]
    pub plmn_identity_list_r14: Option<PLMN_IdentityList>,
    pub v2x_comm_carrier_freq_r14: ARFCN_ValueEUTRA_r9,
    #[asn(optional_idx = 1)]
    pub sl_max_tx_power_r14: Option<P_Max>,
    #[asn(optional_idx = 2)]
    pub sl_bandwidth_r14: Option<SL_InterFreqInfoV2X_r14Sl_Bandwidth_r14>,
    #[asn(optional_idx = 3)]
    pub v2x_scheduling_pool_r14: Option<SL_CommResourcePoolV2X_r14>,
    #[asn(optional_idx = 4)]
    pub v2x_ue_config_list_r14: Option<SL_V2X_UE_ConfigList_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_MinT2Value_r15 {
    pub priority_list_r15: SL_PriorityList_r13,
    pub min_t2_value_r15: SL_MinT2Value_r15MinT2Value_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_MinT2ValueList_r15(pub Vec<SL_MinT2Value_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_NR_AnchorCarrierFreqList_r16(pub Vec<ARFCN_ValueNR_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SL_OffsetIndicator_r12 {
    #[asn(key = 0, extended = false)]
    Small_r12(SL_OffsetIndicator_r12_small_r12),
    #[asn(key = 1, extended = false)]
    Large_r12(SL_OffsetIndicator_r12_large_r12),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "39")]
pub struct SL_OffsetIndicatorSync_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "159")]
pub struct SL_OffsetIndicatorSync_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "40", ub = "159")]
pub struct SL_OffsetIndicatorSync_v1430(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SL_P2X_ResourceSelectionConfig_r14 {
    #[asn(optional_idx = 0)]
    pub partial_sensing_r14: Option<SL_P2X_ResourceSelectionConfig_r14PartialSensing_r14>,
    #[asn(optional_idx = 1)]
    pub random_selection_r14: Option<SL_P2X_ResourceSelectionConfig_r14RandomSelection_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_PPPP_TxConfigIndex_r14 {
    pub priority_threshold_r14: SL_Priority_r13,
    pub default_tx_config_index_r14: SL_PPPP_TxConfigIndex_r14DefaultTxConfigIndex_r14,
    pub cbr_config_index_r14: SL_PPPP_TxConfigIndex_r14Cbr_ConfigIndex_r14,
    pub tx_config_index_list_r14: SL_PPPP_TxConfigIndex_r14Tx_ConfigIndexList_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_PPPP_TxConfigIndex_r15 {
    pub priority_threshold_r15: SL_Priority_r13,
    pub default_tx_config_index_r15: SL_PPPP_TxConfigIndex_r15DefaultTxConfigIndex_r15,
    pub cbr_config_index_r15: SL_PPPP_TxConfigIndex_r15Cbr_ConfigIndex_r15,
    pub tx_config_index_list_r15: SL_PPPP_TxConfigIndex_r15Tx_ConfigIndexList_r15,
    pub mcs_pssch_range_list_r15: SL_PPPP_TxConfigIndex_r15Mcs_PSSCH_RangeList_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SL_PPPP_TxConfigIndex_v1530 {
    #[asn(optional_idx = 0)]
    pub mcs_pssch_range_list_r15: Option<SL_PPPP_TxConfigIndex_v1530Mcs_PSSCH_RangeList_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_PPPP_TxPreconfigIndex_r14 {
    pub priority_threshold_r14: SL_Priority_r13,
    pub default_tx_config_index_r14: SL_PPPP_TxPreconfigIndex_r14DefaultTxConfigIndex_r14,
    pub cbr_config_index_r14: SL_PPPP_TxPreconfigIndex_r14Cbr_ConfigIndex_r14,
    pub tx_config_index_list_r14: SL_PPPP_TxPreconfigIndex_r14Tx_ConfigIndexList_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SL_PPPP_TxPreconfigIndex_v1530 {
    #[asn(optional_idx = 0)]
    pub mcs_pssch_range_r15: Option<SL_PPPP_TxPreconfigIndex_v1530Mcs_PSSCH_Range_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SL_PPPR_Dest_CarrierFreq {
    #[asn(optional_idx = 0)]
    pub destination_info_list_r15: Option<SL_DestinationInfoList_r12>,
    #[asn(optional_idx = 1)]
    pub allowed_carrier_freq_list_r15: Option<SL_AllowedCarrierFreqList_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct SL_PPPR_Dest_CarrierFreqList_r15(pub Vec<SL_PPPR_Dest_CarrierFreq>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SL_PSSCH_TxConfig_r14 {
    #[asn(optional_idx = 0)]
    pub type_tx_sync_r14: Option<SL_TypeTxSync_r14>,
    pub thres_ue_speed_r14: SL_PSSCH_TxConfig_r14ThresUE_Speed_r14,
    pub parameters_above_thres_r14: SL_PSSCH_TxParameters_r14,
    pub parameters_below_thres_r14: SL_PSSCH_TxParameters_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct SL_PSSCH_TxConfigList_r14(pub Vec<SL_PSSCH_TxConfig_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SL_PSSCH_TxParameters_r14 {
    pub min_mcs_pssch_r14: SL_PSSCH_TxParameters_r14MinMCS_PSSCH_r14,
    pub max_mcs_pssch_r14: SL_PSSCH_TxParameters_r14MaxMCS_PSSCH_r14,
    pub min_sub_channel_number_pssch_r14: SL_PSSCH_TxParameters_r14MinSubChannel_NumberPSSCH_r14,
    pub max_subchannel_number_pssch_r14: SL_PSSCH_TxParameters_r14MaxSubchannel_NumberPSSCH_r14,
    pub allowed_retx_number_pssch_r14: SL_PSSCH_TxParameters_r14AllowedRetxNumberPSSCH_r14,
    #[asn(optional_idx = 0)]
    pub max_tx_power_r14: Option<SL_TxPower_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_PSSCH_TxParameters_v1530 {
    pub min_mcs_pssch_r15: SL_PSSCH_TxParameters_v1530MinMCS_PSSCH_r15,
    pub max_mcs_pssch_r15: SL_PSSCH_TxParameters_v1530MaxMCS_PSSCH_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 7)]
pub struct SL_Parameters_r12 {
    #[asn(optional_idx = 0)]
    pub comm_simultaneous_tx_r12: Option<SL_Parameters_r12CommSimultaneousTx_r12>,
    #[asn(optional_idx = 1)]
    pub comm_supported_bands_r12: Option<FreqBandIndicatorListEUTRA_r12>,
    #[asn(optional_idx = 2)]
    pub disc_supported_bands_r12: Option<SupportedBandInfoList_r12>,
    #[asn(optional_idx = 3)]
    pub disc_scheduled_resource_alloc_r12: Option<SL_Parameters_r12DiscScheduledResourceAlloc_r12>,
    #[asn(optional_idx = 4)]
    pub disc_ue_selected_resource_alloc_r12:
        Option<SL_Parameters_r12Disc_UE_SelectedResourceAlloc_r12>,
    #[asn(optional_idx = 5)]
    pub disc_slss_r12: Option<SL_Parameters_r12Disc_SLSS_r12>,
    #[asn(optional_idx = 6)]
    pub disc_supported_proc_r12: Option<SL_Parameters_r12DiscSupportedProc_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct SL_Parameters_v1310 {
    #[asn(optional_idx = 0)]
    pub disc_sys_info_reporting_r13: Option<SL_Parameters_v1310DiscSysInfoReporting_r13>,
    #[asn(optional_idx = 1)]
    pub comm_multiple_tx_r13: Option<SL_Parameters_v1310CommMultipleTx_r13>,
    #[asn(optional_idx = 2)]
    pub disc_inter_freq_tx_r13: Option<SL_Parameters_v1310DiscInterFreqTx_r13>,
    #[asn(optional_idx = 3)]
    pub disc_periodic_slss_r13: Option<SL_Parameters_v1310DiscPeriodicSLSS_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 9)]
pub struct SL_Parameters_v1430 {
    #[asn(optional_idx = 0)]
    pub zone_based_pool_selection_r14: Option<SL_Parameters_v1430ZoneBasedPoolSelection_r14>,
    #[asn(optional_idx = 1)]
    pub ue_autonomous_with_full_sensing_r14:
        Option<SL_Parameters_v1430Ue_AutonomousWithFullSensing_r14>,
    #[asn(optional_idx = 2)]
    pub ue_autonomous_with_partial_sensing_r14:
        Option<SL_Parameters_v1430Ue_AutonomousWithPartialSensing_r14>,
    #[asn(optional_idx = 3)]
    pub sl_congestion_control_r14: Option<SL_Parameters_v1430Sl_CongestionControl_r14>,
    #[asn(optional_idx = 4)]
    pub v2x_tx_with_short_resv_interval_r14:
        Option<SL_Parameters_v1430V2x_TxWithShortResvInterval_r14>,
    #[asn(optional_idx = 5)]
    pub v2x_number_tx_rx_timing_r14: Option<SL_Parameters_v1430V2x_numberTxRxTiming_r14>,
    #[asn(optional_idx = 6)]
    pub v2x_non_adjacent_pscch_pssch_r14: Option<SL_Parameters_v1430V2x_nonAdjacentPSCCH_PSSCH_r14>,
    #[asn(optional_idx = 7)]
    pub slss_tx_rx_r14: Option<SL_Parameters_v1430Slss_TxRx_r14>,
    #[asn(optional_idx = 8)]
    pub v2x_supported_band_combination_list_r14: Option<V2X_SupportedBandCombination_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct SL_Parameters_v1530 {
    #[asn(optional_idx = 0)]
    pub slss_supported_tx_freq_r15: Option<SL_Parameters_v1530Slss_SupportedTxFreq_r15>,
    #[asn(optional_idx = 1)]
    pub sl_64qam_tx_r15: Option<SL_Parameters_v1530Sl_64QAM_Tx_r15>,
    #[asn(optional_idx = 2)]
    pub sl_tx_diversity_r15: Option<SL_Parameters_v1530Sl_TxDiversity_r15>,
    #[asn(optional_idx = 3)]
    pub ue_category_sl_r15: Option<UE_CategorySL_r15>,
    #[asn(optional_idx = 4)]
    pub v2x_supported_band_combination_list_v1530: Option<V2X_SupportedBandCombination_v1530>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct SL_Parameters_v1540 {
    #[asn(optional_idx = 0)]
    pub sl_64qam_rx_r15: Option<SL_Parameters_v1540Sl_64QAM_Rx_r15>,
    #[asn(optional_idx = 1)]
    pub sl_rate_matching_tbs_scaling_r15: Option<SL_Parameters_v1540Sl_RateMatchingTBSScaling_r15>,
    #[asn(optional_idx = 2)]
    pub sl_low_t2min_r15: Option<SL_Parameters_v1540Sl_LowT2min_r15>,
    #[asn(optional_idx = 3)]
    pub v2x_sensing_reporting_mode3_r15: Option<SL_Parameters_v1540V2x_SensingReportingMode3_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SL_Parameters_v1610 {
    #[asn(optional_idx = 0)]
    pub sl_parameter_nr_r16: Option<SL_Parameters_v1610Sl_ParameterNR_r16>,
    #[asn(optional_idx = 1)]
    pub dummy: Option<V2X_SupportedBandCombinationEUTRA_NR_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SL_Parameters_v1630 {
    #[asn(optional_idx = 0)]
    pub v2x_supported_band_combination_list_eutra_nr_r16:
        Option<V2X_SupportedBandCombinationEUTRA_NR_v1630>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SL_Parameters_v1710 {
    #[asn(optional_idx = 0)]
    pub v2x_supported_band_combination_list_eutra_nr_v1710:
        Option<V2X_SupportedBandCombinationEUTRA_NR_v1710>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct SL_PeriodComm_r12(pub u8);
impl SL_PeriodComm_r12 {
    pub const SF40: u8 = 0u8;
    pub const SF60: u8 = 1u8;
    pub const SF70: u8 = 2u8;
    pub const SF80: u8 = 3u8;
    pub const SF120: u8 = 4u8;
    pub const SF140: u8 = 5u8;
    pub const SF160: u8 = 6u8;
    pub const SF240: u8 = 7u8;
    pub const SF280: u8 = 8u8;
    pub const SF320: u8 = 9u8;
    pub const SPARE6: u8 = 10u8;
    pub const SPARE5: u8 = 11u8;
    pub const SPARE4: u8 = 12u8;
    pub const SPARE3: u8 = 13u8;
    pub const SPARE2: u8 = 14u8;
    pub const SPARE: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_PoolSelectionConfig_r12 {
    pub thresh_low_r12: RSRP_RangeSL2_r12,
    pub thresh_high_r12: RSRP_RangeSL2_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SL_PreconfigCommPool_r12 {
    pub sc_cp_len_r12: SL_CP_Len_r12,
    pub sc_period_r12: SL_PeriodComm_r12,
    pub sc_tf_resource_config_r12: SL_TF_ResourceConfig_r12,
    pub sc_tx_parameters_r12: P0_SL_r12,
    pub data_cp_len_r12: SL_CP_Len_r12,
    pub data_tf_resource_config_r12: SL_TF_ResourceConfig_r12,
    pub data_hopping_config_r12: SL_HoppingConfigComm_r12,
    pub data_tx_parameters_r12: P0_SL_r12,
    pub trpt_subset_r12: SL_TRPT_Subset_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SL_PreconfigCommPoolList4_r12(pub Vec<SL_PreconfigCommPool_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "12")]
pub struct SL_PreconfigCommRxPoolList_r13(pub Vec<SL_PreconfigCommPool_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "7")]
pub struct SL_PreconfigCommTxPoolList_r13(pub Vec<SL_PreconfigCommPool_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SL_PreconfigDiscPool_r13 {
    pub cp_len_r13: SL_CP_Len_r12,
    pub disc_period_r13: SL_PreconfigDiscPool_r13DiscPeriod_r13,
    pub num_retx_r13: SL_PreconfigDiscPool_r13NumRetx_r13,
    pub num_repetition_r13: SL_PreconfigDiscPool_r13NumRepetition_r13,
    pub tf_resource_config_r13: SL_TF_ResourceConfig_r12,
    #[asn(optional_idx = 0)]
    pub tx_parameters_r13: Option<SL_PreconfigDiscPool_r13TxParameters_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct SL_PreconfigDiscRxPoolList_r13(pub Vec<SL_PreconfigDiscPool_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SL_PreconfigDiscTxPoolList_r13(pub Vec<SL_PreconfigDiscPool_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SL_PreconfigGeneral_r12 {
    pub rohc_profiles_r12: SL_PreconfigGeneral_r12Rohc_Profiles_r12,
    pub carrier_freq_r12: ARFCN_ValueEUTRA_r9,
    pub max_tx_power_r12: P_Max,
    pub additional_spectrum_emission_r12: AdditionalSpectrumEmission,
    pub sl_bandwidth_r12: SL_PreconfigGeneral_r12Sl_bandwidth_r12,
    pub tdd_config_sl_r12: TDD_ConfigSL_r12,
    pub reserved_r12: SL_PreconfigGeneral_r12Reserved_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_PreconfigRelay_r13 {
    pub reselection_info_oo_c_r13: ReselectionInfoRelay_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SL_PreconfigSync_r12 {
    pub sync_cp_len_r12: SL_CP_Len_r12,
    pub sync_offset_indicator1_r12: SL_OffsetIndicatorSync_r12,
    pub sync_offset_indicator2_r12: SL_OffsetIndicatorSync_r12,
    pub sync_tx_parameters_r12: P0_SL_r12,
    pub sync_tx_thresh_oo_c_r12: RSRP_RangeSL3_r12,
    pub filter_coefficient_r12: FilterCoefficient,
    pub sync_ref_min_hyst_r12: SL_PreconfigSync_r12SyncRefMinHyst_r12,
    pub sync_ref_diff_hyst_r12: SL_PreconfigSync_r12SyncRefDiffHyst_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct SL_PreconfigV2X_RxPoolList_r14(pub Vec<SL_V2X_PreconfigCommPool_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SL_PreconfigV2X_Sync_r14 {
    pub sync_offset_indicators_r14: SL_V2X_SyncOffsetIndicators_r14,
    pub sync_tx_parameters_r14: P0_SL_r12,
    pub sync_tx_thresh_oo_c_r14: RSRP_RangeSL3_r12,
    pub filter_coefficient_r14: FilterCoefficient,
    pub sync_ref_min_hyst_r14: SL_PreconfigV2X_Sync_r14SyncRefMinHyst_r14,
    pub sync_ref_diff_hyst_r14: SL_PreconfigV2X_Sync_r14SyncRefDiffHyst_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_PreconfigV2X_TxPoolList_r14(pub Vec<SL_V2X_PreconfigCommPool_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SL_Preconfiguration_r12 {
    pub preconfig_general_r12: SL_PreconfigGeneral_r12,
    pub preconfig_sync_r12: SL_PreconfigSync_r12,
    pub preconfig_comm_r12: SL_PreconfigCommPoolList4_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8")]
pub struct SL_Priority_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_PriorityList_r13(pub Vec<SL_Priority_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8")]
pub struct SL_Reliability_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_ReliabilityList_r15(pub Vec<SL_Reliability_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SL_ResourcesInterFreq_r13 {
    #[asn(optional_idx = 0)]
    pub disc_rx_resources_inter_freq_r13: Option<SL_DiscRxPoolList_r12>,
    #[asn(optional_idx = 1)]
    pub disc_tx_resources_inter_freq_r13: Option<SL_DiscTxResourcesInterFreq_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct SL_RestrictResourceReservationPeriod_r14(pub u8);
impl SL_RestrictResourceReservationPeriod_r14 {
    pub const V0DOT2: u8 = 0u8;
    pub const V0DOT5: u8 = 1u8;
    pub const V1: u8 = 2u8;
    pub const V2: u8 = 3u8;
    pub const V3: u8 = 4u8;
    pub const V4: u8 = 5u8;
    pub const V5: u8 = 6u8;
    pub const V6: u8 = 7u8;
    pub const V7: u8 = 8u8;
    pub const V8: u8 = 9u8;
    pub const V9: u8 = 10u8;
    pub const V10: u8 = 11u8;
    pub const SPARE4: u8 = 12u8;
    pub const SPARE3: u8 = 13u8;
    pub const SPARE2: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct SL_RestrictResourceReservationPeriodList_r14(
    pub Vec<SL_RestrictResourceReservationPeriod_r14>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SL_SyncAllowed_r14 {
    #[asn(optional_idx = 0)]
    pub gnss_sync_r14: Option<SL_SyncAllowed_r14Gnss_Sync_r14>,
    #[asn(optional_idx = 1)]
    pub enb_sync_r14: Option<SL_SyncAllowed_r14Enb_Sync_r14>,
    #[asn(optional_idx = 2)]
    pub ue_sync_r14: Option<SL_SyncAllowed_r14Ue_Sync_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SL_SyncConfig_r12 {
    pub sync_cp_len_r12: SL_CP_Len_r12,
    pub sync_offset_indicator_r12: SL_OffsetIndicatorSync_r12,
    pub slssid_r12: SLSSID_r12,
    #[asn(optional_idx = 0)]
    pub tx_parameters_r12: Option<SL_SyncConfig_r12TxParameters_r12>,
    #[asn(optional_idx = 1)]
    pub rx_params_n_cell_r12: Option<SL_SyncConfig_r12RxParamsNCell_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct SL_SyncConfigList_r12(pub Vec<SL_SyncConfig_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct SL_SyncConfigListNFreq_r13(pub Vec<SL_SyncConfigNFreq_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct SL_SyncConfigListNFreqV2X_r14(pub Vec<SL_SyncConfigNFreq_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct SL_SyncConfigListV2X_r14(pub Vec<SL_SyncConfig_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct SL_SyncConfigNFreq_r13 {
    #[asn(optional_idx = 0)]
    pub async_parameters_r13: Option<SL_SyncConfigNFreq_r13AsyncParameters_r13>,
    #[asn(optional_idx = 1)]
    pub tx_parameters_r13: Option<SL_SyncConfigNFreq_r13TxParameters_r13>,
    #[asn(optional_idx = 2)]
    pub rx_parameters_r13: Option<SL_SyncConfigNFreq_r13RxParameters_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SL_SyncTxControl_r12 {
    #[asn(optional_idx = 0)]
    pub network_controlled_sync_tx_r12: Option<SL_SyncTxControl_r12NetworkControlledSyncTx_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SL_TF_IndexPair_r12 {
    #[asn(optional_idx = 0)]
    pub disc_sf_index_r12: Option<SL_TF_IndexPair_r12DiscSF_Index_r12>,
    #[asn(optional_idx = 1)]
    pub disc_prb_index_r12: Option<SL_TF_IndexPair_r12DiscPRB_Index_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SL_TF_IndexPair_r12b {
    #[asn(optional_idx = 0)]
    pub disc_sf_index_r12b: Option<SL_TF_IndexPair_r12bDiscSF_Index_r12b>,
    #[asn(optional_idx = 1)]
    pub disc_prb_index_r12b: Option<SL_TF_IndexPair_r12bDiscPRB_Index_r12b>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct SL_TF_IndexPairList_r12(pub Vec<SL_TF_IndexPair_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct SL_TF_IndexPairList_r12b(pub Vec<SL_TF_IndexPair_r12b>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_TF_ResourceConfig_r12 {
    pub prb_num_r12: SL_TF_ResourceConfig_r12Prb_Num_r12,
    pub prb_start_r12: SL_TF_ResourceConfig_r12Prb_Start_r12,
    pub prb_end_r12: SL_TF_ResourceConfig_r12Prb_End_r12,
    pub offset_indicator_r12: SL_OffsetIndicator_r12,
    pub subframe_bitmap_r12: SubframeBitmapSL_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "3", sz_ub = "5")]
pub struct SL_TRPT_Subset_r12(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "64",
    sz_ub = "64"
)]
pub struct SL_ThresPSSCH_RSRP_List_r14(pub Vec<SL_ThresPSSCH_RSRP_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "66")]
pub struct SL_ThresPSSCH_RSRP_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_TxParameters_r12 {
    pub alpha_r12: Alpha_r12,
    pub p0_r12: P0_SL_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4")]
pub struct SL_TxPoolIdentity_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "5", ub = "8")]
pub struct SL_TxPoolIdentity_v1310(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_TxPoolToAddMod_r14 {
    pub pool_identity_r14: SL_V2X_TxPoolIdentity_r14,
    pub pool_r14: SL_CommResourcePoolV2X_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_TxPoolToAddModListV2X_r14(pub Vec<SL_TxPoolToAddMod_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SL_TxPoolToReleaseList_r12(pub Vec<SL_TxPoolIdentity_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SL_TxPoolToReleaseListExt_r13(pub Vec<SL_TxPoolIdentity_v1310>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_TxPoolToReleaseListV2X_r14(pub Vec<SL_V2X_TxPoolIdentity_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SL_TxPower_r14 {
    #[asn(key = 0, extended = false)]
    Minusinfinity_r14(SL_TxPower_r14_minusinfinity_r14),
    #[asn(key = 1, extended = false)]
    TxPower_r14(SL_TxPower_r14_txPower_r14),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct SL_TypeTxSync_r14(pub u8);
impl SL_TypeTxSync_r14 {
    pub const GNSS: u8 = 0u8;
    pub const ENB: u8 = 1u8;
    pub const UE: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_V2X_CommFreqList_r14(pub Vec<SL_V2X_CommFreqList_r14_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_V2X_CommTxFreqList_r14(pub Vec<SL_V2X_CommTxResourceReq_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SL_V2X_CommTxResourceReq_r14 {
    #[asn(optional_idx = 0)]
    pub carrier_freq_comm_tx_r14: Option<SL_V2X_CommTxResourceReq_r14CarrierFreqCommTx_r14>,
    #[asn(optional_idx = 1)]
    pub v2x_type_tx_sync_r14: Option<SL_TypeTxSync_r14>,
    #[asn(optional_idx = 2)]
    pub v2x_destination_info_list_r14: Option<SL_DestinationInfoList_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 13)]
pub struct SL_V2X_ConfigCommon_r14 {
    #[asn(optional_idx = 0)]
    pub v2x_comm_rx_pool_r14: Option<SL_CommRxPoolListV2X_r14>,
    #[asn(optional_idx = 1)]
    pub v2x_comm_tx_pool_normal_common_r14: Option<SL_CommTxPoolListV2X_r14>,
    #[asn(optional_idx = 2)]
    pub p2x_comm_tx_pool_normal_common_r14: Option<SL_CommTxPoolListV2X_r14>,
    #[asn(optional_idx = 3)]
    pub v2x_comm_tx_pool_exceptional_r14: Option<SL_CommResourcePoolV2X_r14>,
    #[asn(optional_idx = 4)]
    pub v2x_sync_config_r14: Option<SL_SyncConfigListV2X_r14>,
    #[asn(optional_idx = 5)]
    pub v2x_inter_freq_info_list_r14: Option<SL_InterFreqInfoListV2X_r14>,
    #[asn(optional_idx = 6)]
    pub v2x_resource_selection_config_r14: Option<SL_CommTxPoolSensingConfig_r14>,
    #[asn(optional_idx = 7)]
    pub zone_config_r14: Option<SL_ZoneConfig_r14>,
    #[asn(optional_idx = 8)]
    pub type_tx_sync_r14: Option<SL_TypeTxSync_r14>,
    #[asn(optional_idx = 9)]
    pub thres_sl_tx_prioritization_r14: Option<SL_Priority_r13>,
    #[asn(optional_idx = 10)]
    pub anchor_carrier_freq_list_r14: Option<SL_AnchorCarrierFreqList_V2X_r14>,
    #[asn(optional_idx = 11)]
    pub offset_dfn_r14: Option<SL_V2X_ConfigCommon_r14OffsetDFN_r14>,
    #[asn(optional_idx = 12)]
    pub cbr_common_tx_config_list_r14: Option<SL_CBR_CommonTxConfigList_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct SL_V2X_ConfigDedicated_r14 {
    #[asn(optional_idx = 0)]
    pub comm_tx_resources_r14: Option<SL_V2X_ConfigDedicated_r14CommTxResources_r14>,
    #[asn(optional_idx = 1)]
    pub v2x_inter_freq_info_list_r14: Option<SL_InterFreqInfoListV2X_r14>,
    #[asn(optional_idx = 2)]
    pub thres_sl_tx_prioritization_r14: Option<SL_Priority_r13>,
    #[asn(optional_idx = 3)]
    pub type_tx_sync_r14: Option<SL_TypeTxSync_r14>,
    #[asn(optional_idx = 4)]
    pub cbr_dedicated_tx_config_list_r14: Option<SL_CBR_CommonTxConfigList_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SL_V2X_FreqSelectionConfig_r15 {
    pub priority_list_r15: SL_PriorityList_r13,
    #[asn(optional_idx = 0)]
    pub thresh_cbr_freq_reselection_r15: Option<SL_CBR_r14>,
    #[asn(optional_idx = 1)]
    pub thresh_cbr_freq_keeping_r15: Option<SL_CBR_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_V2X_FreqSelectionConfigList_r15(pub Vec<SL_V2X_FreqSelectionConfig_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 10)]
pub struct SL_V2X_InterFreqUE_Config_r14 {
    #[asn(optional_idx = 0)]
    pub phys_cell_id_list_r14: Option<PhysCellIdList_r13>,
    #[asn(optional_idx = 1)]
    pub type_tx_sync_r14: Option<SL_TypeTxSync_r14>,
    #[asn(optional_idx = 2)]
    pub v2x_sync_config_r14: Option<SL_SyncConfigListNFreqV2X_r14>,
    #[asn(optional_idx = 3)]
    pub v2x_comm_rx_pool_r14: Option<SL_CommRxPoolListV2X_r14>,
    #[asn(optional_idx = 4)]
    pub v2x_comm_tx_pool_normal_r14: Option<SL_CommTxPoolListV2X_r14>,
    #[asn(optional_idx = 5)]
    pub p2x_comm_tx_pool_normal_r14: Option<SL_CommTxPoolListV2X_r14>,
    #[asn(optional_idx = 6)]
    pub v2x_comm_tx_pool_exceptional_r14: Option<SL_CommResourcePoolV2X_r14>,
    #[asn(optional_idx = 7)]
    pub v2x_resource_selection_config_r14: Option<SL_CommTxPoolSensingConfig_r14>,
    #[asn(optional_idx = 8)]
    pub zone_config_r14: Option<SL_ZoneConfig_r14>,
    #[asn(optional_idx = 9)]
    pub offset_dfn_r14: Option<SL_V2X_InterFreqUE_Config_r14OffsetDFN_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SL_V2X_PacketDuplicationConfig_r15 {
    pub thresh_sl_reliability_r15: SL_Reliability_r15,
    #[asn(optional_idx = 0)]
    pub allowed_carrier_freq_config_r15: Option<SL_PPPR_Dest_CarrierFreqList_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 8)]
pub struct SL_V2X_PreconfigCommPool_r14 {
    #[asn(optional_idx = 0)]
    pub sl_offset_indicator_r14: Option<SL_OffsetIndicator_r12>,
    pub sl_subframe_r14: SubframeBitmapSL_r14,
    pub adjacency_pscch_pssch_r14: SL_V2X_PreconfigCommPool_r14AdjacencyPSCCH_PSSCH_r14,
    pub size_subchannel_r14: SL_V2X_PreconfigCommPool_r14SizeSubchannel_r14,
    pub num_subchannel_r14: SL_V2X_PreconfigCommPool_r14NumSubchannel_r14,
    pub start_rb_subchannel_r14: SL_V2X_PreconfigCommPool_r14StartRB_Subchannel_r14,
    #[asn(optional_idx = 1)]
    pub start_rb_pscch_pool_r14: Option<SL_V2X_PreconfigCommPool_r14StartRB_PSCCH_Pool_r14>,
    pub data_tx_parameters_r14: P0_SL_r12,
    #[asn(optional_idx = 2)]
    pub zone_id_r14: Option<SL_V2X_PreconfigCommPool_r14ZoneID_r14>,
    #[asn(optional_idx = 3)]
    pub thresh_s_rssi_cbr_r14: Option<SL_V2X_PreconfigCommPool_r14ThreshS_RSSI_CBR_r14>,
    #[asn(optional_idx = 4)]
    pub cbr_pssch_tx_config_list_r14: Option<SL_CBR_PPPP_TxPreconfigList_r14>,
    #[asn(optional_idx = 5)]
    pub resource_selection_config_p2x_r14: Option<SL_P2X_ResourceSelectionConfig_r14>,
    #[asn(optional_idx = 6)]
    pub sync_allowed_r14: Option<SL_SyncAllowed_r14>,
    #[asn(optional_idx = 7)]
    pub restrict_resource_reservation_period_r14:
        Option<SL_RestrictResourceReservationPeriodList_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct SL_V2X_PreconfigFreqInfo_r14 {
    pub v2x_comm_preconfig_general_r14: SL_PreconfigGeneral_r12,
    #[asn(optional_idx = 0)]
    pub v2x_comm_preconfig_sync_r14: Option<SL_PreconfigV2X_Sync_r14>,
    pub v2x_comm_rx_pool_list_r14: SL_PreconfigV2X_RxPoolList_r14,
    pub v2x_comm_tx_pool_list_r14: SL_PreconfigV2X_TxPoolList_r14,
    pub p2x_comm_tx_pool_list_r14: SL_PreconfigV2X_TxPoolList_r14,
    #[asn(optional_idx = 1)]
    pub v2x_resource_selection_config_r14: Option<SL_CommTxPoolSensingConfig_r14>,
    #[asn(optional_idx = 2)]
    pub zone_config_r14: Option<SL_ZoneConfig_r14>,
    pub sync_priority_r14: SL_V2X_PreconfigFreqInfo_r14SyncPriority_r14,
    #[asn(optional_idx = 3)]
    pub thres_sl_tx_prioritization_r14: Option<SL_Priority_r13>,
    #[asn(optional_idx = 4)]
    pub offset_dfn_r14: Option<SL_V2X_PreconfigFreqInfo_r14OffsetDFN_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_V2X_PreconfigFreqList_r14(pub Vec<SL_V2X_PreconfigFreqInfo_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SL_V2X_Preconfiguration_r14 {
    pub v2x_preconfig_freq_list_r14: SL_V2X_PreconfigFreqList_r14,
    #[asn(optional_idx = 0)]
    pub anchor_carrier_freq_list_r14: Option<SL_AnchorCarrierFreqList_V2X_r14>,
    #[asn(optional_idx = 1)]
    pub cbr_preconfig_list_r14: Option<SL_CBR_PreconfigTxConfigList_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_V2X_SyncFreqList_r15(pub Vec<ARFCN_ValueEUTRA_r9>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SL_V2X_SyncOffsetIndicators_r14 {
    pub sync_offset_indicator1_r14: SL_OffsetIndicatorSync_r14,
    pub sync_offset_indicator2_r14: SL_OffsetIndicatorSync_r14,
    #[asn(optional_idx = 0)]
    pub sync_offset_indicator3_r14: Option<SL_OffsetIndicatorSync_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8")]
pub struct SL_V2X_TxPoolIdentity_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "72")]
pub struct SL_V2X_TxPoolReportIdentity_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "7")]
pub struct SL_V2X_TxProfile_r15(pub u8);
impl SL_V2X_TxProfile_r15 {
    pub const REL14: u8 = 0u8;
    pub const REL15: u8 = 1u8;
    pub const SPARE6: u8 = 2u8;
    pub const SPARE5: u8 = 3u8;
    pub const SPARE4: u8 = 4u8;
    pub const SPARE3: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct SL_V2X_TxProfileList_r15(pub Vec<SL_V2X_TxProfile_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct SL_V2X_UE_ConfigList_r14(pub Vec<SL_V2X_InterFreqUE_Config_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_ZoneConfig_r14 {
    pub zone_length_r14: SL_ZoneConfig_r14ZoneLength_r14,
    pub zone_width_r14: SL_ZoneConfig_r14ZoneWidth_r14,
    pub zone_id_longi_mod_r14: SL_ZoneConfig_r14ZoneIdLongiMod_r14,
    pub zone_id_lati_mod_r14: SL_ZoneConfig_r14ZoneIdLatiMod_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "167")]
pub struct SLSSID_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SN_FieldLength(pub u8);
impl SN_FieldLength {
    pub const SIZE5: u8 = 0u8;
    pub const SIZE10: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct SN_FieldLength_r15(pub u8);
impl SN_FieldLength_r15 {
    pub const SIZE5: u8 = 0u8;
    pub const SIZE10: u8 = 1u8;
    pub const SIZE16_R15: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SON_Parameters_r9 {
    #[asn(optional_idx = 0)]
    pub rach_report_r9: Option<SON_Parameters_r9Rach_Report_r9>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SPDCCH_Config_r15 {
    #[asn(key = 0, extended = false)]
    Release(SPDCCH_Config_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(SPDCCH_Config_r15_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SPDCCH_Elements_r15 {
    #[asn(key = 0, extended = false)]
    Release(SPDCCH_Elements_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(SPDCCH_Elements_r15_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SPDCCH_Set_r15(pub Vec<SPDCCH_Elements_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SPS_Config {
    #[asn(optional_idx = 0)]
    pub semi_persist_sched_c_rnti: Option<C_RNTI>,
    #[asn(optional_idx = 1)]
    pub sps_config_dl: Option<SPS_ConfigDL>,
    #[asn(optional_idx = 2)]
    pub sps_config_ul: Option<SPS_ConfigUL>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct SPS_Config_v1430 {
    #[asn(optional_idx = 0)]
    pub ul_sps_v_rnti_r14: Option<C_RNTI>,
    #[asn(optional_idx = 1)]
    pub sl_sps_v_rnti_r14: Option<C_RNTI>,
    #[asn(optional_idx = 2)]
    pub sps_config_ul_to_add_mod_list_r14: Option<SPS_ConfigUL_ToAddModList_r14>,
    #[asn(optional_idx = 3)]
    pub sps_config_ul_to_release_list_r14: Option<SPS_ConfigUL_ToReleaseList_r14>,
    #[asn(optional_idx = 4)]
    pub sps_config_sl_to_add_mod_list_r14: Option<SPS_ConfigSL_ToAddModList_r14>,
    #[asn(optional_idx = 5)]
    pub sps_config_sl_to_release_list_r14: Option<SPS_ConfigSL_ToReleaseList_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct SPS_Config_v1530 {
    #[asn(optional_idx = 0)]
    pub semi_persist_sched_c_rnti_r15: Option<C_RNTI>,
    #[asn(optional_idx = 1)]
    pub sps_config_dl_r15: Option<SPS_ConfigDL>,
    #[asn(optional_idx = 2)]
    pub sps_config_ul_stti_to_add_mod_list_r15: Option<SPS_ConfigUL_STTI_ToAddModList_r15>,
    #[asn(optional_idx = 3)]
    pub sps_config_ul_stti_to_release_list_r15: Option<SPS_ConfigUL_STTI_ToReleaseList_r15>,
    #[asn(optional_idx = 4)]
    pub sps_config_ul_to_add_mod_list_r15: Option<SPS_ConfigUL_ToAddModList_r15>,
    #[asn(optional_idx = 5)]
    pub sps_config_ul_to_release_list_r15: Option<SPS_ConfigUL_ToReleaseList_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SPS_Config_v1540 {
    #[asn(optional_idx = 0)]
    pub sps_config_dl_stti_r15: Option<SPS_ConfigDL_STTI_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SPS_ConfigDL {
    #[asn(key = 0, extended = false)]
    Release(SPS_ConfigDL_release),
    #[asn(key = 1, extended = false)]
    Setup(SPS_ConfigDL_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SPS_ConfigDL_STTI_r15 {
    #[asn(key = 0, extended = false)]
    Release(SPS_ConfigDL_STTI_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(SPS_ConfigDL_STTI_r15_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8")]
pub struct SPS_ConfigIndex_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "6")]
pub struct SPS_ConfigIndex_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SPS_ConfigSL_ToAddModList_r14(pub Vec<SPS_ConfigSL_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SPS_ConfigSL_ToReleaseList_r14(pub Vec<SPS_ConfigIndex_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SPS_ConfigSL_r14 {
    pub sps_config_index_r14: SPS_ConfigIndex_r14,
    pub semi_persist_sched_interval_sl_r14: SPS_ConfigSL_r14SemiPersistSchedIntervalSL_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SPS_ConfigUL {
    #[asn(key = 0, extended = false)]
    Release(SPS_ConfigUL_release),
    #[asn(key = 1, extended = false)]
    Setup(SPS_ConfigUL_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct SPS_ConfigUL_STTI_ToAddModList_r15(pub Vec<SPS_ConfigUL_STTI_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct SPS_ConfigUL_STTI_ToReleaseList_r15(pub Vec<SPS_ConfigIndex_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SPS_ConfigUL_STTI_r15 {
    #[asn(key = 0, extended = false)]
    Release(SPS_ConfigUL_STTI_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(SPS_ConfigUL_STTI_r15_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SPS_ConfigUL_ToAddModList_r14(pub Vec<SPS_ConfigUL>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct SPS_ConfigUL_ToAddModList_r15(pub Vec<SPS_ConfigUL>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SPS_ConfigUL_ToReleaseList_r14(pub Vec<SPS_ConfigIndex_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct SPS_ConfigUL_ToReleaseList_r15(pub Vec<SPS_ConfigIndex_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SPT_Parameters_r15 {
    #[asn(optional_idx = 0)]
    pub frame_structure_type_spt_r15: Option<SPT_Parameters_r15FrameStructureType_SPT_r15>,
    #[asn(optional_idx = 1)]
    pub max_number_c_cs_spt_r15: Option<SPT_Parameters_r15MaxNumberCCs_SPT_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SPUCCH_Config_r15 {
    #[asn(key = 0, extended = false)]
    Release(SPUCCH_Config_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(SPUCCH_Config_r15_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SPUCCH_Config_v1550 {
    #[asn(key = 0, extended = false)]
    Release(SPUCCH_Config_v1550_release),
    #[asn(key = 1, extended = false)]
    Setup(SPUCCH_Config_v1550_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SPUCCH_Elements_r15 {
    #[asn(key = 0, extended = false)]
    Release(SPUCCH_Elements_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(SPUCCH_Elements_r15_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SPUCCH_Set_r15(pub Vec<SPUCCH_Elements_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct SR_ProhibitTimerOffset_r17(pub u8);
impl SR_ProhibitTimerOffset_r17 {
    pub const MS90: u8 = 0u8;
    pub const MS180: u8 = 1u8;
    pub const MS270: u8 = 2u8;
    pub const MS360: u8 = 3u8;
    pub const MS450: u8 = 4u8;
    pub const MS540: u8 = 5u8;
    pub const MS1080: u8 = 6u8;
    pub const SPARE: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SR_SubslotSPUCCH_ResourceList_r15(pub Vec<SR_SubslotSPUCCH_ResourceList_r15_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SRB_ToAddMod {
    pub srb_identity: SRB_ToAddModSrb_Identity,
    #[asn(optional_idx = 0)]
    pub rlc_config: Option<SRB_ToAddModRlc_Config>,
    #[asn(optional_idx = 1)]
    pub logical_channel_config: Option<SRB_ToAddModLogicalChannelConfig>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct SRB_ToAddModList(pub Vec<SRB_ToAddMod>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "1")]
pub struct SRB_ToAddModListExt_r15(pub Vec<SRB_ToAddMod>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct SRB_ToReleaseList_r15(pub Vec<SRB_ToReleaseList_r15_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SRS_AntennaPort(pub u8);
impl SRS_AntennaPort {
    pub const AN1: u8 = 0u8;
    pub const AN2: u8 = 1u8;
    pub const AN4: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SRS_CC_SetIndex_r14 {
    pub cc_set_index_r14: SRS_CC_SetIndex_r14Cc_SetIndex_r14,
    pub cc_index_in_one_cc_set_r14: SRS_CC_SetIndex_r14Cc_IndexInOneCC_Set_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SRS_CapabilityPerBandPair_r14 {
    pub retuning_info: SRS_CapabilityPerBandPair_r14RetuningInfo,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SRS_CapabilityPerBandPair_v14b0 {
    #[asn(optional_idx = 0)]
    pub srs_flexible_timing_r14: Option<SRS_CapabilityPerBandPair_v14b0Srs_FlexibleTiming_r14>,
    #[asn(optional_idx = 1)]
    pub srs_harq_reference_config_r14:
        Option<SRS_CapabilityPerBandPair_v14b0Srs_HARQ_ReferenceConfig_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SRS_CapabilityPerBandPair_v1610 {
    #[asn(optional_idx = 0)]
    pub add_srs_carrier_switching_r16:
        Option<SRS_CapabilityPerBandPair_v1610AddSRS_CarrierSwitching_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SRS_ConfigAdd_r16 {
    pub srs_rep_num_add_r16: SRS_ConfigAdd_r16Srs_RepNumAdd_r16,
    pub srs_bandwidth_add_r16: SRS_ConfigAdd_r16Srs_BandwidthAdd_r16,
    pub srs_hopping_bandwidth_add_r16: SRS_ConfigAdd_r16Srs_HoppingBandwidthAdd_r16,
    pub srs_freq_domain_pos_add_r16: SRS_ConfigAdd_r16Srs_FreqDomainPosAdd_r16,
    pub srs_antenna_port_add_r16: SRS_AntennaPort,
    pub srs_cyclic_shift_add_r16: SRS_ConfigAdd_r16Srs_CyclicShiftAdd_r16,
    pub srs_transmission_comb_num_add_r16: SRS_ConfigAdd_r16Srs_TransmissionCombNumAdd_r16,
    pub srs_transmission_comb_add_r16: SRS_ConfigAdd_r16Srs_TransmissionCombAdd_r16,
    pub srs_start_pos_add_r16: SRS_ConfigAdd_r16Srs_StartPosAdd_r16,
    pub srs_duration_add_r16: SRS_ConfigAdd_r16Srs_DurationAdd_r16,
    #[asn(optional_idx = 0)]
    pub srs_guard_symbol_as_add_r16: Option<SRS_ConfigAdd_r16Srs_GuardSymbolAS_Add_r16>,
    #[asn(optional_idx = 1)]
    pub srs_guard_symbol_fh_add_r16: Option<SRS_ConfigAdd_r16Srs_GuardSymbolFH_Add_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SRS_ConfigAp_r10 {
    pub srs_antenna_port_ap_r10: SRS_AntennaPort,
    pub srs_bandwidth_ap_r10: SRS_ConfigAp_r10Srs_BandwidthAp_r10,
    pub freq_domain_position_ap_r10: SRS_ConfigAp_r10FreqDomainPositionAp_r10,
    pub transmission_comb_ap_r10: SRS_ConfigAp_r10TransmissionCombAp_r10,
    pub cyclic_shift_ap_r10: SRS_ConfigAp_r10CyclicShiftAp_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SRS_ConfigAp_r13 {
    pub srs_antenna_port_ap_r13: SRS_AntennaPort,
    pub srs_bandwidth_ap_r13: SRS_ConfigAp_r13Srs_BandwidthAp_r13,
    pub freq_domain_position_ap_r13: SRS_ConfigAp_r13FreqDomainPositionAp_r13,
    pub transmission_comb_ap_r13: SRS_ConfigAp_r13TransmissionCombAp_r13,
    pub cyclic_shift_ap_r13: SRS_ConfigAp_r13CyclicShiftAp_r13,
    pub transmission_comb_num_r13: SRS_ConfigAp_r13TransmissionCombNum_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SRS_ConfigAp_v1310 {
    #[asn(optional_idx = 0)]
    pub transmission_comb_ap_v1310: Option<SRS_ConfigAp_v1310TransmissionCombAp_v1310>,
    #[asn(optional_idx = 1)]
    pub cyclic_shift_ap_v1310: Option<SRS_ConfigAp_v1310CyclicShiftAp_v1310>,
    #[asn(optional_idx = 2)]
    pub transmission_comb_num_r13: Option<SRS_ConfigAp_v1310TransmissionCombNum_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SRS_TPC_PDCCH_Config_r14 {
    #[asn(key = 0, extended = false)]
    Release(SRS_TPC_PDCCH_Config_r14_release),
    #[asn(key = 1, extended = false)]
    Setup(SRS_TPC_PDCCH_Config_r14_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SS_RSSI_Measurement_r15 {
    pub measurement_slots_r15: SS_RSSI_Measurement_r15MeasurementSlots_r15,
    pub end_symbol_r15: SS_RSSI_Measurement_r15EndSymbol_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct SSB_IndexList_r15(pub Vec<RS_IndexNR_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct SSB_PositionQCL_CellsToAddModListNR_r16(pub Vec<SSB_PositionQCL_CellsToAddNR_r16>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct SSB_PositionQCL_CellsToAddModListNR_r17(pub Vec<SSB_PositionQCL_CellsToAddNR_r17>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SSB_PositionQCL_CellsToAddNR_r16 {
    pub phys_cell_id_r16: PhysCellIdNR_r15,
    pub ssb_position_qcl_nr_r16: SSB_PositionQCL_RelationNR_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SSB_PositionQCL_CellsToAddNR_r17 {
    pub phys_cell_id_nr_r17: PhysCellIdNR_r15,
    pub ssb_position_qcl_nr_r17: SSB_PositionQCL_RelationNR_r17,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SSB_PositionQCL_RelationNR_r16(pub u8);
impl SSB_PositionQCL_RelationNR_r16 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N4: u8 = 2u8;
    pub const N8: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SSB_PositionQCL_RelationNR_r17(pub u8);
impl SSB_PositionQCL_RelationNR_r17 {
    pub const N32: u8 = 0u8;
    pub const N64: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum SSB_ToMeasure_r15 {
    #[asn(key = 0, extended = false)]
    ShortBitmap_r15(SSB_ToMeasure_r15_shortBitmap_r15),
    #[asn(key = 1, extended = false)]
    MediumBitmap_r15(SSB_ToMeasure_r15_mediumBitmap_r15),
    #[asn(key = 2, extended = false)]
    LongBitmap_r15(SSB_ToMeasure_r15_longBitmap_r15),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "3")]
pub struct STAG_Id_r11(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct STAG_ToAddMod_r11 {
    pub stag_id_r11: STAG_Id_r11,
    pub time_alignment_timer_stag_r11: TimeAlignmentTimer,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct STAG_ToAddModList_r11(pub Vec<STAG_ToAddMod_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct STAG_ToReleaseList_r11(pub Vec<STAG_Id_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 12)]
pub struct STTI_SPT_BandParameters_r15 {
    #[asn(optional_idx = 0)]
    pub dl_1024qam_slot_r15: Option<STTI_SPT_BandParameters_r15Dl_1024QAM_Slot_r15>,
    #[asn(optional_idx = 1)]
    pub dl_1024qam_subslot_ta_1_r15: Option<STTI_SPT_BandParameters_r15Dl_1024QAM_SubslotTA_1_r15>,
    #[asn(optional_idx = 2)]
    pub dl_1024qam_subslot_ta_2_r15: Option<STTI_SPT_BandParameters_r15Dl_1024QAM_SubslotTA_2_r15>,
    #[asn(optional_idx = 3)]
    pub simultaneous_tx_different_tx_duration_r15:
        Option<STTI_SPT_BandParameters_r15SimultaneousTx_differentTx_duration_r15>,
    #[asn(optional_idx = 4)]
    pub stti_ca_mimo_parameters_dl_r15: Option<CA_MIMO_ParametersDL_r15>,
    pub stti_ca_mimo_parameters_ul_r15: CA_MIMO_ParametersUL_r15,
    #[asn(optional_idx = 5)]
    pub stti_fd_mimo_coexistence: Option<STTI_SPT_BandParameters_r15STTI_FD_MIMO_Coexistence>,
    #[asn(optional_idx = 6)]
    pub stti_mimo_ca_parameters_per_bo_b_cs_r15: Option<MIMO_CA_ParametersPerBoBC_r13>,
    #[asn(optional_idx = 7)]
    pub stti_mimo_ca_parameters_per_bo_b_cs_v1530: Option<MIMO_CA_ParametersPerBoBC_v1430>,
    #[asn(optional_idx = 8)]
    pub stti_supported_combinations_r15: Option<STTI_SupportedCombinations_r15>,
    #[asn(optional_idx = 9)]
    pub stti_supported_csi_proc_r15: Option<STTI_SPT_BandParameters_r15STTI_SupportedCSI_Proc_r15>,
    #[asn(optional_idx = 10)]
    pub ul_256qam_slot_r15: Option<STTI_SPT_BandParameters_r15Ul_256QAM_Slot_r15>,
    #[asn(optional_idx = 11)]
    pub ul_256qam_subslot_r15: Option<STTI_SPT_BandParameters_r15Ul_256QAM_Subslot_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct STTI_SupportedCombinations_r15 {
    #[asn(optional_idx = 0)]
    pub combination_22_r15: Option<DL_UL_CCs_r15>,
    #[asn(optional_idx = 1)]
    pub combination_77_r15: Option<DL_UL_CCs_r15>,
    #[asn(optional_idx = 2)]
    pub combination_27_r15: Option<DL_UL_CCs_r15>,
    #[asn(optional_idx = 3)]
    pub combination_22_27_r15: Option<STTI_SupportedCombinations_r15Combination_22_27_r15>,
    #[asn(optional_idx = 4)]
    pub combination_77_22_r15: Option<STTI_SupportedCombinations_r15Combination_77_22_r15>,
    #[asn(optional_idx = 5)]
    pub combination_77_27_r15: Option<STTI_SupportedCombinations_r15Combination_77_27_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SatelliteInfo_r17 {
    pub satellite_id_r17: SatelliteInfo_r17SatelliteId_r17,
    pub service_info_r17: SatelliteInfo_r17ServiceInfo_r17,
    pub footprint_info_r17: SatelliteInfo_r17FootprintInfo_r17,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SatelliteInfoList_r17(pub Vec<SatelliteInfo_r17>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct ScalingFactorSidelink_r16(pub u8);
impl ScalingFactorSidelink_r16 {
    pub const F0P4: u8 = 0u8;
    pub const F0P75: u8 = 1u8;
    pub const F0P8: u8 = 2u8;
    pub const F1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SchedulingInfo {
    pub si_periodicity: SI_Periodicity_r12,
    pub sib_mapping_info: SIB_MappingInfo,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SchedulingInfo_BR_r13 {
    pub si_narrowband_r13: SchedulingInfo_BR_r13Si_Narrowband_r13,
    pub si_tbs_r13: SchedulingInfo_BR_r13Si_TBS_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SchedulingInfo_MBMS_r14 {
    pub si_periodicity_r14: SchedulingInfo_MBMS_r14Si_Periodicity_r14,
    pub sib_mapping_info_r14: SIB_MappingInfo_MBMS_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SchedulingInfo_v12j0 {
    #[asn(optional_idx = 0)]
    pub sib_mapping_info_v12j0: Option<SIB_MappingInfo_v12j0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SchedulingInfoExt_r12 {
    pub si_periodicity_r12: SI_Periodicity_r12,
    pub sib_mapping_info_r12: SIB_MappingInfo_v12j0,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct SchedulingInfoList(pub Vec<SchedulingInfo>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct SchedulingInfoList_BR_r13(pub Vec<SchedulingInfo_BR_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct SchedulingInfoList_MBMS_r14(pub Vec<SchedulingInfo_MBMS_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct SchedulingInfoList_v12j0(pub Vec<SchedulingInfo_v12j0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct SchedulingInfoListExt_r12(pub Vec<SchedulingInfoExt_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SchedulingRequestConfig {
    #[asn(key = 0, extended = false)]
    Release(SchedulingRequestConfig_release),
    #[asn(key = 1, extended = false)]
    Setup(SchedulingRequestConfig_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SchedulingRequestConfig_v1020 {
    #[asn(optional_idx = 0)]
    pub sr_pucch_resource_index_p1_r10:
        Option<SchedulingRequestConfig_v1020Sr_PUCCH_ResourceIndexP1_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SchedulingRequestConfig_v1530 {
    #[asn(key = 0, extended = false)]
    Release(SchedulingRequestConfig_v1530_release),
    #[asn(key = 1, extended = false)]
    Setup(SchedulingRequestConfig_v1530_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SchedulingRequestConfigSCell_r13 {
    #[asn(key = 0, extended = false)]
    Release(SchedulingRequestConfigSCell_r13_release),
    #[asn(key = 1, extended = false)]
    Setup(SchedulingRequestConfigSCell_r13_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct SecondaryPreRegistrationZoneIdListHRPD(pub Vec<PreRegistrationZoneIdHRPD>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecurityAlgorithmConfig {
    pub ciphering_algorithm: CipheringAlgorithm_r12,
    pub integrity_prot_algorithm: SecurityAlgorithmConfigIntegrityProtAlgorithm,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SecurityConfigHO {
    pub handover_type: SecurityConfigHOHandoverType,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SecurityConfigHO_v1530 {
    pub handover_type_v1530: SecurityConfigHO_v1530HandoverType_v1530,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SecurityConfigSMC {
    pub security_algorithm_config: SecurityAlgorithmConfig,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecurityModeCommand {
    pub rrc_transaction_identifier: RRC_TransactionIdentifier,
    pub critical_extensions: SecurityModeCommandCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SecurityModeCommand_r8_IEs {
    pub security_config_smc: SecurityConfigSMC,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<SecurityModeCommand_v8a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SecurityModeCommand_v8a0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<SecurityModeCommand_v8a0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SecurityModeCommand_v8a0_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecurityModeComplete {
    pub rrc_transaction_identifier: RRC_TransactionIdentifier,
    pub critical_extensions: SecurityModeCompleteCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SecurityModeComplete_r8_IEs {
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<SecurityModeComplete_v8a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SecurityModeComplete_v8a0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<SecurityModeComplete_v8a0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SecurityModeComplete_v8a0_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecurityModeFailure {
    pub rrc_transaction_identifier: RRC_TransactionIdentifier,
    pub critical_extensions: SecurityModeFailureCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SecurityModeFailure_r8_IEs {
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<SecurityModeFailure_v8a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SecurityModeFailure_v8a0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<SecurityModeFailure_v8a0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SecurityModeFailure_v8a0_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SensingResult_r15 {
    pub resource_index_r15: SensingResult_r15ResourceIndex_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct ServCellIndex_r10(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct ServCellIndex_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct ServingSatelliteInfo_r17 {
    pub ephemeris_info_r17: ServingSatelliteInfo_r17EphemerisInfo_r17,
    pub nta_common_parameters_17: ServingSatelliteInfo_r17Nta_CommonParameters_17,
    pub ul_sync_validity_duration_r17: ServingSatelliteInfo_r17Ul_SyncValidityDuration_r17,
    #[asn(optional_idx = 0)]
    pub epoch_time_r17: Option<ServingSatelliteInfo_r17EpochTime_r17>,
    pub k_offset_r17: ServingSatelliteInfo_r17K_Offset_r17,
    #[asn(optional_idx = 1)]
    pub k_mac_r17: Option<ServingSatelliteInfo_r17K_Mac_r17>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SharedSpectrumMeasNR_r17 {
    pub nr_rssi_channel_occupancy_reporting_r17:
        SharedSpectrumMeasNR_r17Nr_RSSI_ChannelOccupancyReporting_r17,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "24", sz_ub = "24")]
pub struct ShortI_RNTI_r15(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct ShortMAC_I(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct ShortTTI_Length_r15(pub u8);
impl ShortTTI_Length_r15 {
    pub const SLOT: u8 = 0u8;
    pub const SUBSLOT: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct ShortTTI_r15 {
    #[asn(optional_idx = 0)]
    pub dl_stti_length_r15: Option<ShortTTI_Length_r15>,
    #[asn(optional_idx = 1)]
    pub ul_stti_length_r15: Option<ShortTTI_Length_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SidelinkUEInformation_r12 {
    pub critical_extensions: SidelinkUEInformation_r12CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct SidelinkUEInformation_r12_IEs {
    #[asn(optional_idx = 0)]
    pub comm_rx_interested_freq_r12: Option<ARFCN_ValueEUTRA_r9>,
    #[asn(optional_idx = 1)]
    pub comm_tx_resource_req_r12: Option<SL_CommTxResourceReq_r12>,
    #[asn(optional_idx = 2)]
    pub disc_rx_interest_r12: Option<SidelinkUEInformation_r12_IEsDiscRxInterest_r12>,
    #[asn(optional_idx = 3)]
    pub disc_tx_resource_req_r12: Option<SidelinkUEInformation_r12_IEsDiscTxResourceReq_r12>,
    #[asn(optional_idx = 4)]
    pub late_non_critical_extension: Option<SidelinkUEInformation_r12_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 5)]
    pub non_critical_extension: Option<SidelinkUEInformation_v1310_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 8)]
pub struct SidelinkUEInformation_v1310_IEs {
    #[asn(optional_idx = 0)]
    pub comm_tx_resource_req_uc_r13: Option<SL_CommTxResourceReq_r12>,
    #[asn(optional_idx = 1)]
    pub comm_tx_resource_info_req_relay_r13:
        Option<SidelinkUEInformation_v1310_IEsCommTxResourceInfoReqRelay_r13>,
    #[asn(optional_idx = 2)]
    pub disc_tx_resource_req_v1310: Option<SidelinkUEInformation_v1310_IEsDiscTxResourceReq_v1310>,
    #[asn(optional_idx = 3)]
    pub disc_tx_resource_req_ps_r13: Option<SL_DiscTxResourceReq_r13>,
    #[asn(optional_idx = 4)]
    pub disc_rx_gap_req_r13: Option<SL_GapRequest_r13>,
    #[asn(optional_idx = 5)]
    pub disc_tx_gap_req_r13: Option<SL_GapRequest_r13>,
    #[asn(optional_idx = 6)]
    pub disc_sys_info_report_freq_list_r13: Option<SL_DiscSysInfoReportFreqList_r13>,
    #[asn(optional_idx = 7)]
    pub non_critical_extension: Option<SidelinkUEInformation_v1430_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct SidelinkUEInformation_v1430_IEs {
    #[asn(optional_idx = 0)]
    pub v2x_comm_rx_interested_freq_list_r14: Option<SL_V2X_CommFreqList_r14>,
    #[asn(optional_idx = 1)]
    pub p2x_comm_tx_type_r14: Option<SidelinkUEInformation_v1430_IEsP2x_CommTxType_r14>,
    #[asn(optional_idx = 2)]
    pub v2x_comm_tx_resource_req_r14: Option<SL_V2X_CommTxFreqList_r14>,
    #[asn(optional_idx = 3)]
    pub non_critical_extension: Option<SidelinkUEInformation_v1530_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SidelinkUEInformation_v1530_IEs {
    #[asn(optional_idx = 0)]
    pub reliability_info_list_sl_r15: Option<SL_ReliabilityList_r15>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SidelinkUEInformation_v1530_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct SkipSubframeProcessing_r15 {
    #[asn(optional_idx = 0)]
    pub skip_processing_dl_slot_r15: Option<SkipSubframeProcessing_r15SkipProcessingDL_Slot_r15>,
    #[asn(optional_idx = 1)]
    pub skip_processing_dl_sub_slot_r15:
        Option<SkipSubframeProcessing_r15SkipProcessingDL_SubSlot_r15>,
    #[asn(optional_idx = 2)]
    pub skip_processing_ul_slot_r15: Option<SkipSubframeProcessing_r15SkipProcessingUL_Slot_r15>,
    #[asn(optional_idx = 3)]
    pub skip_processing_ul_sub_slot_r15:
        Option<SkipSubframeProcessing_r15SkipProcessingUL_SubSlot_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SlotOrSubslotPDSCH_Config_r15 {
    #[asn(key = 0, extended = false)]
    Release(SlotOrSubslotPDSCH_Config_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(SlotOrSubslotPDSCH_Config_r15_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SlotOrSubslotPUSCH_Config_r15 {
    #[asn(key = 0, extended = false)]
    Release(SlotOrSubslotPUSCH_Config_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(SlotOrSubslotPUSCH_Config_r15_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SoundingRS_AperiodicSet_r14 {
    #[asn(optional_idx = 0)]
    pub srs_cc_set_index_list_r14: Option<SoundingRS_AperiodicSet_r14Srs_CC_SetIndexList_r14>,
    pub sounding_rs_ul_config_dedicated_aperiodic_r14: SoundingRS_UL_ConfigDedicatedAperiodic_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SoundingRS_AperiodicSetUpPTsExt_r14 {
    #[asn(optional_idx = 0)]
    pub srs_cc_set_index_list_r14:
        Option<SoundingRS_AperiodicSetUpPTsExt_r14Srs_CC_SetIndexList_r14>,
    pub sounding_rs_ul_config_dedicated_aperiodic_up_p_ts_ext_r14:
        SoundingRS_UL_ConfigDedicatedAperiodicUpPTsExt_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SoundingRS_UL_ConfigCommon {
    #[asn(key = 0, extended = false)]
    Release(SoundingRS_UL_ConfigCommon_release),
    #[asn(key = 1, extended = false)]
    Setup(SoundingRS_UL_ConfigCommon_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SoundingRS_UL_ConfigDedicated {
    #[asn(key = 0, extended = false)]
    Release(SoundingRS_UL_ConfigDedicated_release),
    #[asn(key = 1, extended = false)]
    Setup(SoundingRS_UL_ConfigDedicated_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SoundingRS_UL_ConfigDedicated_v1020 {
    pub srs_antenna_port_r10: SRS_AntennaPort,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SoundingRS_UL_ConfigDedicated_v1310 {
    #[asn(key = 0, extended = false)]
    Release(SoundingRS_UL_ConfigDedicated_v1310_release),
    #[asn(key = 1, extended = false)]
    Setup(SoundingRS_UL_ConfigDedicated_v1310_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SoundingRS_UL_ConfigDedicatedAdd_r16 {
    pub srs_config_index_ap_r16: SoundingRS_UL_ConfigDedicatedAdd_r16Srs_ConfigIndexAp_r16,
    #[asn(optional_idx = 0)]
    pub srs_config_ap_dci_format4_r16:
        Option<SoundingRS_UL_ConfigDedicatedAdd_r16Srs_ConfigApDCI_Format4_r16>,
    #[asn(optional_idx = 1)]
    pub srs_activate_ap_r13: Option<SoundingRS_UL_ConfigDedicatedAdd_r16Srs_ActivateAp_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SoundingRS_UL_ConfigDedicatedAperiodic_r10 {
    #[asn(key = 0, extended = false)]
    Release(SoundingRS_UL_ConfigDedicatedAperiodic_r10_release),
    #[asn(key = 1, extended = false)]
    Setup(SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SoundingRS_UL_ConfigDedicatedAperiodic_v1310 {
    #[asn(key = 0, extended = false)]
    Release(SoundingRS_UL_ConfigDedicatedAperiodic_v1310_release),
    #[asn(key = 1, extended = false)]
    Setup(SoundingRS_UL_ConfigDedicatedAperiodic_v1310_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SoundingRS_UL_ConfigDedicatedAperiodic_v1430 {
    #[asn(key = 0, extended = false)]
    Release(SoundingRS_UL_ConfigDedicatedAperiodic_v1430_release),
    #[asn(key = 1, extended = false)]
    Setup(SoundingRS_UL_ConfigDedicatedAperiodic_v1430_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SoundingRS_UL_ConfigDedicatedAperiodicUpPTsExt_r13 {
    #[asn(key = 0, extended = false)]
    Release(SoundingRS_UL_ConfigDedicatedAperiodicUpPTsExt_r13_release),
    #[asn(key = 1, extended = false)]
    Setup(SoundingRS_UL_ConfigDedicatedAperiodicUpPTsExt_r13_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SoundingRS_UL_ConfigDedicatedUpPTsExt_r13 {
    #[asn(key = 0, extended = false)]
    Release(SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_release),
    #[asn(key = 1, extended = false)]
    Setup(SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SoundingRS_VirtualCellID_r16 {
    pub srs_virtual_cell_id_r16: SoundingRS_VirtualCellID_r16Srs_VirtualCellID_r16,
    pub srs_virtual_cell_id_all_srs_r16: SoundingRS_VirtualCellID_r16Srs_VirtualCellID_AllSRS_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SpeedStateScaleFactors {
    pub sf_medium: SpeedStateScaleFactorsSf_Medium,
    pub sf_high: SpeedStateScaleFactorsSf_High,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "6")]
pub struct SubframeAssignment_r15(pub u8);
impl SubframeAssignment_r15 {
    pub const SA0: u8 = 0u8;
    pub const SA1: u8 = 1u8;
    pub const SA2: u8 = 2u8;
    pub const SA3: u8 = 3u8;
    pub const SA4: u8 = 4u8;
    pub const SA5: u8 = 5u8;
    pub const SA6: u8 = 6u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "6", extensible = false)]
pub enum SubframeBitmapSL_r12 {
    #[asn(key = 0, extended = false)]
    Bs4_r12(SubframeBitmapSL_r12_bs4_r12),
    #[asn(key = 1, extended = false)]
    Bs8_r12(SubframeBitmapSL_r12_bs8_r12),
    #[asn(key = 2, extended = false)]
    Bs12_r12(SubframeBitmapSL_r12_bs12_r12),
    #[asn(key = 3, extended = false)]
    Bs16_r12(SubframeBitmapSL_r12_bs16_r12),
    #[asn(key = 4, extended = false)]
    Bs30_r12(SubframeBitmapSL_r12_bs30_r12),
    #[asn(key = 5, extended = false)]
    Bs40_r12(SubframeBitmapSL_r12_bs40_r12),
    #[asn(key = 6, extended = false)]
    Bs42_r12(SubframeBitmapSL_r12_bs42_r12),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "7", extensible = false)]
pub enum SubframeBitmapSL_r14 {
    #[asn(key = 0, extended = false)]
    Bs10_r14(SubframeBitmapSL_r14_bs10_r14),
    #[asn(key = 1, extended = false)]
    Bs16_r14(SubframeBitmapSL_r14_bs16_r14),
    #[asn(key = 2, extended = false)]
    Bs20_r14(SubframeBitmapSL_r14_bs20_r14),
    #[asn(key = 3, extended = false)]
    Bs30_r14(SubframeBitmapSL_r14_bs30_r14),
    #[asn(key = 4, extended = false)]
    Bs40_r14(SubframeBitmapSL_r14_bs40_r14),
    #[asn(key = 5, extended = false)]
    Bs50_r14(SubframeBitmapSL_r14_bs50_r14),
    #[asn(key = 6, extended = false)]
    Bs60_r14(SubframeBitmapSL_r14_bs60_r14),
    #[asn(key = 7, extended = false)]
    Bs100_r14(SubframeBitmapSL_r14_bs100_r14),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct SupportedBandCombination_r10(pub Vec<BandCombinationParameters_r10>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct SupportedBandCombination_v1090(pub Vec<BandCombinationParameters_v1090>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct SupportedBandCombination_v10i0(pub Vec<BandCombinationParameters_v10i0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct SupportedBandCombination_v1130(pub Vec<BandCombinationParameters_v1130>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct SupportedBandCombination_v1250(pub Vec<BandCombinationParameters_v1250>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct SupportedBandCombination_v1270(pub Vec<BandCombinationParameters_v1270>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct SupportedBandCombination_v1320(pub Vec<BandCombinationParameters_v1320>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct SupportedBandCombination_v1380(pub Vec<BandCombinationParameters_v1380>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct SupportedBandCombination_v1390(pub Vec<BandCombinationParameters_v1390>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct SupportedBandCombination_v1430(pub Vec<BandCombinationParameters_v1430>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct SupportedBandCombination_v1450(pub Vec<BandCombinationParameters_v1450>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct SupportedBandCombination_v1470(pub Vec<BandCombinationParameters_v1470>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct SupportedBandCombination_v14b0(pub Vec<BandCombinationParameters_v14b0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct SupportedBandCombination_v1530(pub Vec<BandCombinationParameters_v1530>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct SupportedBandCombination_v1610(pub Vec<BandCombinationParameters_v1610>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct SupportedBandCombination_v1630(pub Vec<BandCombinationParameters_v1630>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct SupportedBandCombinationAdd_r11(pub Vec<BandCombinationParameters_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct SupportedBandCombinationAdd_v11d0(pub Vec<BandCombinationParameters_v10i0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct SupportedBandCombinationAdd_v1250(pub Vec<BandCombinationParameters_v1250>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct SupportedBandCombinationAdd_v1270(pub Vec<BandCombinationParameters_v1270>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct SupportedBandCombinationAdd_v1320(pub Vec<BandCombinationParameters_v1320>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct SupportedBandCombinationAdd_v1380(pub Vec<BandCombinationParameters_v1380>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct SupportedBandCombinationAdd_v1390(pub Vec<BandCombinationParameters_v1390>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct SupportedBandCombinationAdd_v1430(pub Vec<BandCombinationParameters_v1430>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct SupportedBandCombinationAdd_v1450(pub Vec<BandCombinationParameters_v1450>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct SupportedBandCombinationAdd_v1470(pub Vec<BandCombinationParameters_v1470>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct SupportedBandCombinationAdd_v14b0(pub Vec<BandCombinationParameters_v14b0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct SupportedBandCombinationAdd_v1530(pub Vec<BandCombinationParameters_v1530>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct SupportedBandCombinationAdd_v1610(pub Vec<BandCombinationParameters_v1610>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct SupportedBandCombinationAdd_v1630(pub Vec<BandCombinationParameters_v1630>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct SupportedBandCombinationExt_r10(pub Vec<BandCombinationParametersExt_r10>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "384"
)]
pub struct SupportedBandCombinationReduced_r13(pub Vec<BandCombinationParameters_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "384"
)]
pub struct SupportedBandCombinationReduced_v1320(pub Vec<BandCombinationParameters_v1320>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "384"
)]
pub struct SupportedBandCombinationReduced_v1380(pub Vec<BandCombinationParameters_v1380>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "384"
)]
pub struct SupportedBandCombinationReduced_v1390(pub Vec<BandCombinationParameters_v1390>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "384"
)]
pub struct SupportedBandCombinationReduced_v1430(pub Vec<BandCombinationParameters_v1430>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "384"
)]
pub struct SupportedBandCombinationReduced_v1450(pub Vec<BandCombinationParameters_v1450>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "384"
)]
pub struct SupportedBandCombinationReduced_v1470(pub Vec<BandCombinationParameters_v1470>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "384"
)]
pub struct SupportedBandCombinationReduced_v14b0(pub Vec<BandCombinationParameters_v14b0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "384"
)]
pub struct SupportedBandCombinationReduced_v1530(pub Vec<BandCombinationParameters_v1530>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "384"
)]
pub struct SupportedBandCombinationReduced_v1610(pub Vec<BandCombinationParameters_v1610>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "384"
)]
pub struct SupportedBandCombinationReduced_v1630(pub Vec<BandCombinationParameters_v1630>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SupportedBandEUTRA {
    pub band_eutra: FreqBandIndicator,
    pub half_duplex: SupportedBandEUTRAHalfDuplex,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SupportedBandEUTRA_v1250 {
    #[asn(optional_idx = 0)]
    pub dl_256qam_r12: Option<SupportedBandEUTRA_v1250Dl_256QAM_r12>,
    #[asn(optional_idx = 1)]
    pub ul_64qam_r12: Option<SupportedBandEUTRA_v1250Ul_64QAM_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SupportedBandEUTRA_v1310 {
    #[asn(optional_idx = 0)]
    pub ue_power_class_5_r13: Option<SupportedBandEUTRA_v1310Ue_PowerClass_5_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SupportedBandEUTRA_v1320 {
    #[asn(optional_idx = 0)]
    pub intra_freq_ce_need_for_gaps_r13:
        Option<SupportedBandEUTRA_v1320IntraFreq_CE_NeedForGaps_r13>,
    #[asn(optional_idx = 1)]
    pub ue_power_class_n_r13: Option<SupportedBandEUTRA_v1320Ue_PowerClass_N_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SupportedBandEUTRA_v9e0 {
    #[asn(optional_idx = 0)]
    pub band_eutra_v9e0: Option<FreqBandIndicator_v9e0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "15")]
pub struct SupportedBandGERAN(pub u8);
impl SupportedBandGERAN {
    pub const GSM450: u8 = 0u8;
    pub const GSM480: u8 = 1u8;
    pub const GSM710: u8 = 2u8;
    pub const GSM750: u8 = 3u8;
    pub const GSM810: u8 = 4u8;
    pub const GSM850: u8 = 5u8;
    pub const GSM900_P: u8 = 6u8;
    pub const GSM900_E: u8 = 7u8;
    pub const GSM900_R: u8 = 8u8;
    pub const GSM1800: u8 = 9u8;
    pub const GSM1900: u8 = 10u8;
    pub const SPARE5: u8 = 11u8;
    pub const SPARE4: u8 = 12u8;
    pub const SPARE3: u8 = 13u8;
    pub const SPARE2: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SupportedBandInfo_r12 {
    #[asn(optional_idx = 0)]
    pub support_r12: Option<SupportedBandInfo_r12Support_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct SupportedBandInfoList_r12(pub Vec<SupportedBandInfo_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct SupportedBandList1XRTT(pub Vec<BandclassCDMA2000>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct SupportedBandListEUTRA(pub Vec<SupportedBandEUTRA>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct SupportedBandListEUTRA_v1250(pub Vec<SupportedBandEUTRA_v1250>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct SupportedBandListEUTRA_v1310(pub Vec<SupportedBandEUTRA_v1310>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct SupportedBandListEUTRA_v1320(pub Vec<SupportedBandEUTRA_v1320>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct SupportedBandListEUTRA_v9e0(pub Vec<SupportedBandEUTRA_v9e0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct SupportedBandListGERAN(pub Vec<SupportedBandGERAN>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct SupportedBandListHRPD(pub Vec<BandclassCDMA2000>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "1024"
)]
pub struct SupportedBandListNR_r15(pub Vec<SupportedBandNR_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct SupportedBandListUTRA_FDD(pub Vec<SupportedBandUTRA_FDD>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct SupportedBandListUTRA_TDD128(pub Vec<SupportedBandUTRA_TDD128>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct SupportedBandListUTRA_TDD384(pub Vec<SupportedBandUTRA_TDD384>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct SupportedBandListUTRA_TDD768(pub Vec<SupportedBandUTRA_TDD768>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SupportedBandNR_r15 {
    pub band_nr_r15: FreqBandIndicatorNR_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "15")]
pub struct SupportedBandUTRA_FDD(pub u8);
impl SupportedBandUTRA_FDD {
    pub const BAND_I: u8 = 0u8;
    pub const BAND_II: u8 = 1u8;
    pub const BAND_III: u8 = 2u8;
    pub const BAND_IV: u8 = 3u8;
    pub const BAND_V: u8 = 4u8;
    pub const BAND_VI: u8 = 5u8;
    pub const BAND_VII: u8 = 6u8;
    pub const BAND_VIII: u8 = 7u8;
    pub const BAND_IX: u8 = 8u8;
    pub const BAND_X: u8 = 9u8;
    pub const BAND_XI: u8 = 10u8;
    pub const BAND_XII: u8 = 11u8;
    pub const BAND_XIII: u8 = 12u8;
    pub const BAND_XIV: u8 = 13u8;
    pub const BAND_XV: u8 = 14u8;
    pub const BAND_XVI: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "15")]
pub struct SupportedBandUTRA_TDD128(pub u8);
impl SupportedBandUTRA_TDD128 {
    pub const A: u8 = 0u8;
    pub const B: u8 = 1u8;
    pub const C: u8 = 2u8;
    pub const D: u8 = 3u8;
    pub const E: u8 = 4u8;
    pub const F: u8 = 5u8;
    pub const G: u8 = 6u8;
    pub const H: u8 = 7u8;
    pub const I: u8 = 8u8;
    pub const J: u8 = 9u8;
    pub const K: u8 = 10u8;
    pub const L: u8 = 11u8;
    pub const M: u8 = 12u8;
    pub const N: u8 = 13u8;
    pub const O: u8 = 14u8;
    pub const P: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "15")]
pub struct SupportedBandUTRA_TDD384(pub u8);
impl SupportedBandUTRA_TDD384 {
    pub const A: u8 = 0u8;
    pub const B: u8 = 1u8;
    pub const C: u8 = 2u8;
    pub const D: u8 = 3u8;
    pub const E: u8 = 4u8;
    pub const F: u8 = 5u8;
    pub const G: u8 = 6u8;
    pub const H: u8 = 7u8;
    pub const I: u8 = 8u8;
    pub const J: u8 = 9u8;
    pub const K: u8 = 10u8;
    pub const L: u8 = 11u8;
    pub const M: u8 = 12u8;
    pub const N: u8 = 13u8;
    pub const O: u8 = 14u8;
    pub const P: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "15")]
pub struct SupportedBandUTRA_TDD768(pub u8);
impl SupportedBandUTRA_TDD768 {
    pub const A: u8 = 0u8;
    pub const B: u8 = 1u8;
    pub const C: u8 = 2u8;
    pub const D: u8 = 3u8;
    pub const E: u8 = 4u8;
    pub const F: u8 = 5u8;
    pub const G: u8 = 6u8;
    pub const H: u8 = 7u8;
    pub const I: u8 = 8u8;
    pub const J: u8 = 9u8;
    pub const K: u8 = 10u8;
    pub const L: u8 = 11u8;
    pub const M: u8 = 12u8;
    pub const N: u8 = 13u8;
    pub const O: u8 = 14u8;
    pub const P: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct SupportedBandwidthCombinationSet_r10(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SupportedOperatorDic_r15 {
    pub version_of_dictionary_r15: SupportedOperatorDic_r15VersionOfDictionary_r15,
    pub associated_plmn_id_r15: PLMN_Identity,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SupportedUDC_r15 {
    #[asn(optional_idx = 0)]
    pub supported_standard_dic_r15: Option<SupportedUDC_r15SupportedStandardDic_r15>,
    #[asn(optional_idx = 1)]
    pub supported_operator_dic_r15: Option<SupportedOperatorDic_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "10")]
pub struct SystemInfoListGERAN(pub Vec<SystemInfoListGERAN_Entry>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct SystemInfoValueTagList_r13(pub Vec<SystemInfoValueTagSI_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct SystemInfoValueTagSI_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SystemInformation {
    pub critical_extensions: SystemInformationCriticalExtensions,
}

pub type SystemInformation_BR_r13 = SystemInformation;

pub type SystemInformation_MBMS_r14 = SystemInformation;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SystemInformation_r8_IEs {
    pub sib_type_and_info: SystemInformation_r8_IEsSib_TypeAndInfo,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<SystemInformation_v8a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SystemInformation_v8a0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<SystemInformation_v8a0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SystemInformation_v8a0_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SystemInformationBlockPos_r15 {
    pub assistance_data_sib_element_r15: SystemInformationBlockPos_r15AssistanceDataSIB_Element_r15,
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<SystemInformationBlockPos_r15LateNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SystemInformationBlockType1 {
    pub cell_access_related_info: SystemInformationBlockType1CellAccessRelatedInfo,
    pub cell_selection_info: SystemInformationBlockType1CellSelectionInfo,
    #[asn(optional_idx = 0)]
    pub p_max: Option<P_Max>,
    pub freq_band_indicator: FreqBandIndicator,
    pub scheduling_info_list: SchedulingInfoList,
    #[asn(optional_idx = 1)]
    pub tdd_config: Option<TDD_Config>,
    pub si_window_length: SystemInformationBlockType1Si_WindowLength,
    pub system_info_value_tag: SystemInformationBlockType1SystemInfoValueTag,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<SystemInformationBlockType1_v890_IEs>,
}

pub type SystemInformationBlockType1_BR_r13 = SystemInformationBlockType1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct SystemInformationBlockType1_MBMS_r14 {
    pub cell_access_related_info_r14: SystemInformationBlockType1_MBMS_r14CellAccessRelatedInfo_r14,
    pub freq_band_indicator_r14: FreqBandIndicator_r11,
    #[asn(optional_idx = 0)]
    pub multi_band_info_list_r14: Option<MultiBandInfoList_r11>,
    pub scheduling_info_list_mbms_r14: SchedulingInfoList_MBMS_r14,
    pub si_window_length_r14: SystemInformationBlockType1_MBMS_r14Si_WindowLength_r14,
    pub system_info_value_tag_r14: SystemInformationBlockType1_MBMS_r14SystemInfoValueTag_r14,
    #[asn(optional_idx = 1)]
    pub non_mbsfn_subframe_config_r14: Option<NonMBSFN_SubframeConfig_r14>,
    pub pdsch_config_common_r14: PDSCH_ConfigCommon,
    #[asn(optional_idx = 2)]
    pub system_information_block_type13_r14: Option<SystemInformationBlockType13_r9>,
    #[asn(optional_idx = 3)]
    pub cell_access_related_info_list_r14:
        Option<SystemInformationBlockType1_MBMS_r14CellAccessRelatedInfoList_r14>,
    #[asn(optional_idx = 4)]
    pub non_critical_extension: Option<SystemInformationBlockType1_MBMS_r14NonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SystemInformationBlockType1_v10j0_IEs {
    #[asn(optional_idx = 0)]
    pub freq_band_info_r10: Option<NS_PmaxList_r10>,
    #[asn(optional_idx = 1)]
    pub multi_band_info_list_v10j0: Option<MultiBandInfoList_v10j0>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<SystemInformationBlockType1_v10l0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SystemInformationBlockType1_v10l0_IEs {
    #[asn(optional_idx = 0)]
    pub freq_band_info_v10l0: Option<NS_PmaxList_v10l0>,
    #[asn(optional_idx = 1)]
    pub multi_band_info_list_v10l0: Option<MultiBandInfoList_v10l0>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<SystemInformationBlockType1_v10x0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SystemInformationBlockType1_v10x0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<SystemInformationBlockType1_v10x0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SystemInformationBlockType1_v12j0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SystemInformationBlockType1_v1130_IEs {
    #[asn(optional_idx = 0)]
    pub tdd_config_v1130: Option<TDD_Config_v1130>,
    #[asn(optional_idx = 1)]
    pub cell_selection_info_v1130: Option<CellSelectionInfo_v1130>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<SystemInformationBlockType1_v1250_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SystemInformationBlockType1_v1250_IEs {
    pub cell_access_related_info_v1250:
        SystemInformationBlockType1_v1250_IEsCellAccessRelatedInfo_v1250,
    #[asn(optional_idx = 0)]
    pub cell_selection_info_v1250: Option<CellSelectionInfo_v1250>,
    #[asn(optional_idx = 1)]
    pub freq_band_indicator_priority_r12:
        Option<SystemInformationBlockType1_v1250_IEsFreqBandIndicatorPriority_r12>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<SystemInformationBlockType1_v1310_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SystemInformationBlockType1_v12j0_IEs {
    #[asn(optional_idx = 0)]
    pub scheduling_info_list_v12j0: Option<SchedulingInfoList_v12j0>,
    #[asn(optional_idx = 1)]
    pub scheduling_info_list_ext_r12: Option<SchedulingInfoListExt_r12>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<SystemInformationBlockType1_v15g0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct SystemInformationBlockType1_v1310_IEs {
    #[asn(optional_idx = 0)]
    pub hyper_sfn_r13: Option<SystemInformationBlockType1_v1310_IEsHyperSFN_r13>,
    #[asn(optional_idx = 1)]
    pub edrx_allowed_r13: Option<SystemInformationBlockType1_v1310_IEsEDRX_Allowed_r13>,
    #[asn(optional_idx = 2)]
    pub cell_selection_info_ce_r13: Option<CellSelectionInfoCE_r13>,
    #[asn(optional_idx = 3)]
    pub bandwidth_reduced_access_related_info_r13:
        Option<SystemInformationBlockType1_v1310_IEsBandwidthReducedAccessRelatedInfo_r13>,
    #[asn(optional_idx = 4)]
    pub non_critical_extension: Option<SystemInformationBlockType1_v1320_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SystemInformationBlockType1_v1320_IEs {
    #[asn(optional_idx = 0)]
    pub freq_hopping_parameters_dl_r13:
        Option<SystemInformationBlockType1_v1320_IEsFreqHoppingParametersDL_r13>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SystemInformationBlockType1_v1350_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SystemInformationBlockType1_v1350_IEs {
    #[asn(optional_idx = 0)]
    pub cell_selection_info_ce1_r13: Option<CellSelectionInfoCE1_r13>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SystemInformationBlockType1_v1360_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SystemInformationBlockType1_v1360_IEs {
    #[asn(optional_idx = 0)]
    pub cell_selection_info_ce1_v1360: Option<CellSelectionInfoCE1_v1360>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SystemInformationBlockType1_v1430_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct SystemInformationBlockType1_v1430_IEs {
    #[asn(optional_idx = 0)]
    pub e_call_over_ims_support_r14:
        Option<SystemInformationBlockType1_v1430_IEsECallOverIMS_Support_r14>,
    #[asn(optional_idx = 1)]
    pub tdd_config_v1430: Option<TDD_Config_v1430>,
    #[asn(optional_idx = 2)]
    pub cell_access_related_info_list_r14:
        Option<SystemInformationBlockType1_v1430_IEsCellAccessRelatedInfoList_r14>,
    #[asn(optional_idx = 3)]
    pub non_critical_extension: Option<SystemInformationBlockType1_v1450_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SystemInformationBlockType1_v1450_IEs {
    #[asn(optional_idx = 0)]
    pub tdd_config_v1450: Option<TDD_Config_v1450>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SystemInformationBlockType1_v1530_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 9)]
pub struct SystemInformationBlockType1_v1530_IEs {
    #[asn(optional_idx = 0)]
    pub hsdn_cell_r15: Option<SystemInformationBlockType1_v1530_IEsHsdn_Cell_r15>,
    #[asn(optional_idx = 1)]
    pub cell_selection_info_ce_v1530: Option<CellSelectionInfoCE_v1530>,
    #[asn(optional_idx = 2)]
    pub crs_intf_mitig_config_r15:
        Option<SystemInformationBlockType1_v1530_IEsCrs_IntfMitigConfig_r15>,
    pub cell_barred_crs_r15: SystemInformationBlockType1_v1530_IEsCellBarred_CRS_r15,
    #[asn(optional_idx = 3)]
    pub plmn_identity_list_v1530: Option<PLMN_IdentityList_v1530>,
    #[asn(optional_idx = 4)]
    pub pos_scheduling_info_list_r15: Option<PosSchedulingInfoList_r15>,
    #[asn(optional_idx = 5)]
    pub cell_access_related_info_5gc_r15:
        Option<SystemInformationBlockType1_v1530_IEsCellAccessRelatedInfo_5GC_r15>,
    #[asn(optional_idx = 6)]
    pub ims_emergency_support5_gc_r15:
        Option<SystemInformationBlockType1_v1530_IEsIms_EmergencySupport5GC_r15>,
    #[asn(optional_idx = 7)]
    pub e_call_over_ims_support5_gc_r15:
        Option<SystemInformationBlockType1_v1530_IEsECallOverIMS_Support5GC_r15>,
    #[asn(optional_idx = 8)]
    pub non_critical_extension: Option<SystemInformationBlockType1_v1540_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SystemInformationBlockType1_v1540_IEs {
    #[asn(optional_idx = 0)]
    pub si_pos_offset_r15: Option<SystemInformationBlockType1_v1540_IEsSi_posOffset_r15>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SystemInformationBlockType1_v1610_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SystemInformationBlockType1_v15g0_IEs {
    #[asn(optional_idx = 0)]
    pub bandwidth_reduced_access_related_info_v15g0:
        Option<SystemInformationBlockType1_v15g0_IEsBandwidthReducedAccessRelatedInfo_v15g0>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SystemInformationBlockType1_v15g0_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct SystemInformationBlockType1_v1610_IEs {
    #[asn(optional_idx = 0)]
    pub edrx_allowed_5gc_r16: Option<SystemInformationBlockType1_v1610_IEsEDRX_Allowed_5GC_r16>,
    #[asn(optional_idx = 1)]
    pub transmission_in_control_ch_region_r16:
        Option<SystemInformationBlockType1_v1610_IEsTransmissionInControlChRegion_r16>,
    #[asn(optional_idx = 2)]
    pub camping_allowed_in_ce_r16:
        Option<SystemInformationBlockType1_v1610_IEsCampingAllowedInCE_r16>,
    #[asn(optional_idx = 3)]
    pub plmn_identity_list_v1610: Option<PLMN_IdentityList_v1610>,
    #[asn(optional_idx = 4)]
    pub non_critical_extension: Option<SystemInformationBlockType1_v1700_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SystemInformationBlockType1_v1700_IEs {
    #[asn(optional_idx = 0)]
    pub cell_access_related_info_ntn_r17:
        Option<SystemInformationBlockType1_v1700_IEsCellAccessRelatedInfo_NTN_r17>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SystemInformationBlockType1_v1700_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SystemInformationBlockType1_v890_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<SystemInformationBlockType1_v890_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SystemInformationBlockType1_v920_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SystemInformationBlockType1_v8h0_IEs {
    #[asn(optional_idx = 0)]
    pub multi_band_info_list: Option<MultiBandInfoList>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SystemInformationBlockType1_v9e0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SystemInformationBlockType1_v920_IEs {
    #[asn(optional_idx = 0)]
    pub ims_emergency_support_r9:
        Option<SystemInformationBlockType1_v920_IEsIms_EmergencySupport_r9>,
    #[asn(optional_idx = 1)]
    pub cell_selection_info_v920: Option<CellSelectionInfo_v920>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<SystemInformationBlockType1_v1130_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SystemInformationBlockType1_v9e0_IEs {
    #[asn(optional_idx = 0)]
    pub freq_band_indicator_v9e0: Option<FreqBandIndicator_v9e0>,
    #[asn(optional_idx = 1)]
    pub multi_band_info_list_v9e0: Option<MultiBandInfoList_v9e0>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<SystemInformationBlockType1_v10j0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SystemInformationBlockType10 {
    pub message_identifier: SystemInformationBlockType10MessageIdentifier,
    pub serial_number: SystemInformationBlockType10SerialNumber,
    pub warning_type: SystemInformationBlockType10WarningType,
    #[asn(optional_idx = 0)]
    pub dummy: Option<SystemInformationBlockType10Dummy>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SystemInformationBlockType11 {
    pub message_identifier: SystemInformationBlockType11MessageIdentifier,
    pub serial_number: SystemInformationBlockType11SerialNumber,
    pub warning_message_segment_type: SystemInformationBlockType11WarningMessageSegmentType,
    pub warning_message_segment_number: SystemInformationBlockType11WarningMessageSegmentNumber,
    pub warning_message_segment: SystemInformationBlockType11WarningMessageSegment,
    #[asn(optional_idx = 0)]
    pub data_coding_scheme: Option<SystemInformationBlockType11DataCodingScheme>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SystemInformationBlockType12_r9 {
    pub message_identifier_r9: SystemInformationBlockType12_r9MessageIdentifier_r9,
    pub serial_number_r9: SystemInformationBlockType12_r9SerialNumber_r9,
    pub warning_message_segment_type_r9:
        SystemInformationBlockType12_r9WarningMessageSegmentType_r9,
    pub warning_message_segment_number_r9:
        SystemInformationBlockType12_r9WarningMessageSegmentNumber_r9,
    pub warning_message_segment_r9: SystemInformationBlockType12_r9WarningMessageSegment_r9,
    #[asn(optional_idx = 0)]
    pub data_coding_scheme_r9: Option<SystemInformationBlockType12_r9DataCodingScheme_r9>,
    #[asn(optional_idx = 1)]
    pub late_non_critical_extension:
        Option<SystemInformationBlockType12_r9LateNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SystemInformationBlockType13_r9 {
    pub mbsfn_area_info_list_r9: MBSFN_AreaInfoList_r9,
    pub notification_config_r9: MBMS_NotificationConfig_r9,
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<SystemInformationBlockType13_r9LateNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SystemInformationBlockType14_r11 {
    #[asn(optional_idx = 0)]
    pub eab_param_r11: Option<SystemInformationBlockType14_r11Eab_Param_r11>,
    #[asn(optional_idx = 1)]
    pub late_non_critical_extension:
        Option<SystemInformationBlockType14_r11LateNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct SystemInformationBlockType15_r11 {
    #[asn(optional_idx = 0)]
    pub mbms_sai_intra_freq_r11: Option<MBMS_SAI_List_r11>,
    #[asn(optional_idx = 1)]
    pub mbms_sai_inter_freq_list_r11: Option<MBMS_SAI_InterFreqList_r11>,
    #[asn(optional_idx = 2)]
    pub late_non_critical_extension:
        Option<SystemInformationBlockType15_r11LateNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SystemInformationBlockType16_r11 {
    #[asn(optional_idx = 0)]
    pub time_info_r11: Option<SystemInformationBlockType16_r11TimeInfo_r11>,
    #[asn(optional_idx = 1)]
    pub late_non_critical_extension:
        Option<SystemInformationBlockType16_r11LateNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SystemInformationBlockType17_r12 {
    #[asn(optional_idx = 0)]
    pub wlan_offload_info_per_plmn_list_r12:
        Option<SystemInformationBlockType17_r12Wlan_OffloadInfoPerPLMN_List_r12>,
    #[asn(optional_idx = 1)]
    pub late_non_critical_extension:
        Option<SystemInformationBlockType17_r12LateNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SystemInformationBlockType18_r12 {
    #[asn(optional_idx = 0)]
    pub comm_config_r12: Option<SystemInformationBlockType18_r12CommConfig_r12>,
    #[asn(optional_idx = 1)]
    pub late_non_critical_extension:
        Option<SystemInformationBlockType18_r12LateNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct SystemInformationBlockType19_r12 {
    #[asn(optional_idx = 0)]
    pub disc_config_r12: Option<SystemInformationBlockType19_r12DiscConfig_r12>,
    #[asn(optional_idx = 1)]
    pub disc_inter_freq_list_r12: Option<SL_CarrierFreqInfoList_r12>,
    #[asn(optional_idx = 2)]
    pub late_non_critical_extension:
        Option<SystemInformationBlockType19_r12LateNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SystemInformationBlockType2 {
    #[asn(optional_idx = 0)]
    pub ac_barring_info: Option<SystemInformationBlockType2Ac_BarringInfo>,
    pub radio_resource_config_common: RadioResourceConfigCommonSIB,
    pub ue_timers_and_constants: UE_TimersAndConstants,
    pub freq_info: SystemInformationBlockType2FreqInfo,
    #[asn(optional_idx = 1)]
    pub mbsfn_subframe_config_list: Option<MBSFN_SubframeConfigList>,
    pub time_alignment_timer_common: TimeAlignmentTimer,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SystemInformationBlockType2_v10m0_IEs {
    #[asn(optional_idx = 0)]
    pub freq_info_v10l0: Option<SystemInformationBlockType2_v10m0_IEsFreqInfo_v10l0>,
    #[asn(optional_idx = 1)]
    pub multi_band_info_list_v10l0:
        Option<SystemInformationBlockType2_v10m0_IEsMultiBandInfoList_v10l0>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<SystemInformationBlockType2_v10n0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SystemInformationBlockType2_v10n0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<SystemInformationBlockType2_v10n0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SystemInformationBlockType2_v13c0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SystemInformationBlockType2_v13c0_IEs {
    #[asn(optional_idx = 0)]
    pub uplink_power_control_common_v13c0: Option<UplinkPowerControlCommon_v1310>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SystemInformationBlockType2_v13c0_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SystemInformationBlockType2_v8h0_IEs {
    #[asn(optional_idx = 0)]
    pub multi_band_info_list: Option<SystemInformationBlockType2_v8h0_IEsMultiBandInfoList>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SystemInformationBlockType2_v9e0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SystemInformationBlockType2_v9e0_IEs {
    #[asn(optional_idx = 0)]
    pub ul_carrier_freq_v9e0: Option<ARFCN_ValueEUTRA_v9e0>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SystemInformationBlockType2_v9i0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SystemInformationBlockType2_v9i0_IEs {
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<SystemInformationBlockType2_v9i0_IEsNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub dummy: Option<SystemInformationBlockType2_v9i0_IEsDummy>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SystemInformationBlockType20_r13 {
    pub sc_mcch_repetition_period_r13: SystemInformationBlockType20_r13Sc_mcch_RepetitionPeriod_r13,
    pub sc_mcch_offset_r13: SystemInformationBlockType20_r13Sc_mcch_Offset_r13,
    pub sc_mcch_first_subframe_r13: SystemInformationBlockType20_r13Sc_mcch_FirstSubframe_r13,
    #[asn(optional_idx = 0)]
    pub sc_mcch_duration_r13: Option<SystemInformationBlockType20_r13Sc_mcch_duration_r13>,
    pub sc_mcch_modification_period_r13:
        SystemInformationBlockType20_r13Sc_mcch_ModificationPeriod_r13,
    #[asn(optional_idx = 1)]
    pub late_non_critical_extension:
        Option<SystemInformationBlockType20_r13LateNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SystemInformationBlockType21_r14 {
    #[asn(optional_idx = 0)]
    pub sl_v2x_config_common_r14: Option<SL_V2X_ConfigCommon_r14>,
    #[asn(optional_idx = 1)]
    pub late_non_critical_extension:
        Option<SystemInformationBlockType21_r14LateNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct SystemInformationBlockType24_r15 {
    #[asn(optional_idx = 0)]
    pub carrier_freq_list_nr_r15: Option<CarrierFreqListNR_r15>,
    pub t_reselection_nr_r15: T_Reselection,
    #[asn(optional_idx = 1)]
    pub t_reselection_nr_sf_r15: Option<SpeedStateScaleFactors>,
    #[asn(optional_idx = 2)]
    pub late_non_critical_extension:
        Option<SystemInformationBlockType24_r15LateNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct SystemInformationBlockType25_r15 {
    #[asn(optional_idx = 0)]
    pub uac_barring_for_common_r15: Option<UAC_BarringPerCatList_r15>,
    #[asn(optional_idx = 1)]
    pub uac_barring_per_plmn_list_r15: Option<UAC_BarringPerPLMN_List_r15>,
    pub uac_barring_info_set_list_r15: UAC_BarringInfoSetList_r15,
    #[asn(optional_idx = 2)]
    pub uac_ac1_select_assist_info_r15:
        Option<SystemInformationBlockType25_r15Uac_AC1_SelectAssistInfo_r15>,
    #[asn(optional_idx = 3)]
    pub late_non_critical_extension:
        Option<SystemInformationBlockType25_r15LateNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 7)]
pub struct SystemInformationBlockType26_r15 {
    #[asn(optional_idx = 0)]
    pub v2x_inter_freq_info_list_r15: Option<SL_InterFreqInfoListV2X_r14>,
    #[asn(optional_idx = 1)]
    pub cbr_pssch_tx_config_list_r15: Option<SL_CBR_PPPP_TxConfigList_r15>,
    #[asn(optional_idx = 2)]
    pub v2x_packet_duplication_config_r15: Option<SL_V2X_PacketDuplicationConfig_r15>,
    #[asn(optional_idx = 3)]
    pub sync_freq_list_r15: Option<SL_V2X_SyncFreqList_r15>,
    #[asn(optional_idx = 4)]
    pub slss_tx_multi_freq_r15: Option<SystemInformationBlockType26_r15Slss_TxMultiFreq_r15>,
    #[asn(optional_idx = 5)]
    pub v2x_freq_selection_config_list_r15: Option<SL_V2X_FreqSelectionConfigList_r15>,
    #[asn(optional_idx = 6)]
    pub thresh_s_rssi_cbr_r15: Option<SystemInformationBlockType26_r15ThreshS_RSSI_CBR_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SystemInformationBlockType26a_r16 {
    pub plmn_info_list_r16: PLMN_InfoList_r16,
    pub band_list_endc_r16: BandListENDC_r16,
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<SystemInformationBlockType26a_r16LateNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SystemInformationBlockType27_r16 {
    #[asn(optional_idx = 0)]
    pub carrier_freq_list_nbiot_r16: Option<CarrierFreqListNBIOT_r16>,
    #[asn(optional_idx = 1)]
    pub late_non_critical_extension:
        Option<SystemInformationBlockType27_r16LateNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SystemInformationBlockType28_r16 {
    pub segment_number_r16: SystemInformationBlockType28_r16SegmentNumber_r16,
    pub segment_type_r16: SystemInformationBlockType28_r16SegmentType_r16,
    pub segment_container_r16: SystemInformationBlockType28_r16SegmentContainer_r16,
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<SystemInformationBlockType28_r16LateNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct SystemInformationBlockType29_r16 {
    #[asn(optional_idx = 0)]
    pub resource_reservation_config_common_dl_r16: Option<ResourceReservationConfigDL_r16>,
    #[asn(optional_idx = 1)]
    pub resource_reservation_config_common_ul_r16: Option<ResourceReservationConfigUL_r16>,
    #[asn(optional_idx = 2)]
    pub late_non_critical_extension:
        Option<SystemInformationBlockType29_r16LateNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SystemInformationBlockType3 {
    pub cell_reselection_info_common: SystemInformationBlockType3CellReselectionInfoCommon,
    pub cell_reselection_serving_freq_info:
        SystemInformationBlockType3CellReselectionServingFreqInfo,
    pub intra_freq_cell_reselection_info: SystemInformationBlockType3IntraFreqCellReselectionInfo,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SystemInformationBlockType3_v10j0_IEs {
    #[asn(optional_idx = 0)]
    pub freq_band_info_r10: Option<NS_PmaxList_r10>,
    #[asn(optional_idx = 1)]
    pub multi_band_info_list_v10j0: Option<MultiBandInfoList_v10j0>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<SystemInformationBlockType3_v10l0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SystemInformationBlockType3_v10l0_IEs {
    #[asn(optional_idx = 0)]
    pub freq_band_info_v10l0: Option<NS_PmaxList_v10l0>,
    #[asn(optional_idx = 1)]
    pub multi_band_info_list_v10l0: Option<MultiBandInfoList_v10l0>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<SystemInformationBlockType3_v10l0_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct SystemInformationBlockType30_r17 {
    #[asn(optional_idx = 0)]
    pub common_plm_ns_with_disaster_condition_r17:
        Option<SystemInformationBlockType30_r17CommonPLMNsWithDisasterCondition_r17>,
    #[asn(optional_idx = 1)]
    pub applicable_disaster_info_list_r17:
        Option<SystemInformationBlockType30_r17ApplicableDisasterInfoList_r17>,
    #[asn(optional_idx = 2)]
    pub late_non_critical_extension:
        Option<SystemInformationBlockType30_r17LateNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SystemInformationBlockType31_r17 {
    pub serving_satellite_info_r17: ServingSatelliteInfo_r17,
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<SystemInformationBlockType31_r17LateNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SystemInformationBlockType32_r17 {
    #[asn(optional_idx = 0)]
    pub satellite_info_list_r17: Option<SatelliteInfoList_r17>,
    #[asn(optional_idx = 1)]
    pub late_non_critical_extension:
        Option<SystemInformationBlockType32_r17LateNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct SystemInformationBlockType4 {
    #[asn(optional_idx = 0)]
    pub intra_freq_neigh_cell_list: Option<IntraFreqNeighCellList>,
    #[asn(optional_idx = 1)]
    pub intra_freq_excluded_cell_list: Option<IntraFreqExcludedCellList>,
    #[asn(optional_idx = 2)]
    pub csg_phys_cell_id_range: Option<PhysCellIdRange>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SystemInformationBlockType5 {
    pub inter_freq_carrier_freq_list: InterFreqCarrierFreqList,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SystemInformationBlockType5_v10j0_IEs {
    #[asn(optional_idx = 0)]
    pub inter_freq_carrier_freq_list_v10j0:
        Option<SystemInformationBlockType5_v10j0_IEsInterFreqCarrierFreqList_v10j0>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SystemInformationBlockType5_v10l0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SystemInformationBlockType5_v10l0_IEs {
    #[asn(optional_idx = 0)]
    pub inter_freq_carrier_freq_list_v10l0:
        Option<SystemInformationBlockType5_v10l0_IEsInterFreqCarrierFreqList_v10l0>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SystemInformationBlockType5_v13a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SystemInformationBlockType5_v13a0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<SystemInformationBlockType5_v13a0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub inter_freq_carrier_freq_list_v13a0: Option<InterFreqCarrierFreqList_v13a0>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<SystemInformationBlockType5_v13a0_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SystemInformationBlockType5_v8h0_IEs {
    #[asn(optional_idx = 0)]
    pub inter_freq_carrier_freq_list_v8h0:
        Option<SystemInformationBlockType5_v8h0_IEsInterFreqCarrierFreqList_v8h0>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SystemInformationBlockType5_v9e0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SystemInformationBlockType5_v9e0_IEs {
    #[asn(optional_idx = 0)]
    pub inter_freq_carrier_freq_list_v9e0:
        Option<SystemInformationBlockType5_v9e0_IEsInterFreqCarrierFreqList_v9e0>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SystemInformationBlockType5_v10j0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct SystemInformationBlockType6 {
    #[asn(optional_idx = 0)]
    pub carrier_freq_list_utra_fdd: Option<CarrierFreqListUTRA_FDD>,
    #[asn(optional_idx = 1)]
    pub carrier_freq_list_utra_tdd: Option<CarrierFreqListUTRA_TDD>,
    pub t_reselection_utra: T_Reselection,
    #[asn(optional_idx = 2)]
    pub t_reselection_utra_sf: Option<SpeedStateScaleFactors>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SystemInformationBlockType6_v8h0_IEs {
    #[asn(optional_idx = 0)]
    pub carrier_freq_list_utra_fdd_v8h0:
        Option<SystemInformationBlockType6_v8h0_IEsCarrierFreqListUTRA_FDD_v8h0>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<SystemInformationBlockType6_v8h0_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SystemInformationBlockType7 {
    pub t_reselection_geran: T_Reselection,
    #[asn(optional_idx = 0)]
    pub t_reselection_geran_sf: Option<SpeedStateScaleFactors>,
    #[asn(optional_idx = 1)]
    pub carrier_freqs_info_list: Option<CarrierFreqsInfoListGERAN>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct SystemInformationBlockType8 {
    #[asn(optional_idx = 0)]
    pub system_time_info: Option<SystemTimeInfoCDMA2000>,
    #[asn(optional_idx = 1)]
    pub search_window_size: Option<SystemInformationBlockType8SearchWindowSize>,
    #[asn(optional_idx = 2)]
    pub parameters_hrpd: Option<SystemInformationBlockType8ParametersHRPD>,
    #[asn(optional_idx = 3)]
    pub parameters1_xrtt: Option<SystemInformationBlockType8Parameters1XRTT>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SystemInformationBlockType9 {
    #[asn(optional_idx = 0)]
    pub hnb_name: Option<SystemInformationBlockType9Hnb_Name>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SystemTimeInfoCDMA2000 {
    pub cdma_eutra_synchronisation: SystemTimeInfoCDMA2000Cdma_EUTRA_Synchronisation,
    pub cdma_system_time: SystemTimeInfoCDMA2000Cdma_SystemTime,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "63")]
pub struct T_PollRetransmit(pub u8);
impl T_PollRetransmit {
    pub const MS5: u8 = 0u8;
    pub const MS10: u8 = 1u8;
    pub const MS15: u8 = 2u8;
    pub const MS20: u8 = 3u8;
    pub const MS25: u8 = 4u8;
    pub const MS30: u8 = 5u8;
    pub const MS35: u8 = 6u8;
    pub const MS40: u8 = 7u8;
    pub const MS45: u8 = 8u8;
    pub const MS50: u8 = 9u8;
    pub const MS55: u8 = 10u8;
    pub const MS60: u8 = 11u8;
    pub const MS65: u8 = 12u8;
    pub const MS70: u8 = 13u8;
    pub const MS75: u8 = 14u8;
    pub const MS80: u8 = 15u8;
    pub const MS85: u8 = 16u8;
    pub const MS90: u8 = 17u8;
    pub const MS95: u8 = 18u8;
    pub const MS100: u8 = 19u8;
    pub const MS105: u8 = 20u8;
    pub const MS110: u8 = 21u8;
    pub const MS115: u8 = 22u8;
    pub const MS120: u8 = 23u8;
    pub const MS125: u8 = 24u8;
    pub const MS130: u8 = 25u8;
    pub const MS135: u8 = 26u8;
    pub const MS140: u8 = 27u8;
    pub const MS145: u8 = 28u8;
    pub const MS150: u8 = 29u8;
    pub const MS155: u8 = 30u8;
    pub const MS160: u8 = 31u8;
    pub const MS165: u8 = 32u8;
    pub const MS170: u8 = 33u8;
    pub const MS175: u8 = 34u8;
    pub const MS180: u8 = 35u8;
    pub const MS185: u8 = 36u8;
    pub const MS190: u8 = 37u8;
    pub const MS195: u8 = 38u8;
    pub const MS200: u8 = 39u8;
    pub const MS205: u8 = 40u8;
    pub const MS210: u8 = 41u8;
    pub const MS215: u8 = 42u8;
    pub const MS220: u8 = 43u8;
    pub const MS225: u8 = 44u8;
    pub const MS230: u8 = 45u8;
    pub const MS235: u8 = 46u8;
    pub const MS240: u8 = 47u8;
    pub const MS245: u8 = 48u8;
    pub const MS250: u8 = 49u8;
    pub const MS300: u8 = 50u8;
    pub const MS350: u8 = 51u8;
    pub const MS400: u8 = 52u8;
    pub const MS450: u8 = 53u8;
    pub const MS500: u8 = 54u8;
    pub const MS800_V1310: u8 = 55u8;
    pub const MS1000_V1310: u8 = 56u8;
    pub const MS2000_V1310: u8 = 57u8;
    pub const MS4000_V1310: u8 = 58u8;
    pub const SPARE5: u8 = 59u8;
    pub const SPARE4: u8 = 60u8;
    pub const SPARE3: u8 = 61u8;
    pub const SPARE2: u8 = 62u8;
    pub const SPARE1: u8 = 63u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "31")]
pub struct T_Reordering(pub u8);
impl T_Reordering {
    pub const MS0: u8 = 0u8;
    pub const MS5: u8 = 1u8;
    pub const MS10: u8 = 2u8;
    pub const MS15: u8 = 3u8;
    pub const MS20: u8 = 4u8;
    pub const MS25: u8 = 5u8;
    pub const MS30: u8 = 6u8;
    pub const MS35: u8 = 7u8;
    pub const MS40: u8 = 8u8;
    pub const MS45: u8 = 9u8;
    pub const MS50: u8 = 10u8;
    pub const MS55: u8 = 11u8;
    pub const MS60: u8 = 12u8;
    pub const MS65: u8 = 13u8;
    pub const MS70: u8 = 14u8;
    pub const MS75: u8 = 15u8;
    pub const MS80: u8 = 16u8;
    pub const MS85: u8 = 17u8;
    pub const MS90: u8 = 18u8;
    pub const MS95: u8 = 19u8;
    pub const MS100: u8 = 20u8;
    pub const MS110: u8 = 21u8;
    pub const MS120: u8 = 22u8;
    pub const MS130: u8 = 23u8;
    pub const MS140: u8 = 24u8;
    pub const MS150: u8 = 25u8;
    pub const MS160: u8 = 26u8;
    pub const MS170: u8 = 27u8;
    pub const MS180: u8 = 28u8;
    pub const MS190: u8 = 29u8;
    pub const MS200: u8 = 30u8;
    pub const MS1600_V1310: u8 = 31u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct T_ReorderingExt_r17(pub u8);
impl T_ReorderingExt_r17 {
    pub const MS2200: u8 = 0u8;
    pub const MS3200: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct T_Reselection(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct T_ReselectionEUTRA_CE_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "63")]
pub struct T_StatusProhibit(pub u8);
impl T_StatusProhibit {
    pub const MS0: u8 = 0u8;
    pub const MS5: u8 = 1u8;
    pub const MS10: u8 = 2u8;
    pub const MS15: u8 = 3u8;
    pub const MS20: u8 = 4u8;
    pub const MS25: u8 = 5u8;
    pub const MS30: u8 = 6u8;
    pub const MS35: u8 = 7u8;
    pub const MS40: u8 = 8u8;
    pub const MS45: u8 = 9u8;
    pub const MS50: u8 = 10u8;
    pub const MS55: u8 = 11u8;
    pub const MS60: u8 = 12u8;
    pub const MS65: u8 = 13u8;
    pub const MS70: u8 = 14u8;
    pub const MS75: u8 = 15u8;
    pub const MS80: u8 = 16u8;
    pub const MS85: u8 = 17u8;
    pub const MS90: u8 = 18u8;
    pub const MS95: u8 = 19u8;
    pub const MS100: u8 = 20u8;
    pub const MS105: u8 = 21u8;
    pub const MS110: u8 = 22u8;
    pub const MS115: u8 = 23u8;
    pub const MS120: u8 = 24u8;
    pub const MS125: u8 = 25u8;
    pub const MS130: u8 = 26u8;
    pub const MS135: u8 = 27u8;
    pub const MS140: u8 = 28u8;
    pub const MS145: u8 = 29u8;
    pub const MS150: u8 = 30u8;
    pub const MS155: u8 = 31u8;
    pub const MS160: u8 = 32u8;
    pub const MS165: u8 = 33u8;
    pub const MS170: u8 = 34u8;
    pub const MS175: u8 = 35u8;
    pub const MS180: u8 = 36u8;
    pub const MS185: u8 = 37u8;
    pub const MS190: u8 = 38u8;
    pub const MS195: u8 = 39u8;
    pub const MS200: u8 = 40u8;
    pub const MS205: u8 = 41u8;
    pub const MS210: u8 = 42u8;
    pub const MS215: u8 = 43u8;
    pub const MS220: u8 = 44u8;
    pub const MS225: u8 = 45u8;
    pub const MS230: u8 = 46u8;
    pub const MS235: u8 = 47u8;
    pub const MS240: u8 = 48u8;
    pub const MS245: u8 = 49u8;
    pub const MS250: u8 = 50u8;
    pub const MS300: u8 = 51u8;
    pub const MS350: u8 = 52u8;
    pub const MS400: u8 = 53u8;
    pub const MS450: u8 = 54u8;
    pub const MS500: u8 = 55u8;
    pub const MS800_V1310: u8 = 56u8;
    pub const MS1000_V1310: u8 = 57u8;
    pub const MS1200_V1310: u8 = 58u8;
    pub const MS1600_V1310: u8 = 59u8;
    pub const MS2000_V1310: u8 = 60u8;
    pub const MS2400_V1310: u8 = 61u8;
    pub const SPARE2: u8 = 62u8;
    pub const SPARE1: u8 = 63u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TDD_Config {
    pub subframe_assignment: TDD_ConfigSubframeAssignment,
    pub special_subframe_patterns: TDD_ConfigSpecialSubframePatterns,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TDD_Config_v1130 {
    pub special_subframe_patterns_v1130: TDD_Config_v1130SpecialSubframePatterns_v1130,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TDD_Config_v1430 {
    pub special_subframe_patterns_v1430: TDD_Config_v1430SpecialSubframePatterns_v1430,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TDD_Config_v1450 {
    pub special_subframe_patterns_v1450: TDD_Config_v1450SpecialSubframePatterns_v1450,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TDD_ConfigSL_r12 {
    pub subframe_assignment_sl_r12: TDD_ConfigSL_r12SubframeAssignmentSL_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum TDD_PUSCH_UpPTS_r14 {
    #[asn(key = 0, extended = false)]
    Release(TDD_PUSCH_UpPTS_r14_release),
    #[asn(key = 1, extended = false)]
    Setup(TDD_PUSCH_UpPTS_r14_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum TDM_AssistanceInfo_r11 {
    #[asn(key = 0, extended = false)]
    Drx_AssistanceInfo_r11(TDM_AssistanceInfo_r11_drx_AssistanceInfo_r11),
    #[asn(key = 1, extended = false)]
    Idc_SubframePatternList_r11(IDC_SubframePatternList_r11),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum TDM_PatternConfig_r15 {
    #[asn(key = 0, extended = false)]
    Release(TDM_PatternConfig_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(TDM_PatternConfig_r15_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TLE_EphemerisParameters_r17 {
    pub inclination_r17: TLE_EphemerisParameters_r17Inclination_r17,
    pub argument_perigee_r17: TLE_EphemerisParameters_r17ArgumentPerigee_r17,
    pub right_ascension_r17: TLE_EphemerisParameters_r17RightAscension_r17,
    pub mean_anomaly_r17: TLE_EphemerisParameters_r17MeanAnomaly_r17,
    pub eccentricity_r17: TLE_EphemerisParameters_r17Eccentricity_r17,
    pub mean_motion_r17: TLE_EphemerisParameters_r17MeanMotion_r17,
    pub b_star_decimal_r17: TLE_EphemerisParameters_r17BStarDecimal_r17,
    pub b_star_exponent_r17: TLE_EphemerisParameters_r17BStarExponent_r17,
    pub epoch_star_r17: TLE_EphemerisParameters_r17EpochStar_r17,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TMGI_r9 {
    pub plmn_id_r9: TMGI_r9Plmn_Id_r9,
    pub service_id_r9: TMGI_r9ServiceId_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum TPC_Index {
    #[asn(key = 0, extended = false)]
    IndexOfFormat3(TPC_Index_indexOfFormat3),
    #[asn(key = 1, extended = false)]
    IndexOfFormat3A(TPC_Index_indexOfFormat3A),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum TPC_PDCCH_Config {
    #[asn(key = 0, extended = false)]
    Release(TPC_PDCCH_Config_release),
    #[asn(key = 1, extended = false)]
    Setup(TPC_PDCCH_Config_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum TPC_PDCCH_ConfigSCell_r13 {
    #[asn(key = 0, extended = false)]
    Release(TPC_PDCCH_ConfigSCell_r13_release),
    #[asn(key = 1, extended = false)]
    Setup(TPC_PDCCH_ConfigSCell_r13_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TargetMBSFN_Area_r12 {
    #[asn(optional_idx = 0)]
    pub mbsfn_area_id_r12: Option<MBSFN_AreaId_r12>,
    pub carrier_freq_r12: ARFCN_ValueEUTRA_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "0", sz_ub = "8")]
pub struct TargetMBSFN_AreaList_r12(pub Vec<TargetMBSFN_Area_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63")]
pub struct ThresholdCDMA2000(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum ThresholdEUTRA {
    #[asn(key = 0, extended = false)]
    Threshold_RSRP(RSRP_Range),
    #[asn(key = 1, extended = false)]
    Threshold_RSRQ(RSRQ_Range),
}

pub type ThresholdEUTRA_v1250 = CSI_RSRP_Range_r12;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63")]
pub struct ThresholdGERAN(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct ThresholdListNR_r15 {
    #[asn(optional_idx = 0)]
    pub nr_rsrp_r15: Option<RSRP_RangeNR_r15>,
    #[asn(optional_idx = 1)]
    pub nr_rsrq_r15: Option<RSRQ_RangeNR_r15>,
    #[asn(optional_idx = 2)]
    pub nr_sinr_r15: Option<RS_SINR_RangeNR_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum ThresholdNR_r15 {
    #[asn(key = 0, extended = false)]
    Nr_RSRP_r15(RSRP_RangeNR_r15),
    #[asn(key = 1, extended = false)]
    Nr_RSRQ_r15(RSRQ_RangeNR_r15),
    #[asn(key = 2, extended = false)]
    Nr_SINR_r15(RS_SINR_RangeNR_r15),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum ThresholdUTRA {
    #[asn(key = 0, extended = false)]
    Utra_RSCP(ThresholdUTRA_utra_RSCP),
    #[asn(key = 1, extended = false)]
    Utra_EcN0(ThresholdUTRA_utra_EcN0),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct TimeAlignmentTimer(pub u8);
impl TimeAlignmentTimer {
    pub const SF500: u8 = 0u8;
    pub const SF750: u8 = 1u8;
    pub const SF1280: u8 = 2u8;
    pub const SF1920: u8 = 3u8;
    pub const SF2560: u8 = 4u8;
    pub const SF5120: u8 = 5u8;
    pub const SF10240: u8 = 6u8;
    pub const INFINITY: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1048575")]
pub struct TimeOffsetUTC_r17(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct TimeReferenceInfo_r15 {
    pub time_r15: ReferenceTime_r15,
    #[asn(optional_idx = 0)]
    pub uncertainty_r15: Option<TimeReferenceInfo_r15Uncertainty_r15>,
    #[asn(optional_idx = 1)]
    pub time_info_type_r15: Option<TimeReferenceInfo_r15TimeInfoType_r15>,
    #[asn(optional_idx = 2)]
    pub reference_sfn_r15: Option<TimeReferenceInfo_r15ReferenceSFN_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "172800")]
pub struct TimeSinceFailure_r11(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct TimeToTrigger(pub u8);
impl TimeToTrigger {
    pub const MS0: u8 = 0u8;
    pub const MS40: u8 = 1u8;
    pub const MS64: u8 = 2u8;
    pub const MS80: u8 = 3u8;
    pub const MS100: u8 = 4u8;
    pub const MS128: u8 = 5u8;
    pub const MS160: u8 = 6u8;
    pub const MS256: u8 = 7u8;
    pub const MS320: u8 = 8u8;
    pub const MS480: u8 = 9u8;
    pub const MS512: u8 = 10u8;
    pub const MS640: u8 = 11u8;
    pub const MS1024: u8 = 12u8;
    pub const MS1280: u8 = 13u8;
    pub const MS2560: u8 = 14u8;
    pub const MS5120: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "172800")]
pub struct TimeUntilReconnection_r16(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TraceReference_r10 {
    pub plmn_identity_r10: PLMN_Identity,
    pub trace_id_r10: TraceReference_r10TraceId_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct TrackingAreaCode(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "24", sz_ub = "24")]
pub struct TrackingAreaCode_5GC_r15(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct TrackingAreaCodeList_r10(pub Vec<TrackingAreaCode>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TrackingAreaCodeList_v1130 {
    pub plmn_identity_per_tac_list_r11: TrackingAreaCodeList_v1130Plmn_Identity_perTAC_List_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "24", sz_ub = "24")]
pub struct TrackingAreaCodeNR_r15(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "12")]
pub struct TrackingAreaList_r17(pub Vec<TrackingAreaCode>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct TrafficPatternInfo_r14 {
    pub traffic_periodicity_r14: TrafficPatternInfo_r14TrafficPeriodicity_r14,
    pub timing_offset_r14: TrafficPatternInfo_r14TimingOffset_r14,
    #[asn(optional_idx = 0)]
    pub priority_info_sl_r14: Option<SL_Priority_r13>,
    #[asn(optional_idx = 1)]
    pub logical_channel_identity_ul_r14: Option<TrafficPatternInfo_r14LogicalChannelIdentityUL_r14>,
    pub message_size_r14: TrafficPatternInfo_r14MessageSize_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct TrafficPatternInfo_v1530 {
    #[asn(optional_idx = 0)]
    pub traffic_destination_r15: Option<SL_DestinationIdentity_r12>,
    #[asn(optional_idx = 1)]
    pub reliability_info_sl_r15: Option<SL_Reliability_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct TrafficPatternInfoList_r14(pub Vec<TrafficPatternInfo_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct TrafficPatternInfoList_v1530(pub Vec<TrafficPatternInfo_v1530>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct TunnelConfigLWIP_r13 {
    pub ip_address_r13: IP_Address_r13,
    pub ike_identity_r13: IKE_Identity_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63")]
pub struct Tx_ConfigIndex_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "127")]
pub struct Tx_PreconfigIndex_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "72")]
pub struct Tx_ResourcePoolMeasList_r14(pub Vec<SL_V2X_TxPoolReportIdentity_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct UAC_AC1_SelectAssistInfo_r15(pub u8);
impl UAC_AC1_SelectAssistInfo_r15 {
    pub const A: u8 = 0u8;
    pub const B: u8 = 1u8;
    pub const C: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct UAC_AC1_SelectAssistInfo_r16(pub u8);
impl UAC_AC1_SelectAssistInfo_r16 {
    pub const A: u8 = 0u8;
    pub const B: u8 = 1u8;
    pub const C: u8 = 2u8;
    pub const NOT_CONFIGURED: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UAC_BarringInfoSet_r15 {
    pub uac_barring_factor_r15: UAC_BarringInfoSet_r15Uac_BarringFactor_r15,
    pub uac_barring_time_r15: UAC_BarringInfoSet_r15Uac_BarringTime_r15,
    pub uac_barring_for_access_identity_r15: UAC_BarringInfoSet_r15Uac_BarringForAccessIdentity_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UAC_BarringInfoSet_v1700 {
    #[asn(optional_idx = 0)]
    pub uac_barring_factor_for_ai3_r17: Option<UAC_BarringInfoSet_v1700Uac_BarringFactorForAI3_r17>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8")]
pub struct UAC_BarringInfoSetIndex_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct UAC_BarringInfoSetList_r15(pub Vec<UAC_BarringInfoSet_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct UAC_BarringInfoSetList_v1700(pub Vec<UAC_BarringInfoSet_v1700>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UAC_BarringPerCat_r15 {
    pub access_category_r15: UAC_BarringPerCat_r15AccessCategory_r15,
    pub uac_barring_info_set_index_r15: UAC_BarringInfoSetIndex_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "63")]
pub struct UAC_BarringPerCatList_r15(pub Vec<UAC_BarringPerCat_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct UAC_BarringPerPLMN_List_r15(pub Vec<UAC_BarringPerPLMN_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UAC_BarringPerPLMN_r15 {
    pub plmn_identity_index_r15: UAC_BarringPerPLMN_r15Plmn_IdentityIndex_r15,
    #[asn(optional_idx = 0)]
    pub uac_ac_barring_list_type_r15: Option<UAC_BarringPerPLMN_r15Uac_AC_BarringListType_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UDT_Restricting_r13 {
    #[asn(optional_idx = 0)]
    pub udt_restricting_r13: Option<UDT_Restricting_r13Udt_Restricting_r13>,
    #[asn(optional_idx = 1)]
    pub udt_restricting_time_r13: Option<UDT_Restricting_r13Udt_RestrictingTime_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct UDT_RestrictingPerPLMN_List_r13(pub Vec<UDT_RestrictingPerPLMN_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UDT_RestrictingPerPLMN_r13 {
    pub plmn_identity_index_r13: UDT_RestrictingPerPLMN_r13Plmn_IdentityIndex_r13,
    #[asn(optional_idx = 0)]
    pub udt_restricting_r13: Option<UDT_Restricting_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_BasedNetwPerfMeasParameters_r10 {
    #[asn(optional_idx = 0)]
    pub logged_measurements_idle_r10:
        Option<UE_BasedNetwPerfMeasParameters_r10LoggedMeasurementsIdle_r10>,
    #[asn(optional_idx = 1)]
    pub standalone_gnss_location_r10:
        Option<UE_BasedNetwPerfMeasParameters_r10StandaloneGNSS_Location_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_BasedNetwPerfMeasParameters_v1250 {
    pub logged_mbsfn_measurements_r12:
        UE_BasedNetwPerfMeasParameters_v1250LoggedMBSFNMeasurements_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UE_BasedNetwPerfMeasParameters_v1430 {
    #[asn(optional_idx = 0)]
    pub location_report_r14: Option<UE_BasedNetwPerfMeasParameters_v1430LocationReport_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct UE_BasedNetwPerfMeasParameters_v1530 {
    #[asn(optional_idx = 0)]
    pub logged_meas_bt_r15: Option<UE_BasedNetwPerfMeasParameters_v1530LoggedMeasBT_r15>,
    #[asn(optional_idx = 1)]
    pub logged_meas_wlan_r15: Option<UE_BasedNetwPerfMeasParameters_v1530LoggedMeasWLAN_r15>,
    #[asn(optional_idx = 2)]
    pub imm_meas_bt_r15: Option<UE_BasedNetwPerfMeasParameters_v1530ImmMeasBT_r15>,
    #[asn(optional_idx = 3)]
    pub imm_meas_wlan_r15: Option<UE_BasedNetwPerfMeasParameters_v1530ImmMeasWLAN_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UE_BasedNetwPerfMeasParameters_v1610 {
    #[asn(optional_idx = 0)]
    pub ul_pdcp_avg_delay_r16: Option<UE_BasedNetwPerfMeasParameters_v1610Ul_PDCP_AvgDelay_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct UE_BasedNetwPerfMeasParameters_v1700 {
    #[asn(optional_idx = 0)]
    pub logged_meas_idle_event_l1_r17:
        Option<UE_BasedNetwPerfMeasParameters_v1700LoggedMeasIdleEventL1_r17>,
    #[asn(optional_idx = 1)]
    pub logged_meas_idle_event_out_of_coverage_r17:
        Option<UE_BasedNetwPerfMeasParameters_v1700LoggedMeasIdleEventOutOfCoverage_r17>,
    #[asn(optional_idx = 2)]
    pub logged_meas_uncom_bar_pre_r17:
        Option<UE_BasedNetwPerfMeasParameters_v1700LoggedMeasUncomBarPre_r17>,
    #[asn(optional_idx = 3)]
    pub imm_meas_uncom_bar_pre_r17:
        Option<UE_BasedNetwPerfMeasParameters_v1700ImmMeasUncomBarPre_r17>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_CapabilityRAT_Container {
    pub rat_type: RAT_Type,
    pub ue_capability_rat_container: UE_CapabilityRAT_ContainerUeCapabilityRAT_Container,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "0", sz_ub = "8")]
pub struct UE_CapabilityRAT_ContainerList(pub Vec<UE_CapabilityRAT_Container>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct UE_CapabilityRequest(pub Vec<RAT_Type>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_CategorySL_r15 {
    pub ue_category_sl_c_tx_r15: UE_CategorySL_r15Ue_CategorySL_C_TX_r15,
    pub ue_category_sl_c_rx_r15: UE_CategorySL_r15Ue_CategorySL_C_RX_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability {
    pub access_stratum_release: AccessStratumRelease,
    pub ue_category: UE_EUTRA_CapabilityUe_Category,
    pub pdcp_parameters: PDCP_Parameters,
    pub phy_layer_parameters: PhyLayerParameters,
    pub rf_parameters: RF_Parameters,
    pub meas_parameters: MeasParameters,
    #[asn(optional_idx = 0)]
    pub feature_group_indicators: Option<UE_EUTRA_CapabilityFeatureGroupIndicators>,
    pub inter_rat_parameters: UE_EUTRA_CapabilityInterRAT_Parameters,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v920_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 9)]
pub struct UE_EUTRA_Capability_v1020_IEs {
    #[asn(optional_idx = 0)]
    pub ue_category_v1020: Option<UE_EUTRA_Capability_v1020_IEsUe_Category_v1020>,
    #[asn(optional_idx = 1)]
    pub phy_layer_parameters_v1020: Option<PhyLayerParameters_v1020>,
    #[asn(optional_idx = 2)]
    pub rf_parameters_v1020: Option<RF_Parameters_v1020>,
    #[asn(optional_idx = 3)]
    pub meas_parameters_v1020: Option<MeasParameters_v1020>,
    #[asn(optional_idx = 4)]
    pub feature_group_ind_rel10_r10: Option<UE_EUTRA_Capability_v1020_IEsFeatureGroupIndRel10_r10>,
    #[asn(optional_idx = 5)]
    pub inter_rat_parameters_cdma2000_v1020: Option<IRAT_ParametersCDMA2000_1XRTT_v1020>,
    #[asn(optional_idx = 6)]
    pub ue_based_netw_perf_meas_parameters_r10: Option<UE_BasedNetwPerfMeasParameters_r10>,
    #[asn(optional_idx = 7)]
    pub inter_rat_parameters_utra_tdd_v1020: Option<IRAT_ParametersUTRA_TDD_v1020>,
    #[asn(optional_idx = 8)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1060_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct UE_EUTRA_Capability_v1060_IEs {
    #[asn(optional_idx = 0)]
    pub fdd_add_ue_eutra_capabilities_v1060: Option<UE_EUTRA_CapabilityAddXDD_Mode_v1060>,
    #[asn(optional_idx = 1)]
    pub tdd_add_ue_eutra_capabilities_v1060: Option<UE_EUTRA_CapabilityAddXDD_Mode_v1060>,
    #[asn(optional_idx = 2)]
    pub rf_parameters_v1060: Option<RF_Parameters_v1060>,
    #[asn(optional_idx = 3)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1090_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v1090_IEs {
    #[asn(optional_idx = 0)]
    pub rf_parameters_v1090: Option<RF_Parameters_v1090>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1130_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v10c0_IEs {
    #[asn(optional_idx = 0)]
    pub otdoa_positioning_capabilities_r10: Option<OTDOA_PositioningCapabilities_r10>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v10f0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v10f0_IEs {
    #[asn(optional_idx = 0)]
    pub rf_parameters_v10f0: Option<RF_Parameters_v10f0>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v10i0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct UE_EUTRA_Capability_v10i0_IEs {
    #[asn(optional_idx = 0)]
    pub rf_parameters_v10i0: Option<RF_Parameters_v10i0>,
    #[asn(optional_idx = 1)]
    pub late_non_critical_extension: Option<UE_EUTRA_Capability_v10i0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v11d0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v10j0_IEs {
    #[asn(optional_idx = 0)]
    pub rf_parameters_v10j0: Option<RF_Parameters_v10j0>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v10j0_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct UE_EUTRA_Capability_v1130_IEs {
    pub pdcp_parameters_v1130: PDCP_Parameters_v1130,
    #[asn(optional_idx = 0)]
    pub phy_layer_parameters_v1130: Option<PhyLayerParameters_v1130>,
    pub rf_parameters_v1130: RF_Parameters_v1130,
    pub meas_parameters_v1130: MeasParameters_v1130,
    pub inter_rat_parameters_cdma2000_v1130: IRAT_ParametersCDMA2000_v1130,
    pub other_parameters_r11: Other_Parameters_r11,
    #[asn(optional_idx = 1)]
    pub fdd_add_ue_eutra_capabilities_v1130: Option<UE_EUTRA_CapabilityAddXDD_Mode_v1130>,
    #[asn(optional_idx = 2)]
    pub tdd_add_ue_eutra_capabilities_v1130: Option<UE_EUTRA_CapabilityAddXDD_Mode_v1130>,
    #[asn(optional_idx = 3)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1170_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct UE_EUTRA_Capability_v1170_IEs {
    #[asn(optional_idx = 0)]
    pub phy_layer_parameters_v1170: Option<PhyLayerParameters_v1170>,
    #[asn(optional_idx = 1)]
    pub ue_category_v1170: Option<UE_EUTRA_Capability_v1170_IEsUe_Category_v1170>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1180_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct UE_EUTRA_Capability_v1180_IEs {
    #[asn(optional_idx = 0)]
    pub rf_parameters_v1180: Option<RF_Parameters_v1180>,
    #[asn(optional_idx = 1)]
    pub mbms_parameters_r11: Option<MBMS_Parameters_r11>,
    #[asn(optional_idx = 2)]
    pub fdd_add_ue_eutra_capabilities_v1180: Option<UE_EUTRA_CapabilityAddXDD_Mode_v1180>,
    #[asn(optional_idx = 3)]
    pub tdd_add_ue_eutra_capabilities_v1180: Option<UE_EUTRA_CapabilityAddXDD_Mode_v1180>,
    #[asn(optional_idx = 4)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v11a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct UE_EUTRA_Capability_v11a0_IEs {
    #[asn(optional_idx = 0)]
    pub ue_category_v11a0: Option<UE_EUTRA_Capability_v11a0_IEsUe_Category_v11a0>,
    #[asn(optional_idx = 1)]
    pub meas_parameters_v11a0: Option<MeasParameters_v11a0>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1250_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct UE_EUTRA_Capability_v11d0_IEs {
    #[asn(optional_idx = 0)]
    pub rf_parameters_v11d0: Option<RF_Parameters_v11d0>,
    #[asn(optional_idx = 1)]
    pub other_parameters_v11d0: Option<Other_Parameters_v11d0>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v11x0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v11x0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<UE_EUTRA_Capability_v11x0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v12b0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 15)]
pub struct UE_EUTRA_Capability_v1250_IEs {
    #[asn(optional_idx = 0)]
    pub phy_layer_parameters_v1250: Option<PhyLayerParameters_v1250>,
    #[asn(optional_idx = 1)]
    pub rf_parameters_v1250: Option<RF_Parameters_v1250>,
    #[asn(optional_idx = 2)]
    pub rlc_parameters_r12: Option<RLC_Parameters_r12>,
    #[asn(optional_idx = 3)]
    pub ue_based_netw_perf_meas_parameters_v1250: Option<UE_BasedNetwPerfMeasParameters_v1250>,
    #[asn(optional_idx = 4)]
    pub ue_category_dl_r12: Option<UE_EUTRA_Capability_v1250_IEsUe_CategoryDL_r12>,
    #[asn(optional_idx = 5)]
    pub ue_category_ul_r12: Option<UE_EUTRA_Capability_v1250_IEsUe_CategoryUL_r12>,
    #[asn(optional_idx = 6)]
    pub wlan_iw_parameters_r12: Option<WLAN_IW_Parameters_r12>,
    #[asn(optional_idx = 7)]
    pub meas_parameters_v1250: Option<MeasParameters_v1250>,
    #[asn(optional_idx = 8)]
    pub dc_parameters_r12: Option<DC_Parameters_r12>,
    #[asn(optional_idx = 9)]
    pub mbms_parameters_v1250: Option<MBMS_Parameters_v1250>,
    #[asn(optional_idx = 10)]
    pub mac_parameters_r12: Option<MAC_Parameters_r12>,
    #[asn(optional_idx = 11)]
    pub fdd_add_ue_eutra_capabilities_v1250: Option<UE_EUTRA_CapabilityAddXDD_Mode_v1250>,
    #[asn(optional_idx = 12)]
    pub tdd_add_ue_eutra_capabilities_v1250: Option<UE_EUTRA_CapabilityAddXDD_Mode_v1250>,
    #[asn(optional_idx = 13)]
    pub sl_parameters_r12: Option<SL_Parameters_r12>,
    #[asn(optional_idx = 14)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1260_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v1260_IEs {
    #[asn(optional_idx = 0)]
    pub ue_category_dl_v1260: Option<UE_EUTRA_Capability_v1260_IEsUe_CategoryDL_v1260>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1270_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v1270_IEs {
    #[asn(optional_idx = 0)]
    pub rf_parameters_v1270: Option<RF_Parameters_v1270>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1280_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v1280_IEs {
    #[asn(optional_idx = 0)]
    pub phy_layer_parameters_v1280: Option<PhyLayerParameters_v1280>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1310_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v12b0_IEs {
    #[asn(optional_idx = 0)]
    pub rf_parameters_v12b0: Option<RF_Parameters_v12b0>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v12x0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v12x0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<UE_EUTRA_Capability_v12x0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1370_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 15)]
pub struct UE_EUTRA_Capability_v1310_IEs {
    #[asn(optional_idx = 0)]
    pub ue_category_dl_v1310: Option<UE_EUTRA_Capability_v1310_IEsUe_CategoryDL_v1310>,
    #[asn(optional_idx = 1)]
    pub ue_category_ul_v1310: Option<UE_EUTRA_Capability_v1310_IEsUe_CategoryUL_v1310>,
    pub pdcp_parameters_v1310: PDCP_Parameters_v1310,
    pub rlc_parameters_v1310: RLC_Parameters_v1310,
    #[asn(optional_idx = 2)]
    pub mac_parameters_v1310: Option<MAC_Parameters_v1310>,
    #[asn(optional_idx = 3)]
    pub phy_layer_parameters_v1310: Option<PhyLayerParameters_v1310>,
    #[asn(optional_idx = 4)]
    pub rf_parameters_v1310: Option<RF_Parameters_v1310>,
    #[asn(optional_idx = 5)]
    pub meas_parameters_v1310: Option<MeasParameters_v1310>,
    #[asn(optional_idx = 6)]
    pub dc_parameters_v1310: Option<DC_Parameters_v1310>,
    #[asn(optional_idx = 7)]
    pub sl_parameters_v1310: Option<SL_Parameters_v1310>,
    #[asn(optional_idx = 8)]
    pub scptm_parameters_r13: Option<SCPTM_Parameters_r13>,
    #[asn(optional_idx = 9)]
    pub ce_parameters_r13: Option<CE_Parameters_r13>,
    pub inter_rat_parameters_wlan_r13: IRAT_ParametersWLAN_r13,
    #[asn(optional_idx = 10)]
    pub laa_parameters_r13: Option<LAA_Parameters_r13>,
    #[asn(optional_idx = 11)]
    pub lwa_parameters_r13: Option<LWA_Parameters_r13>,
    pub wlan_iw_parameters_v1310: WLAN_IW_Parameters_v1310,
    pub lwip_parameters_r13: LWIP_Parameters_r13,
    #[asn(optional_idx = 12)]
    pub fdd_add_ue_eutra_capabilities_v1310: Option<UE_EUTRA_CapabilityAddXDD_Mode_v1310>,
    #[asn(optional_idx = 13)]
    pub tdd_add_ue_eutra_capabilities_v1310: Option<UE_EUTRA_CapabilityAddXDD_Mode_v1310>,
    #[asn(optional_idx = 14)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1320_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct UE_EUTRA_Capability_v1320_IEs {
    #[asn(optional_idx = 0)]
    pub ce_parameters_v1320: Option<CE_Parameters_v1320>,
    #[asn(optional_idx = 1)]
    pub phy_layer_parameters_v1320: Option<PhyLayerParameters_v1320>,
    #[asn(optional_idx = 2)]
    pub rf_parameters_v1320: Option<RF_Parameters_v1320>,
    #[asn(optional_idx = 3)]
    pub fdd_add_ue_eutra_capabilities_v1320: Option<UE_EUTRA_CapabilityAddXDD_Mode_v1320>,
    #[asn(optional_idx = 4)]
    pub tdd_add_ue_eutra_capabilities_v1320: Option<UE_EUTRA_CapabilityAddXDD_Mode_v1320>,
    #[asn(optional_idx = 5)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1330_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct UE_EUTRA_Capability_v1330_IEs {
    #[asn(optional_idx = 0)]
    pub ue_category_dl_v1330: Option<UE_EUTRA_Capability_v1330_IEsUe_CategoryDL_v1330>,
    #[asn(optional_idx = 1)]
    pub phy_layer_parameters_v1330: Option<PhyLayerParameters_v1330>,
    #[asn(optional_idx = 2)]
    pub ue_ce_need_ul_gaps_r13: Option<UE_EUTRA_Capability_v1330_IEsUe_CE_NeedULGaps_r13>,
    #[asn(optional_idx = 3)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1340_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v1340_IEs {
    #[asn(optional_idx = 0)]
    pub ue_category_ul_v1340: Option<UE_EUTRA_Capability_v1340_IEsUe_CategoryUL_v1340>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1350_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct UE_EUTRA_Capability_v1350_IEs {
    #[asn(optional_idx = 0)]
    pub ue_category_dl_v1350: Option<UE_EUTRA_Capability_v1350_IEsUe_CategoryDL_v1350>,
    #[asn(optional_idx = 1)]
    pub ue_category_ul_v1350: Option<UE_EUTRA_Capability_v1350_IEsUe_CategoryUL_v1350>,
    pub ce_parameters_v1350: CE_Parameters_v1350,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1360_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v1360_IEs {
    #[asn(optional_idx = 0)]
    pub other_parameters_v1360: Option<Other_Parameters_v1360>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1430_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct UE_EUTRA_Capability_v1370_IEs {
    #[asn(optional_idx = 0)]
    pub ce_parameters_v1370: Option<CE_Parameters_v1370>,
    #[asn(optional_idx = 1)]
    pub fdd_add_ue_eutra_capabilities_v1370: Option<UE_EUTRA_CapabilityAddXDD_Mode_v1370>,
    #[asn(optional_idx = 2)]
    pub tdd_add_ue_eutra_capabilities_v1370: Option<UE_EUTRA_CapabilityAddXDD_Mode_v1370>,
    #[asn(optional_idx = 3)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1380_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v1380_IEs {
    #[asn(optional_idx = 0)]
    pub rf_parameters_v1380: Option<RF_Parameters_v1380>,
    pub ce_parameters_v1380: CE_Parameters_v1380,
    pub fdd_add_ue_eutra_capabilities_v1380: UE_EUTRA_CapabilityAddXDD_Mode_v1380,
    pub tdd_add_ue_eutra_capabilities_v1380: UE_EUTRA_CapabilityAddXDD_Mode_v1380,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1390_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v1390_IEs {
    #[asn(optional_idx = 0)]
    pub rf_parameters_v1390: Option<RF_Parameters_v1390>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v13e0a_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v13e0a_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<UE_EUTRA_Capability_v13e0a_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1470_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UE_EUTRA_Capability_v13e0b_IEs {
    pub phy_layer_parameters_v13e0: PhyLayerParameters_v13e0,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v13e0b_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 19)]
pub struct UE_EUTRA_Capability_v1430_IEs {
    pub phy_layer_parameters_v1430: PhyLayerParameters_v1430,
    #[asn(optional_idx = 0)]
    pub ue_category_dl_v1430: Option<UE_EUTRA_Capability_v1430_IEsUe_CategoryDL_v1430>,
    #[asn(optional_idx = 1)]
    pub ue_category_ul_v1430: Option<UE_EUTRA_Capability_v1430_IEsUe_CategoryUL_v1430>,
    #[asn(optional_idx = 2)]
    pub ue_category_ul_v1430b: Option<UE_EUTRA_Capability_v1430_IEsUe_CategoryUL_v1430b>,
    #[asn(optional_idx = 3)]
    pub mac_parameters_v1430: Option<MAC_Parameters_v1430>,
    #[asn(optional_idx = 4)]
    pub meas_parameters_v1430: Option<MeasParameters_v1430>,
    #[asn(optional_idx = 5)]
    pub pdcp_parameters_v1430: Option<PDCP_Parameters_v1430>,
    pub rlc_parameters_v1430: RLC_Parameters_v1430,
    #[asn(optional_idx = 6)]
    pub rf_parameters_v1430: Option<RF_Parameters_v1430>,
    #[asn(optional_idx = 7)]
    pub laa_parameters_v1430: Option<LAA_Parameters_v1430>,
    #[asn(optional_idx = 8)]
    pub lwa_parameters_v1430: Option<LWA_Parameters_v1430>,
    #[asn(optional_idx = 9)]
    pub lwip_parameters_v1430: Option<LWIP_Parameters_v1430>,
    pub other_parameters_v1430: Other_Parameters_v1430,
    #[asn(optional_idx = 10)]
    pub mmtel_parameters_r14: Option<MMTEL_Parameters_r14>,
    #[asn(optional_idx = 11)]
    pub mobility_parameters_r14: Option<MobilityParameters_r14>,
    pub ce_parameters_v1430: CE_Parameters_v1430,
    #[asn(optional_idx = 12)]
    pub fdd_add_ue_eutra_capabilities_v1430: Option<UE_EUTRA_CapabilityAddXDD_Mode_v1430>,
    #[asn(optional_idx = 13)]
    pub tdd_add_ue_eutra_capabilities_v1430: Option<UE_EUTRA_CapabilityAddXDD_Mode_v1430>,
    #[asn(optional_idx = 14)]
    pub mbms_parameters_v1430: Option<MBMS_Parameters_v1430>,
    #[asn(optional_idx = 15)]
    pub sl_parameters_v1430: Option<SL_Parameters_v1430>,
    #[asn(optional_idx = 16)]
    pub ue_based_netw_perf_meas_parameters_v1430: Option<UE_BasedNetwPerfMeasParameters_v1430>,
    #[asn(optional_idx = 17)]
    pub high_speed_enh_parameters_r14: Option<HighSpeedEnhParameters_r14>,
    #[asn(optional_idx = 18)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1440_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UE_EUTRA_Capability_v1440_IEs {
    pub lwa_parameters_v1440: LWA_Parameters_v1440,
    pub mac_parameters_v1440: MAC_Parameters_v1440,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1450_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct UE_EUTRA_Capability_v1450_IEs {
    #[asn(optional_idx = 0)]
    pub phy_layer_parameters_v1450: Option<PhyLayerParameters_v1450>,
    #[asn(optional_idx = 1)]
    pub rf_parameters_v1450: Option<RF_Parameters_v1450>,
    pub other_parameters_v1450: OtherParameters_v1450,
    #[asn(optional_idx = 2)]
    pub ue_category_dl_v1450: Option<UE_EUTRA_Capability_v1450_IEsUe_CategoryDL_v1450>,
    #[asn(optional_idx = 3)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1460_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v1460_IEs {
    #[asn(optional_idx = 0)]
    pub ue_category_dl_v1460: Option<UE_EUTRA_Capability_v1460_IEsUe_CategoryDL_v1460>,
    pub other_parameters_v1460: Other_Parameters_v1460,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1510_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct UE_EUTRA_Capability_v1470_IEs {
    #[asn(optional_idx = 0)]
    pub mbms_parameters_v1470: Option<MBMS_Parameters_v1470>,
    #[asn(optional_idx = 1)]
    pub phy_layer_parameters_v1470: Option<PhyLayerParameters_v1470>,
    #[asn(optional_idx = 2)]
    pub rf_parameters_v1470: Option<RF_Parameters_v1470>,
    #[asn(optional_idx = 3)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v14a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UE_EUTRA_Capability_v14a0_IEs {
    pub phy_layer_parameters_v14a0: PhyLayerParameters_v14a0,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v14b0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v14b0_IEs {
    #[asn(optional_idx = 0)]
    pub rf_parameters_v14b0: Option<RF_Parameters_v14b0>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v14x0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v14x0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<UE_EUTRA_Capability_v14x0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v15x0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct UE_EUTRA_Capability_v1510_IEs {
    #[asn(optional_idx = 0)]
    pub irat_parameters_nr_r15: Option<IRAT_ParametersNR_r15>,
    #[asn(optional_idx = 1)]
    pub feature_sets_eutra_r15: Option<FeatureSetsEUTRA_r15>,
    #[asn(optional_idx = 2)]
    pub pdcp_parameters_nr_r15: Option<PDCP_ParametersNR_r15>,
    #[asn(optional_idx = 3)]
    pub fdd_add_ue_eutra_capabilities_v1510: Option<UE_EUTRA_CapabilityAddXDD_Mode_v1510>,
    #[asn(optional_idx = 4)]
    pub tdd_add_ue_eutra_capabilities_v1510: Option<UE_EUTRA_CapabilityAddXDD_Mode_v1510>,
    #[asn(optional_idx = 5)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1520_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UE_EUTRA_Capability_v1520_IEs {
    pub meas_parameters_v1520: MeasParameters_v1520,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1530_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 18)]
pub struct UE_EUTRA_Capability_v1530_IEs {
    #[asn(optional_idx = 0)]
    pub meas_parameters_v1530: Option<MeasParameters_v1530>,
    #[asn(optional_idx = 1)]
    pub other_parameters_v1530: Option<Other_Parameters_v1530>,
    #[asn(optional_idx = 2)]
    pub neigh_cell_si_acquisition_parameters_v1530: Option<NeighCellSI_AcquisitionParameters_v1530>,
    #[asn(optional_idx = 3)]
    pub mac_parameters_v1530: Option<MAC_Parameters_v1530>,
    #[asn(optional_idx = 4)]
    pub phy_layer_parameters_v1530: Option<PhyLayerParameters_v1530>,
    #[asn(optional_idx = 5)]
    pub rf_parameters_v1530: Option<RF_Parameters_v1530>,
    #[asn(optional_idx = 6)]
    pub pdcp_parameters_v1530: Option<PDCP_Parameters_v1530>,
    #[asn(optional_idx = 7)]
    pub ue_category_dl_v1530: Option<UE_EUTRA_Capability_v1530_IEsUe_CategoryDL_v1530>,
    #[asn(optional_idx = 8)]
    pub ue_based_netw_perf_meas_parameters_v1530: Option<UE_BasedNetwPerfMeasParameters_v1530>,
    #[asn(optional_idx = 9)]
    pub rlc_parameters_v1530: Option<RLC_Parameters_v1530>,
    #[asn(optional_idx = 10)]
    pub sl_parameters_v1530: Option<SL_Parameters_v1530>,
    #[asn(optional_idx = 11)]
    pub extended_number_of_dr_bs_r15: Option<UE_EUTRA_Capability_v1530_IEsExtendedNumberOfDRBs_r15>,
    #[asn(optional_idx = 12)]
    pub reduced_cp_latency_r15: Option<UE_EUTRA_Capability_v1530_IEsReducedCP_Latency_r15>,
    #[asn(optional_idx = 13)]
    pub laa_parameters_v1530: Option<LAA_Parameters_v1530>,
    #[asn(optional_idx = 14)]
    pub ue_category_ul_v1530: Option<UE_EUTRA_Capability_v1530_IEsUe_CategoryUL_v1530>,
    #[asn(optional_idx = 15)]
    pub fdd_add_ue_eutra_capabilities_v1530: Option<UE_EUTRA_CapabilityAddXDD_Mode_v1530>,
    #[asn(optional_idx = 16)]
    pub tdd_add_ue_eutra_capabilities_v1530: Option<UE_EUTRA_CapabilityAddXDD_Mode_v1530>,
    #[asn(optional_idx = 17)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1540_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct UE_EUTRA_Capability_v1540_IEs {
    #[asn(optional_idx = 0)]
    pub phy_layer_parameters_v1540: Option<PhyLayerParameters_v1540>,
    pub other_parameters_v1540: Other_Parameters_v1540,
    #[asn(optional_idx = 1)]
    pub fdd_add_ue_eutra_capabilities_v1540: Option<UE_EUTRA_CapabilityAddXDD_Mode_v1540>,
    #[asn(optional_idx = 2)]
    pub tdd_add_ue_eutra_capabilities_v1540: Option<UE_EUTRA_CapabilityAddXDD_Mode_v1540>,
    #[asn(optional_idx = 3)]
    pub sl_parameters_v1540: Option<SL_Parameters_v1540>,
    #[asn(optional_idx = 4)]
    pub irat_parameters_nr_v1540: Option<IRAT_ParametersNR_v1540>,
    #[asn(optional_idx = 5)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1550_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v1550_IEs {
    #[asn(optional_idx = 0)]
    pub neigh_cell_si_acquisition_parameters_v1550: Option<NeighCellSI_AcquisitionParameters_v1550>,
    pub phy_layer_parameters_v1550: PhyLayerParameters_v1550,
    pub mac_parameters_v1550: MAC_Parameters_v1550,
    pub fdd_add_ue_eutra_capabilities_v1550: UE_EUTRA_CapabilityAddXDD_Mode_v1550,
    pub tdd_add_ue_eutra_capabilities_v1550: UE_EUTRA_CapabilityAddXDD_Mode_v1550,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1560_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v1560_IEs {
    pub pdcp_parameters_nr_v1560: PDCP_ParametersNR_v1560,
    pub irat_parameters_nr_v1560: IRAT_ParametersNR_v1560,
    #[asn(optional_idx = 0)]
    pub applied_capability_filter_common_r15:
        Option<UE_EUTRA_Capability_v1560_IEsAppliedCapabilityFilterCommon_r15>,
    pub fdd_add_ue_eutra_capabilities_v1560: UE_EUTRA_CapabilityAddXDD_Mode_v1560,
    pub tdd_add_ue_eutra_capabilities_v1560: UE_EUTRA_CapabilityAddXDD_Mode_v1560,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1570_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct UE_EUTRA_Capability_v1570_IEs {
    #[asn(optional_idx = 0)]
    pub rf_parameters_v1570: Option<RF_Parameters_v1570>,
    #[asn(optional_idx = 1)]
    pub irat_parameters_nr_v1570: Option<IRAT_ParametersNR_v1570>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v15a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct UE_EUTRA_Capability_v15a0_IEs {
    pub neigh_cell_si_acquisition_parameters_v15a0: NeighCellSI_AcquisitionParameters_v15a0,
    #[asn(optional_idx = 0)]
    pub eutra_5gc_parameters_r15: Option<EUTRA_5GC_Parameters_r15>,
    #[asn(optional_idx = 1)]
    pub fdd_add_ue_eutra_capabilities_v15a0: Option<UE_EUTRA_CapabilityAddXDD_Mode_v15a0>,
    #[asn(optional_idx = 2)]
    pub tdd_add_ue_eutra_capabilities_v15a0: Option<UE_EUTRA_CapabilityAddXDD_Mode_v15a0>,
    #[asn(optional_idx = 3)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1610_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v15x0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<UE_EUTRA_Capability_v15x0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v16c0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 18)]
pub struct UE_EUTRA_Capability_v1610_IEs {
    #[asn(optional_idx = 0)]
    pub high_speed_enh_parameters_v1610: Option<HighSpeedEnhParameters_v1610>,
    #[asn(optional_idx = 1)]
    pub neigh_cell_si_acquisition_parameters_v1610: Option<NeighCellSI_AcquisitionParameters_v1610>,
    #[asn(optional_idx = 2)]
    pub mbms_parameters_v1610: Option<MBMS_Parameters_v1610>,
    #[asn(optional_idx = 3)]
    pub pdcp_parameters_v1610: Option<PDCP_Parameters_v1610>,
    #[asn(optional_idx = 4)]
    pub mac_parameters_v1610: Option<MAC_Parameters_v1610>,
    #[asn(optional_idx = 5)]
    pub phy_layer_parameters_v1610: Option<PhyLayerParameters_v1610>,
    #[asn(optional_idx = 6)]
    pub meas_parameters_v1610: Option<MeasParameters_v1610>,
    #[asn(optional_idx = 7)]
    pub pur_parameters_r16: Option<PUR_Parameters_r16>,
    #[asn(optional_idx = 8)]
    pub eutra_5gc_parameters_v1610: Option<EUTRA_5GC_Parameters_v1610>,
    #[asn(optional_idx = 9)]
    pub other_parameters_v1610: Option<Other_Parameters_v1610>,
    #[asn(optional_idx = 10)]
    pub dl_dedicated_message_segmentation_r16:
        Option<UE_EUTRA_Capability_v1610_IEsDl_DedicatedMessageSegmentation_r16>,
    pub mmtel_parameters_v1610: MMTEL_Parameters_v1610,
    #[asn(optional_idx = 11)]
    pub irat_parameters_nr_v1610: Option<IRAT_ParametersNR_v1610>,
    #[asn(optional_idx = 12)]
    pub rf_parameters_v1610: Option<RF_Parameters_v1610>,
    #[asn(optional_idx = 13)]
    pub mobility_parameters_v1610: Option<MobilityParameters_v1610>,
    pub ue_based_netw_perf_meas_parameters_v1610: UE_BasedNetwPerfMeasParameters_v1610,
    #[asn(optional_idx = 14)]
    pub sl_parameters_v1610: Option<SL_Parameters_v1610>,
    #[asn(optional_idx = 15)]
    pub fdd_add_ue_eutra_capabilities_v1610: Option<UE_EUTRA_CapabilityAddXDD_Mode_v1610>,
    #[asn(optional_idx = 16)]
    pub tdd_add_ue_eutra_capabilities_v1610: Option<UE_EUTRA_CapabilityAddXDD_Mode_v1610>,
    #[asn(optional_idx = 17)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1630_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct UE_EUTRA_Capability_v1630_IEs {
    #[asn(optional_idx = 0)]
    pub rf_parameters_v1630: Option<RF_Parameters_v1630>,
    #[asn(optional_idx = 1)]
    pub sl_parameters_v1630: Option<SL_Parameters_v1630>,
    #[asn(optional_idx = 2)]
    pub early_security_reactivation_r16:
        Option<UE_EUTRA_Capability_v1630_IEsEarlySecurityReactivation_r16>,
    pub mac_parameters_v1630: MAC_Parameters_v1630,
    #[asn(optional_idx = 3)]
    pub meas_parameters_v1630: Option<MeasParameters_v1630>,
    pub fdd_add_ue_eutra_capabilities_v1630: UE_EUTRA_CapabilityAddXDD_Mode_v1630,
    pub tdd_add_ue_eutra_capabilities_v1630: UE_EUTRA_CapabilityAddXDD_Mode_v1630,
    #[asn(optional_idx = 4)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1650_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v1650_IEs {
    #[asn(optional_idx = 0)]
    pub other_parameters_v1650: Option<Other_Parameters_v1650>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1660_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UE_EUTRA_Capability_v1660_IEs {
    pub irat_parameters_nr_v1660: IRAT_ParametersNR_v1660,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1690_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UE_EUTRA_Capability_v1690_IEs {
    pub other_parameters_v1690: Other_Parameters_v1690,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1700_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v16c0_IEs {
    pub meas_parameters_v16c0: MeasParameters_v16c0,
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<UE_EUTRA_Capability_v16c0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v16c0_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct UE_EUTRA_Capability_v1700_IEs {
    #[asn(optional_idx = 0)]
    pub meas_parameters_v1700: Option<MeasParameters_v1700>,
    #[asn(optional_idx = 1)]
    pub ue_based_netw_perf_meas_parameters_v1700: Option<UE_BasedNetwPerfMeasParameters_v1700>,
    pub phy_layer_parameters_v1700: PhyLayerParameters_v1700,
    #[asn(optional_idx = 2)]
    pub ntn_parameters_r17: Option<NTN_Parameters_r17>,
    #[asn(optional_idx = 3)]
    pub irat_parameters_nr_v1700: Option<IRAT_ParametersNR_v1700>,
    pub mbms_parameters_v1700: MBMS_Parameters_v1700,
    #[asn(optional_idx = 4)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1710_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct UE_EUTRA_Capability_v1710_IEs {
    pub irat_parameters_nr_v1710: IRAT_ParametersNR_v1710,
    #[asn(optional_idx = 0)]
    pub neigh_cell_si_acquisition_parameters_v1710: Option<NeighCellSI_AcquisitionParameters_v1710>,
    #[asn(optional_idx = 1)]
    pub sl_parameters_v1710: Option<SL_Parameters_v1710>,
    #[asn(optional_idx = 2)]
    pub sidelink_requested_r17: Option<UE_EUTRA_Capability_v1710_IEsSidelinkRequested_r17>,
    #[asn(optional_idx = 3)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1720_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UE_EUTRA_Capability_v1720_IEs {
    pub ntn_parameters_v1720: NTN_Parameters_v1720,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1730_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UE_EUTRA_Capability_v1730_IEs {
    pub phy_layer_parameters_v1730: PhyLayerParameters_v1730,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1730_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct UE_EUTRA_Capability_v920_IEs {
    pub phy_layer_parameters_v920: PhyLayerParameters_v920,
    pub inter_rat_parameters_geran_v920: IRAT_ParametersGERAN_v920,
    #[asn(optional_idx = 0)]
    pub inter_rat_parameters_utra_v920: Option<IRAT_ParametersUTRA_v920>,
    #[asn(optional_idx = 1)]
    pub inter_rat_parameters_cdma2000_v920: Option<IRAT_ParametersCDMA2000_1XRTT_v920>,
    #[asn(optional_idx = 2)]
    pub device_type_r9: Option<UE_EUTRA_Capability_v920_IEsDeviceType_r9>,
    pub csg_proximity_indication_parameters_r9: CSG_ProximityIndicationParameters_r9,
    pub neigh_cell_si_acquisition_parameters_r9: NeighCellSI_AcquisitionParameters_r9,
    pub son_parameters_r9: SON_Parameters_r9,
    #[asn(optional_idx = 3)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v940_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v940_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<UE_EUTRA_Capability_v940_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v1020_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct UE_EUTRA_Capability_v9a0_IEs {
    #[asn(optional_idx = 0)]
    pub feature_group_ind_rel9_add_r9:
        Option<UE_EUTRA_Capability_v9a0_IEsFeatureGroupIndRel9Add_r9>,
    #[asn(optional_idx = 1)]
    pub fdd_add_ue_eutra_capabilities_r9: Option<UE_EUTRA_CapabilityAddXDD_Mode_r9>,
    #[asn(optional_idx = 2)]
    pub tdd_add_ue_eutra_capabilities_r9: Option<UE_EUTRA_CapabilityAddXDD_Mode_r9>,
    #[asn(optional_idx = 3)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v9c0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v9c0_IEs {
    #[asn(optional_idx = 0)]
    pub inter_rat_parameters_utra_v9c0: Option<IRAT_ParametersUTRA_v9c0>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v9d0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v9d0_IEs {
    #[asn(optional_idx = 0)]
    pub phy_layer_parameters_v9d0: Option<PhyLayerParameters_v9d0>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v9e0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_Capability_v9e0_IEs {
    #[asn(optional_idx = 0)]
    pub rf_parameters_v9e0: Option<RF_Parameters_v9e0>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v9h0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct UE_EUTRA_Capability_v9h0_IEs {
    #[asn(optional_idx = 0)]
    pub inter_rat_parameters_utra_v9h0: Option<IRAT_ParametersUTRA_v9h0>,
    #[asn(optional_idx = 1)]
    pub late_non_critical_extension: Option<UE_EUTRA_Capability_v9h0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<UE_EUTRA_Capability_v10c0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 7)]
pub struct UE_EUTRA_CapabilityAddXDD_Mode_r9 {
    #[asn(optional_idx = 0)]
    pub phy_layer_parameters_r9: Option<PhyLayerParameters>,
    #[asn(optional_idx = 1)]
    pub feature_group_indicators_r9:
        Option<UE_EUTRA_CapabilityAddXDD_Mode_r9FeatureGroupIndicators_r9>,
    #[asn(optional_idx = 2)]
    pub feature_group_ind_rel9_add_r9:
        Option<UE_EUTRA_CapabilityAddXDD_Mode_r9FeatureGroupIndRel9Add_r9>,
    #[asn(optional_idx = 3)]
    pub inter_rat_parameters_geran_r9: Option<IRAT_ParametersGERAN>,
    #[asn(optional_idx = 4)]
    pub inter_rat_parameters_utra_r9: Option<IRAT_ParametersUTRA_v920>,
    #[asn(optional_idx = 5)]
    pub inter_rat_parameters_cdma2000_r9: Option<IRAT_ParametersCDMA2000_1XRTT_v920>,
    #[asn(optional_idx = 6)]
    pub neigh_cell_si_acquisition_parameters_r9: Option<NeighCellSI_AcquisitionParameters_r9>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct UE_EUTRA_CapabilityAddXDD_Mode_v1060 {
    #[asn(optional_idx = 0)]
    pub phy_layer_parameters_v1060: Option<PhyLayerParameters_v1020>,
    #[asn(optional_idx = 1)]
    pub feature_group_ind_rel10_v1060:
        Option<UE_EUTRA_CapabilityAddXDD_Mode_v1060FeatureGroupIndRel10_v1060>,
    #[asn(optional_idx = 2)]
    pub inter_rat_parameters_cdma2000_v1060: Option<IRAT_ParametersCDMA2000_1XRTT_v1020>,
    #[asn(optional_idx = 3)]
    pub inter_rat_parameters_utra_tdd_v1060: Option<IRAT_ParametersUTRA_TDD_v1020>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct UE_EUTRA_CapabilityAddXDD_Mode_v1130 {
    #[asn(optional_idx = 0)]
    pub phy_layer_parameters_v1130: Option<PhyLayerParameters_v1130>,
    #[asn(optional_idx = 1)]
    pub meas_parameters_v1130: Option<MeasParameters_v1130>,
    #[asn(optional_idx = 2)]
    pub other_parameters_r11: Option<Other_Parameters_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_EUTRA_CapabilityAddXDD_Mode_v1180 {
    pub mbms_parameters_r11: MBMS_Parameters_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_CapabilityAddXDD_Mode_v1250 {
    #[asn(optional_idx = 0)]
    pub phy_layer_parameters_v1250: Option<PhyLayerParameters_v1250>,
    #[asn(optional_idx = 1)]
    pub meas_parameters_v1250: Option<MeasParameters_v1250>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UE_EUTRA_CapabilityAddXDD_Mode_v1310 {
    #[asn(optional_idx = 0)]
    pub phy_layer_parameters_v1310: Option<PhyLayerParameters_v1310>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_CapabilityAddXDD_Mode_v1320 {
    #[asn(optional_idx = 0)]
    pub phy_layer_parameters_v1320: Option<PhyLayerParameters_v1320>,
    #[asn(optional_idx = 1)]
    pub scptm_parameters_r13: Option<SCPTM_Parameters_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UE_EUTRA_CapabilityAddXDD_Mode_v1370 {
    #[asn(optional_idx = 0)]
    pub ce_parameters_v1370: Option<CE_Parameters_v1370>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_EUTRA_CapabilityAddXDD_Mode_v1380 {
    pub ce_parameters_v1380: CE_Parameters_v1380,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_CapabilityAddXDD_Mode_v1430 {
    #[asn(optional_idx = 0)]
    pub phy_layer_parameters_v1430: Option<PhyLayerParameters_v1430>,
    #[asn(optional_idx = 1)]
    pub mmtel_parameters_r14: Option<MMTEL_Parameters_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UE_EUTRA_CapabilityAddXDD_Mode_v1510 {
    #[asn(optional_idx = 0)]
    pub pdcp_parameters_nr_r15: Option<PDCP_ParametersNR_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_CapabilityAddXDD_Mode_v1530 {
    #[asn(optional_idx = 0)]
    pub neigh_cell_si_acquisition_parameters_v1530: Option<NeighCellSI_AcquisitionParameters_v1530>,
    #[asn(optional_idx = 1)]
    pub reduced_cp_latency_r15: Option<UE_EUTRA_CapabilityAddXDD_Mode_v1530ReducedCP_Latency_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UE_EUTRA_CapabilityAddXDD_Mode_v1540 {
    #[asn(optional_idx = 0)]
    pub eutra_5gc_parameters_r15: Option<EUTRA_5GC_Parameters_r15>,
    #[asn(optional_idx = 1)]
    pub irat_parameters_nr_v1540: Option<IRAT_ParametersNR_v1540>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UE_EUTRA_CapabilityAddXDD_Mode_v1550 {
    #[asn(optional_idx = 0)]
    pub neigh_cell_si_acquisition_parameters_v1550: Option<NeighCellSI_AcquisitionParameters_v1550>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_EUTRA_CapabilityAddXDD_Mode_v1560 {
    pub pdcp_parameters_nr_v1560: PDCP_ParametersNR_v1560,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct UE_EUTRA_CapabilityAddXDD_Mode_v15a0 {
    #[asn(optional_idx = 0)]
    pub phy_layer_parameters_v1530: Option<PhyLayerParameters_v1530>,
    #[asn(optional_idx = 1)]
    pub phy_layer_parameters_v1540: Option<PhyLayerParameters_v1540>,
    #[asn(optional_idx = 2)]
    pub phy_layer_parameters_v1550: Option<PhyLayerParameters_v1550>,
    pub neigh_cell_si_acquisition_parameters_v15a0: NeighCellSI_AcquisitionParameters_v15a0,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 7)]
pub struct UE_EUTRA_CapabilityAddXDD_Mode_v1610 {
    #[asn(optional_idx = 0)]
    pub phy_layer_parameters_v1610: Option<PhyLayerParameters_v1610>,
    #[asn(optional_idx = 1)]
    pub pur_parameters_r16: Option<PUR_Parameters_r16>,
    #[asn(optional_idx = 2)]
    pub meas_parameters_v1610: Option<MeasParameters_v1610>,
    #[asn(optional_idx = 3)]
    pub eutra_5gc_parameters_v1610: Option<EUTRA_5GC_Parameters_v1610>,
    #[asn(optional_idx = 4)]
    pub irat_parameters_nr_v1610: Option<IRAT_ParametersNR_v1610>,
    #[asn(optional_idx = 5)]
    pub neigh_cell_si_acquisition_parameters_v1610: Option<NeighCellSI_AcquisitionParameters_v1610>,
    #[asn(optional_idx = 6)]
    pub mobility_parameters_v1610: Option<MobilityParameters_v1610>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_EUTRA_CapabilityAddXDD_Mode_v1630 {
    pub meas_parameters_v1630: MeasParameters_v1630,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UE_RadioPagingInfo_r12 {
    #[asn(optional_idx = 0)]
    pub ue_category_v1250: Option<UE_RadioPagingInfo_r12Ue_Category_v1250>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UE_TimersAndConstants {
    pub t300: UE_TimersAndConstantsT300,
    pub t301: UE_TimersAndConstantsT301,
    pub t310: UE_TimersAndConstantsT310,
    pub n310: UE_TimersAndConstantsN310,
    pub t311: UE_TimersAndConstantsT311,
    pub n311: UE_TimersAndConstantsN311,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEAssistanceInformation_r11 {
    pub critical_extensions: UEAssistanceInformation_r11CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct UEAssistanceInformation_r11_IEs {
    #[asn(optional_idx = 0)]
    pub power_pref_indication_r11: Option<UEAssistanceInformation_r11_IEsPowerPrefIndication_r11>,
    #[asn(optional_idx = 1)]
    pub late_non_critical_extension:
        Option<UEAssistanceInformation_r11_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<UEAssistanceInformation_v1430_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct UEAssistanceInformation_v1430_IEs {
    #[asn(optional_idx = 0)]
    pub bw_preference_r14: Option<BW_Preference_r14>,
    #[asn(optional_idx = 1)]
    pub sps_assistance_information_r14:
        Option<UEAssistanceInformation_v1430_IEsSps_AssistanceInformation_r14>,
    #[asn(optional_idx = 2)]
    pub rlm_report_r14: Option<UEAssistanceInformation_v1430_IEsRlm_Report_r14>,
    #[asn(optional_idx = 3)]
    pub delay_budget_report_r14: Option<DelayBudgetReport_r14>,
    #[asn(optional_idx = 4)]
    pub non_critical_extension: Option<UEAssistanceInformation_v1450_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UEAssistanceInformation_v1450_IEs {
    #[asn(optional_idx = 0)]
    pub overheating_assistance_r14: Option<OverheatingAssistance_r14>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UEAssistanceInformation_v1530_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UEAssistanceInformation_v1530_IEs {
    #[asn(optional_idx = 0)]
    pub sps_assistance_information_v1530:
        Option<UEAssistanceInformation_v1530_IEsSps_AssistanceInformation_v1530>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UEAssistanceInformation_v1610_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UEAssistanceInformation_v1610_IEs {
    #[asn(optional_idx = 0)]
    pub overheating_assistance_v1610: Option<OverheatingAssistance_v1610>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UEAssistanceInformation_v1700_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct UEAssistanceInformation_v1700_IEs {
    #[asn(optional_idx = 0)]
    pub uplink_data_r17: Option<UEAssistanceInformation_v1700_IEsUplinkData_r17>,
    #[asn(optional_idx = 1)]
    pub scg_deactivation_preference_r17:
        Option<UEAssistanceInformation_v1700_IEsScg_DeactivationPreference_r17>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<UEAssistanceInformation_v1710_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UEAssistanceInformation_v1710_IEs {
    #[asn(optional_idx = 0)]
    pub overheating_assistance_v1710: Option<OverheatingAssistance_v1710>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UEAssistanceInformation_v1710_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UECapabilityEnquiry {
    pub rrc_transaction_identifier: RRC_TransactionIdentifier,
    pub critical_extensions: UECapabilityEnquiryCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UECapabilityEnquiry_r8_IEs {
    pub ue_capability_request: UE_CapabilityRequest,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<UECapabilityEnquiry_v8a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UECapabilityEnquiry_v1180_IEs {
    #[asn(optional_idx = 0)]
    pub requested_frequency_bands_r11:
        Option<UECapabilityEnquiry_v1180_IEsRequestedFrequencyBands_r11>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UECapabilityEnquiry_v1310_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct UECapabilityEnquiry_v1310_IEs {
    #[asn(optional_idx = 0)]
    pub request_reduced_format_r13: Option<UECapabilityEnquiry_v1310_IEsRequestReducedFormat_r13>,
    #[asn(optional_idx = 1)]
    pub request_skip_fallback_comb_r13:
        Option<UECapabilityEnquiry_v1310_IEsRequestSkipFallbackComb_r13>,
    #[asn(optional_idx = 2)]
    pub requested_max_c_cs_dl_r13: Option<UECapabilityEnquiry_v1310_IEsRequestedMaxCCsDL_r13>,
    #[asn(optional_idx = 3)]
    pub requested_max_c_cs_ul_r13: Option<UECapabilityEnquiry_v1310_IEsRequestedMaxCCsUL_r13>,
    #[asn(optional_idx = 4)]
    pub request_reduced_int_non_cont_comb_r13:
        Option<UECapabilityEnquiry_v1310_IEsRequestReducedIntNonContComb_r13>,
    #[asn(optional_idx = 5)]
    pub non_critical_extension: Option<UECapabilityEnquiry_v1430_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UECapabilityEnquiry_v1430_IEs {
    #[asn(optional_idx = 0)]
    pub request_diff_fallback_comb_list_r14: Option<BandCombinationList_r14>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UECapabilityEnquiry_v1510_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UECapabilityEnquiry_v1510_IEs {
    #[asn(optional_idx = 0)]
    pub requested_freq_bands_nr_mrdc_r15:
        Option<UECapabilityEnquiry_v1510_IEsRequestedFreqBandsNR_MRDC_r15>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UECapabilityEnquiry_v1530_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct UECapabilityEnquiry_v1530_IEs {
    #[asn(optional_idx = 0)]
    pub request_stti_spt_capability_r15:
        Option<UECapabilityEnquiry_v1530_IEsRequestSTTI_SPT_Capability_r15>,
    #[asn(optional_idx = 1)]
    pub eutra_nr_only_r15: Option<UECapabilityEnquiry_v1530_IEsEutra_nr_only_r15>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<UECapabilityEnquiry_v1550_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UECapabilityEnquiry_v1550_IEs {
    #[asn(optional_idx = 0)]
    pub requested_capability_nr_r15: Option<UECapabilityEnquiry_v1550_IEsRequestedCapabilityNR_r15>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UECapabilityEnquiry_v1560_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UECapabilityEnquiry_v1560_IEs {
    #[asn(optional_idx = 0)]
    pub requested_capability_common_r15:
        Option<UECapabilityEnquiry_v1560_IEsRequestedCapabilityCommon_r15>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UECapabilityEnquiry_v1610_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UECapabilityEnquiry_v1610_IEs {
    #[asn(optional_idx = 0)]
    pub rrc_seg_allowed_r16: Option<UECapabilityEnquiry_v1610_IEsRrc_SegAllowed_r16>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UECapabilityEnquiry_v1710_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UECapabilityEnquiry_v1710_IEs {
    #[asn(optional_idx = 0)]
    pub sidelink_request_r17: Option<UECapabilityEnquiry_v1710_IEsSidelinkRequest_r17>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UECapabilityEnquiry_v1710_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UECapabilityEnquiry_v8a0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<UECapabilityEnquiry_v8a0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UECapabilityEnquiry_v1180_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UECapabilityInformation {
    pub rrc_transaction_identifier: RRC_TransactionIdentifier,
    pub critical_extensions: UECapabilityInformationCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UECapabilityInformation_r8_IEs {
    pub ue_capability_rat_container_list: UE_CapabilityRAT_ContainerList,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<UECapabilityInformation_v8a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UECapabilityInformation_v1250_IEs {
    #[asn(optional_idx = 0)]
    pub ue_radio_paging_info_r12: Option<UE_RadioPagingInfo_r12>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UECapabilityInformation_v1250_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UECapabilityInformation_v8a0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<UECapabilityInformation_v8a0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UECapabilityInformation_v1250_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEInformationRequest_r9 {
    pub rrc_transaction_identifier: RRC_TransactionIdentifier,
    pub critical_extensions: UEInformationRequest_r9CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UEInformationRequest_r9_IEs {
    pub rach_report_req_r9: UEInformationRequest_r9_IEsRach_ReportReq_r9,
    pub rlf_report_req_r9: UEInformationRequest_r9_IEsRlf_ReportReq_r9,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<UEInformationRequest_v930_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UEInformationRequest_v1020_IEs {
    #[asn(optional_idx = 0)]
    pub log_meas_report_req_r10: Option<UEInformationRequest_v1020_IEsLogMeasReportReq_r10>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UEInformationRequest_v1130_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UEInformationRequest_v1130_IEs {
    #[asn(optional_idx = 0)]
    pub conn_est_fail_report_req_r11:
        Option<UEInformationRequest_v1130_IEsConnEstFailReportReq_r11>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UEInformationRequest_v1250_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UEInformationRequest_v1250_IEs {
    #[asn(optional_idx = 0)]
    pub mobility_history_report_req_r12:
        Option<UEInformationRequest_v1250_IEsMobilityHistoryReportReq_r12>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UEInformationRequest_v1530_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct UEInformationRequest_v1530_IEs {
    #[asn(optional_idx = 0)]
    pub idle_mode_measurement_req_r15:
        Option<UEInformationRequest_v1530_IEsIdleModeMeasurementReq_r15>,
    #[asn(optional_idx = 1)]
    pub flight_path_info_req_r15: Option<FlightPathInfoReportConfig_r15>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<UEInformationRequest_v1710_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UEInformationRequest_v1710_IEs {
    #[asn(optional_idx = 0)]
    pub coarse_location_req_r17: Option<UEInformationRequest_v1710_IEsCoarseLocationReq_r17>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UEInformationRequest_v1710_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UEInformationRequest_v930_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<UEInformationRequest_v930_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UEInformationRequest_v1020_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEInformationResponse_r9 {
    pub rrc_transaction_identifier: RRC_TransactionIdentifier,
    pub critical_extensions: UEInformationResponse_r9CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct UEInformationResponse_r9_IEs {
    #[asn(optional_idx = 0)]
    pub rach_report_r9: Option<RACH_Report_r16>,
    #[asn(optional_idx = 1)]
    pub rlf_report_r9: Option<RLF_Report_r9>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<UEInformationResponse_v930_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UEInformationResponse_v1020_IEs {
    #[asn(optional_idx = 0)]
    pub log_meas_report_r10: Option<LogMeasReport_r10>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UEInformationResponse_v1130_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UEInformationResponse_v1130_IEs {
    #[asn(optional_idx = 0)]
    pub conn_est_fail_report_r11: Option<ConnEstFailReport_r11>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UEInformationResponse_v1250_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UEInformationResponse_v1250_IEs {
    #[asn(optional_idx = 0)]
    pub mobility_history_report_r12: Option<MobilityHistoryReport_r12>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UEInformationResponse_v1530_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct UEInformationResponse_v1530_IEs {
    #[asn(optional_idx = 0)]
    pub meas_result_list_idle_r15: Option<MeasResultListIdle_r15>,
    #[asn(optional_idx = 1)]
    pub flight_path_info_report_r15: Option<FlightPathInfoReport_r15>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<UEInformationResponse_v1610_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct UEInformationResponse_v1610_IEs {
    #[asn(optional_idx = 0)]
    pub rach_report_v1610: Option<RACH_Report_v1610>,
    #[asn(optional_idx = 1)]
    pub meas_result_list_ext_idle_r16: Option<MeasResultListExtIdle_r16>,
    #[asn(optional_idx = 2)]
    pub meas_result_list_idle_nr_r16: Option<MeasResultListIdleNR_r16>,
    #[asn(optional_idx = 3)]
    pub non_critical_extension: Option<UEInformationResponse_v1710_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UEInformationResponse_v1710_IEs {
    #[asn(optional_idx = 0)]
    pub coarse_location_info_r17: Option<UEInformationResponse_v1710_IEsCoarseLocationInfo_r17>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UEInformationResponse_v1710_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UEInformationResponse_v930_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<UEInformationResponse_v930_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UEInformationResponse_v1020_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UEInformationResponse_v9e0_IEs {
    #[asn(optional_idx = 0)]
    pub rlf_report_v9e0: Option<RLF_Report_v9e0>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UEInformationResponse_v9e0_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEPagingCoverageInformation {
    pub critical_extensions: UEPagingCoverageInformationCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UEPagingCoverageInformation_r13_IEs {
    #[asn(optional_idx = 0)]
    pub mpdcch_num_repetition_r13:
        Option<UEPagingCoverageInformation_r13_IEsMpdcch_NumRepetition_r13>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UEPagingCoverageInformation_r13_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioAccessCapabilityInformation {
    pub critical_extensions: UERadioAccessCapabilityInformationCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UERadioAccessCapabilityInformation_r8_IEs {
    pub ue_radio_access_capability_info:
        UERadioAccessCapabilityInformation_r8_IEsUe_RadioAccessCapabilityInfo,
    #[asn(optional_idx = 0)]
    pub non_critical_extension:
        Option<UERadioAccessCapabilityInformation_r8_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioPagingInformation {
    pub critical_extensions: UERadioPagingInformationCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UERadioPagingInformation_r12_IEs {
    pub ue_radio_paging_info_r12: UERadioPagingInformation_r12_IEsUe_RadioPagingInfo_r12,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<UERadioPagingInformation_v1310_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UERadioPagingInformation_v1310_IEs {
    #[asn(optional_idx = 0)]
    pub supported_band_list_eutra_for_paging_r13:
        Option<UERadioPagingInformation_v1310_IEsSupportedBandListEUTRAForPaging_r13>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UERadioPagingInformation_v1610_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UERadioPagingInformation_v1610_IEs {
    #[asn(optional_idx = 0)]
    pub access_stratum_release_r16:
        Option<UERadioPagingInformation_v1610_IEsAccessStratumRelease_r16>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UERadioPagingInformation_v1610_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UL_256QAM_perCC_Info_r14 {
    #[asn(optional_idx = 0)]
    pub ul_256qam_per_cc_r14: Option<UL_256QAM_perCC_Info_r14Ul_256QAM_perCC_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UL_AM_RLC {
    pub t_poll_retransmit: T_PollRetransmit,
    pub poll_pdu: PollPDU,
    pub poll_byte: PollByte,
    pub max_retx_threshold: UL_AM_RLCMaxRetxThreshold,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UL_AM_RLC_r15 {
    pub t_poll_retransmit_r15: T_PollRetransmit,
    pub poll_pdu_r15: PollPDU_r15,
    pub poll_byte_r15: PollByte_r14,
    pub max_retx_threshold_r15: UL_AM_RLC_r15MaxRetxThreshold_r15,
    pub extended_rlc_li_field_r15: UL_AM_RLC_r15Extended_RLC_LI_Field_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UL_CCCH_Message {
    pub message: UL_CCCH_MessageType,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UL_CCCH_MessageType {
    #[asn(key = 0, extended = false)]
    C1(UL_CCCH_MessageType_c1),
    #[asn(key = 1, extended = false)]
    MessageClassExtension(UL_CCCH_MessageType_messageClassExtension),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct UL_CyclicPrefixLength(pub u8);
impl UL_CyclicPrefixLength {
    pub const LEN1: u8 = 0u8;
    pub const LEN2: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UL_DCCH_Message {
    pub message: UL_DCCH_MessageType,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UL_DCCH_MessageType {
    #[asn(key = 0, extended = false)]
    C1(UL_DCCH_MessageType_c1),
    #[asn(key = 1, extended = false)]
    MessageClassExtension(UL_DCCH_MessageType_messageClassExtension),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UL_DelayConfig_r13 {
    #[asn(key = 0, extended = false)]
    Release(UL_DelayConfig_r13_release),
    #[asn(key = 1, extended = false)]
    Setup(UL_DelayConfig_r13_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UL_DelayValueConfig_r16 {
    #[asn(key = 0, extended = false)]
    Release(UL_DelayValueConfig_r16_release),
    #[asn(key = 1, extended = false)]
    Setup(UL_DelayValueConfig_r16_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UL_PDCP_DelayResult_r13 {
    pub qci_id_r13: UL_PDCP_DelayResult_r13Qci_Id_r13,
    pub excess_delay_r13: UL_PDCP_DelayResult_r13ExcessDelay_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct UL_PDCP_DelayResultList_r13(pub Vec<UL_PDCP_DelayResult_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UL_PDCP_DelayValueResult_r16 {
    pub drb_id_r16: DRB_Identity,
    pub average_delay_r16: UL_PDCP_DelayValueResult_r16AverageDelay_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "11")]
pub struct UL_PDCP_DelayValueResultList_r16(pub Vec<UL_PDCP_DelayValueResult_r16>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UL_ReferenceSignalsPUSCH {
    pub group_hopping_enabled: UL_ReferenceSignalsPUSCHGroupHoppingEnabled,
    pub group_assignment_pusch: UL_ReferenceSignalsPUSCHGroupAssignmentPUSCH,
    pub sequence_hopping_enabled: UL_ReferenceSignalsPUSCHSequenceHoppingEnabled,
    pub cyclic_shift: UL_ReferenceSignalsPUSCHCyclicShift,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UL_UM_RLC {
    pub sn_field_length: SN_FieldLength,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ULDedicatedMessageSegment_r16 {
    pub critical_extensions: ULDedicatedMessageSegment_r16CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct ULDedicatedMessageSegment_r16_IEs {
    pub segment_number_r16: ULDedicatedMessageSegment_r16_IEsSegmentNumber_r16,
    pub rrc_message_segment_container_r16:
        ULDedicatedMessageSegment_r16_IEsRrc_MessageSegmentContainer_r16,
    pub rrc_message_segment_type_r16: ULDedicatedMessageSegment_r16_IEsRrc_MessageSegmentType_r16,
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<ULDedicatedMessageSegment_r16_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<ULDedicatedMessageSegment_r16_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ULHandoverPreparationTransfer {
    pub critical_extensions: ULHandoverPreparationTransferCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct ULHandoverPreparationTransfer_r8_IEs {
    pub cdma2000_type: CDMA2000_Type,
    #[asn(optional_idx = 0)]
    pub meid: Option<ULHandoverPreparationTransfer_r8_IEsMeid>,
    pub dedicated_info: DedicatedInfoCDMA2000,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<ULHandoverPreparationTransfer_v8a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct ULHandoverPreparationTransfer_v8a0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<ULHandoverPreparationTransfer_v8a0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<ULHandoverPreparationTransfer_v8a0_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ULInformationTransfer {
    pub critical_extensions: ULInformationTransferCriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct ULInformationTransfer_r16_IEs {
    #[asn(optional_idx = 0)]
    pub dedicated_info_type_r16: Option<ULInformationTransfer_r16_IEsDedicatedInfoType_r16>,
    #[asn(optional_idx = 1)]
    pub dedicated_info_f1c_r16: Option<DedicatedInfoF1c_r16>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<ULInformationTransfer_v8a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct ULInformationTransfer_r8_IEs {
    pub dedicated_info_type: ULInformationTransfer_r8_IEsDedicatedInfoType,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<ULInformationTransfer_v8a0_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct ULInformationTransfer_v8a0_IEs {
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension: Option<ULInformationTransfer_v8a0_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<ULInformationTransfer_v8a0_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ULInformationTransferIRAT_r16 {
    pub critical_extensions: ULInformationTransferIRAT_r16CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct ULInformationTransferIRAT_r16_IEs {
    #[asn(optional_idx = 0)]
    pub ul_dcch_message_nr_r16: Option<ULInformationTransferIRAT_r16_IEsUl_DCCH_MessageNR_r16>,
    #[asn(optional_idx = 1)]
    pub late_non_critical_extension:
        Option<ULInformationTransferIRAT_r16_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<ULInformationTransferIRAT_r16_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ULInformationTransferMRDC_r15 {
    pub critical_extensions: ULInformationTransferMRDC_r15CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct ULInformationTransferMRDC_r15_IEs {
    #[asn(optional_idx = 0)]
    pub ul_dcch_message_nr_r15: Option<ULInformationTransferMRDC_r15_IEsUl_DCCH_MessageNR_r15>,
    #[asn(optional_idx = 1)]
    pub late_non_critical_extension:
        Option<ULInformationTransferMRDC_r15_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 2)]
    pub non_critical_extension: Option<ULInformationTransferMRDC_r15_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UplinkPUSCH_LessPowerControlDedicated_v1430 {
    #[asn(optional_idx = 0)]
    pub p0_ue_periodic_srs_r14:
        Option<UplinkPUSCH_LessPowerControlDedicated_v1430P0_UE_PeriodicSRS_r14>,
    #[asn(optional_idx = 1)]
    pub p0_ue_aperiodic_srs_r14:
        Option<UplinkPUSCH_LessPowerControlDedicated_v1430P0_UE_AperiodicSRS_r14>,
    pub accumulation_enabled_r14:
        UplinkPUSCH_LessPowerControlDedicated_v1430AccumulationEnabled_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct UplinkPowerControlAddSRS_r16 {
    #[asn(optional_idx = 0)]
    pub tpc_index_srs_add_r16: Option<TPC_Index>,
    #[asn(optional_idx = 1)]
    pub starting_bit_of_format3_b_srs_add_r16:
        Option<UplinkPowerControlAddSRS_r16StartingBitOfFormat3B_SRS_Add_r16>,
    #[asn(optional_idx = 2)]
    pub field_type_format3_b_srs_add_r16:
        Option<UplinkPowerControlAddSRS_r16FieldTypeFormat3B_SRS_Add_r16>,
    #[asn(optional_idx = 3)]
    pub p0_ue_srs_add_r16: Option<UplinkPowerControlAddSRS_r16P0_UE_SRS_Add_r16>,
    pub accumulation_enabled_srs_add_r16:
        UplinkPowerControlAddSRS_r16AccumulationEnabledSRS_Add_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkPowerControlCommon {
    pub p0_nominal_pusch: UplinkPowerControlCommonP0_NominalPUSCH,
    pub alpha: Alpha_r12,
    pub p0_nominal_pucch: UplinkPowerControlCommonP0_NominalPUCCH,
    pub delta_f_list_pucch: DeltaFList_PUCCH,
    pub delta_preamble_msg3: UplinkPowerControlCommonDeltaPreambleMsg3,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkPowerControlCommon_v1020 {
    pub delta_f_pucch_format3_r10: UplinkPowerControlCommon_v1020DeltaF_PUCCH_Format3_r10,
    pub delta_f_pucch_format1b_cs_r10: UplinkPowerControlCommon_v1020DeltaF_PUCCH_Format1bCS_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UplinkPowerControlCommon_v1310 {
    #[asn(optional_idx = 0)]
    pub delta_f_pucch_format4_r13: Option<UplinkPowerControlCommon_v1310DeltaF_PUCCH_Format4_r13>,
    #[asn(optional_idx = 1)]
    pub delta_f_pucch_format5_13: Option<UplinkPowerControlCommon_v1310DeltaF_PUCCH_Format5_13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkPowerControlCommon_v1530 {
    pub delta_f_list_spucch_r15: DeltaFList_SPUCCH_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkPowerControlCommon_v1610 {
    pub alpha_srs_add_r16: Alpha_r12,
    pub p0_nominal_srs_add_r16: UplinkPowerControlCommon_v1610P0_NominalSRS_Add_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkPowerControlCommonPSCell_r12 {
    pub delta_f_pucch_format3_r12: UplinkPowerControlCommonPSCell_r12DeltaF_PUCCH_Format3_r12,
    pub delta_f_pucch_format1b_cs_r12:
        UplinkPowerControlCommonPSCell_r12DeltaF_PUCCH_Format1bCS_r12,
    pub p0_nominal_pucch_r12: UplinkPowerControlCommonPSCell_r12P0_NominalPUCCH_r12,
    pub delta_f_list_pucch_r12: DeltaFList_PUCCH,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct UplinkPowerControlCommonPUSCH_LessCell_v1430 {
    #[asn(optional_idx = 0)]
    pub p0_nominal_periodic_srs_r14:
        Option<UplinkPowerControlCommonPUSCH_LessCell_v1430P0_Nominal_PeriodicSRS_r14>,
    #[asn(optional_idx = 1)]
    pub p0_nominal_aperiodic_srs_r14:
        Option<UplinkPowerControlCommonPUSCH_LessCell_v1430P0_Nominal_AperiodicSRS_r14>,
    #[asn(optional_idx = 2)]
    pub alpha_srs_r14: Option<Alpha_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkPowerControlCommonSCell_r10 {
    pub p0_nominal_pusch_r10: UplinkPowerControlCommonSCell_r10P0_NominalPUSCH_r10,
    pub alpha_r10: Alpha_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkPowerControlCommonSCell_v1130 {
    pub delta_preamble_msg3_r11: UplinkPowerControlCommonSCell_v1130DeltaPreambleMsg3_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct UplinkPowerControlCommonSCell_v1310 {
    pub p0_nominal_pucch: UplinkPowerControlCommonSCell_v1310P0_NominalPUCCH,
    pub delta_f_list_pucch: DeltaFList_PUCCH,
    #[asn(optional_idx = 0)]
    pub delta_f_pucch_format3_r12:
        Option<UplinkPowerControlCommonSCell_v1310DeltaF_PUCCH_Format3_r12>,
    #[asn(optional_idx = 1)]
    pub delta_f_pucch_format1b_cs_r12:
        Option<UplinkPowerControlCommonSCell_v1310DeltaF_PUCCH_Format1bCS_r12>,
    #[asn(optional_idx = 2)]
    pub delta_f_pucch_format4_r13:
        Option<UplinkPowerControlCommonSCell_v1310DeltaF_PUCCH_Format4_r13>,
    #[asn(optional_idx = 3)]
    pub delta_f_pucch_format5_13:
        Option<UplinkPowerControlCommonSCell_v1310DeltaF_PUCCH_Format5_13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UplinkPowerControlDedicated {
    pub p0_ue_pusch: UplinkPowerControlDedicatedP0_UE_PUSCH,
    pub delta_mcs_enabled: UplinkPowerControlDedicatedDeltaMCS_Enabled,
    pub accumulation_enabled: UplinkPowerControlDedicatedAccumulationEnabled,
    pub p0_ue_pucch: UplinkPowerControlDedicatedP0_UE_PUCCH,
    pub psrs_offset: UplinkPowerControlDedicatedPSRS_Offset,
    #[asn(optional_idx = 0)]
    pub filter_coefficient: Option<FilterCoefficient>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UplinkPowerControlDedicated_v1020 {
    #[asn(optional_idx = 0)]
    pub delta_tx_d_offset_list_pucch_r10: Option<DeltaTxD_OffsetListPUCCH_r10>,
    #[asn(optional_idx = 1)]
    pub psrs_offset_ap_r10: Option<UplinkPowerControlDedicated_v1020PSRS_OffsetAp_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct UplinkPowerControlDedicated_v1130 {
    #[asn(optional_idx = 0)]
    pub psrs_offset_v1130: Option<UplinkPowerControlDedicated_v1130PSRS_Offset_v1130>,
    #[asn(optional_idx = 1)]
    pub psrs_offset_ap_v1130: Option<UplinkPowerControlDedicated_v1130PSRS_OffsetAp_v1130>,
    #[asn(optional_idx = 2)]
    pub delta_tx_d_offset_list_pucch_v1130: Option<DeltaTxD_OffsetListPUCCH_v1130>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkPowerControlDedicated_v1250 {
    pub set2_power_control_parameter: UplinkPowerControlDedicated_v1250Set2PowerControlParameter,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UplinkPowerControlDedicated_v1530 {
    #[asn(optional_idx = 0)]
    pub alpha_ue_r15: Option<Alpha_r12>,
    #[asn(optional_idx = 1)]
    pub p0_ue_pusch_r15: Option<UplinkPowerControlDedicated_v1530P0_UE_PUSCH_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UplinkPowerControlDedicatedSCell_r10 {
    pub p0_ue_pusch_r10: UplinkPowerControlDedicatedSCell_r10P0_UE_PUSCH_r10,
    pub delta_mcs_enabled_r10: UplinkPowerControlDedicatedSCell_r10DeltaMCS_Enabled_r10,
    pub accumulation_enabled_r10: UplinkPowerControlDedicatedSCell_r10AccumulationEnabled_r10,
    pub psrs_offset_r10: UplinkPowerControlDedicatedSCell_r10PSRS_Offset_r10,
    #[asn(optional_idx = 0)]
    pub psrs_offset_ap_r10: Option<UplinkPowerControlDedicatedSCell_r10PSRS_OffsetAp_r10>,
    #[asn(optional_idx = 1)]
    pub filter_coefficient_r10: Option<FilterCoefficient>,
    pub pathloss_reference_linking_r10:
        UplinkPowerControlDedicatedSCell_r10PathlossReferenceLinking_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UplinkPowerControlDedicatedSCell_v1310 {
    pub p0_ue_pucch: UplinkPowerControlDedicatedSCell_v1310P0_UE_PUCCH,
    #[asn(optional_idx = 0)]
    pub delta_tx_d_offset_list_pucch_r10: Option<DeltaTxD_OffsetListPUCCH_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UplinkPowerControlDedicatedSTTI_r15 {
    pub accumulation_enabled_stti_r15:
        UplinkPowerControlDedicatedSTTI_r15AccumulationEnabledSTTI_r15,
    #[asn(optional_idx = 0)]
    pub delta_tx_d_offset_list_spucch_r15: Option<DeltaTxD_OffsetListSPUCCH_r15>,
    pub uplink_power_csi_payload: UplinkPowerControlDedicatedSTTI_r15UplinkPower_CSIPayload,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct V2X_BandCombinationParameters_r14(pub Vec<V2X_BandParameters_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct V2X_BandCombinationParameters_v1530(pub Vec<V2X_BandParameters_v1530>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct V2X_BandCombinationParametersEUTRA_NR_v1630 {
    pub band_list_sidelink_eutra_nr_r16:
        V2X_BandCombinationParametersEUTRA_NR_v1630BandListSidelinkEUTRA_NR_r16,
    pub band_list_sidelink_eutra_nr_v1630:
        V2X_BandCombinationParametersEUTRA_NR_v1630BandListSidelinkEUTRA_NR_v1630,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct V2X_BandCombinationParametersEUTRA_NR_v1710(pub Vec<V2X_BandParametersEUTRA_NR_v1710>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct V2X_BandParameters_r14 {
    pub v2x_freq_band_eutra_r14: FreqBandIndicator_r11,
    #[asn(optional_idx = 0)]
    pub band_parameters_tx_sl_r14: Option<BandParametersTxSL_r14>,
    #[asn(optional_idx = 1)]
    pub band_parameters_rx_sl_r14: Option<BandParametersRxSL_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct V2X_BandParameters_v1530 {
    #[asn(optional_idx = 0)]
    pub v2x_enhanced_high_reception_r15:
        Option<V2X_BandParameters_v1530V2x_EnhancedHighReception_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum V2X_BandParametersEUTRA_NR_r16 {
    #[asn(key = 0, extended = false)]
    Eutra(V2X_BandParametersEUTRA_NR_r16_eutra),
    #[asn(key = 1, extended = false)]
    Nr(V2X_BandParametersEUTRA_NR_r16_nr),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum V2X_BandParametersEUTRA_NR_v1630 {
    #[asn(key = 0, extended = false)]
    Eutra(V2X_BandParametersEUTRA_NR_v1630_eutra),
    #[asn(key = 1, extended = false)]
    Nr(V2X_BandParametersEUTRA_NR_v1630_nr),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct V2X_BandParametersEUTRA_NR_v1710 {
    #[asn(optional_idx = 0)]
    pub v2x_band_parameters_eutra_nr_v1710:
        Option<V2X_BandParametersEUTRA_NR_v1710V2x_BandParametersEUTRA_NR_v1710>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct V2X_BandwidthClass_r14(pub u8);
impl V2X_BandwidthClass_r14 {
    pub const A: u8 = 0u8;
    pub const B: u8 = 1u8;
    pub const C: u8 = 2u8;
    pub const D: u8 = 3u8;
    pub const E: u8 = 4u8;
    pub const F: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct V2X_BandwidthClassSL_r14(pub Vec<V2X_BandwidthClass_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "384"
)]
pub struct V2X_SupportedBandCombination_r14(pub Vec<V2X_BandCombinationParameters_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "384"
)]
pub struct V2X_SupportedBandCombination_v1530(pub Vec<V2X_BandCombinationParameters_v1530>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "512"
)]
pub struct V2X_SupportedBandCombinationEUTRA_NR_r16(pub Vec<V2X_BandParametersEUTRA_NR_r16>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "512"
)]
pub struct V2X_SupportedBandCombinationEUTRA_NR_v1630(
    pub Vec<V2X_BandCombinationParametersEUTRA_NR_v1630>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "512"
)]
pub struct V2X_SupportedBandCombinationEUTRA_NR_v1710(
    pub Vec<V2X_BandCombinationParametersEUTRA_NR_v1710>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct ValidityArea_r16 {
    pub carrier_freq_r16: ARFCN_ValueEUTRA_r9,
    #[asn(optional_idx = 0)]
    pub validity_cell_list_r16: Option<ValidityCellList_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct ValidityAreaList_r16(pub Vec<ValidityArea_r16>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct ValidityCellList_r16(pub Vec<PhysCellIdRange>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct VarConditionalReconfiguration {
    #[asn(optional_idx = 0)]
    pub cond_reconfiguration_list_r16: Option<CondReconfigurationToAddModList_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct VarConnEstFailReport_r11 {
    pub conn_est_fail_report_r11: ConnEstFailReport_r11,
    pub plmn_identity_r11: PLMN_Identity,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct VarLogMeasConfig_r10 {
    #[asn(optional_idx = 0)]
    pub area_configuration_r10: Option<AreaConfiguration_r10>,
    pub logging_duration_r10: LoggingDuration_r10,
    pub logging_interval_r10: LoggingInterval_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct VarLogMeasConfig_r11 {
    #[asn(optional_idx = 0)]
    pub area_configuration_r10: Option<AreaConfiguration_r10>,
    #[asn(optional_idx = 1)]
    pub area_configuration_v1130: Option<AreaConfiguration_v1130>,
    pub logging_duration_r10: LoggingDuration_r10,
    pub logging_interval_r10: LoggingInterval_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct VarLogMeasConfig_r12 {
    #[asn(optional_idx = 0)]
    pub area_configuration_r10: Option<AreaConfiguration_r10>,
    #[asn(optional_idx = 1)]
    pub area_configuration_v1130: Option<AreaConfiguration_v1130>,
    pub logging_duration_r10: LoggingDuration_r10,
    pub logging_interval_r10: LoggingInterval_r10,
    #[asn(optional_idx = 2)]
    pub target_mbsfn_area_list_r12: Option<TargetMBSFN_AreaList_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct VarLogMeasConfig_r15 {
    #[asn(optional_idx = 0)]
    pub area_configuration_r10: Option<AreaConfiguration_r10>,
    #[asn(optional_idx = 1)]
    pub area_configuration_v1130: Option<AreaConfiguration_v1130>,
    pub logging_duration_r10: LoggingDuration_r10,
    pub logging_interval_r10: LoggingInterval_r10,
    #[asn(optional_idx = 2)]
    pub target_mbsfn_area_list_r12: Option<TargetMBSFN_AreaList_r12>,
    #[asn(optional_idx = 3)]
    pub bt_name_list_r15: Option<BT_NameList_r15>,
    #[asn(optional_idx = 4)]
    pub wlan_name_list_r15: Option<WLAN_NameList_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 7)]
pub struct VarLogMeasConfig_r17 {
    #[asn(optional_idx = 0)]
    pub area_configuration_r10: Option<AreaConfiguration_r10>,
    #[asn(optional_idx = 1)]
    pub area_configuration_v1130: Option<AreaConfiguration_v1130>,
    pub logging_duration_r10: LoggingDuration_r10,
    pub logging_interval_r10: LoggingInterval_r10,
    #[asn(optional_idx = 2)]
    pub target_mbsfn_area_list_r12: Option<TargetMBSFN_AreaList_r12>,
    #[asn(optional_idx = 3)]
    pub bt_name_list_r15: Option<BT_NameList_r15>,
    #[asn(optional_idx = 4)]
    pub wlan_name_list_r15: Option<WLAN_NameList_r15>,
    #[asn(optional_idx = 5)]
    pub logged_event_trigger_config_r17: Option<LoggedEventTriggerConfig_r17>,
    #[asn(optional_idx = 6)]
    pub meas_uncom_bar_pre_r17: Option<VarLogMeasConfig_r17MeasUncomBarPre_r17>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct VarLogMeasReport_r10 {
    pub trace_reference_r10: TraceReference_r10,
    pub trace_recording_session_ref_r10: VarLogMeasReport_r10TraceRecordingSessionRef_r10,
    pub tce_id_r10: VarLogMeasReport_r10Tce_Id_r10,
    pub plmn_identity_r10: PLMN_Identity,
    pub absolute_time_info_r10: AbsoluteTimeInfo_r10,
    pub log_meas_info_list_r10: LogMeasInfoList2_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct VarLogMeasReport_r11 {
    pub trace_reference_r10: TraceReference_r10,
    pub trace_recording_session_ref_r10: VarLogMeasReport_r11TraceRecordingSessionRef_r10,
    pub tce_id_r10: VarLogMeasReport_r11Tce_Id_r10,
    pub plmn_identity_list_r11: PLMN_IdentityList3_r11,
    pub absolute_time_info_r10: AbsoluteTimeInfo_r10,
    pub log_meas_info_list_r10: LogMeasInfoList2_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 13)]
pub struct VarMeasConfig {
    #[asn(optional_idx = 0)]
    pub meas_id_list: Option<MeasIdToAddModList>,
    #[asn(optional_idx = 1)]
    pub meas_id_list_ext_r12: Option<MeasIdToAddModListExt_r12>,
    #[asn(optional_idx = 2)]
    pub meas_id_list_v1310: Option<MeasIdToAddModList_v1310>,
    #[asn(optional_idx = 3)]
    pub meas_id_list_ext_v1310: Option<MeasIdToAddModListExt_v1310>,
    #[asn(optional_idx = 4)]
    pub meas_object_list: Option<MeasObjectToAddModList>,
    #[asn(optional_idx = 5)]
    pub meas_object_list_ext_r13: Option<MeasObjectToAddModListExt_r13>,
    #[asn(optional_idx = 6)]
    pub meas_object_list_v9i0: Option<MeasObjectToAddModList_v9e0>,
    #[asn(optional_idx = 7)]
    pub report_config_list: Option<ReportConfigToAddModList>,
    #[asn(optional_idx = 8)]
    pub quantity_config: Option<QuantityConfig>,
    #[asn(optional_idx = 9)]
    pub meas_scale_factor_r12: Option<MeasScaleFactor_r12>,
    #[asn(optional_idx = 10)]
    pub s_measure: Option<VarMeasConfigS_Measure>,
    #[asn(optional_idx = 11)]
    pub speed_state_pars: Option<VarMeasConfigSpeedStatePars>,
    #[asn(optional_idx = 12)]
    pub allow_interruptions_r11: Option<VarMeasConfigAllowInterruptions_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct VarMeasIdleConfig_r15 {
    #[asn(optional_idx = 0)]
    pub meas_idle_carrier_list_eutra_r15: Option<EUTRA_CarrierList_r15>,
    pub meas_idle_duration_r15: VarMeasIdleConfig_r15MeasIdleDuration_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct VarMeasIdleConfig_r16 {
    #[asn(optional_idx = 0)]
    pub meas_idle_carrier_list_nr_r16: Option<NR_CarrierList_r16>,
    #[asn(optional_idx = 1)]
    pub validity_area_list_r16: Option<ValidityAreaList_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct VarMeasIdleReport_r15 {
    pub meas_report_idle_r15: MeasResultListIdle_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct VarMeasIdleReport_r16 {
    #[asn(optional_idx = 0)]
    pub meas_report_idle_r16: Option<MeasResultListExtIdle_r16>,
    #[asn(optional_idx = 1)]
    pub meas_report_idle_nr_r16: Option<MeasResultListIdleNR_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct VarMeasReport {
    pub meas_id: MeasId,
    #[asn(optional_idx = 0)]
    pub meas_id_v1250: Option<MeasId_v1250>,
    #[asn(optional_idx = 1)]
    pub cells_triggered_list: Option<CellsTriggeredList>,
    #[asn(optional_idx = 2)]
    pub csi_rs_triggered_list_r12: Option<CSI_RS_TriggeredList_r12>,
    #[asn(optional_idx = 3)]
    pub pools_triggered_list_r14: Option<Tx_ResourcePoolMeasList_r14>,
    pub number_of_reports_sent: VarMeasReportNumberOfReportsSent,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct VarMeasReportList(pub Vec<VarMeasReport>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct VarMeasReportList_r12(pub Vec<VarMeasReport>);

pub type VarMobilityHistoryReport_r12 = VisitedCellInfoList_r12;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct VarPendingRnaUpdate_r15 {
    #[asn(optional_idx = 0)]
    pub pending_rna_update: Option<VarPendingRnaUpdate_r15PendingRnaUpdate>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct VarRLF_Report_r10 {
    pub rlf_report_r10: RLF_Report_r9,
    pub plmn_identity_r10: PLMN_Identity,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct VarRLF_Report_r11 {
    pub rlf_report_r10: RLF_Report_r9,
    pub plmn_identity_list_r11: PLMN_IdentityList3_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct VarShortINACTIVE_MAC_Input_r15 {
    pub cell_identity_r15: CellIdentity,
    pub phys_cell_id_r15: PhysCellId,
    pub c_rnti_r15: C_RNTI,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct VarShortMAC_Input {
    pub cell_identity: CellIdentity,
    pub phys_cell_id: PhysCellId,
    pub c_rnti: C_RNTI,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct VarShortResumeMAC_Input_r13 {
    pub cell_identity_r13: CellIdentity,
    pub phys_cell_id_r13: PhysCellId,
    pub c_rnti_r13: C_RNTI,
    pub resume_discriminator_r13: VarShortResumeMAC_Input_r13ResumeDiscriminator_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct VarWLAN_MobilityConfig {
    #[asn(optional_idx = 0)]
    pub wlan_mobility_set_r13: Option<WLAN_Id_List_r13>,
    #[asn(optional_idx = 1)]
    pub success_report_requested: Option<VarWLAN_MobilityConfigSuccessReportRequested>,
    #[asn(optional_idx = 2)]
    pub wlan_suspend_config_r14: Option<WLAN_SuspendConfig_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct VarWLAN_Status_r13 {
    pub status_r13: WLAN_Status_r13,
    #[asn(optional_idx = 0)]
    pub status_r14: Option<WLAN_Status_v1430>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-131072", ub = "131071")]
pub struct VelocityStateVector_r17(pub i32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 6)]
pub struct VictimSystemType_r11 {
    #[asn(optional_idx = 0)]
    pub gps_r11: Option<VictimSystemType_r11Gps_r11>,
    #[asn(optional_idx = 1)]
    pub glonass_r11: Option<VictimSystemType_r11Glonass_r11>,
    #[asn(optional_idx = 2)]
    pub bds_r11: Option<VictimSystemType_r11Bds_r11>,
    #[asn(optional_idx = 3)]
    pub galileo_r11: Option<VictimSystemType_r11Galileo_r11>,
    #[asn(optional_idx = 4)]
    pub wlan_r11: Option<VictimSystemType_r11Wlan_r11>,
    #[asn(optional_idx = 5)]
    pub bluetooth_r11: Option<VictimSystemType_r11Bluetooth_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct VictimSystemType_v1610 {
    #[asn(optional_idx = 0)]
    pub navic_r16: Option<VictimSystemType_v1610Navic_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct VisitedCellInfo_r12 {
    #[asn(optional_idx = 0)]
    pub visited_cell_id_r12: Option<VisitedCellInfo_r12VisitedCellId_r12>,
    pub time_spent_r12: VisitedCellInfo_r12TimeSpent_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct VisitedCellInfoList_r12(pub Vec<VisitedCellInfo_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "7")]
pub struct WLAN_BandIndicator_r13(pub u8);
impl WLAN_BandIndicator_r13 {
    pub const BAND2DOT4: u8 = 0u8;
    pub const BAND5: u8 = 1u8;
    pub const BAND60_V1430: u8 = 2u8;
    pub const SPARE5: u8 = 3u8;
    pub const SPARE4: u8 = 4u8;
    pub const SPARE3: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct WLAN_CarrierInfo_r13 {
    #[asn(optional_idx = 0)]
    pub operating_class_r13: Option<WLAN_CarrierInfo_r13OperatingClass_r13>,
    #[asn(optional_idx = 1)]
    pub country_code_r13: Option<WLAN_CarrierInfo_r13CountryCode_r13>,
    #[asn(optional_idx = 2)]
    pub channel_numbers_r13: Option<WLAN_ChannelList_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct WLAN_Channel_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct WLAN_ChannelList_r13(pub Vec<WLAN_Channel_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct WLAN_IW_Parameters_r12 {
    #[asn(optional_idx = 0)]
    pub wlan_iw_ran_rules_r12: Option<WLAN_IW_Parameters_r12Wlan_IW_RAN_Rules_r12>,
    #[asn(optional_idx = 1)]
    pub wlan_iw_andsf_policies_r12: Option<WLAN_IW_Parameters_r12Wlan_IW_ANDSF_Policies_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct WLAN_IW_Parameters_v1310 {
    #[asn(optional_idx = 0)]
    pub rclwi_r13: Option<WLAN_IW_Parameters_v1310Rclwi_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct WLAN_Id_List_r12(pub Vec<WLAN_Identifiers_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct WLAN_Id_List_r13(pub Vec<WLAN_Identifiers_r12>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct WLAN_Identifiers_r12 {
    #[asn(optional_idx = 0)]
    pub ssid_r12: Option<WLAN_Identifiers_r12Ssid_r12>,
    #[asn(optional_idx = 1)]
    pub bssid_r12: Option<WLAN_Identifiers_r12Bssid_r12>,
    #[asn(optional_idx = 2)]
    pub hessid_r12: Option<WLAN_Identifiers_r12Hessid_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct WLAN_MobilityConfig_r13 {
    #[asn(optional_idx = 0)]
    pub wlan_to_release_list_r13: Option<WLAN_Id_List_r13>,
    #[asn(optional_idx = 1)]
    pub wlan_to_add_list_r13: Option<WLAN_Id_List_r13>,
    #[asn(optional_idx = 2)]
    pub association_timer_r13: Option<WLAN_MobilityConfig_r13AssociationTimer_r13>,
    #[asn(optional_idx = 3)]
    pub success_report_requested_r13: Option<WLAN_MobilityConfig_r13SuccessReportRequested_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "32"
)]
pub struct WLAN_Name_r15(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct WLAN_NameList_r15(pub Vec<WLAN_Name_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum WLAN_NameListConfig_r15 {
    #[asn(key = 0, extended = false)]
    Release(WLAN_NameListConfig_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(WLAN_NameList_r15),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 10)]
pub struct WLAN_OffloadConfig_r12 {
    #[asn(optional_idx = 0)]
    pub threshold_rsrp_r12: Option<WLAN_OffloadConfig_r12ThresholdRSRP_r12>,
    #[asn(optional_idx = 1)]
    pub threshold_rsrq_r12: Option<WLAN_OffloadConfig_r12ThresholdRSRQ_r12>,
    #[asn(optional_idx = 2)]
    pub threshold_rsrq_on_all_symbols_with_wb_r12:
        Option<WLAN_OffloadConfig_r12ThresholdRSRQ_OnAllSymbolsWithWB_r12>,
    #[asn(optional_idx = 3)]
    pub threshold_rsrq_on_all_symbols_r12:
        Option<WLAN_OffloadConfig_r12ThresholdRSRQ_OnAllSymbols_r12>,
    #[asn(optional_idx = 4)]
    pub threshold_rsrq_wb_r12: Option<WLAN_OffloadConfig_r12ThresholdRSRQ_WB_r12>,
    #[asn(optional_idx = 5)]
    pub threshold_channel_utilization_r12:
        Option<WLAN_OffloadConfig_r12ThresholdChannelUtilization_r12>,
    #[asn(optional_idx = 6)]
    pub threshold_backhaul_bandwidth_r12:
        Option<WLAN_OffloadConfig_r12ThresholdBackhaul_Bandwidth_r12>,
    #[asn(optional_idx = 7)]
    pub threshold_wlan_rssi_r12: Option<WLAN_OffloadConfig_r12ThresholdWLAN_RSSI_r12>,
    #[asn(optional_idx = 8)]
    pub offload_preference_indicator_r12:
        Option<WLAN_OffloadConfig_r12OffloadPreferenceIndicator_r12>,
    #[asn(optional_idx = 9)]
    pub t_steering_wlan_r12: Option<T_Reselection>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct WLAN_OffloadInfoPerPLMN_r12 {
    #[asn(optional_idx = 0)]
    pub wlan_offload_config_common_r12: Option<WLAN_OffloadConfig_r12>,
    #[asn(optional_idx = 1)]
    pub wlan_id_list_r12: Option<WLAN_Id_List_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "141")]
pub struct WLAN_RSSI_Range_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct WLAN_RTT_r15 {
    pub rtt_value_r15: WLAN_RTT_r15RttValue_r15,
    pub rtt_units_r15: WLAN_RTT_r15RttUnits_r15,
    #[asn(optional_idx = 0)]
    pub rtt_accuracy_r15: Option<WLAN_RTT_r15RttAccuracy_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct WLAN_Status_r13(pub u8);
impl WLAN_Status_r13 {
    pub const SUCCESSFUL_ASSOCIATION: u8 = 0u8;
    pub const FAILURE_WLAN_RADIO_LINK: u8 = 1u8;
    pub const FAILURE_WLAN_UNAVAILABLE: u8 = 2u8;
    pub const FAILURE_TIMEOUT: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct WLAN_Status_v1430(pub u8);
impl WLAN_Status_v1430 {
    pub const SUSPENDED: u8 = 0u8;
    pub const RESUMED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct WLAN_SuspendConfig_r14 {
    #[asn(optional_idx = 0)]
    pub wlan_suspend_resume_allowed_r14:
        Option<WLAN_SuspendConfig_r14Wlan_SuspendResumeAllowed_r14>,
    #[asn(optional_idx = 1)]
    pub wlan_suspend_triggers_status_report_r14:
        Option<WLAN_SuspendConfig_r14Wlan_SuspendTriggersStatusReport_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "31")]
pub struct WLAN_backhaulRate_r12(pub u8);
impl WLAN_backhaulRate_r12 {
    pub const R0: u8 = 0u8;
    pub const R4: u8 = 1u8;
    pub const R8: u8 = 2u8;
    pub const R16: u8 = 3u8;
    pub const R32: u8 = 4u8;
    pub const R64: u8 = 5u8;
    pub const R128: u8 = 6u8;
    pub const R256: u8 = 7u8;
    pub const R512: u8 = 8u8;
    pub const R1024: u8 = 9u8;
    pub const R2048: u8 = 10u8;
    pub const R4096: u8 = 11u8;
    pub const R8192: u8 = 12u8;
    pub const R16384: u8 = 13u8;
    pub const R32768: u8 = 14u8;
    pub const R65536: u8 = 15u8;
    pub const R131072: u8 = 16u8;
    pub const R262144: u8 = 17u8;
    pub const R524288: u8 = 18u8;
    pub const R1048576: u8 = 19u8;
    pub const R2097152: u8 = 20u8;
    pub const R4194304: u8 = 21u8;
    pub const R8388608: u8 = 22u8;
    pub const R16777216: u8 = 23u8;
    pub const R33554432: u8 = 24u8;
    pub const R67108864: u8 = 25u8;
    pub const R134217728: u8 = 26u8;
    pub const R268435456: u8 = 27u8;
    pub const R536870912: u8 = 28u8;
    pub const R1073741824: u8 = 29u8;
    pub const R2147483648: u8 = 30u8;
    pub const R4294967296: u8 = 31u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WLANConnectionStatusReport_r13 {
    pub critical_extensions: WLANConnectionStatusReport_r13CriticalExtensions,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct WLANConnectionStatusReport_r13_IEs {
    pub wlan_status_r13: WLAN_Status_r13,
    #[asn(optional_idx = 0)]
    pub late_non_critical_extension:
        Option<WLANConnectionStatusReport_r13_IEsLateNonCriticalExtension>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<WLANConnectionStatusReport_v1430_IEs>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct WLANConnectionStatusReport_v1430_IEs {
    pub wlan_status_v1430: WLAN_Status_v1430,
    #[asn(optional_idx = 0)]
    pub non_critical_extension: Option<WLANConnectionStatusReport_v1430_IEsNonCriticalExtension>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct WUS_Config_r15 {
    pub max_duration_factor_r15: WUS_Config_r15MaxDurationFactor_r15,
    #[asn(optional_idx = 0)]
    pub num_p_os_r15: Option<WUS_Config_r15NumPOs_r15>,
    pub freq_location_r15: WUS_Config_r15FreqLocation_r15,
    pub time_offset_drx_r15: WUS_Config_r15TimeOffsetDRX_r15,
    pub time_offset_e_drx_short_r15: WUS_Config_r15TimeOffset_eDRX_Short_r15,
    #[asn(optional_idx = 1)]
    pub time_offset_e_drx_long_r15: Option<WUS_Config_r15TimeOffset_eDRX_Long_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WUS_Config_v1560 {
    pub power_boost_r15: WUS_Config_v1560PowerBoost_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WUS_Config_v1610 {
    pub num_drx_cycles_relaxed_r16: WUS_Config_v1610NumDRX_CyclesRelaxed_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct WayPointLocation_r15 {
    pub way_point_location_r15: LocationInfo_r10,
    #[asn(optional_idx = 0)]
    pub time_stamp_r15: Option<AbsoluteTimeInfo_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WidebandPRG_r16 {
    pub wideband_prg_subframe_r16: WidebandPRG_r16WidebandPRG_Subframe_r16,
    pub wideband_prg_slot_subslot_r16: WidebandPRG_r16WidebandPRG_SlotSubslot_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum ZeroTxPowerCSI_RS_Conf_r12 {
    #[asn(key = 0, extended = false)]
    Release(ZeroTxPowerCSI_RS_Conf_r12_release),
    #[asn(key = 1, extended = false)]
    Setup(ZeroTxPowerCSI_RS_r12),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ZeroTxPowerCSI_RS_r12 {
    pub zero_tx_power_resource_config_list_r12:
        ZeroTxPowerCSI_RS_r12ZeroTxPowerResourceConfigList_r12,
    pub zero_tx_power_subframe_config_r12: ZeroTxPowerCSI_RS_r12ZeroTxPowerSubframeConfig_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct AC_BarringConfigAc_BarringFactor(pub u8);
impl AC_BarringConfigAc_BarringFactor {
    pub const P00: u8 = 0u8;
    pub const P05: u8 = 1u8;
    pub const P10: u8 = 2u8;
    pub const P15: u8 = 3u8;
    pub const P20: u8 = 4u8;
    pub const P25: u8 = 5u8;
    pub const P30: u8 = 6u8;
    pub const P40: u8 = 7u8;
    pub const P50: u8 = 8u8;
    pub const P60: u8 = 9u8;
    pub const P70: u8 = 10u8;
    pub const P75: u8 = 11u8;
    pub const P80: u8 = 12u8;
    pub const P85: u8 = 13u8;
    pub const P90: u8 = 14u8;
    pub const P95: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct AC_BarringConfigAc_BarringTime(pub u8);
impl AC_BarringConfigAc_BarringTime {
    pub const S4: u8 = 0u8;
    pub const S8: u8 = 1u8;
    pub const S16: u8 = 2u8;
    pub const S32: u8 = 3u8;
    pub const S64: u8 = 4u8;
    pub const S128: u8 = 5u8;
    pub const S256: u8 = 6u8;
    pub const S512: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "5", sz_ub = "5")]
pub struct AC_BarringConfigAc_BarringForSpecialAC(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63")]
pub struct AC_BarringConfig1XRTT_r9Ac_Barring0to9_r9(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct AC_BarringConfig1XRTT_r9Ac_Barring10_r9(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct AC_BarringConfig1XRTT_r9Ac_Barring11_r9(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct AC_BarringConfig1XRTT_r9Ac_Barring12_r9(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct AC_BarringConfig1XRTT_r9Ac_Barring13_r9(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct AC_BarringConfig1XRTT_r9Ac_Barring14_r9(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct AC_BarringConfig1XRTT_r9Ac_Barring15_r9(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct AC_BarringConfig1XRTT_r9Ac_BarringMsg_r9(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct AC_BarringConfig1XRTT_r9Ac_BarringReg_r9(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct AC_BarringConfig1XRTT_r9Ac_BarringEmg_r9(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "6")]
pub struct AC_BarringPerPLMN_r12Plmn_IdentityIndex_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct AC_BarringPerPLMN_r12Ac_BarringInfo_r12Ac_BarringForEmergency_r12(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct AC_BarringPerPLMN_r12Ac_BarringInfo_r12 {
    pub ac_barring_for_emergency_r12:
        AC_BarringPerPLMN_r12Ac_BarringInfo_r12Ac_BarringForEmergency_r12,
    #[asn(optional_idx = 0)]
    pub ac_barring_for_mo_signalling_r12: Option<AC_BarringConfig>,
    #[asn(optional_idx = 1)]
    pub ac_barring_for_mo_data_r12: Option<AC_BarringConfig>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct AC_BarringPerPLMN_r12Ac_BarringSkipForMMTELVoice_r12(pub u8);
impl AC_BarringPerPLMN_r12Ac_BarringSkipForMMTELVoice_r12 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct AC_BarringPerPLMN_r12Ac_BarringSkipForMMTELVideo_r12(pub u8);
impl AC_BarringPerPLMN_r12Ac_BarringSkipForMMTELVideo_r12 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct AC_BarringPerPLMN_r12Ac_BarringSkipForSMS_r12(pub u8);
impl AC_BarringPerPLMN_r12Ac_BarringSkipForSMS_r12 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct ACDC_BarringForCommon_r13Acdc_HPLMNonly_r13(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "6")]
pub struct ACDC_BarringPerPLMN_r13Plmn_IdentityIndex_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct ACDC_BarringPerPLMN_r13Acdc_OnlyForHPLMN_r13(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "9")]
pub struct AS_Config_v1550Tdm_PatternConfig_r15Harq_Offset_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AS_Config_v1550Tdm_PatternConfig_r15 {
    pub subframe_assignment_r15: SubframeAssignment_r15,
    pub harq_offset_r15: AS_Config_v1550Tdm_PatternConfig_r15Harq_Offset_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct AS_Config_v1700Scg_State_r17(pub u8);
impl AS_Config_v1700Scg_State_r17 {
    pub const DEACTIVATED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct AS_ConfigNR_r15SourceRB_ConfigNR_r15(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct AS_ConfigNR_r15SourceRB_ConfigSN_NR_r15(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct AS_ConfigNR_r15SourceOtherConfigSN_NR_r15(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct AS_ConfigNR_v1570SourceSCG_ConfiguredNR_r15(pub u8);
impl AS_ConfigNR_v1570SourceSCG_ConfiguredNR_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct AS_Context_v1130Idc_Indication_r11(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct AS_Context_v1130MbmsInterestIndication_r11(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct AS_Context_v1130UeAssistanceInformation_r11(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct AS_Context_v1320WlanConnectionStatusReport_r13(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct AS_Context_v1610SidelinkUEInformationNR_r16(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct AS_Context_v1610UeAssistanceInformationNR_r16(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct AS_Context_v1620UeAssistanceInformationNR_SCG_r16(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct AUL_Config_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "40", sz_ub = "40")]
pub struct AUL_Config_r15_setupAul_Subframes_r15(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct AUL_Config_r15_setupAul_HARQ_Processes_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct AUL_Config_r15_setupTransmissionModeUL_AUL_r15(pub u8);
impl AUL_Config_r15_setupTransmissionModeUL_AUL_r15 {
    pub const TM1: u8 = 0u8;
    pub const TM2: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "5", sz_ub = "5")]
pub struct AUL_Config_r15_setupAul_StartingFullBW_InsideMCOT_r15(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "7", sz_ub = "7")]
pub struct AUL_Config_r15_setupAul_StartingFullBW_OutsideMCOT_r15(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "4")]
pub struct AUL_Config_r15_setupAul_StartingPartialBW_InsideMCOT_r15(pub u8);
impl AUL_Config_r15_setupAul_StartingPartialBW_InsideMCOT_r15 {
    pub const O34: u8 = 0u8;
    pub const O43: u8 = 1u8;
    pub const O52: u8 = 2u8;
    pub const O61: u8 = 3u8;
    pub const O_OS1: u8 = 4u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "6")]
pub struct AUL_Config_r15_setupAul_StartingPartialBW_OutsideMCOT_r15(pub u8);
impl AUL_Config_r15_setupAul_StartingPartialBW_OutsideMCOT_r15 {
    pub const O16: u8 = 0u8;
    pub const O25: u8 = 1u8;
    pub const O34: u8 = 2u8;
    pub const O43: u8 = 3u8;
    pub const O52: u8 = 4u8;
    pub const O61: u8 = 5u8;
    pub const O_OS1: u8 = 6u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "16")]
pub struct AUL_Config_r15_setupAul_RetransmissionTimer_r15(pub u8);
impl AUL_Config_r15_setupAul_RetransmissionTimer_r15 {
    pub const PSF4: u8 = 0u8;
    pub const PSF5: u8 = 1u8;
    pub const PSF6: u8 = 2u8;
    pub const PSF8: u8 = 3u8;
    pub const PSF10: u8 = 4u8;
    pub const PSF12: u8 = 5u8;
    pub const PSF20: u8 = 6u8;
    pub const PSF28: u8 = 7u8;
    pub const PSF37: u8 = 8u8;
    pub const PSF44: u8 = 9u8;
    pub const PSF68: u8 = 10u8;
    pub const PSF84: u8 = 11u8;
    pub const PSF100: u8 = 12u8;
    pub const PSF116: u8 = 13u8;
    pub const PSF132: u8 = 14u8;
    pub const PSF164: u8 = 15u8;
    pub const PSF324: u8 = 16u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "12", ub = "13")]
pub struct AUL_Config_r15_setupEndingSymbolAUL_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "2", ub = "4")]
pub struct AUL_Config_r15_setupSubframeOffsetCOT_Sharing_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct AUL_Config_r15_setupContentionWindowSizeTimer_r15(pub u8);
impl AUL_Config_r15_setupContentionWindowSizeTimer_r15 {
    pub const N0: u8 = 0u8;
    pub const N5: u8 = 1u8;
    pub const N10: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AUL_Config_r15_setup {
    pub aul_crnti_r15: C_RNTI,
    pub aul_subframes_r15: AUL_Config_r15_setupAul_Subframes_r15,
    pub aul_harq_processes_r15: AUL_Config_r15_setupAul_HARQ_Processes_r15,
    pub transmission_mode_ul_aul_r15: AUL_Config_r15_setupTransmissionModeUL_AUL_r15,
    pub aul_starting_full_bw_inside_mcot_r15: AUL_Config_r15_setupAul_StartingFullBW_InsideMCOT_r15,
    pub aul_starting_full_bw_outside_mcot_r15:
        AUL_Config_r15_setupAul_StartingFullBW_OutsideMCOT_r15,
    pub aul_starting_partial_bw_inside_mcot_r15:
        AUL_Config_r15_setupAul_StartingPartialBW_InsideMCOT_r15,
    pub aul_starting_partial_bw_outside_mcot_r15:
        AUL_Config_r15_setupAul_StartingPartialBW_OutsideMCOT_r15,
    pub aul_retransmission_timer_r15: AUL_Config_r15_setupAul_RetransmissionTimer_r15,
    pub ending_symbol_aul_r15: AUL_Config_r15_setupEndingSymbolAUL_r15,
    pub subframe_offset_cot_sharing_r15: AUL_Config_r15_setupSubframeOffsetCOT_Sharing_r15,
    pub contention_window_size_timer_r15: AUL_Config_r15_setupContentionWindowSizeTimer_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct AdditionalSI_Info_r9Csg_MemberStatus_r9(pub u8);
impl AdditionalSI_Info_r9Csg_MemberStatus_r9 {
    pub const MEMBER: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct AffectedCarrierFreq_r11InterferenceDirection_r11(pub u8);
impl AffectedCarrierFreq_r11InterferenceDirection_r11 {
    pub const EUTRA: u8 = 0u8;
    pub const OTHER: u8 = 1u8;
    pub const BOTH: u8 = 2u8;
    pub const SPARE: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct AffectedCarrierFreqCombInfoMRDC_r15InterferenceDirectionMRDC_r15(pub u8);
impl AffectedCarrierFreqCombInfoMRDC_r15InterferenceDirectionMRDC_r15 {
    pub const EUTRA_NR: u8 = 0u8;
    pub const NR: u8 = 1u8;
    pub const OTHER: u8 = 2u8;
    pub const EUTRA_NR_OTHER: u8 = 3u8;
    pub const NR_OTHER: u8 = 4u8;
    pub const SPARE3: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct AffectedCarrierFreqCombInfoMRDC_r15AffectedCarrierFreqCombMRDC_r15 {
    #[asn(optional_idx = 0)]
    pub affected_carrier_freq_comb_eutra_r15: Option<AffectedCarrierFreqComb_r15>,
    pub affected_carrier_freq_comb_nr_r15: AffectedCarrierFreqCombNR_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct AllowedCellsToAddMod_r13CellIndex_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct AltTTT_CellsToAddMod_r12CellIndex_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct AntennaInfoCommonAntennaPortsCount(pub u8);
impl AntennaInfoCommonAntennaPortsCount {
    pub const AN1: u8 = 0u8;
    pub const AN2: u8 = 1u8;
    pub const AN4: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct AntennaInfoDedicatedTransmissionMode(pub u8);
impl AntennaInfoDedicatedTransmissionMode {
    pub const TM1: u8 = 0u8;
    pub const TM2: u8 = 1u8;
    pub const TM3: u8 = 2u8;
    pub const TM4: u8 = 3u8;
    pub const TM5: u8 = 4u8;
    pub const TM6: u8 = 5u8;
    pub const TM7: u8 = 6u8;
    pub const TM8_V920: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct AntennaInfoDedicatedCodebookSubsetRestriction_n2TxAntenna_tm3(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct AntennaInfoDedicatedCodebookSubsetRestriction_n4TxAntenna_tm3(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "6", sz_ub = "6")]
pub struct AntennaInfoDedicatedCodebookSubsetRestriction_n2TxAntenna_tm4(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "64", sz_ub = "64")]
pub struct AntennaInfoDedicatedCodebookSubsetRestriction_n4TxAntenna_tm4(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct AntennaInfoDedicatedCodebookSubsetRestriction_n2TxAntenna_tm5(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct AntennaInfoDedicatedCodebookSubsetRestriction_n4TxAntenna_tm5(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct AntennaInfoDedicatedCodebookSubsetRestriction_n2TxAntenna_tm6(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct AntennaInfoDedicatedCodebookSubsetRestriction_n4TxAntenna_tm6(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "7", extensible = false)]
pub enum AntennaInfoDedicatedCodebookSubsetRestriction {
    #[asn(key = 0, extended = false)]
    N2TxAntenna_tm3(AntennaInfoDedicatedCodebookSubsetRestriction_n2TxAntenna_tm3),
    #[asn(key = 1, extended = false)]
    N4TxAntenna_tm3(AntennaInfoDedicatedCodebookSubsetRestriction_n4TxAntenna_tm3),
    #[asn(key = 2, extended = false)]
    N2TxAntenna_tm4(AntennaInfoDedicatedCodebookSubsetRestriction_n2TxAntenna_tm4),
    #[asn(key = 3, extended = false)]
    N4TxAntenna_tm4(AntennaInfoDedicatedCodebookSubsetRestriction_n4TxAntenna_tm4),
    #[asn(key = 4, extended = false)]
    N2TxAntenna_tm5(AntennaInfoDedicatedCodebookSubsetRestriction_n2TxAntenna_tm5),
    #[asn(key = 5, extended = false)]
    N4TxAntenna_tm5(AntennaInfoDedicatedCodebookSubsetRestriction_n4TxAntenna_tm5),
    #[asn(key = 6, extended = false)]
    N2TxAntenna_tm6(AntennaInfoDedicatedCodebookSubsetRestriction_n2TxAntenna_tm6),
    #[asn(key = 7, extended = false)]
    N4TxAntenna_tm6(AntennaInfoDedicatedCodebookSubsetRestriction_n4TxAntenna_tm6),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct AntennaInfoDedicatedUe_TransmitAntennaSelection_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct AntennaInfoDedicatedUe_TransmitAntennaSelection_setup(pub u8);
impl AntennaInfoDedicatedUe_TransmitAntennaSelection_setup {
    pub const CLOSED_LOOP: u8 = 0u8;
    pub const OPEN_LOOP: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum AntennaInfoDedicatedUe_TransmitAntennaSelection {
    #[asn(key = 0, extended = false)]
    Release(AntennaInfoDedicatedUe_TransmitAntennaSelection_release),
    #[asn(key = 1, extended = false)]
    Setup(AntennaInfoDedicatedUe_TransmitAntennaSelection_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct AntennaInfoDedicated_r10TransmissionMode_r10(pub u8);
impl AntennaInfoDedicated_r10TransmissionMode_r10 {
    pub const TM1: u8 = 0u8;
    pub const TM2: u8 = 1u8;
    pub const TM3: u8 = 2u8;
    pub const TM4: u8 = 3u8;
    pub const TM5: u8 = 4u8;
    pub const TM6: u8 = 5u8;
    pub const TM7: u8 = 6u8;
    pub const TM8_V920: u8 = 7u8;
    pub const TM9_V1020: u8 = 8u8;
    pub const TM10_V1130: u8 = 9u8;
    pub const SPARE6: u8 = 10u8;
    pub const SPARE5: u8 = 11u8;
    pub const SPARE4: u8 = 12u8;
    pub const SPARE3: u8 = 13u8;
    pub const SPARE2: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING")]
pub struct AntennaInfoDedicated_r10CodebookSubsetRestriction_r10(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct AntennaInfoDedicated_r10Ue_TransmitAntennaSelection_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct AntennaInfoDedicated_r10Ue_TransmitAntennaSelection_setup(pub u8);
impl AntennaInfoDedicated_r10Ue_TransmitAntennaSelection_setup {
    pub const CLOSED_LOOP: u8 = 0u8;
    pub const OPEN_LOOP: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum AntennaInfoDedicated_r10Ue_TransmitAntennaSelection {
    #[asn(key = 0, extended = false)]
    Release(AntennaInfoDedicated_r10Ue_TransmitAntennaSelection_release),
    #[asn(key = 1, extended = false)]
    Setup(AntennaInfoDedicated_r10Ue_TransmitAntennaSelection_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct AntennaInfoDedicated_v10i0MaxLayersMIMO_r10(pub u8);
impl AntennaInfoDedicated_v10i0MaxLayersMIMO_r10 {
    pub const TWO_LAYERS: u8 = 0u8;
    pub const FOUR_LAYERS: u8 = 1u8;
    pub const EIGHT_LAYERS: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct AntennaInfoDedicated_v1250AlternativeCodebookEnabledFor4TX_r12(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct AntennaInfoDedicated_v1430Ce_UE_TxAntennaSelection_config_r14(pub u8);
impl AntennaInfoDedicated_v1430Ce_UE_TxAntennaSelection_config_r14 {
    pub const ON: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct AntennaInfoDedicated_v1530_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct AntennaInfoDedicated_v1530_setup_ue_TxAntennaSelection_SRS_1T4R_Config_r15;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct AntennaInfoDedicated_v1530_setup_ue_TxAntennaSelection_SRS_2T4R_NrOfPairs_r15(pub u8);
impl AntennaInfoDedicated_v1530_setup_ue_TxAntennaSelection_SRS_2T4R_NrOfPairs_r15 {
    pub const TWO: u8 = 0u8;
    pub const THREE: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum AntennaInfoDedicated_v1530_setup {
    #[asn(key = 0, extended = false)]
    Ue_TxAntennaSelection_SRS_1T4R_Config_r15(
        AntennaInfoDedicated_v1530_setup_ue_TxAntennaSelection_SRS_1T4R_Config_r15,
    ),
    #[asn(key = 1, extended = false)]
    Ue_TxAntennaSelection_SRS_2T4R_NrOfPairs_r15(
        AntennaInfoDedicated_v1530_setup_ue_TxAntennaSelection_SRS_2T4R_NrOfPairs_r15,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "6", sz_ub = "6")]
pub struct AntennaInfoDedicated_v920CodebookSubsetRestriction_v920_n2TxAntenna_tm8_r9(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct AntennaInfoDedicated_v920CodebookSubsetRestriction_v920_n4TxAntenna_tm8_r9(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum AntennaInfoDedicated_v920CodebookSubsetRestriction_v920 {
    #[asn(key = 0, extended = false)]
    N2TxAntenna_tm8_r9(AntennaInfoDedicated_v920CodebookSubsetRestriction_v920_n2TxAntenna_tm8_r9),
    #[asn(key = 1, extended = false)]
    N4TxAntenna_tm8_r9(AntennaInfoDedicated_v920CodebookSubsetRestriction_v920_n4TxAntenna_tm8_r9),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct AntennaInfoDedicatedSTTI_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct AntennaInfoDedicatedSTTI_r15_setupTransmissionModeDL_MBSFN_r15(pub u8);
impl AntennaInfoDedicatedSTTI_r15_setupTransmissionModeDL_MBSFN_r15 {
    pub const TM9: u8 = 0u8;
    pub const TM10: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct AntennaInfoDedicatedSTTI_r15_setupTransmissionModeDL_nonMBSFN_r15(pub u8);
impl AntennaInfoDedicatedSTTI_r15_setupTransmissionModeDL_nonMBSFN_r15 {
    pub const TM1: u8 = 0u8;
    pub const TM2: u8 = 1u8;
    pub const TM3: u8 = 2u8;
    pub const TM4: u8 = 3u8;
    pub const TM6: u8 = 4u8;
    pub const TM8: u8 = 5u8;
    pub const TM9: u8 = 6u8;
    pub const TM10: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction_n2TxAntenna_tm3_r15(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction_n4TxAntenna_tm3_r15(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "6", sz_ub = "6")]
pub struct AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction_n2TxAntenna_tm4_r15(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "64", sz_ub = "64")]
pub struct AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction_n4TxAntenna_tm4_r15(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction_n2TxAntenna_tm5_r15(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction_n4TxAntenna_tm5_r15(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction_n2TxAntenna_tm6_r15(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction_n4TxAntenna_tm6_r15(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "6", sz_ub = "6")]
pub struct AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction_n2TxAntenna_tm8_r15(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "64", sz_ub = "64")]
pub struct AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction_n4TxAntenna_tm8_r15(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "6", sz_ub = "6")]
pub struct AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction_n2TxAntenna_tm9and10_r15(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "96", sz_ub = "96")]
pub struct AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction_n4TxAntenna_tm9and10_r15(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "BITSTRING",
    sz_extensible = false,
    sz_lb = "109",
    sz_ub = "109"
)]
pub struct AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction_n8TxAntenna_tm9and10_r15(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "12", extensible = false)]
pub enum AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction {
    #[asn(key = 0, extended = false)]
    N2TxAntenna_tm3_r15(
        AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction_n2TxAntenna_tm3_r15,
    ),
    #[asn(key = 1, extended = false)]
    N4TxAntenna_tm3_r15(
        AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction_n4TxAntenna_tm3_r15,
    ),
    #[asn(key = 2, extended = false)]
    N2TxAntenna_tm4_r15(
        AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction_n2TxAntenna_tm4_r15,
    ),
    #[asn(key = 3, extended = false)]
    N4TxAntenna_tm4_r15(
        AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction_n4TxAntenna_tm4_r15,
    ),
    #[asn(key = 4, extended = false)]
    N2TxAntenna_tm5_r15(
        AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction_n2TxAntenna_tm5_r15,
    ),
    #[asn(key = 5, extended = false)]
    N4TxAntenna_tm5_r15(
        AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction_n4TxAntenna_tm5_r15,
    ),
    #[asn(key = 6, extended = false)]
    N2TxAntenna_tm6_r15(
        AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction_n2TxAntenna_tm6_r15,
    ),
    #[asn(key = 7, extended = false)]
    N4TxAntenna_tm6_r15(
        AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction_n4TxAntenna_tm6_r15,
    ),
    #[asn(key = 8, extended = false)]
    N2TxAntenna_tm8_r15(
        AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction_n2TxAntenna_tm8_r15,
    ),
    #[asn(key = 9, extended = false)]
    N4TxAntenna_tm8_r15(
        AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction_n4TxAntenna_tm8_r15,
    ),
    #[asn(key = 10, extended = false)]
    N2TxAntenna_tm9and10_r15(
        AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction_n2TxAntenna_tm9and10_r15,
    ),
    #[asn(key = 11, extended = false)]
    N4TxAntenna_tm9and10_r15(
        AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction_n4TxAntenna_tm9and10_r15,
    ),
    #[asn(key = 12, extended = false)]
    N8TxAntenna_tm9and10_r15(
        AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction_n8TxAntenna_tm9and10_r15,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct AntennaInfoDedicatedSTTI_r15_setupMaxLayersMIMO_STTI_r15(pub u8);
impl AntennaInfoDedicatedSTTI_r15_setupMaxLayersMIMO_STTI_r15 {
    pub const TWO_LAYERS: u8 = 0u8;
    pub const FOUR_LAYERS: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct AntennaInfoDedicatedSTTI_r15_setupSlotSubslotPDSCH_TxDiv_2Layer_r15(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct AntennaInfoDedicatedSTTI_r15_setupSlotSubslotPDSCH_TxDiv_4Layer_r15(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct AntennaInfoDedicatedSTTI_r15_setup {
    #[asn(optional_idx = 0)]
    pub transmission_mode_dl_mbsfn_r15:
        Option<AntennaInfoDedicatedSTTI_r15_setupTransmissionModeDL_MBSFN_r15>,
    #[asn(optional_idx = 1)]
    pub transmission_mode_dl_non_mbsfn_r15:
        Option<AntennaInfoDedicatedSTTI_r15_setupTransmissionModeDL_nonMBSFN_r15>,
    #[asn(optional_idx = 2)]
    pub codebook_subset_restriction:
        Option<AntennaInfoDedicatedSTTI_r15_setupCodebookSubsetRestriction>,
    #[asn(optional_idx = 3)]
    pub max_layers_mimo_stti_r15: Option<AntennaInfoDedicatedSTTI_r15_setupMaxLayersMIMO_STTI_r15>,
    pub slot_subslot_pdsch_tx_div_2layer_r15:
        AntennaInfoDedicatedSTTI_r15_setupSlotSubslotPDSCH_TxDiv_2Layer_r15,
    pub slot_subslot_pdsch_tx_div_4layer_r15:
        AntennaInfoDedicatedSTTI_r15_setupSlotSubslotPDSCH_TxDiv_4Layer_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct AntennaInfoUL_STTI_r15TransmissionModeUL_STTI_r15(pub u8);
impl AntennaInfoUL_STTI_r15TransmissionModeUL_STTI_r15 {
    pub const TM1: u8 = 0u8;
    pub const TM2: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct AntennaInfoUL_r10TransmissionModeUL_r10(pub u8);
impl AntennaInfoUL_r10TransmissionModeUL_r10 {
    pub const TM1: u8 = 0u8;
    pub const TM2: u8 = 1u8;
    pub const SPARE6: u8 = 2u8;
    pub const SPARE5: u8 = 3u8;
    pub const SPARE4: u8 = 4u8;
    pub const SPARE3: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct AntennaInfoUL_r10FourAntennaPortActivated_r10(pub u8);
impl AntennaInfoUL_r10FourAntennaPortActivated_r10 {
    pub const SETUP: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct ApplicableDisasterInfo_r17_noDisasterRoaming_r17;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct ApplicableDisasterInfo_r17_disasterRelatedIndication_r17;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct ApplicableDisasterInfo_r17_commonPLMNs_r17;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct ApplicableDisasterInfo_r17_dedicatedPLMNs_r17(pub Vec<PLMN_Identity>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct BCCH_ConfigModificationPeriodCoeff(pub u8);
impl BCCH_ConfigModificationPeriodCoeff {
    pub const N2: u8 = 0u8;
    pub const N4: u8 = 1u8;
    pub const N8: u8 = 2u8;
    pub const N16: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BCCH_Config_v1310ModificationPeriodCoeff_v1310(pub u8);
impl BCCH_Config_v1310ModificationPeriodCoeff_v1310 {
    pub const N64: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum BCCH_DL_SCH_MessageType_c1 {
    #[asn(key = 0, extended = false)]
    SystemInformation(SystemInformation),
    #[asn(key = 1, extended = false)]
    SystemInformationBlockType1(SystemInformationBlockType1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BCCH_DL_SCH_MessageType_messageClassExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum BCCH_DL_SCH_MessageType_BR_r13_c1 {
    #[asn(key = 0, extended = false)]
    SystemInformation_BR_r13(SystemInformation_BR_r13),
    #[asn(key = 1, extended = false)]
    SystemInformationBlockType1_BR_r13(SystemInformationBlockType1_BR_r13),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BCCH_DL_SCH_MessageType_BR_r13_messageClassExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum BCCH_DL_SCH_MessageType_MBMS_r14_c1 {
    #[asn(key = 0, extended = false)]
    SystemInformation_MBMS_r14(SystemInformation_MBMS_r14),
    #[asn(key = 1, extended = false)]
    SystemInformationBlockType1_MBMS_r14(SystemInformationBlockType1_MBMS_r14),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BCCH_DL_SCH_MessageType_MBMS_r14_messageClassExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct BLER_Result_r12BlocksReceived_r12N_r12(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct BLER_Result_r12BlocksReceived_r12M_r12(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BLER_Result_r12BlocksReceived_r12 {
    pub n_r12: BLER_Result_r12BlocksReceived_r12N_r12,
    pub m_r12: BLER_Result_r12BlocksReceived_r12M_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct BT_NameListConfig_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct BW_Preference_r14Dl_Preference_r14(pub u8);
impl BW_Preference_r14Dl_Preference_r14 {
    pub const MHZ1DOT4: u8 = 0u8;
    pub const MHZ5: u8 = 1u8;
    pub const MHZ20: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct BW_Preference_r14Ul_Preference_r14(pub u8);
impl BW_Preference_r14Ul_Preference_r14 {
    pub const MHZ1DOT4: u8 = 0u8;
    pub const MHZ5: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63")]
pub struct BandClassInfoCDMA2000ThreshX_High(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63")]
pub struct BandClassInfoCDMA2000ThreshX_Low(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct BandCombinationParameters_r11BandParameterList_r11(pub Vec<BandParameters_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandCombinationParameters_r11MultipleTimingAdvance_r11(pub u8);
impl BandCombinationParameters_r11MultipleTimingAdvance_r11 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandCombinationParameters_r11SimultaneousRx_Tx_r11(pub u8);
impl BandCombinationParameters_r11SimultaneousRx_Tx_r11 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandCombinationParameters_r13DifferentFallbackSupported_r13(pub u8);
impl BandCombinationParameters_r13DifferentFallbackSupported_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct BandCombinationParameters_r13BandParameterList_r13(pub Vec<BandParameters_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandCombinationParameters_r13MultipleTimingAdvance_r13(pub u8);
impl BandCombinationParameters_r13MultipleTimingAdvance_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandCombinationParameters_r13SimultaneousRx_Tx_r13(pub u8);
impl BandCombinationParameters_r13SimultaneousRx_Tx_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandCombinationParameters_r13Dc_Support_r13Asynchronous_r13(pub u8);
impl BandCombinationParameters_r13Dc_Support_r13Asynchronous_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct BandCombinationParameters_r13Dc_Support_r13SupportedCellGrouping_r13_threeEntries_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "7", sz_ub = "7")]
pub struct BandCombinationParameters_r13Dc_Support_r13SupportedCellGrouping_r13_fourEntries_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "15", sz_ub = "15")]
pub struct BandCombinationParameters_r13Dc_Support_r13SupportedCellGrouping_r13_fiveEntries_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum BandCombinationParameters_r13Dc_Support_r13SupportedCellGrouping_r13 {
    #[asn(key = 0, extended = false)]
    ThreeEntries_r13(
        BandCombinationParameters_r13Dc_Support_r13SupportedCellGrouping_r13_threeEntries_r13,
    ),
    #[asn(key = 1, extended = false)]
    FourEntries_r13(
        BandCombinationParameters_r13Dc_Support_r13SupportedCellGrouping_r13_fourEntries_r13,
    ),
    #[asn(key = 2, extended = false)]
    FiveEntries_r13(
        BandCombinationParameters_r13Dc_Support_r13SupportedCellGrouping_r13_fiveEntries_r13,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct BandCombinationParameters_r13Dc_Support_r13 {
    #[asn(optional_idx = 0)]
    pub asynchronous_r13: Option<BandCombinationParameters_r13Dc_Support_r13Asynchronous_r13>,
    #[asn(optional_idx = 1)]
    pub supported_cell_grouping_r13:
        Option<BandCombinationParameters_r13Dc_Support_r13SupportedCellGrouping_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct BandCombinationParameters_r13SupportedNAICS_2CRS_AP_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct BandCombinationParameters_r13CommSupportedBandsPerBC_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct BandCombinationParameters_v10i0BandParameterList_v10i0(pub Vec<BandParameters_v10i0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandCombinationParameters_v1130MultipleTimingAdvance_r11(pub u8);
impl BandCombinationParameters_v1130MultipleTimingAdvance_r11 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandCombinationParameters_v1130SimultaneousRx_Tx_r11(pub u8);
impl BandCombinationParameters_v1130SimultaneousRx_Tx_r11 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct BandCombinationParameters_v1130BandParameterList_r11(pub Vec<BandParameters_v1130>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandCombinationParameters_v1250Dc_Support_r12Asynchronous_r12(pub u8);
impl BandCombinationParameters_v1250Dc_Support_r12Asynchronous_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct BandCombinationParameters_v1250Dc_Support_r12SupportedCellGrouping_r12_threeEntries_r12(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "7", sz_ub = "7")]
pub struct BandCombinationParameters_v1250Dc_Support_r12SupportedCellGrouping_r12_fourEntries_r12(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "15", sz_ub = "15")]
pub struct BandCombinationParameters_v1250Dc_Support_r12SupportedCellGrouping_r12_fiveEntries_r12(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum BandCombinationParameters_v1250Dc_Support_r12SupportedCellGrouping_r12 {
    #[asn(key = 0, extended = false)]
    ThreeEntries_r12(
        BandCombinationParameters_v1250Dc_Support_r12SupportedCellGrouping_r12_threeEntries_r12,
    ),
    #[asn(key = 1, extended = false)]
    FourEntries_r12(
        BandCombinationParameters_v1250Dc_Support_r12SupportedCellGrouping_r12_fourEntries_r12,
    ),
    #[asn(key = 2, extended = false)]
    FiveEntries_r12(
        BandCombinationParameters_v1250Dc_Support_r12SupportedCellGrouping_r12_fiveEntries_r12,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct BandCombinationParameters_v1250Dc_Support_r12 {
    #[asn(optional_idx = 0)]
    pub asynchronous_r12: Option<BandCombinationParameters_v1250Dc_Support_r12Asynchronous_r12>,
    #[asn(optional_idx = 1)]
    pub supported_cell_grouping_r12:
        Option<BandCombinationParameters_v1250Dc_Support_r12SupportedCellGrouping_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct BandCombinationParameters_v1250SupportedNAICS_2CRS_AP_r12(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct BandCombinationParameters_v1250CommSupportedBandsPerBC_r12(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct BandCombinationParameters_v1270BandParameterList_v1270(pub Vec<BandParameters_v1270>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct BandCombinationParameters_v1320BandParameterList_v1320(pub Vec<BandParameters_v1320>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandCombinationParameters_v1320AdditionalRx_Tx_PerformanceReq_r13(pub u8);
impl BandCombinationParameters_v1320AdditionalRx_Tx_PerformanceReq_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct BandCombinationParameters_v1380BandParameterList_v1380(pub Vec<BandParameters_v1380>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandCombinationParameters_v1390Ue_CA_PowerClass_N_r13(pub u8);
impl BandCombinationParameters_v1390Ue_CA_PowerClass_N_r13 {
    pub const CLASS2: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct BandCombinationParameters_v1430BandParameterList_v1430(pub Vec<BandParameters_v1430>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "1", sz_ub = "384")]
pub struct BandCombinationParameters_v1430V2x_SupportedTxBandCombListPerBC_r14(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "1", sz_ub = "384")]
pub struct BandCombinationParameters_v1430V2x_SupportedRxBandCombListPerBC_r14(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct BandCombinationParameters_v1450BandParameterList_v1450(pub Vec<BandParameters_v1450>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct BandCombinationParameters_v1470BandParameterList_v1470(pub Vec<BandParameters_v1470>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "31")]
pub struct BandCombinationParameters_v1470Srs_MaxSimultaneousCCs_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct BandCombinationParameters_v14b0BandParameterList_v14b0(pub Vec<BandParameters_v14b0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct BandCombinationParameters_v1530BandParameterList_v1530(pub Vec<BandParameters_v1530>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct BandCombinationParameters_v1610BandParameterList_v1610(pub Vec<BandParameters_v1610>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandCombinationParameters_v1610InterFreqDAPS_r16InterFreqAsyncDAPS_r16(pub u8);
impl BandCombinationParameters_v1610InterFreqDAPS_r16InterFreqAsyncDAPS_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandCombinationParameters_v1610InterFreqDAPS_r16InterFreqMultiUL_TransmissionDAPS_r16(
    pub u8,
);
impl BandCombinationParameters_v1610InterFreqDAPS_r16InterFreqMultiUL_TransmissionDAPS_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct BandCombinationParameters_v1610InterFreqDAPS_r16 {
    #[asn(optional_idx = 0)]
    pub inter_freq_async_daps_r16:
        Option<BandCombinationParameters_v1610InterFreqDAPS_r16InterFreqAsyncDAPS_r16>,
    #[asn(optional_idx = 1)]
    pub inter_freq_multi_ul_transmission_daps_r16: Option<
        BandCombinationParameters_v1610InterFreqDAPS_r16InterFreqMultiUL_TransmissionDAPS_r16,
    >,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "1", sz_ub = "512")]
pub struct BandCombinationParameters_v1630V2x_SupportedTxBandCombListPerBC_v1630(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "1", sz_ub = "512")]
pub struct BandCombinationParameters_v1630V2x_SupportedRxBandCombListPerBC_v1630(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "512"
)]
pub struct BandCombinationParameters_v1630ScalingFactorTxSidelink_r16(
    pub Vec<ScalingFactorSidelink_r16>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "512"
)]
pub struct BandCombinationParameters_v1630ScalingFactorRxSidelink_r16(
    pub Vec<ScalingFactorSidelink_r16>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandCombinationParameters_v1630InterBandPowerSharingSyncDAPS_r16(pub u8);
impl BandCombinationParameters_v1630InterBandPowerSharingSyncDAPS_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandCombinationParameters_v1630InterBandPowerSharingAsyncDAPS_r16(pub u8);
impl BandCombinationParameters_v1630InterBandPowerSharingAsyncDAPS_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct BandParameters_r11SupportedCSI_Proc_r11(pub u8);
impl BandParameters_r11SupportedCSI_Proc_r11 {
    pub const N1: u8 = 0u8;
    pub const N3: u8 = 1u8;
    pub const N4: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct BandParameters_r13SupportedCSI_Proc_r13(pub u8);
impl BandParameters_r13SupportedCSI_Proc_r13 {
    pub const N1: u8 = 0u8;
    pub const N3: u8 = 1u8;
    pub const N4: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct BandParameters_v10i0BandParametersDL_v10i0(pub Vec<CA_MIMO_ParametersDL_v10i0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct BandParameters_v1130SupportedCSI_Proc_r11(pub u8);
impl BandParameters_v1130SupportedCSI_Proc_r11 {
    pub const N1: u8 = 0u8;
    pub const N3: u8 = 1u8;
    pub const N4: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct BandParameters_v1270BandParametersDL_v1270(pub Vec<CA_MIMO_ParametersDL_v1270>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct BandParameters_v1380TxAntennaSwitchDL_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct BandParameters_v1380TxAntennaSwitchUL_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandParameters_v1430Ul_256QAM_r14(pub u8);
impl BandParameters_v1430Ul_256QAM_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "2", sz_ub = "32")]
pub struct BandParameters_v1430Ul_256QAM_perCC_InfoList_r14(pub Vec<UL_256QAM_perCC_Info_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct BandParameters_v1430Srs_CapabilityPerBandPairList_r14(
    pub Vec<SRS_CapabilityPerBandPair_r14>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct BandParameters_v14b0Srs_CapabilityPerBandPairList_v14b0(
    pub Vec<SRS_CapabilityPerBandPair_v14b0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandParameters_v1530Ue_TxAntennaSelection_SRS_1T4R_r15(pub u8);
impl BandParameters_v1530Ue_TxAntennaSelection_SRS_1T4R_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandParameters_v1530Ue_TxAntennaSelection_SRS_2T4R_2Pairs_r15(pub u8);
impl BandParameters_v1530Ue_TxAntennaSelection_SRS_2T4R_2Pairs_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandParameters_v1530Ue_TxAntennaSelection_SRS_2T4R_3Pairs_r15(pub u8);
impl BandParameters_v1530Ue_TxAntennaSelection_SRS_2T4R_3Pairs_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandParameters_v1530Dl_1024QAM_r15(pub u8);
impl BandParameters_v1530Dl_1024QAM_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandParameters_v1530Qcl_TypeC_Operation_r15(pub u8);
impl BandParameters_v1530Qcl_TypeC_Operation_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandParameters_v1530Qcl_CRI_BasedCSI_Reporting_r15(pub u8);
impl BandParameters_v1530Qcl_CRI_BasedCSI_Reporting_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandParameters_v1610IntraFreqDAPS_r16IntraFreqAsyncDAPS_r16(pub u8);
impl BandParameters_v1610IntraFreqDAPS_r16IntraFreqAsyncDAPS_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandParameters_v1610IntraFreqDAPS_r16Dummy(pub u8);
impl BandParameters_v1610IntraFreqDAPS_r16Dummy {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandParameters_v1610IntraFreqDAPS_r16IntraFreqTwoTAGs_DAPS_r16(pub u8);
impl BandParameters_v1610IntraFreqDAPS_r16IntraFreqTwoTAGs_DAPS_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct BandParameters_v1610IntraFreqDAPS_r16 {
    #[asn(optional_idx = 0)]
    pub intra_freq_async_daps_r16:
        Option<BandParameters_v1610IntraFreqDAPS_r16IntraFreqAsyncDAPS_r16>,
    #[asn(optional_idx = 1)]
    pub dummy: Option<BandParameters_v1610IntraFreqDAPS_r16Dummy>,
    #[asn(optional_idx = 2)]
    pub intra_freq_two_ta_gs_daps_r16:
        Option<BandParameters_v1610IntraFreqDAPS_r16IntraFreqTwoTAGs_DAPS_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandParameters_v1610AddSRS_FrequencyHopping_r16(pub u8);
impl BandParameters_v1610AddSRS_FrequencyHopping_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandParameters_v1610AddSRS_AntennaSwitching_r16AddSRS_1T2R_r16(pub u8);
impl BandParameters_v1610AddSRS_AntennaSwitching_r16AddSRS_1T2R_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandParameters_v1610AddSRS_AntennaSwitching_r16AddSRS_1T4R_r16(pub u8);
impl BandParameters_v1610AddSRS_AntennaSwitching_r16AddSRS_1T4R_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandParameters_v1610AddSRS_AntennaSwitching_r16AddSRS_2T4R_2pairs_r16(pub u8);
impl BandParameters_v1610AddSRS_AntennaSwitching_r16AddSRS_2T4R_2pairs_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandParameters_v1610AddSRS_AntennaSwitching_r16AddSRS_2T4R_3pairs_r16(pub u8);
impl BandParameters_v1610AddSRS_AntennaSwitching_r16AddSRS_2T4R_3pairs_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct BandParameters_v1610AddSRS_AntennaSwitching_r16 {
    #[asn(optional_idx = 0)]
    pub add_srs_1t2r_r16: Option<BandParameters_v1610AddSRS_AntennaSwitching_r16AddSRS_1T2R_r16>,
    #[asn(optional_idx = 1)]
    pub add_srs_1t4r_r16: Option<BandParameters_v1610AddSRS_AntennaSwitching_r16AddSRS_1T4R_r16>,
    #[asn(optional_idx = 2)]
    pub add_srs_2t4r_2pairs_r16:
        Option<BandParameters_v1610AddSRS_AntennaSwitching_r16AddSRS_2T4R_2pairs_r16>,
    #[asn(optional_idx = 3)]
    pub add_srs_2t4r_3pairs_r16:
        Option<BandParameters_v1610AddSRS_AntennaSwitching_r16AddSRS_2T4R_3pairs_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct BandParameters_v1610Srs_CapabilityPerBandPairList_v1610(
    pub Vec<SRS_CapabilityPerBandPair_v1610>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandParametersRxSL_r14V2x_HighReception_r14(pub u8);
impl BandParametersRxSL_r14V2x_HighReception_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandParametersTxSL_r14V2x_eNB_Scheduled_r14(pub u8);
impl BandParametersTxSL_r14V2x_eNB_Scheduled_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct BandParametersTxSL_r14V2x_HighPower_r14(pub u8);
impl BandParametersTxSL_r14V2x_HighPower_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct BarringPerACDC_Category_r13Acdc_Category_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct BarringPerACDC_Category_r13Acdc_BarringConfig_r13Ac_BarringFactor_r13(pub u8);
impl BarringPerACDC_Category_r13Acdc_BarringConfig_r13Ac_BarringFactor_r13 {
    pub const P00: u8 = 0u8;
    pub const P05: u8 = 1u8;
    pub const P10: u8 = 2u8;
    pub const P15: u8 = 3u8;
    pub const P20: u8 = 4u8;
    pub const P25: u8 = 5u8;
    pub const P30: u8 = 6u8;
    pub const P40: u8 = 7u8;
    pub const P50: u8 = 8u8;
    pub const P60: u8 = 9u8;
    pub const P70: u8 = 10u8;
    pub const P75: u8 = 11u8;
    pub const P80: u8 = 12u8;
    pub const P85: u8 = 13u8;
    pub const P90: u8 = 14u8;
    pub const P95: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct BarringPerACDC_Category_r13Acdc_BarringConfig_r13Ac_BarringTime_r13(pub u8);
impl BarringPerACDC_Category_r13Acdc_BarringConfig_r13Ac_BarringTime_r13 {
    pub const S4: u8 = 0u8;
    pub const S8: u8 = 1u8;
    pub const S16: u8 = 2u8;
    pub const S32: u8 = 3u8;
    pub const S64: u8 = 4u8;
    pub const S128: u8 = 5u8;
    pub const S256: u8 = 6u8;
    pub const S512: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BarringPerACDC_Category_r13Acdc_BarringConfig_r13 {
    pub ac_barring_factor_r13:
        BarringPerACDC_Category_r13Acdc_BarringConfig_r13Ac_BarringFactor_r13,
    pub ac_barring_time_r13: BarringPerACDC_Category_r13Acdc_BarringConfig_r13Ac_BarringTime_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct BeamMeasConfigIdleNR_r16ReportQuantityRS_IndexNR_r16(pub u8);
impl BeamMeasConfigIdleNR_r16ReportQuantityRS_IndexNR_r16 {
    pub const RSRP: u8 = 0u8;
    pub const RSRQ: u8 = 1u8;
    pub const BOTH: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "32")]
pub struct BeamMeasConfigIdleNR_r16MaxReportRS_Index_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct BeamMeasConfigIdleNR_r16ReportRS_IndexResultsNR_r16(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CA_MIMO_ParametersDL_r13FourLayerTM3_TM4_r13(pub u8);
impl CA_MIMO_ParametersDL_r13FourLayerTM3_TM4_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CA_MIMO_ParametersDL_r13IntraBandContiguousCC_InfoList_r13(
    pub Vec<IntraBandContiguousCC_Info_r12>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CA_MIMO_ParametersDL_r15FourLayerTM3_TM4_r15(pub u8);
impl CA_MIMO_ParametersDL_r15FourLayerTM3_TM4_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CA_MIMO_ParametersDL_r15IntraBandContiguousCC_InfoList_r15(
    pub Vec<IntraBandContiguousCC_Info_r12>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CA_MIMO_ParametersDL_v10i0FourLayerTM3_TM4_r10(pub u8);
impl CA_MIMO_ParametersDL_v10i0FourLayerTM3_TM4_r10 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "5")]
pub struct CA_MIMO_ParametersDL_v1270IntraBandContiguousCC_InfoList_r12(
    pub Vec<IntraBandContiguousCC_Info_r12>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_MultiTB_Parameters_r16Pdsch_MultiTB_CE_ModeA_r16(pub u8);
impl CE_MultiTB_Parameters_r16Pdsch_MultiTB_CE_ModeA_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_MultiTB_Parameters_r16Pdsch_MultiTB_CE_ModeB_r16(pub u8);
impl CE_MultiTB_Parameters_r16Pdsch_MultiTB_CE_ModeB_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_MultiTB_Parameters_r16Pusch_MultiTB_CE_ModeA_r16(pub u8);
impl CE_MultiTB_Parameters_r16Pusch_MultiTB_CE_ModeA_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_MultiTB_Parameters_r16Pusch_MultiTB_CE_ModeB_r16(pub u8);
impl CE_MultiTB_Parameters_r16Pusch_MultiTB_CE_ModeB_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_MultiTB_Parameters_r16Ce_MultiTB_64QAM_r16(pub u8);
impl CE_MultiTB_Parameters_r16Ce_MultiTB_64QAM_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_MultiTB_Parameters_r16Ce_MultiTB_EarlyTermination_r16(pub u8);
impl CE_MultiTB_Parameters_r16Ce_MultiTB_EarlyTermination_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_MultiTB_Parameters_r16Ce_MultiTB_FrequencyHopping_r16(pub u8);
impl CE_MultiTB_Parameters_r16Ce_MultiTB_FrequencyHopping_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_MultiTB_Parameters_r16Ce_MultiTB_HARQ_AckBundling_r16(pub u8);
impl CE_MultiTB_Parameters_r16Ce_MultiTB_HARQ_AckBundling_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_MultiTB_Parameters_r16Ce_MultiTB_Interleaving_r16(pub u8);
impl CE_MultiTB_Parameters_r16Ce_MultiTB_Interleaving_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_MultiTB_Parameters_r16Ce_MultiTB_SubPRB_r16(pub u8);
impl CE_MultiTB_Parameters_r16Ce_MultiTB_SubPRB_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct CE_PDSCH_14HARQ_Config_r17Ce_HARQ_AckDelay_r17(pub u8);
impl CE_PDSCH_14HARQ_Config_r17Ce_HARQ_AckDelay_r17 {
    pub const ALT_1: u8 = 0u8;
    pub const ALT_2E: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_PDSCH_MultiTB_Config_r16Interleaving_r16(pub u8);
impl CE_PDSCH_MultiTB_Config_r16Interleaving_r16 {
    pub const ON: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_PDSCH_MultiTB_Config_r16Harq_AckBundling_r16(pub u8);
impl CE_PDSCH_MultiTB_Config_r16Harq_AckBundling_r16 {
    pub const ON: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_PUSCH_MultiTB_Config_r16Interleaving_r16(pub u8);
impl CE_PUSCH_MultiTB_Config_r16Interleaving_r16 {
    pub const ON: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_Parameters_r13Ce_ModeA_r13(pub u8);
impl CE_Parameters_r13Ce_ModeA_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_Parameters_r13Ce_ModeB_r13(pub u8);
impl CE_Parameters_r13Ce_ModeB_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_Parameters_v1320IntraFreqA3_CE_ModeA_r13(pub u8);
impl CE_Parameters_v1320IntraFreqA3_CE_ModeA_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_Parameters_v1320IntraFreqA3_CE_ModeB_r13(pub u8);
impl CE_Parameters_v1320IntraFreqA3_CE_ModeB_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_Parameters_v1320IntraFreqHO_CE_ModeA_r13(pub u8);
impl CE_Parameters_v1320IntraFreqHO_CE_ModeA_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_Parameters_v1320IntraFreqHO_CE_ModeB_r13(pub u8);
impl CE_Parameters_v1320IntraFreqHO_CE_ModeB_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_Parameters_v1350UnicastFrequencyHopping_r13(pub u8);
impl CE_Parameters_v1350UnicastFrequencyHopping_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_Parameters_v1370Tm9_CE_ModeA_r13(pub u8);
impl CE_Parameters_v1370Tm9_CE_ModeA_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_Parameters_v1370Tm9_CE_ModeB_r13(pub u8);
impl CE_Parameters_v1370Tm9_CE_ModeB_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_Parameters_v1380Tm6_CE_ModeA_r13(pub u8);
impl CE_Parameters_v1380Tm6_CE_ModeA_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_Parameters_v1430Ce_SwitchWithoutHO_r14(pub u8);
impl CE_Parameters_v1430Ce_SwitchWithoutHO_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_ResourceResvParameters_r16SubframeResourceResvDL_CE_ModeA_r16(pub u8);
impl CE_ResourceResvParameters_r16SubframeResourceResvDL_CE_ModeA_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_ResourceResvParameters_r16SubframeResourceResvDL_CE_ModeB_r16(pub u8);
impl CE_ResourceResvParameters_r16SubframeResourceResvDL_CE_ModeB_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_ResourceResvParameters_r16SubframeResourceResvUL_CE_ModeA_r16(pub u8);
impl CE_ResourceResvParameters_r16SubframeResourceResvUL_CE_ModeA_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_ResourceResvParameters_r16SubframeResourceResvUL_CE_ModeB_r16(pub u8);
impl CE_ResourceResvParameters_r16SubframeResourceResvUL_CE_ModeB_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_ResourceResvParameters_r16SlotSymbolResourceResvDL_CE_ModeA_r16(pub u8);
impl CE_ResourceResvParameters_r16SlotSymbolResourceResvDL_CE_ModeA_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_ResourceResvParameters_r16SlotSymbolResourceResvDL_CE_ModeB_r16(pub u8);
impl CE_ResourceResvParameters_r16SlotSymbolResourceResvDL_CE_ModeB_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_ResourceResvParameters_r16SlotSymbolResourceResvUL_CE_ModeA_r16(pub u8);
impl CE_ResourceResvParameters_r16SlotSymbolResourceResvUL_CE_ModeA_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_ResourceResvParameters_r16SlotSymbolResourceResvUL_CE_ModeB_r16(pub u8);
impl CE_ResourceResvParameters_r16SlotSymbolResourceResvUL_CE_ModeB_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_ResourceResvParameters_r16SubcarrierPuncturingCE_ModeA_r16(pub u8);
impl CE_ResourceResvParameters_r16SubcarrierPuncturingCE_ModeA_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CE_ResourceResvParameters_r16SubcarrierPuncturingCE_ModeB_r16(pub u8);
impl CE_ResourceResvParameters_r16SubcarrierPuncturingCE_ModeB_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4")]
pub struct CFI_Config_r15Cfi_SubframeNonMBSFN_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "3")]
pub struct CFI_Config_r15Cfi_SlotSubslotNonMBSFN_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "2")]
pub struct CFI_Config_r15Cfi_SubframeMBSFN_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "2")]
pub struct CFI_Config_r15Cfi_SlotSubslotMBSFN_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4")]
pub struct CFI_PatternConfig_r15Cfi_PatternSubframe_r15_Entry(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "10",
    sz_ub = "10"
)]
pub struct CFI_PatternConfig_r15Cfi_PatternSubframe_r15(
    pub Vec<CFI_PatternConfig_r15Cfi_PatternSubframe_r15_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "3")]
pub struct CFI_PatternConfig_r15Cfi_PatternSlotSubslot_r15_Entry(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "10",
    sz_ub = "10"
)]
pub struct CFI_PatternConfig_r15Cfi_PatternSlotSubslot_r15(
    pub Vec<CFI_PatternConfig_r15Cfi_PatternSlotSubslot_r15_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct CGI_InfoNR_r15NoSIB1_r15Ssb_SubcarrierOffset_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct CGI_InfoNR_r15NoSIB1_r15Pdcch_ConfigSIB1_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CGI_InfoNR_r15NoSIB1_r15 {
    pub ssb_subcarrier_offset_r15: CGI_InfoNR_r15NoSIB1_r15Ssb_SubcarrierOffset_r15,
    pub pdcch_config_sib1_r15: CGI_InfoNR_r15NoSIB1_r15Pdcch_ConfigSIB1_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CIOT_OptimisationPLMN_r13Up_CIoT_EPS_Optimisation_r13(pub u8);
impl CIOT_OptimisationPLMN_r13Up_CIoT_EPS_Optimisation_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CIOT_OptimisationPLMN_r13Cp_CIoT_EPS_Optimisation_r13(pub u8);
impl CIOT_OptimisationPLMN_r13Cp_CIoT_EPS_Optimisation_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CIOT_OptimisationPLMN_r13AttachWithoutPDN_Connectivity_r13(pub u8);
impl CIOT_OptimisationPLMN_r13AttachWithoutPDN_Connectivity_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CQI_ReportAperiodic_r10_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct CQI_ReportAperiodic_r10_setupAperiodicCSI_Trigger_r10Trigger1_r10(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct CQI_ReportAperiodic_r10_setupAperiodicCSI_Trigger_r10Trigger2_r10(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CQI_ReportAperiodic_r10_setupAperiodicCSI_Trigger_r10 {
    pub trigger1_r10: CQI_ReportAperiodic_r10_setupAperiodicCSI_Trigger_r10Trigger1_r10,
    pub trigger2_r10: CQI_ReportAperiodic_r10_setupAperiodicCSI_Trigger_r10Trigger2_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CQI_ReportAperiodic_r10_setup {
    pub cqi_report_mode_aperiodic_r10: CQI_ReportModeAperiodic,
    #[asn(optional_idx = 0)]
    pub aperiodic_csi_trigger_r10: Option<CQI_ReportAperiodic_r10_setupAperiodicCSI_Trigger_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CQI_ReportAperiodic_v1250_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct CQI_ReportAperiodic_v1250_setupAperiodicCSI_Trigger_v1250Trigger_SubframeSetIndicator_r12(
    pub u8,
);
impl CQI_ReportAperiodic_v1250_setupAperiodicCSI_Trigger_v1250Trigger_SubframeSetIndicator_r12 {
    pub const S1: u8 = 0u8;
    pub const S2: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct CQI_ReportAperiodic_v1250_setupAperiodicCSI_Trigger_v1250Trigger1_SubframeSetIndicator_r12(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct CQI_ReportAperiodic_v1250_setupAperiodicCSI_Trigger_v1250Trigger2_SubframeSetIndicator_r12(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CQI_ReportAperiodic_v1250_setupAperiodicCSI_Trigger_v1250 {
    pub trigger_subframe_set_indicator_r12:
        CQI_ReportAperiodic_v1250_setupAperiodicCSI_Trigger_v1250Trigger_SubframeSetIndicator_r12,
    pub trigger1_subframe_set_indicator_r12:
        CQI_ReportAperiodic_v1250_setupAperiodicCSI_Trigger_v1250Trigger1_SubframeSetIndicator_r12,
    pub trigger2_subframe_set_indicator_r12:
        CQI_ReportAperiodic_v1250_setupAperiodicCSI_Trigger_v1250Trigger2_SubframeSetIndicator_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CQI_ReportAperiodic_v1250_setup {
    pub aperiodic_csi_trigger_v1250: CQI_ReportAperiodic_v1250_setupAperiodicCSI_Trigger_v1250,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CQI_ReportAperiodic_v1310_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger_v1310Trigger1_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger_v1310Trigger2_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger_v1310Trigger3_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger_v1310Trigger4_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger_v1310Trigger5_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger_v1310Trigger6_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger_v1310 {
    pub trigger1_r13: CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger_v1310Trigger1_r13,
    pub trigger2_r13: CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger_v1310Trigger2_r13,
    pub trigger3_r13: CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger_v1310Trigger3_r13,
    pub trigger4_r13: CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger_v1310Trigger4_r13,
    pub trigger5_r13: CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger_v1310Trigger5_r13,
    pub trigger6_r13: CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger_v1310Trigger6_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger2_r13_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger2_r13_setupTrigger1_SubframeSetIndicator_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger2_r13_setupTrigger2_SubframeSetIndicator_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger2_r13_setupTrigger3_SubframeSetIndicator_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger2_r13_setupTrigger4_SubframeSetIndicator_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger2_r13_setupTrigger5_SubframeSetIndicator_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger2_r13_setupTrigger6_SubframeSetIndicator_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger2_r13_setup { pub trigger1_subframe_set_indicator_r13 : CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger2_r13_setupTrigger1_SubframeSetIndicator_r13 , pub trigger2_subframe_set_indicator_r13 : CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger2_r13_setupTrigger2_SubframeSetIndicator_r13 , pub trigger3_subframe_set_indicator_r13 : CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger2_r13_setupTrigger3_SubframeSetIndicator_r13 , pub trigger4_subframe_set_indicator_r13 : CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger2_r13_setupTrigger4_SubframeSetIndicator_r13 , pub trigger5_subframe_set_indicator_r13 : CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger2_r13_setupTrigger5_SubframeSetIndicator_r13 , pub trigger6_subframe_set_indicator_r13 : CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger2_r13_setupTrigger6_SubframeSetIndicator_r13 , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger2_r13 {
    #[asn(key = 0, extended = false)]
    Release(CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger2_r13_release),
    #[asn(key = 1, extended = false)]
    Setup(CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger2_r13_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CQI_ReportAperiodic_v1310_setup {
    #[asn(optional_idx = 0)]
    pub aperiodic_csi_trigger_v1310:
        Option<CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger_v1310>,
    #[asn(optional_idx = 1)]
    pub aperiodic_csi_trigger2_r13:
        Option<CQI_ReportAperiodic_v1310_setupAperiodicCSI_Trigger2_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct CQI_ReportAperiodicHybrid_r14Triggers_r14_oneBit_r14Trigger1_Indicator_r14(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CQI_ReportAperiodicHybrid_r14Triggers_r14_oneBit_r14 {
    pub trigger1_indicator_r14:
        CQI_ReportAperiodicHybrid_r14Triggers_r14_oneBit_r14Trigger1_Indicator_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct CQI_ReportAperiodicHybrid_r14Triggers_r14_twoBit_r14Trigger01_Indicator_r14(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct CQI_ReportAperiodicHybrid_r14Triggers_r14_twoBit_r14Trigger10_Indicator_r14(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct CQI_ReportAperiodicHybrid_r14Triggers_r14_twoBit_r14Trigger11_Indicator_r14(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CQI_ReportAperiodicHybrid_r14Triggers_r14_twoBit_r14 {
    pub trigger01_indicator_r14:
        CQI_ReportAperiodicHybrid_r14Triggers_r14_twoBit_r14Trigger01_Indicator_r14,
    pub trigger10_indicator_r14:
        CQI_ReportAperiodicHybrid_r14Triggers_r14_twoBit_r14Trigger10_Indicator_r14,
    pub trigger11_indicator_r14:
        CQI_ReportAperiodicHybrid_r14Triggers_r14_twoBit_r14Trigger11_Indicator_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct CQI_ReportAperiodicHybrid_r14Triggers_r14_threeBit_r14Trigger001_Indicator_r14(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct CQI_ReportAperiodicHybrid_r14Triggers_r14_threeBit_r14Trigger010_Indicator_r14(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct CQI_ReportAperiodicHybrid_r14Triggers_r14_threeBit_r14Trigger011_Indicator_r14(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct CQI_ReportAperiodicHybrid_r14Triggers_r14_threeBit_r14Trigger100_Indicator_r14(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct CQI_ReportAperiodicHybrid_r14Triggers_r14_threeBit_r14Trigger101_Indicator_r14(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct CQI_ReportAperiodicHybrid_r14Triggers_r14_threeBit_r14Trigger110_Indicator_r14(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct CQI_ReportAperiodicHybrid_r14Triggers_r14_threeBit_r14Trigger111_Indicator_r14(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CQI_ReportAperiodicHybrid_r14Triggers_r14_threeBit_r14 {
    pub trigger001_indicator_r14:
        CQI_ReportAperiodicHybrid_r14Triggers_r14_threeBit_r14Trigger001_Indicator_r14,
    pub trigger010_indicator_r14:
        CQI_ReportAperiodicHybrid_r14Triggers_r14_threeBit_r14Trigger010_Indicator_r14,
    pub trigger011_indicator_r14:
        CQI_ReportAperiodicHybrid_r14Triggers_r14_threeBit_r14Trigger011_Indicator_r14,
    pub trigger100_indicator_r14:
        CQI_ReportAperiodicHybrid_r14Triggers_r14_threeBit_r14Trigger100_Indicator_r14,
    pub trigger101_indicator_r14:
        CQI_ReportAperiodicHybrid_r14Triggers_r14_threeBit_r14Trigger101_Indicator_r14,
    pub trigger110_indicator_r14:
        CQI_ReportAperiodicHybrid_r14Triggers_r14_threeBit_r14Trigger110_Indicator_r14,
    pub trigger111_indicator_r14:
        CQI_ReportAperiodicHybrid_r14Triggers_r14_threeBit_r14Trigger111_Indicator_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum CQI_ReportAperiodicHybrid_r14Triggers_r14 {
    #[asn(key = 0, extended = false)]
    OneBit_r14(CQI_ReportAperiodicHybrid_r14Triggers_r14_oneBit_r14),
    #[asn(key = 1, extended = false)]
    TwoBit_r14(CQI_ReportAperiodicHybrid_r14Triggers_r14_twoBit_r14),
    #[asn(key = 2, extended = false)]
    ThreeBit_r14(CQI_ReportAperiodicHybrid_r14Triggers_r14_threeBit_r14),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct CQI_ReportAperiodicProc_r11Trigger01_r11(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct CQI_ReportAperiodicProc_r11Trigger10_r11(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct CQI_ReportAperiodicProc_r11Trigger11_r11(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct CQI_ReportAperiodicProc_v1310Trigger001_r13(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct CQI_ReportAperiodicProc_v1310Trigger010_r13(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct CQI_ReportAperiodicProc_v1310Trigger011_r13(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct CQI_ReportAperiodicProc_v1310Trigger100_r13(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct CQI_ReportAperiodicProc_v1310Trigger101_r13(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct CQI_ReportAperiodicProc_v1310Trigger110_r13(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct CQI_ReportAperiodicProc_v1310Trigger111_r13(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CQI_ReportBothProc_r11Pmi_RI_Report_r11(pub u8);
impl CQI_ReportBothProc_r11Pmi_RI_Report_r11 {
    pub const SETUP: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-1", ub = "6")]
pub struct CQI_ReportConfigNomPDSCH_RS_EPRE_Offset(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-1", ub = "6")]
pub struct CQI_ReportConfig_r10NomPDSCH_RS_EPRE_Offset(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CQI_ReportConfig_r10Pmi_RI_Report_r9(pub u8);
impl CQI_ReportConfig_r10Pmi_RI_Report_r9 {
    pub const SETUP: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CQI_ReportConfig_r10Csi_SubframePatternConfig_r10_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CQI_ReportConfig_r10Csi_SubframePatternConfig_r10_setup {
    pub csi_meas_subframe_set1_r10: MeasSubframePattern_r10,
    pub csi_meas_subframe_set2_r10: MeasSubframePattern_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CQI_ReportConfig_r10Csi_SubframePatternConfig_r10 {
    #[asn(key = 0, extended = false)]
    Release(CQI_ReportConfig_r10Csi_SubframePatternConfig_r10_release),
    #[asn(key = 1, extended = false)]
    Setup(CQI_ReportConfig_r10Csi_SubframePatternConfig_r10_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CQI_ReportConfig_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct CQI_ReportConfig_r15_setupAltCQI_Table_1024QAM_r15(pub u8);
impl CQI_ReportConfig_r15_setupAltCQI_Table_1024QAM_r15 {
    pub const ALL_SUBFRAMES: u8 = 0u8;
    pub const CSI_SUBFRAME_SET1: u8 = 1u8;
    pub const CSI_SUBFRAME_SET2: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 7)]
pub struct CQI_ReportConfig_r15_setup {
    #[asn(optional_idx = 0)]
    pub cqi_report_config_r10: Option<CQI_ReportConfig_r10>,
    #[asn(optional_idx = 1)]
    pub cqi_report_config_v1130: Option<CQI_ReportConfig_v1130>,
    #[asn(optional_idx = 2)]
    pub cqi_report_config_p_cell_v1250: Option<CQI_ReportConfig_v1250>,
    #[asn(optional_idx = 3)]
    pub cqi_report_config_v1310: Option<CQI_ReportConfig_v1310>,
    #[asn(optional_idx = 4)]
    pub cqi_report_config_v1320: Option<CQI_ReportConfig_v1320>,
    #[asn(optional_idx = 5)]
    pub cqi_report_config_v1430: Option<CQI_ReportConfig_v1430>,
    #[asn(optional_idx = 6)]
    pub alt_cqi_table_1024qam_r15: Option<CQI_ReportConfig_r15_setupAltCQI_Table_1024QAM_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CQI_ReportConfig_v1250Csi_SubframePatternConfig_r12_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "10", sz_ub = "10")]
pub struct CQI_ReportConfig_v1250Csi_SubframePatternConfig_r12_setupCsi_MeasSubframeSets_r12(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CQI_ReportConfig_v1250Csi_SubframePatternConfig_r12_setup {
    pub csi_meas_subframe_sets_r12:
        CQI_ReportConfig_v1250Csi_SubframePatternConfig_r12_setupCsi_MeasSubframeSets_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CQI_ReportConfig_v1250Csi_SubframePatternConfig_r12 {
    #[asn(key = 0, extended = false)]
    Release(CQI_ReportConfig_v1250Csi_SubframePatternConfig_r12_release),
    #[asn(key = 1, extended = false)]
    Setup(CQI_ReportConfig_v1250Csi_SubframePatternConfig_r12_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct CQI_ReportConfig_v1250AltCQI_Table_r12(pub u8);
impl CQI_ReportConfig_v1250AltCQI_Table_r12 {
    pub const ALL_SUBFRAMES: u8 = 0u8;
    pub const CSI_SUBFRAME_SET1: u8 = 1u8;
    pub const CSI_SUBFRAME_SET2: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct CQI_ReportConfig_v1530AltCQI_Table_1024QAM_r15(pub u8);
impl CQI_ReportConfig_v1530AltCQI_Table_1024QAM_r15 {
    pub const ALL_SUBFRAMES: u8 = 0u8;
    pub const CSI_SUBFRAME_SET1: u8 = 1u8;
    pub const CSI_SUBFRAME_SET2: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CQI_ReportConfig_v920Cqi_Mask_r9(pub u8);
impl CQI_ReportConfig_v920Cqi_Mask_r9 {
    pub const SETUP: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CQI_ReportConfig_v920Pmi_RI_Report_r9(pub u8);
impl CQI_ReportConfig_v920Pmi_RI_Report_r9 {
    pub const SETUP: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-1", ub = "6")]
pub struct CQI_ReportConfigSCell_r10NomPDSCH_RS_EPRE_Offset_r10(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CQI_ReportConfigSCell_r10Pmi_RI_Report_r10(pub u8);
impl CQI_ReportConfigSCell_r10Pmi_RI_Report_r10 {
    pub const SETUP: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct CQI_ReportConfigSCell_r15AltCQI_Table_1024QAM_r15(pub u8);
impl CQI_ReportConfigSCell_r15AltCQI_Table_1024QAM_r15 {
    pub const ALL_SUBFRAMES: u8 = 0u8;
    pub const CSI_SUBFRAME_SET1: u8 = 1u8;
    pub const CSI_SUBFRAME_SET2: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CQI_ReportPeriodic_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1185")]
pub struct CQI_ReportPeriodic_setupCqi_PUCCH_ResourceIndex(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct CQI_ReportPeriodic_setupCqi_pmi_ConfigIndex(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CQI_ReportPeriodic_setupCqi_FormatIndicatorPeriodic_widebandCQI;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4")]
pub struct CQI_ReportPeriodic_setupCqi_FormatIndicatorPeriodic_subbandCQIK(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CQI_ReportPeriodic_setupCqi_FormatIndicatorPeriodic_subbandCQI {
    pub k: CQI_ReportPeriodic_setupCqi_FormatIndicatorPeriodic_subbandCQIK,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CQI_ReportPeriodic_setupCqi_FormatIndicatorPeriodic {
    #[asn(key = 0, extended = false)]
    WidebandCQI(CQI_ReportPeriodic_setupCqi_FormatIndicatorPeriodic_widebandCQI),
    #[asn(key = 1, extended = false)]
    SubbandCQI(CQI_ReportPeriodic_setupCqi_FormatIndicatorPeriodic_subbandCQI),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct CQI_ReportPeriodic_setupRi_ConfigIndex(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct CQI_ReportPeriodic_setupSimultaneousAckNackAndCQI(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CQI_ReportPeriodic_setup {
    pub cqi_pucch_resource_index: CQI_ReportPeriodic_setupCqi_PUCCH_ResourceIndex,
    pub cqi_pmi_config_index: CQI_ReportPeriodic_setupCqi_pmi_ConfigIndex,
    pub cqi_format_indicator_periodic: CQI_ReportPeriodic_setupCqi_FormatIndicatorPeriodic,
    #[asn(optional_idx = 0)]
    pub ri_config_index: Option<CQI_ReportPeriodic_setupRi_ConfigIndex>,
    pub simultaneous_ack_nack_and_cqi: CQI_ReportPeriodic_setupSimultaneousAckNackAndCQI,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CQI_ReportPeriodic_r10_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1184")]
pub struct CQI_ReportPeriodic_r10_setupCqi_PUCCH_ResourceIndex_r10(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1184")]
pub struct CQI_ReportPeriodic_r10_setupCqi_PUCCH_ResourceIndexP1_r10(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct CQI_ReportPeriodic_r10_setupCqi_pmi_ConfigIndex(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct CQI_ReportPeriodic_r10_setupCqi_FormatIndicatorPeriodic_r10_widebandCQI_r10Csi_ReportMode_r10(
    pub u8,
);
impl CQI_ReportPeriodic_r10_setupCqi_FormatIndicatorPeriodic_r10_widebandCQI_r10Csi_ReportMode_r10 {
    pub const SUBMODE1: u8 = 0u8;
    pub const SUBMODE2: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CQI_ReportPeriodic_r10_setupCqi_FormatIndicatorPeriodic_r10_widebandCQI_r10 { # [asn (optional_idx = 0 ,)] pub csi_report_mode_r10 : Option < CQI_ReportPeriodic_r10_setupCqi_FormatIndicatorPeriodic_r10_widebandCQI_r10Csi_ReportMode_r10 > , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4")]
pub struct CQI_ReportPeriodic_r10_setupCqi_FormatIndicatorPeriodic_r10_subbandCQI_r10K(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct CQI_ReportPeriodic_r10_setupCqi_FormatIndicatorPeriodic_r10_subbandCQI_r10PeriodicityFactor_r10(
    pub u8,
);
impl
    CQI_ReportPeriodic_r10_setupCqi_FormatIndicatorPeriodic_r10_subbandCQI_r10PeriodicityFactor_r10
{
    pub const N2: u8 = 0u8;
    pub const N4: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CQI_ReportPeriodic_r10_setupCqi_FormatIndicatorPeriodic_r10_subbandCQI_r10 { pub k : CQI_ReportPeriodic_r10_setupCqi_FormatIndicatorPeriodic_r10_subbandCQI_r10K , pub periodicity_factor_r10 : CQI_ReportPeriodic_r10_setupCqi_FormatIndicatorPeriodic_r10_subbandCQI_r10PeriodicityFactor_r10 , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CQI_ReportPeriodic_r10_setupCqi_FormatIndicatorPeriodic_r10 {
    #[asn(key = 0, extended = false)]
    WidebandCQI_r10(CQI_ReportPeriodic_r10_setupCqi_FormatIndicatorPeriodic_r10_widebandCQI_r10),
    #[asn(key = 1, extended = false)]
    SubbandCQI_r10(CQI_ReportPeriodic_r10_setupCqi_FormatIndicatorPeriodic_r10_subbandCQI_r10),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct CQI_ReportPeriodic_r10_setupRi_ConfigIndex(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct CQI_ReportPeriodic_r10_setupSimultaneousAckNackAndCQI(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CQI_ReportPeriodic_r10_setupCqi_Mask_r9(pub u8);
impl CQI_ReportPeriodic_r10_setupCqi_Mask_r9 {
    pub const SETUP: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CQI_ReportPeriodic_r10_setupCsi_ConfigIndex_r10_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct CQI_ReportPeriodic_r10_setupCsi_ConfigIndex_r10_setupCqi_pmi_ConfigIndex2_r10(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct CQI_ReportPeriodic_r10_setupCsi_ConfigIndex_r10_setupRi_ConfigIndex2_r10(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CQI_ReportPeriodic_r10_setupCsi_ConfigIndex_r10_setup {
    pub cqi_pmi_config_index2_r10:
        CQI_ReportPeriodic_r10_setupCsi_ConfigIndex_r10_setupCqi_pmi_ConfigIndex2_r10,
    #[asn(optional_idx = 0)]
    pub ri_config_index2_r10:
        Option<CQI_ReportPeriodic_r10_setupCsi_ConfigIndex_r10_setupRi_ConfigIndex2_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CQI_ReportPeriodic_r10_setupCsi_ConfigIndex_r10 {
    #[asn(key = 0, extended = false)]
    Release(CQI_ReportPeriodic_r10_setupCsi_ConfigIndex_r10_release),
    #[asn(key = 1, extended = false)]
    Setup(CQI_ReportPeriodic_r10_setupCsi_ConfigIndex_r10_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct CQI_ReportPeriodic_r10_setup {
    pub cqi_pucch_resource_index_r10: CQI_ReportPeriodic_r10_setupCqi_PUCCH_ResourceIndex_r10,
    #[asn(optional_idx = 0)]
    pub cqi_pucch_resource_index_p1_r10:
        Option<CQI_ReportPeriodic_r10_setupCqi_PUCCH_ResourceIndexP1_r10>,
    pub cqi_pmi_config_index: CQI_ReportPeriodic_r10_setupCqi_pmi_ConfigIndex,
    pub cqi_format_indicator_periodic_r10:
        CQI_ReportPeriodic_r10_setupCqi_FormatIndicatorPeriodic_r10,
    #[asn(optional_idx = 1)]
    pub ri_config_index: Option<CQI_ReportPeriodic_r10_setupRi_ConfigIndex>,
    pub simultaneous_ack_nack_and_cqi: CQI_ReportPeriodic_r10_setupSimultaneousAckNackAndCQI,
    #[asn(optional_idx = 2)]
    pub cqi_mask_r9: Option<CQI_ReportPeriodic_r10_setupCqi_Mask_r9>,
    #[asn(optional_idx = 3)]
    pub csi_config_index_r10: Option<CQI_ReportPeriodic_r10_setupCsi_ConfigIndex_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CQI_ReportPeriodic_v1130SimultaneousAckNackAndCQI_Format3_r11(pub u8);
impl CQI_ReportPeriodic_v1130SimultaneousAckNackAndCQI_Format3_r11 {
    pub const SETUP: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CQI_ReportPeriodic_v1310SimultaneousAckNackAndCQI_Format4_Format5_r13(pub u8);
impl CQI_ReportPeriodic_v1310SimultaneousAckNackAndCQI_Format4_Format5_r13 {
    pub const SETUP: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct CQI_ReportPeriodic_v1320PeriodicityFactorWB_r13(pub u8);
impl CQI_ReportPeriodic_v1320PeriodicityFactorWB_r13 {
    pub const N2: u8 = 0u8;
    pub const N4: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct CQI_ReportPeriodicProcExt_r11Cqi_pmi_ConfigIndex_r11(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct CQI_ReportPeriodicProcExt_r11Cqi_FormatIndicatorPeriodic_r11_widebandCQI_r11Csi_ReportMode_r11(
    pub u8,
);
impl
    CQI_ReportPeriodicProcExt_r11Cqi_FormatIndicatorPeriodic_r11_widebandCQI_r11Csi_ReportMode_r11
{
    pub const SUBMODE1: u8 = 0u8;
    pub const SUBMODE2: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CQI_ReportPeriodicProcExt_r11Cqi_FormatIndicatorPeriodic_r11_widebandCQI_r11 { # [asn (optional_idx = 0 ,)] pub csi_report_mode_r11 : Option < CQI_ReportPeriodicProcExt_r11Cqi_FormatIndicatorPeriodic_r11_widebandCQI_r11Csi_ReportMode_r11 > , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4")]
pub struct CQI_ReportPeriodicProcExt_r11Cqi_FormatIndicatorPeriodic_r11_subbandCQI_r11K(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct CQI_ReportPeriodicProcExt_r11Cqi_FormatIndicatorPeriodic_r11_subbandCQI_r11PeriodicityFactor_r11(
    pub u8,
);
impl
    CQI_ReportPeriodicProcExt_r11Cqi_FormatIndicatorPeriodic_r11_subbandCQI_r11PeriodicityFactor_r11
{
    pub const N2: u8 = 0u8;
    pub const N4: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CQI_ReportPeriodicProcExt_r11Cqi_FormatIndicatorPeriodic_r11_subbandCQI_r11 { pub k : CQI_ReportPeriodicProcExt_r11Cqi_FormatIndicatorPeriodic_r11_subbandCQI_r11K , pub periodicity_factor_r11 : CQI_ReportPeriodicProcExt_r11Cqi_FormatIndicatorPeriodic_r11_subbandCQI_r11PeriodicityFactor_r11 , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CQI_ReportPeriodicProcExt_r11Cqi_FormatIndicatorPeriodic_r11 {
    #[asn(key = 0, extended = false)]
    WidebandCQI_r11(CQI_ReportPeriodicProcExt_r11Cqi_FormatIndicatorPeriodic_r11_widebandCQI_r11),
    #[asn(key = 1, extended = false)]
    SubbandCQI_r11(CQI_ReportPeriodicProcExt_r11Cqi_FormatIndicatorPeriodic_r11_subbandCQI_r11),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct CQI_ReportPeriodicProcExt_r11Ri_ConfigIndex_r11(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CQI_ReportPeriodicProcExt_r11Csi_ConfigIndex_r11_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct CQI_ReportPeriodicProcExt_r11Csi_ConfigIndex_r11_setupCqi_pmi_ConfigIndex2_r11(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct CQI_ReportPeriodicProcExt_r11Csi_ConfigIndex_r11_setupRi_ConfigIndex2_r11(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CQI_ReportPeriodicProcExt_r11Csi_ConfigIndex_r11_setup {
    pub cqi_pmi_config_index2_r11:
        CQI_ReportPeriodicProcExt_r11Csi_ConfigIndex_r11_setupCqi_pmi_ConfigIndex2_r11,
    #[asn(optional_idx = 0)]
    pub ri_config_index2_r11:
        Option<CQI_ReportPeriodicProcExt_r11Csi_ConfigIndex_r11_setupRi_ConfigIndex2_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CQI_ReportPeriodicProcExt_r11Csi_ConfigIndex_r11 {
    #[asn(key = 0, extended = false)]
    Release(CQI_ReportPeriodicProcExt_r11Csi_ConfigIndex_r11_release),
    #[asn(key = 1, extended = false)]
    Setup(CQI_ReportPeriodicProcExt_r11Csi_ConfigIndex_r11_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CQI_ReportPeriodicSCell_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct CQI_ReportPeriodicSCell_r15_setupCqi_pmi_ConfigIndexDormant_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct CQI_ReportPeriodicSCell_r15_setupRi_ConfigIndexDormant_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CQI_ReportPeriodicSCell_r15_setupCsi_SubframePatternDormant_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CQI_ReportPeriodicSCell_r15_setupCsi_SubframePatternDormant_r15_setup {
    pub csi_meas_subframe_set1_r15: MeasSubframePattern_r10,
    pub csi_meas_subframe_set2_r15: MeasSubframePattern_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CQI_ReportPeriodicSCell_r15_setupCsi_SubframePatternDormant_r15 {
    #[asn(key = 0, extended = false)]
    Release(CQI_ReportPeriodicSCell_r15_setupCsi_SubframePatternDormant_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(CQI_ReportPeriodicSCell_r15_setupCsi_SubframePatternDormant_r15_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct CQI_ReportPeriodicSCell_r15_setupCqi_FormatIndicatorDormant_r15_widebandCQI_r15Csi_ReportMode_r15(
    pub u8,
);
impl CQI_ReportPeriodicSCell_r15_setupCqi_FormatIndicatorDormant_r15_widebandCQI_r15Csi_ReportMode_r15 { pub const SUBMODE1 : u8 = 0u8 ; pub const SUBMODE2 : u8 = 1u8 ; }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CQI_ReportPeriodicSCell_r15_setupCqi_FormatIndicatorDormant_r15_widebandCQI_r15 { # [asn (optional_idx = 0 ,)] pub csi_report_mode_r15 : Option < CQI_ReportPeriodicSCell_r15_setupCqi_FormatIndicatorDormant_r15_widebandCQI_r15Csi_ReportMode_r15 > , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4")]
pub struct CQI_ReportPeriodicSCell_r15_setupCqi_FormatIndicatorDormant_r15_subbandCQI_r15K_r15(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct CQI_ReportPeriodicSCell_r15_setupCqi_FormatIndicatorDormant_r15_subbandCQI_r15PeriodicityFactor_r15(
    pub u8,
);
impl CQI_ReportPeriodicSCell_r15_setupCqi_FormatIndicatorDormant_r15_subbandCQI_r15PeriodicityFactor_r15 { pub const N2 : u8 = 0u8 ; pub const N4 : u8 = 1u8 ; }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CQI_ReportPeriodicSCell_r15_setupCqi_FormatIndicatorDormant_r15_subbandCQI_r15 { pub k_r15 : CQI_ReportPeriodicSCell_r15_setupCqi_FormatIndicatorDormant_r15_subbandCQI_r15K_r15 , pub periodicity_factor_r15 : CQI_ReportPeriodicSCell_r15_setupCqi_FormatIndicatorDormant_r15_subbandCQI_r15PeriodicityFactor_r15 , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CQI_ReportPeriodicSCell_r15_setupCqi_FormatIndicatorDormant_r15 {
    #[asn(key = 0, extended = false)]
    WidebandCQI_r15(
        CQI_ReportPeriodicSCell_r15_setupCqi_FormatIndicatorDormant_r15_widebandCQI_r15,
    ),
    #[asn(key = 1, extended = false)]
    SubbandCQI_r15(CQI_ReportPeriodicSCell_r15_setupCqi_FormatIndicatorDormant_r15_subbandCQI_r15),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct CQI_ReportPeriodicSCell_r15_setup {
    pub cqi_pmi_config_index_dormant_r15:
        CQI_ReportPeriodicSCell_r15_setupCqi_pmi_ConfigIndexDormant_r15,
    #[asn(optional_idx = 0)]
    pub ri_config_index_dormant_r15:
        Option<CQI_ReportPeriodicSCell_r15_setupRi_ConfigIndexDormant_r15>,
    #[asn(optional_idx = 1)]
    pub csi_subframe_pattern_dormant_r15:
        Option<CQI_ReportPeriodicSCell_r15_setupCsi_SubframePatternDormant_r15>,
    #[asn(optional_idx = 2)]
    pub cqi_format_indicator_dormant_r15:
        Option<CQI_ReportPeriodicSCell_r15_setupCqi_FormatIndicatorDormant_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct CQI_ReportPeriodicSCell_v1730Cqi_pmi_ConfigIndex2Dormant_r17(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct CQI_ReportPeriodicSCell_v1730Ri_ConfigIndex2Dormant_r17(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CQI_ShortConfigSCell_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct CQI_ShortConfigSCell_r15_setupCqi_pmi_ConfigIndexShort_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct CQI_ShortConfigSCell_r15_setupRi_ConfigIndexShort_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct CQI_ShortConfigSCell_r15_setupCqi_FormatIndicatorShort_r15_widebandCQI_Short_r15Csi_ReportModeShort_r15(
    pub u8,
);
impl CQI_ShortConfigSCell_r15_setupCqi_FormatIndicatorShort_r15_widebandCQI_Short_r15Csi_ReportModeShort_r15 { pub const SUBMODE1 : u8 = 0u8 ; pub const SUBMODE2 : u8 = 1u8 ; }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CQI_ShortConfigSCell_r15_setupCqi_FormatIndicatorShort_r15_widebandCQI_Short_r15 { # [asn (optional_idx = 0 ,)] pub csi_report_mode_short_r15 : Option < CQI_ShortConfigSCell_r15_setupCqi_FormatIndicatorShort_r15_widebandCQI_Short_r15Csi_ReportModeShort_r15 > , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4")]
pub struct CQI_ShortConfigSCell_r15_setupCqi_FormatIndicatorShort_r15_subbandCQI_Short_r15K_r15(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct CQI_ShortConfigSCell_r15_setupCqi_FormatIndicatorShort_r15_subbandCQI_Short_r15PeriodicityFactor_r15(
    pub u8,
);
impl CQI_ShortConfigSCell_r15_setupCqi_FormatIndicatorShort_r15_subbandCQI_Short_r15PeriodicityFactor_r15 { pub const N2 : u8 = 0u8 ; pub const N4 : u8 = 1u8 ; }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CQI_ShortConfigSCell_r15_setupCqi_FormatIndicatorShort_r15_subbandCQI_Short_r15 { pub k_r15 : CQI_ShortConfigSCell_r15_setupCqi_FormatIndicatorShort_r15_subbandCQI_Short_r15K_r15 , pub periodicity_factor_r15 : CQI_ShortConfigSCell_r15_setupCqi_FormatIndicatorShort_r15_subbandCQI_Short_r15PeriodicityFactor_r15 , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CQI_ShortConfigSCell_r15_setupCqi_FormatIndicatorShort_r15 {
    #[asn(key = 0, extended = false)]
    WidebandCQI_Short_r15(
        CQI_ShortConfigSCell_r15_setupCqi_FormatIndicatorShort_r15_widebandCQI_Short_r15,
    ),
    #[asn(key = 1, extended = false)]
    SubbandCQI_Short_r15(
        CQI_ShortConfigSCell_r15_setupCqi_FormatIndicatorShort_r15_subbandCQI_Short_r15,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CQI_ShortConfigSCell_r15_setup {
    pub cqi_pmi_config_index_short_r15: CQI_ShortConfigSCell_r15_setupCqi_pmi_ConfigIndexShort_r15,
    #[asn(optional_idx = 0)]
    pub ri_config_index_short_r15: Option<CQI_ShortConfigSCell_r15_setupRi_ConfigIndexShort_r15>,
    #[asn(optional_idx = 1)]
    pub cqi_format_indicator_short_r15:
        Option<CQI_ShortConfigSCell_r15_setupCqi_FormatIndicatorShort_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CRI_ReportConfig_r13_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CRI_ReportConfig_r13_setup {
    pub cri_config_index_r13: CRI_ConfigIndex_r13,
    #[asn(optional_idx = 0)]
    pub cri_config_index2_r13: Option<CRI_ConfigIndex_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct CRS_AssistanceInfo_r11AntennaPortsCount_r11(pub u8);
impl CRS_AssistanceInfo_r11AntennaPortsCount_r11 {
    pub const AN1: u8 = 0u8;
    pub const AN2: u8 = 1u8;
    pub const AN4: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct CRS_AssistanceInfo_r13AntennaPortsCount_r13(pub u8);
impl CRS_AssistanceInfo_r13AntennaPortsCount_r13 {
    pub const AN1: u8 = 0u8;
    pub const AN2: u8 = 1u8;
    pub const AN4: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CRS_AssistanceInfo_r15Crs_IntfMitigEnabled_r15(pub u8);
impl CRS_AssistanceInfo_r15Crs_IntfMitigEnabled_r15 {
    pub const ENABLED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct CRS_ChEstMPDCCH_ConfigCommon_r16PowerRatio_r16(pub u8);
impl CRS_ChEstMPDCCH_ConfigCommon_r16PowerRatio_r16 {
    pub const D_B_4DOT77: u8 = 0u8;
    pub const D_B_3: u8 = 1u8;
    pub const D_B_1DOT77: u8 = 2u8;
    pub const D_B0: u8 = 3u8;
    pub const D_B1: u8 = 4u8;
    pub const D_B2: u8 = 5u8;
    pub const D_B3: u8 = 6u8;
    pub const D_B4DOT77: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct CRS_ChEstMPDCCH_ConfigDedicated_r16PowerRatio_r16(pub u8);
impl CRS_ChEstMPDCCH_ConfigDedicated_r16PowerRatio_r16 {
    pub const D_B_4DOT77: u8 = 0u8;
    pub const D_B_3: u8 = 1u8;
    pub const D_B_1DOT77: u8 = 2u8;
    pub const D_B0: u8 = 3u8;
    pub const D_B1: u8 = 4u8;
    pub const D_B2: u8 = 5u8;
    pub const D_B3: u8 = 6u8;
    pub const D_B4DOT77: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct CRS_ChEstMPDCCH_ConfigDedicated_r16LocalizedMappingType_r16(pub u8);
impl CRS_ChEstMPDCCH_ConfigDedicated_r16LocalizedMappingType_r16 {
    pub const PREDEFINED: u8 = 0u8;
    pub const CSI_BASED: u8 = 1u8;
    pub const RECIPROCITY_BASED: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "15", sz_ub = "15")]
pub struct CSFB_RegistrationParam1XRTTSid(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct CSFB_RegistrationParam1XRTTNid(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct CSFB_RegistrationParam1XRTTMultipleSID(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct CSFB_RegistrationParam1XRTTMultipleNID(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct CSFB_RegistrationParam1XRTTHomeReg(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct CSFB_RegistrationParam1XRTTForeignSIDReg(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct CSFB_RegistrationParam1XRTTForeignNIDReg(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct CSFB_RegistrationParam1XRTTParameterReg(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct CSFB_RegistrationParam1XRTTPowerUpReg(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "7", sz_ub = "7")]
pub struct CSFB_RegistrationParam1XRTTRegistrationPeriod(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "12", sz_ub = "12")]
pub struct CSFB_RegistrationParam1XRTTRegistrationZone(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct CSFB_RegistrationParam1XRTTTotalZone(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct CSFB_RegistrationParam1XRTTZoneTimer(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CSFB_RegistrationParam1XRTT_v920PowerDownReg_r9(pub u8);
impl CSFB_RegistrationParam1XRTT_v920PowerDownReg_r9 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CSFBParametersRequestCDMA2000CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CSFBParametersRequestCDMA2000CriticalExtensions {
    #[asn(key = 0, extended = false)]
    CsfbParametersRequestCDMA2000_r8(CSFBParametersRequestCDMA2000_r8_IEs),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        CSFBParametersRequestCDMA2000CriticalExtensions_criticalExtensionsFuture,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct CSFBParametersRequestCDMA2000_v8a0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CSFBParametersRequestCDMA2000_v8a0_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CSFBParametersResponseCDMA2000CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CSFBParametersResponseCDMA2000CriticalExtensions {
    #[asn(key = 0, extended = false)]
    CsfbParametersResponseCDMA2000_r8(CSFBParametersResponseCDMA2000_r8_IEs),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        CSFBParametersResponseCDMA2000CriticalExtensions_criticalExtensionsFuture,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct CSFBParametersResponseCDMA2000_v8a0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CSFBParametersResponseCDMA2000_v8a0_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CSG_ProximityIndicationParameters_r9IntraFreqProximityIndication_r9(pub u8);
impl CSG_ProximityIndicationParameters_r9IntraFreqProximityIndication_r9 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CSG_ProximityIndicationParameters_r9InterFreqProximityIndication_r9(pub u8);
impl CSG_ProximityIndicationParameters_r9InterFreqProximityIndication_r9 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CSG_ProximityIndicationParameters_r9Utran_ProximityIndication_r9(pub u8);
impl CSG_ProximityIndicationParameters_r9Utran_ProximityIndication_r9 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct CSI_IM_Config_r11ResourceConfig_r11(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "154")]
pub struct CSI_IM_Config_r11SubframeConfig_r11(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct CSI_IM_ConfigExt_r12ResourceConfig_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "154")]
pub struct CSI_IM_ConfigExt_r12SubframeConfig_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct CSI_Process_r11Cqi_ReportPeriodicProcId_r11(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CSI_RS_Config_r10Csi_RS_r10_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct CSI_RS_Config_r10Csi_RS_r10_setupAntennaPortsCount_r10(pub u8);
impl CSI_RS_Config_r10Csi_RS_r10_setupAntennaPortsCount_r10 {
    pub const AN1: u8 = 0u8;
    pub const AN2: u8 = 1u8;
    pub const AN4: u8 = 2u8;
    pub const AN8: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct CSI_RS_Config_r10Csi_RS_r10_setupResourceConfig_r10(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "154")]
pub struct CSI_RS_Config_r10Csi_RS_r10_setupSubframeConfig_r10(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-8", ub = "15")]
pub struct CSI_RS_Config_r10Csi_RS_r10_setupP_C_r10(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CSI_RS_Config_r10Csi_RS_r10_setup {
    pub antenna_ports_count_r10: CSI_RS_Config_r10Csi_RS_r10_setupAntennaPortsCount_r10,
    pub resource_config_r10: CSI_RS_Config_r10Csi_RS_r10_setupResourceConfig_r10,
    pub subframe_config_r10: CSI_RS_Config_r10Csi_RS_r10_setupSubframeConfig_r10,
    pub p_c_r10: CSI_RS_Config_r10Csi_RS_r10_setupP_C_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CSI_RS_Config_r10Csi_RS_r10 {
    #[asn(key = 0, extended = false)]
    Release(CSI_RS_Config_r10Csi_RS_r10_release),
    #[asn(key = 1, extended = false)]
    Setup(CSI_RS_Config_r10Csi_RS_r10_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CSI_RS_Config_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct CSI_RS_Config_r15_setup {
    #[asn(optional_idx = 0)]
    pub csi_rs_config_r10: Option<CSI_RS_Config_r10>,
    #[asn(optional_idx = 1)]
    pub csi_rs_config_v1250: Option<CSI_RS_Config_v1250>,
    #[asn(optional_idx = 2)]
    pub csi_rs_config_v1310: Option<CSI_RS_Config_v1310>,
    #[asn(optional_idx = 3)]
    pub csi_rs_config_v1430: Option<CSI_RS_Config_v1430>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CSI_RS_Config_v1250Ds_ZeroTxPowerCSI_RS_r12_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "5")]
pub struct CSI_RS_Config_v1250Ds_ZeroTxPowerCSI_RS_r12_setupZeroTxPowerCSI_RS_List_r12(
    pub Vec<ZeroTxPowerCSI_RS_r12>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CSI_RS_Config_v1250Ds_ZeroTxPowerCSI_RS_r12_setup {
    pub zero_tx_power_csi_rs_list_r12:
        CSI_RS_Config_v1250Ds_ZeroTxPowerCSI_RS_r12_setupZeroTxPowerCSI_RS_List_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CSI_RS_Config_v1250Ds_ZeroTxPowerCSI_RS_r12 {
    #[asn(key = 0, extended = false)]
    Release(CSI_RS_Config_v1250Ds_ZeroTxPowerCSI_RS_r12_release),
    #[asn(key = 1, extended = false)]
    Setup(CSI_RS_Config_v1250Ds_ZeroTxPowerCSI_RS_r12_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct CSI_RS_Config_v1430AdvancedCodebookEnabled_r14(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "7")]
pub struct CSI_RS_ConfigBeamformed_r13Csi_RS_ConfigNZPIdListExt_r13(
    pub Vec<CSI_RS_ConfigNZPId_r13>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CSI_RS_ConfigBeamformed_r13Csi_IM_ConfigIdList_r13(pub Vec<CSI_IM_ConfigId_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CSI_RS_ConfigBeamformed_r13P_C_AndCBSR_PerResourceConfigList_r13(
    pub Vec<P_C_AndCBSR_Pair_r13>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct CSI_RS_ConfigBeamformed_r13Ace_For4Tx_PerResourceConfigList_r13_Entry(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "7")]
pub struct CSI_RS_ConfigBeamformed_r13Ace_For4Tx_PerResourceConfigList_r13(
    pub Vec<CSI_RS_ConfigBeamformed_r13Ace_For4Tx_PerResourceConfigList_r13_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CSI_RS_ConfigBeamformed_r13AlternativeCodebookEnabledBeamformed_r13(pub u8);
impl CSI_RS_ConfigBeamformed_r13AlternativeCodebookEnabledBeamformed_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CSI_RS_ConfigBeamformed_r13ChannelMeasRestriction_r13(pub u8);
impl CSI_RS_ConfigBeamformed_r13ChannelMeasRestriction_r13 {
    pub const ON: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "7")]
pub struct CSI_RS_ConfigBeamformed_r14Csi_RS_ConfigNZPIdListExt_r14(
    pub Vec<CSI_RS_ConfigNZPId_r13>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CSI_RS_ConfigBeamformed_r14Csi_IM_ConfigIdList_r14(pub Vec<CSI_IM_ConfigId_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CSI_RS_ConfigBeamformed_r14P_C_AndCBSR_PerResourceConfigList_r14(
    pub Vec<P_C_AndCBSR_Pair_r13>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct CSI_RS_ConfigBeamformed_r14Ace_For4Tx_PerResourceConfigList_r14_Entry(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "7")]
pub struct CSI_RS_ConfigBeamformed_r14Ace_For4Tx_PerResourceConfigList_r14(
    pub Vec<CSI_RS_ConfigBeamformed_r14Ace_For4Tx_PerResourceConfigList_r14_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CSI_RS_ConfigBeamformed_r14AlternativeCodebookEnabledBeamformed_r14(pub u8);
impl CSI_RS_ConfigBeamformed_r14AlternativeCodebookEnabledBeamformed_r14 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CSI_RS_ConfigBeamformed_r14ChannelMeasRestriction_r14(pub u8);
impl CSI_RS_ConfigBeamformed_r14ChannelMeasRestriction_r14 {
    pub const ON: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CSI_RS_ConfigBeamformed_r14Csi_RS_ConfigNZP_ApList_r14(pub Vec<CSI_RS_ConfigNZP_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CSI_RS_ConfigBeamformed_v1430Csi_RS_ConfigNZP_ApList_r14(pub Vec<CSI_RS_ConfigNZP_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CSI_RS_ConfigEMIMO_Hybrid_r14_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct CSI_RS_ConfigEMIMO_Hybrid_r14_setupPeriodicityOffsetIndex_r14(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CSI_RS_ConfigEMIMO_Hybrid_r14_setup {
    #[asn(optional_idx = 0)]
    pub periodicity_offset_index_r14:
        Option<CSI_RS_ConfigEMIMO_Hybrid_r14_setupPeriodicityOffsetIndex_r14>,
    #[asn(optional_idx = 1)]
    pub emimo_type2_r14: Option<CSI_RS_ConfigEMIMO2_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CSI_RS_ConfigEMIMO_r13_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CSI_RS_ConfigEMIMO_r13_setup {
    #[asn(key = 0, extended = false)]
    NonPrecoded_r13(CSI_RS_ConfigNonPrecoded_r13),
    #[asn(key = 1, extended = false)]
    Beamformed_r13(CSI_RS_ConfigBeamformed_r13),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CSI_RS_ConfigEMIMO_v1430_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CSI_RS_ConfigEMIMO_v1430_setup {
    #[asn(key = 0, extended = false)]
    NonPrecoded_v1430(CSI_RS_ConfigNonPrecoded_v1430),
    #[asn(key = 1, extended = false)]
    Beamformed_v1430(CSI_RS_ConfigBeamformed_v1430),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CSI_RS_ConfigEMIMO_v1480_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CSI_RS_ConfigEMIMO_v1480_setup {
    #[asn(key = 0, extended = false)]
    NonPrecoded_v1480(CSI_RS_ConfigNonPrecoded_v1480),
    #[asn(key = 1, extended = false)]
    Beamformed_v1480(CSI_RS_ConfigBeamformed_v1430),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CSI_RS_ConfigEMIMO_v1530_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = false)]
pub enum CSI_RS_ConfigEMIMO_v1530_setup {
    #[asn(key = 0, extended = false)]
    NonPrecoded_v1530(CSI_RS_ConfigNonPrecoded_v1530),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CSI_RS_ConfigEMIMO2_r14_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct CSI_RS_ConfigNZP_Activation_r14Csi_RS_NZP_mode_r14(pub u8);
impl CSI_RS_ConfigNZP_Activation_r14Csi_RS_NZP_mode_r14 {
    pub const SEMI_PERSISTENT: u8 = 0u8;
    pub const APERIODIC: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4")]
pub struct CSI_RS_ConfigNZP_Activation_r14ActivatedResources_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CSI_RS_ConfigNZP_EMIMO_r13_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct CSI_RS_ConfigNZP_EMIMO_r13_setupNzp_resourceConfigList_r13(
    pub Vec<NZP_ResourceConfig_r13>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct CSI_RS_ConfigNZP_EMIMO_r13_setupCdmType_r13(pub u8);
impl CSI_RS_ConfigNZP_EMIMO_r13_setupCdmType_r13 {
    pub const CDM2: u8 = 0u8;
    pub const CDM4: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CSI_RS_ConfigNZP_EMIMO_r13_setup {
    pub nzp_resource_config_list_r13: CSI_RS_ConfigNZP_EMIMO_r13_setupNzp_resourceConfigList_r13,
    #[asn(optional_idx = 0)]
    pub cdm_type_r13: Option<CSI_RS_ConfigNZP_EMIMO_r13_setupCdmType_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "0", sz_ub = "4")]
pub struct CSI_RS_ConfigNZP_EMIMO_v1430Nzp_resourceConfigListExt_r14(
    pub Vec<NZP_ResourceConfig_r13>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CSI_RS_ConfigNZP_EMIMO_v1430CdmType_v1430(pub u8);
impl CSI_RS_ConfigNZP_EMIMO_v1430CdmType_v1430 {
    pub const CDM8: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct CSI_RS_ConfigNZP_r11AntennaPortsCount_r11(pub u8);
impl CSI_RS_ConfigNZP_r11AntennaPortsCount_r11 {
    pub const AN1: u8 = 0u8;
    pub const AN2: u8 = 1u8;
    pub const AN4: u8 = 2u8;
    pub const AN8: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct CSI_RS_ConfigNZP_r11ResourceConfig_r11(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "154")]
pub struct CSI_RS_ConfigNZP_r11SubframeConfig_r11(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "503")]
pub struct CSI_RS_ConfigNZP_r11ScramblingIdentity_r11(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "503")]
pub struct CSI_RS_ConfigNZP_r11Qcl_CRS_Info_r11Qcl_ScramblingIdentity_r11(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct CSI_RS_ConfigNZP_r11Qcl_CRS_Info_r11Crs_PortsCount_r11(pub u8);
impl CSI_RS_ConfigNZP_r11Qcl_CRS_Info_r11Crs_PortsCount_r11 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N4: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CSI_RS_ConfigNZP_r11Qcl_CRS_Info_r11Mbsfn_SubframeConfigList_r11_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CSI_RS_ConfigNZP_r11Qcl_CRS_Info_r11Mbsfn_SubframeConfigList_r11_setup {
    pub subframe_config_list: MBSFN_SubframeConfigList,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CSI_RS_ConfigNZP_r11Qcl_CRS_Info_r11Mbsfn_SubframeConfigList_r11 {
    #[asn(key = 0, extended = false)]
    Release(CSI_RS_ConfigNZP_r11Qcl_CRS_Info_r11Mbsfn_SubframeConfigList_r11_release),
    #[asn(key = 1, extended = false)]
    Setup(CSI_RS_ConfigNZP_r11Qcl_CRS_Info_r11Mbsfn_SubframeConfigList_r11_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CSI_RS_ConfigNZP_r11Qcl_CRS_Info_r11 {
    pub qcl_scrambling_identity_r11: CSI_RS_ConfigNZP_r11Qcl_CRS_Info_r11Qcl_ScramblingIdentity_r11,
    pub crs_ports_count_r11: CSI_RS_ConfigNZP_r11Qcl_CRS_Info_r11Crs_PortsCount_r11,
    #[asn(optional_idx = 0)]
    pub mbsfn_subframe_config_list_r11:
        Option<CSI_RS_ConfigNZP_r11Qcl_CRS_Info_r11Mbsfn_SubframeConfigList_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "4")]
pub struct CSI_RS_ConfigNonPrecoded_r13CodebookConfigN1_r13(pub u8);
impl CSI_RS_ConfigNonPrecoded_r13CodebookConfigN1_r13 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N3: u8 = 2u8;
    pub const N4: u8 = 3u8;
    pub const N8: u8 = 4u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "4")]
pub struct CSI_RS_ConfigNonPrecoded_r13CodebookConfigN2_r13(pub u8);
impl CSI_RS_ConfigNonPrecoded_r13CodebookConfigN2_r13 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N3: u8 = 2u8;
    pub const N4: u8 = 3u8;
    pub const N8: u8 = 4u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct CSI_RS_ConfigNonPrecoded_r13CodebookOverSamplingRateConfig_O1_r13(pub u8);
impl CSI_RS_ConfigNonPrecoded_r13CodebookOverSamplingRateConfig_O1_r13 {
    pub const N4: u8 = 0u8;
    pub const N8: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct CSI_RS_ConfigNonPrecoded_r13CodebookOverSamplingRateConfig_O2_r13(pub u8);
impl CSI_RS_ConfigNonPrecoded_r13CodebookOverSamplingRateConfig_O2_r13 {
    pub const N4: u8 = 0u8;
    pub const N8: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4")]
pub struct CSI_RS_ConfigNonPrecoded_r13CodebookConfig_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct CSI_RS_ConfigNonPrecoded_r13Csi_IM_ConfigIdList_r13(pub Vec<CSI_IM_ConfigId_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "6")]
pub struct CSI_RS_ConfigNonPrecoded_v1430CodebookConfigN1_v1430(pub u8);
impl CSI_RS_ConfigNonPrecoded_v1430CodebookConfigN1_v1430 {
    pub const N5: u8 = 0u8;
    pub const N6: u8 = 1u8;
    pub const N7: u8 = 2u8;
    pub const N10: u8 = 3u8;
    pub const N12: u8 = 4u8;
    pub const N14: u8 = 5u8;
    pub const N16: u8 = 6u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct CSI_RS_ConfigNonPrecoded_v1430CodebookConfigN2_v1430(pub u8);
impl CSI_RS_ConfigNonPrecoded_v1430CodebookConfigN2_v1430 {
    pub const N5: u8 = 0u8;
    pub const N6: u8 = 1u8;
    pub const N7: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "6")]
pub struct CSI_RS_ConfigNonPrecoded_v1480CodebookConfigN1_v1480(pub u8);
impl CSI_RS_ConfigNonPrecoded_v1480CodebookConfigN1_v1480 {
    pub const N5: u8 = 0u8;
    pub const N6: u8 = 1u8;
    pub const N7: u8 = 2u8;
    pub const N10: u8 = 3u8;
    pub const N12: u8 = 4u8;
    pub const N14: u8 = 5u8;
    pub const N16: u8 = 6u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct CSI_RS_ConfigNonPrecoded_v1480CodebookConfigN2_r1480(pub u8);
impl CSI_RS_ConfigNonPrecoded_v1480CodebookConfigN2_r1480 {
    pub const N5: u8 = 0u8;
    pub const N6: u8 = 1u8;
    pub const N7: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CSI_RS_ConfigZP_ApList_r14_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct CSI_RS_ConfigZP_ApList_r14_setup(pub Vec<CSI_RS_ConfigZP_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct CSI_RS_ConfigZP_r11ResourceConfigList_r11(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "154")]
pub struct CSI_RS_ConfigZP_r11SubframeConfig_r11(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct CarrierBandwidthEUTRADl_Bandwidth(pub u8);
impl CarrierBandwidthEUTRADl_Bandwidth {
    pub const N6: u8 = 0u8;
    pub const N15: u8 = 1u8;
    pub const N25: u8 = 2u8;
    pub const N50: u8 = 3u8;
    pub const N75: u8 = 4u8;
    pub const N100: u8 = 5u8;
    pub const SPARE10: u8 = 6u8;
    pub const SPARE9: u8 = 7u8;
    pub const SPARE8: u8 = 8u8;
    pub const SPARE7: u8 = 9u8;
    pub const SPARE6: u8 = 10u8;
    pub const SPARE5: u8 = 11u8;
    pub const SPARE4: u8 = 12u8;
    pub const SPARE3: u8 = 13u8;
    pub const SPARE2: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct CarrierBandwidthEUTRAUl_Bandwidth(pub u8);
impl CarrierBandwidthEUTRAUl_Bandwidth {
    pub const N6: u8 = 0u8;
    pub const N15: u8 = 1u8;
    pub const N25: u8 = 2u8;
    pub const N50: u8 = 3u8;
    pub const N75: u8 = 4u8;
    pub const N100: u8 = 5u8;
    pub const SPARE10: u8 = 6u8;
    pub const SPARE9: u8 = 7u8;
    pub const SPARE8: u8 = 8u8;
    pub const SPARE7: u8 = 9u8;
    pub const SPARE6: u8 = 10u8;
    pub const SPARE5: u8 = 11u8;
    pub const SPARE4: u8 = 12u8;
    pub const SPARE3: u8 = 13u8;
    pub const SPARE2: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CarrierFreqInfoUTRA_FDD_v8h0MultiBandInfoList(pub Vec<FreqBandIndicator_UTRA_FDD>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CarrierFreqInfoUTRA_v1250ReducedMeasPerformance_r12(pub u8);
impl CarrierFreqInfoUTRA_v1250ReducedMeasPerformance_r12 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "24")]
pub struct CarrierFreqNBIOT_r16CarrierFreqOffset_r16(pub u8);
impl CarrierFreqNBIOT_r16CarrierFreqOffset_r16 {
    pub const V_10: u8 = 0u8;
    pub const V_9: u8 = 1u8;
    pub const V_8DOT5: u8 = 2u8;
    pub const V_8: u8 = 3u8;
    pub const V_7: u8 = 4u8;
    pub const V_6: u8 = 5u8;
    pub const V_5: u8 = 6u8;
    pub const V_4DOT5: u8 = 7u8;
    pub const V_4: u8 = 8u8;
    pub const V_3: u8 = 9u8;
    pub const V_2: u8 = 10u8;
    pub const V_1: u8 = 11u8;
    pub const V_0DOT5: u8 = 12u8;
    pub const V0: u8 = 13u8;
    pub const V1: u8 = 14u8;
    pub const V2: u8 = 15u8;
    pub const V3: u8 = 16u8;
    pub const V3DOT5: u8 = 17u8;
    pub const V4: u8 = 18u8;
    pub const V5: u8 = 19u8;
    pub const V6: u8 = 20u8;
    pub const V7: u8 = 21u8;
    pub const V7DOT5: u8 = 22u8;
    pub const V8: u8 = 23u8;
    pub const V9: u8 = 24u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct CarrierFreqNR_r15SubcarrierSpacingSSB_r15(pub u8);
impl CarrierFreqNR_r15SubcarrierSpacingSSB_r15 {
    pub const K_HZ15: u8 = 0u8;
    pub const K_HZ30: u8 = 1u8;
    pub const K_HZ120: u8 = 2u8;
    pub const K_HZ240: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CarrierFreqNR_r15ThreshX_Q_r15 {
    pub thresh_x_high_q_r15: ReselectionThresholdQ_r9,
    pub thresh_x_low_q_r15: ReselectionThresholdQ_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-70", ub = "-22")]
pub struct CarrierFreqNR_r15Q_RxLevMin_r15(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-70", ub = "-22")]
pub struct CarrierFreqNR_r15Q_RxLevMinSUL_r15(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-43", ub = "-12")]
pub struct CarrierFreqNR_r15Q_QualMin_r15(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct CarrierFreqNR_r15DeriveSSB_IndexFromCell_r15(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CarrierFreqNR_v1610HighSpeedCarrierNR_r16(pub u8);
impl CarrierFreqNR_v1610HighSpeedCarrierNR_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct CarrierFreqNR_v1720SubcarrierSpacingSSB_r17(pub u8);
impl CarrierFreqNR_v1720SubcarrierSpacingSSB_r17 {
    pub const K_HZ480: u8 = 0u8;
    pub const SPARE1: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-60", ub = "-13")]
pub struct CarrierFreqUTRA_FDDQ_RxLevMin(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-50", ub = "33")]
pub struct CarrierFreqUTRA_FDDP_MaxUTRA(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-24", ub = "0")]
pub struct CarrierFreqUTRA_FDDQ_QualMin(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-60", ub = "-13")]
pub struct CarrierFreqUTRA_FDD_Ext_r12Q_RxLevMin_r12(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-50", ub = "33")]
pub struct CarrierFreqUTRA_FDD_Ext_r12P_MaxUTRA_r12(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-24", ub = "0")]
pub struct CarrierFreqUTRA_FDD_Ext_r12Q_QualMin_r12(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CarrierFreqUTRA_FDD_Ext_r12ThreshX_Q_r12 {
    pub thresh_x_high_q_r12: ReselectionThresholdQ_r9,
    pub thresh_x_low_q_r12: ReselectionThresholdQ_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct CarrierFreqUTRA_FDD_Ext_r12MultiBandInfoList_r12(pub Vec<FreqBandIndicator_UTRA_FDD>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CarrierFreqUTRA_FDD_Ext_r12ReducedMeasPerformance_r12(pub u8);
impl CarrierFreqUTRA_FDD_Ext_r12ReducedMeasPerformance_r12 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-60", ub = "-13")]
pub struct CarrierFreqUTRA_TDDQ_RxLevMin(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-50", ub = "33")]
pub struct CarrierFreqUTRA_TDDP_MaxUTRA(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-60", ub = "-13")]
pub struct CarrierFreqUTRA_TDD_r12Q_RxLevMin_r12(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-50", ub = "33")]
pub struct CarrierFreqUTRA_TDD_r12P_MaxUTRA_r12(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct CarrierFreqUTRA_TDD_r12ReducedMeasPerformance_r12(pub u8);
impl CarrierFreqUTRA_TDD_r12ReducedMeasPerformance_r12 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8")]
pub struct CarrierFreqsGERANFollowingARFCNs_equallySpacedARFCNsArfcn_Spacing(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct CarrierFreqsGERANFollowingARFCNs_equallySpacedARFCNsNumberOfFollowingARFCNs(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CarrierFreqsGERANFollowingARFCNs_equallySpacedARFCNs {
    pub arfcn_spacing: CarrierFreqsGERANFollowingARFCNs_equallySpacedARFCNsArfcn_Spacing,
    pub number_of_following_arfc_ns:
        CarrierFreqsGERANFollowingARFCNs_equallySpacedARFCNsNumberOfFollowingARFCNs,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "16"
)]
pub struct CarrierFreqsGERANFollowingARFCNs_variableBitMapOfARFCNs(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum CarrierFreqsGERANFollowingARFCNs {
    #[asn(key = 0, extended = false)]
    ExplicitListOfARFCNs(ExplicitListOfARFCNs),
    #[asn(key = 1, extended = false)]
    EquallySpacedARFCNs(CarrierFreqsGERANFollowingARFCNs_equallySpacedARFCNs),
    #[asn(key = 2, extended = false)]
    VariableBitMapOfARFCNs(CarrierFreqsGERANFollowingARFCNs_variableBitMapOfARFCNs),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct CarrierFreqsInfoGERANCommonInfoNcc_Permitted(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "45")]
pub struct CarrierFreqsInfoGERANCommonInfoQ_RxLevMin(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "39")]
pub struct CarrierFreqsInfoGERANCommonInfoP_MaxGERAN(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CarrierFreqsInfoGERANCommonInfo {
    #[asn(optional_idx = 0)]
    pub cell_reselection_priority: Option<CellReselectionPriority>,
    pub ncc_permitted: CarrierFreqsInfoGERANCommonInfoNcc_Permitted,
    pub q_rx_lev_min: CarrierFreqsInfoGERANCommonInfoQ_RxLevMin,
    #[asn(optional_idx = 1)]
    pub p_max_geran: Option<CarrierFreqsInfoGERANCommonInfoP_MaxGERAN>,
    pub thresh_x_high: ReselectionThreshold,
    pub thresh_x_low: ReselectionThreshold,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct CarrierInfoNR_r15SubcarrierSpacingSSB_r15(pub u8);
impl CarrierInfoNR_r15SubcarrierSpacingSSB_r15 {
    pub const K_HZ15: u8 = 0u8;
    pub const K_HZ30: u8 = 1u8;
    pub const K_HZ120: u8 = 2u8;
    pub const K_HZ240: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct CarrierInfoNR_r17SubcarrierSpacingSSB_r17(pub u8);
impl CarrierInfoNR_r17SubcarrierSpacingSSB_r17 {
    pub const K_HZ15: u8 = 0u8;
    pub const K_HZ30: u8 = 1u8;
    pub const K_HZ120: u8 = 2u8;
    pub const K_HZ240: u8 = 3u8;
    pub const K_HZ480: u8 = 4u8;
    pub const SPARE1: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Cell_ToAddMod_r12CellIdentification_r12 {
    pub phys_cell_id_r12: PhysCellId,
    pub dl_carrier_freq_r12: ARFCN_ValueEUTRA_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Cell_ToAddMod_r12MeasResultCellToAdd_r12 {
    pub rsrp_result_r12: RSRP_Range,
    pub rsrq_result_r12: RSRQ_Range,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct CellChangeOrderT304(pub u8);
impl CellChangeOrderT304 {
    pub const MS100: u8 = 0u8;
    pub const MS200: u8 = 1u8;
    pub const MS500: u8 = 2u8;
    pub const MS1000: u8 = 3u8;
    pub const MS2000: u8 = 4u8;
    pub const MS4000: u8 = 5u8;
    pub const MS8000: u8 = 6u8;
    pub const MS10000_V1310: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct CellChangeOrderTargetRAT_Type_geranNetworkControlOrder(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct CellChangeOrderTargetRAT_Type_geran {
    pub phys_cell_id: PhysCellIdGERAN,
    pub carrier_freq: CarrierFreqGERAN,
    #[asn(optional_idx = 0)]
    pub network_control_order: Option<CellChangeOrderTargetRAT_Type_geranNetworkControlOrder>,
    #[asn(optional_idx = 1)]
    pub system_information: Option<SI_OrPSI_GERAN>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = true)]
pub enum CellChangeOrderTargetRAT_Type {
    #[asn(key = 0, extended = false)]
    Geran(CellChangeOrderTargetRAT_Type_geran),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "47", sz_ub = "47")]
pub struct CellGlobalIdCDMA2000_cellGlobalId1XRTT(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "BITSTRING",
    sz_extensible = false,
    sz_lb = "128",
    sz_ub = "128"
)]
pub struct CellGlobalIdCDMA2000_cellGlobalIdHRPD(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct CellGlobalIdGERANLocationAreaCode(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct CellGlobalIdGERANCellIdentity(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "28", sz_ub = "28")]
pub struct CellGlobalIdUTRACellIdentity(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "6")]
pub struct CellIdentity_5GC_r15_cellId_Index_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct CellInfoUTRA_FDD_r9Utra_BCCH_Container_r9(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct CellInfoUTRA_TDD_r10Utra_BCCH_Container_r10(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct CellInfoUTRA_TDD_r9Utra_BCCH_Container_r9(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct CellReselectionInfoCommon_v1460S_SearchDeltaP_r14(pub u8);
impl CellReselectionInfoCommon_v1460S_SearchDeltaP_r14 {
    pub const D_B6: u8 = 0u8;
    pub const D_B9: u8 = 1u8;
    pub const D_B12: u8 = 2u8;
    pub const D_B15: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "2", ub = "16")]
pub struct CellReselectionInfoHSDN_r15CellEquivalentSize_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct CellReselectionParametersCDMA2000_r11NeighCellList_r11(pub Vec<NeighCellCDMA2000_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8")]
pub struct CellSelectionInfo_v920Q_QualMinOffset_r9(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct CellSelectionInfoCE_v1530PowerClass14dBm_Offset_r15(pub u8);
impl CellSelectionInfoCE_v1530PowerClass14dBm_Offset_r15 {
    pub const D_B_6: u8 = 0u8;
    pub const D_B_3: u8 = 1u8;
    pub const D_B3: u8 = 2u8;
    pub const D_B6: u8 = 3u8;
    pub const D_B9: u8 = 4u8;
    pub const D_B12: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-8", ub = "-1")]
pub struct CellSelectionInfoCE1_v1360Delta_RxLevMinCE1_v1360(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8")]
pub struct CellSelectionInfoNFreq_r13Q_RxLevMinOffset(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct CellSelectionInfoNFreq_r13Q_Hyst_r13(pub u8);
impl CellSelectionInfoNFreq_r13Q_Hyst_r13 {
    pub const D_B0: u8 = 0u8;
    pub const D_B1: u8 = 1u8;
    pub const D_B2: u8 = 2u8;
    pub const D_B3: u8 = 3u8;
    pub const D_B4: u8 = 4u8;
    pub const D_B5: u8 = 5u8;
    pub const D_B6: u8 = 6u8;
    pub const D_B8: u8 = 7u8;
    pub const D_B10: u8 = 8u8;
    pub const D_B12: u8 = 9u8;
    pub const D_B14: u8 = 10u8;
    pub const D_B16: u8 = 11u8;
    pub const D_B18: u8 = 12u8;
    pub const D_B20: u8 = 13u8;
    pub const D_B22: u8 = 14u8;
    pub const D_B24: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct CellsToAddModCellIndex(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct CellsToAddModCDMA2000CellIndex(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct CellsToAddModNR_r15CellIndex_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct CellsToAddModNR_r16CellIndex_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct CellsToAddModUTRA_FDDCellIndex(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct CellsToAddModUTRA_TDDCellIndex(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CellsTriggeredList_Entry_physCellIdUTRA {
    #[asn(key = 0, extended = false)]
    Fdd(PhysCellIdUTRA_FDD),
    #[asn(key = 1, extended = false)]
    Tdd(PhysCellIdUTRA_TDD),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellsTriggeredList_Entry_physCellIdGERAN {
    pub carrier_freq: CarrierFreqGERAN,
    pub phys_cell_id: PhysCellIdGERAN,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct CellsTriggeredList_Entry_physCellIdNR_r15 {
    pub carrier_freq: ARFCN_ValueNR_r15,
    pub phys_cell_id: PhysCellIdNR_r15,
    #[asn(optional_idx = 0)]
    pub rs_index_list_r15: Option<SSB_IndexList_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "5", extensible = false)]
pub enum CellsTriggeredList_Entry {
    #[asn(key = 0, extended = false)]
    PhysCellIdEUTRA(PhysCellId),
    #[asn(key = 1, extended = false)]
    PhysCellIdUTRA(CellsTriggeredList_Entry_physCellIdUTRA),
    #[asn(key = 2, extended = false)]
    PhysCellIdGERAN(CellsTriggeredList_Entry_physCellIdGERAN),
    #[asn(key = 3, extended = false)]
    PhysCellIdCDMA2000(PhysCellIdCDMA2000),
    #[asn(key = 4, extended = false)]
    Wlan_Identifiers_r13(WLAN_Identifiers_r12),
    #[asn(key = 5, extended = false)]
    PhysCellIdNR_r15(CellsTriggeredList_Entry_physCellIdNR_r15),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct CondReconfigurationAddMod_r16TriggerCondition_r16(pub Vec<MeasId>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct CondReconfigurationAddMod_r16CondReconfigurationToApply_r16(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-30", ub = "30")]
pub struct CondReconfigurationTriggerEUTRA_r16CondEventId_r16_condEventA3_r16A3_Offset_r16(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CondReconfigurationTriggerEUTRA_r16CondEventId_r16_condEventA3_r16 {
    pub a3_offset_r16:
        CondReconfigurationTriggerEUTRA_r16CondEventId_r16_condEventA3_r16A3_Offset_r16,
    pub hysteresis_r16: Hysteresis,
    pub time_to_trigger_r16: TimeToTrigger,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CondReconfigurationTriggerEUTRA_r16CondEventId_r16_condEventA5_r16 {
    pub a5_threshold1_r16: ThresholdEUTRA,
    pub a5_threshold2_r16: ThresholdEUTRA,
    pub hysteresis_r16: Hysteresis,
    pub time_to_trigger_r16: TimeToTrigger,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum CondReconfigurationTriggerEUTRA_r16CondEventId_r16 {
    #[asn(key = 0, extended = false)]
    CondEventA3_r16(CondReconfigurationTriggerEUTRA_r16CondEventId_r16_condEventA3_r16),
    #[asn(key = 1, extended = false)]
    CondEventA5_r16(CondReconfigurationTriggerEUTRA_r16CondEventId_r16_condEventA5_r16),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CondReconfigurationTriggerNR_r17CondEventId_r17_condEventB1_NR_r17 {
    pub b1_threshold_nr_r17: ThresholdNR_r15,
    pub hysteresis_r17: Hysteresis,
    pub time_to_trigger_r17: TimeToTrigger,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = true)]
pub enum CondReconfigurationTriggerNR_r17CondEventId_r17 {
    #[asn(key = 0, extended = false)]
    CondEventB1_NR_r17(CondReconfigurationTriggerNR_r17CondEventId_r17_condEventB1_NR_r17),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct ConditionalReconfiguration_r16AttemptCondReconf_r16(pub u8);
impl ConditionalReconfiguration_r16AttemptCondReconf_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "100")]
pub struct ConfigRestrictInfoDAPS_r16MaxSCH_TB_BitsDL_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "100")]
pub struct ConfigRestrictInfoDAPS_r16MaxSCH_TB_BitsUL_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct ConnEstFailReport_r11MeasResultFailedCell_r11 {
    pub rsrp_result_r11: RSRP_Range,
    #[asn(optional_idx = 0)]
    pub rsrq_result_r11: Option<RSRQ_Range>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct ConnEstFailReport_r11MeasResultNeighCells_r11 {
    #[asn(optional_idx = 0)]
    pub meas_result_list_eutra_r11: Option<MeasResultList2EUTRA_r9>,
    #[asn(optional_idx = 1)]
    pub meas_result_list_utra_r11: Option<MeasResultList2UTRA_r9>,
    #[asn(optional_idx = 2)]
    pub meas_result_list_geran_r11: Option<MeasResultListGERAN>,
    #[asn(optional_idx = 3)]
    pub meas_results_cdma2000_r11: Option<MeasResultList2CDMA2000_r9>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct ConnEstFailReport_r11ContentionDetected_r11(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct ConnEstFailReport_r11MaxTxPowerReached_r11(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CounterCheckCriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CounterCheckCriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct CounterCheckCriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum CounterCheckCriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    CounterCheck_r8(CounterCheck_r8_IEs),
    #[asn(key = 1, extended = false)]
    Spare3(CounterCheckCriticalExtensions_c1_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(CounterCheckCriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(CounterCheckCriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CounterCheckCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CounterCheckCriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(CounterCheckCriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(CounterCheckCriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CounterCheck_v1530_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct CounterCheck_v8a0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CounterCheckResponseCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CounterCheckResponseCriticalExtensions {
    #[asn(key = 0, extended = false)]
    CounterCheckResponse_r8(CounterCheckResponse_r8_IEs),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(CounterCheckResponseCriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CounterCheckResponse_v1530_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct CounterCheckResponse_v8a0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct CountingResponseInfo_r10CountingResponseService_r10(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct CrossCarrierSchedulingConfig_r10SchedulingCellInfo_r10_own_r10Cif_Presence_r10(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CrossCarrierSchedulingConfig_r10SchedulingCellInfo_r10_own_r10 {
    pub cif_presence_r10:
        CrossCarrierSchedulingConfig_r10SchedulingCellInfo_r10_own_r10Cif_Presence_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4")]
pub struct CrossCarrierSchedulingConfig_r10SchedulingCellInfo_r10_other_r10Pdsch_Start_r10(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CrossCarrierSchedulingConfig_r10SchedulingCellInfo_r10_other_r10 {
    pub scheduling_cell_id_r10: ServCellIndex_r10,
    pub pdsch_start_r10:
        CrossCarrierSchedulingConfig_r10SchedulingCellInfo_r10_other_r10Pdsch_Start_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CrossCarrierSchedulingConfig_r10SchedulingCellInfo_r10 {
    #[asn(key = 0, extended = false)]
    Own_r10(CrossCarrierSchedulingConfig_r10SchedulingCellInfo_r10_own_r10),
    #[asn(key = 1, extended = false)]
    Other_r10(CrossCarrierSchedulingConfig_r10SchedulingCellInfo_r10_other_r10),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct CrossCarrierSchedulingConfig_r13SchedulingCellInfo_r13_own_r13Cif_Presence_r13(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CrossCarrierSchedulingConfig_r13SchedulingCellInfo_r13_own_r13 {
    pub cif_presence_r13:
        CrossCarrierSchedulingConfig_r13SchedulingCellInfo_r13_own_r13Cif_Presence_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4")]
pub struct CrossCarrierSchedulingConfig_r13SchedulingCellInfo_r13_other_r13Pdsch_Start_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "7")]
pub struct CrossCarrierSchedulingConfig_r13SchedulingCellInfo_r13_other_r13Cif_InSchedulingCell_r13(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CrossCarrierSchedulingConfig_r13SchedulingCellInfo_r13_other_r13 {
    pub scheduling_cell_id_r13: ServCellIndex_r13,
    pub pdsch_start_r13:
        CrossCarrierSchedulingConfig_r13SchedulingCellInfo_r13_other_r13Pdsch_Start_r13,
    pub cif_in_scheduling_cell_r13:
        CrossCarrierSchedulingConfig_r13SchedulingCellInfo_r13_other_r13Cif_InSchedulingCell_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CrossCarrierSchedulingConfig_r13SchedulingCellInfo_r13 {
    #[asn(key = 0, extended = false)]
    Own_r13(CrossCarrierSchedulingConfig_r13SchedulingCellInfo_r13_own_r13),
    #[asn(key = 1, extended = false)]
    Other_r13(CrossCarrierSchedulingConfig_r13SchedulingCellInfo_r13_other_r13),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "7")]
pub struct CrossCarrierSchedulingConfigLAA_UL_r14Cif_InSchedulingCell_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct DAPS_PowerCoordinationInfo_r16P_DAPS_Source_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct DAPS_PowerCoordinationInfo_r16P_DAPS_Target_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "2")]
pub struct DAPS_PowerCoordinationInfo_r16PowerControlMode_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct DC_Parameters_r12Drb_TypeSplit_r12(pub u8);
impl DC_Parameters_r12Drb_TypeSplit_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct DC_Parameters_r12Drb_TypeSCG_r12(pub u8);
impl DC_Parameters_r12Drb_TypeSCG_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct DC_Parameters_v1310Pdcp_TransferSplitUL_r13(pub u8);
impl DC_Parameters_v1310Pdcp_TransferSplitUL_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct DC_Parameters_v1310Ue_SSTD_Meas_r13(pub u8);
impl DC_Parameters_v1310Ue_SSTD_Meas_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct DL_AM_RLC_r15Extended_RLC_LI_Field_r15(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum DL_CCCH_MessageType_c1 {
    #[asn(key = 0, extended = false)]
    RrcConnectionReestablishment(RRCConnectionReestablishment),
    #[asn(key = 1, extended = false)]
    RrcConnectionReestablishmentReject(RRCConnectionReestablishmentReject),
    #[asn(key = 2, extended = false)]
    RrcConnectionReject(RRCConnectionReject),
    #[asn(key = 3, extended = false)]
    RrcConnectionSetup(RRCConnectionSetup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct DL_CCCH_MessageType_messageClassExtension_c2_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct DL_CCCH_MessageType_messageClassExtension_c2_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct DL_CCCH_MessageType_messageClassExtension_c2_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum DL_CCCH_MessageType_messageClassExtension_c2 {
    #[asn(key = 0, extended = false)]
    RrcEarlyDataComplete_r15(RRCEarlyDataComplete_r15),
    #[asn(key = 1, extended = false)]
    Spare3(DL_CCCH_MessageType_messageClassExtension_c2_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(DL_CCCH_MessageType_messageClassExtension_c2_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(DL_CCCH_MessageType_messageClassExtension_c2_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DL_CCCH_MessageType_messageClassExtension_messageClassExtensionFuture_r15 {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum DL_CCCH_MessageType_messageClassExtension {
    #[asn(key = 0, extended = false)]
    C2(DL_CCCH_MessageType_messageClassExtension_c2),
    #[asn(key = 1, extended = false)]
    MessageClassExtensionFuture_r15(
        DL_CCCH_MessageType_messageClassExtension_messageClassExtensionFuture_r15,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct DL_DCCH_MessageType_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct DL_DCCH_MessageType_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "15", extensible = false)]
pub enum DL_DCCH_MessageType_c1 {
    #[asn(key = 0, extended = false)]
    CsfbParametersResponseCDMA2000(CSFBParametersResponseCDMA2000),
    #[asn(key = 1, extended = false)]
    DlInformationTransfer(DLInformationTransfer),
    #[asn(key = 2, extended = false)]
    HandoverFromEUTRAPreparationRequest(HandoverFromEUTRAPreparationRequest),
    #[asn(key = 3, extended = false)]
    MobilityFromEUTRACommand(MobilityFromEUTRACommand),
    #[asn(key = 4, extended = false)]
    RrcConnectionReconfiguration(RRCConnectionReconfiguration),
    #[asn(key = 5, extended = false)]
    RrcConnectionRelease(RRCConnectionRelease),
    #[asn(key = 6, extended = false)]
    SecurityModeCommand(SecurityModeCommand),
    #[asn(key = 7, extended = false)]
    UeCapabilityEnquiry(UECapabilityEnquiry),
    #[asn(key = 8, extended = false)]
    CounterCheck(CounterCheck),
    #[asn(key = 9, extended = false)]
    UeInformationRequest_r9(UEInformationRequest_r9),
    #[asn(key = 10, extended = false)]
    LoggedMeasurementConfiguration_r10(LoggedMeasurementConfiguration_r10),
    #[asn(key = 11, extended = false)]
    RnReconfiguration_r10(RNReconfiguration_r10),
    #[asn(key = 12, extended = false)]
    RrcConnectionResume_r13(RRCConnectionResume_r13),
    #[asn(key = 13, extended = false)]
    DlDedicatedMessageSegment_r16(DLDedicatedMessageSegment_r16),
    #[asn(key = 14, extended = false)]
    Spare2(DL_DCCH_MessageType_c1_spare2),
    #[asn(key = 15, extended = false)]
    Spare1(DL_DCCH_MessageType_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DL_DCCH_MessageType_messageClassExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct DL_UL_CCs_r15MaxNumberDL_CCs_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct DL_UL_CCs_r15MaxNumberUL_CCs_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DLDedicatedMessageSegment_r16CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum DLDedicatedMessageSegment_r16CriticalExtensions {
    #[asn(key = 0, extended = false)]
    DlDedicatedMessageSegment_r16(DLDedicatedMessageSegment_r16_IEs),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        DLDedicatedMessageSegment_r16CriticalExtensions_criticalExtensionsFuture,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4")]
pub struct DLDedicatedMessageSegment_r16_IEsSegmentNumber_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct DLDedicatedMessageSegment_r16_IEsRrc_MessageSegmentContainer_r16(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct DLDedicatedMessageSegment_r16_IEsRrc_MessageSegmentType_r16(pub u8);
impl DLDedicatedMessageSegment_r16_IEsRrc_MessageSegmentType_r16 {
    pub const NOT_LAST_SEGMENT: u8 = 0u8;
    pub const LAST_SEGMENT: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct DLDedicatedMessageSegment_r16_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DLDedicatedMessageSegment_r16_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct DLInformationTransferCriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct DLInformationTransferCriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum DLInformationTransferCriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    DlInformationTransfer_r8(DLInformationTransfer_r8_IEs),
    #[asn(key = 1, extended = false)]
    DlInformationTransfer_r15(DLInformationTransfer_r15_IEs),
    #[asn(key = 2, extended = false)]
    Spare2(DLInformationTransferCriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(DLInformationTransferCriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DLInformationTransferCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum DLInformationTransferCriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(DLInformationTransferCriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(DLInformationTransferCriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum DLInformationTransfer_r15_IEsDedicatedInfoType_r15 {
    #[asn(key = 0, extended = false)]
    DedicatedInfoNAS(DedicatedInfoNAS),
    #[asn(key = 1, extended = false)]
    DedicatedInfoCDMA2000_1XRTT(DedicatedInfoCDMA2000),
    #[asn(key = 2, extended = false)]
    DedicatedInfoCDMA2000_HRPD(DedicatedInfoCDMA2000),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum DLInformationTransfer_r8_IEsDedicatedInfoType {
    #[asn(key = 0, extended = false)]
    DedicatedInfoNAS(DedicatedInfoNAS),
    #[asn(key = 1, extended = false)]
    DedicatedInfoCDMA2000_1XRTT(DedicatedInfoCDMA2000),
    #[asn(key = 2, extended = false)]
    DedicatedInfoCDMA2000_HRPD(DedicatedInfoCDMA2000),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DLInformationTransfer_v1610_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct DLInformationTransfer_v8a0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct DMRS_Config_r11_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "503")]
pub struct DMRS_Config_r11_setupScramblingIdentity_r11(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "503")]
pub struct DMRS_Config_r11_setupScramblingIdentity2_r11(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DMRS_Config_r11_setup {
    pub scrambling_identity_r11: DMRS_Config_r11_setupScramblingIdentity_r11,
    pub scrambling_identity2_r11: DMRS_Config_r11_setupScramblingIdentity2_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct DMRS_Config_v1310Dmrs_tableAlt_r13(pub u8);
impl DMRS_Config_v1310Dmrs_tableAlt_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4294967295")]
pub struct DRB_CountInfoCount_Uplink(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4294967295")]
pub struct DRB_CountInfoCount_Downlink(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "33554431")]
pub struct DRB_CountMSB_InfoCountMSB_Uplink(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "33554431")]
pub struct DRB_CountMSB_InfoCountMSB_Downlink(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct DRB_InfoSCG_r12Eps_BearerIdentity_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct DRB_InfoSCG_r12Drb_Type_r12(pub u8);
impl DRB_InfoSCG_r12Drb_Type_r12 {
    pub const SPLIT: u8 = 0u8;
    pub const SCG: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct DRB_ToAddModEps_BearerIdentity(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "3", ub = "10")]
pub struct DRB_ToAddModLogicalChannelIdentity(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct DRB_ToAddModSCG_r12Drb_Type_r12_split_r12;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct DRB_ToAddModSCG_r12Drb_Type_r12_scg_r12Eps_BearerIdentity_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct DRB_ToAddModSCG_r12Drb_Type_r12_scg_r12 {
    #[asn(optional_idx = 0)]
    pub eps_bearer_identity_r12:
        Option<DRB_ToAddModSCG_r12Drb_Type_r12_scg_r12Eps_BearerIdentity_r12>,
    #[asn(optional_idx = 1)]
    pub pdcp_config_r12: Option<PDCP_Config>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum DRB_ToAddModSCG_r12Drb_Type_r12 {
    #[asn(key = 0, extended = false)]
    Split_r12(DRB_ToAddModSCG_r12Drb_Type_r12_split_r12),
    #[asn(key = 1, extended = false)]
    Scg_r12(DRB_ToAddModSCG_r12Drb_Type_r12_scg_r12),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "3", ub = "10")]
pub struct DRB_ToAddModSCG_r12LogicalChannelIdentitySCG_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct DRX_Config_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct DRX_Config_setupOnDurationTimer(pub u8);
impl DRX_Config_setupOnDurationTimer {
    pub const PSF1: u8 = 0u8;
    pub const PSF2: u8 = 1u8;
    pub const PSF3: u8 = 2u8;
    pub const PSF4: u8 = 3u8;
    pub const PSF5: u8 = 4u8;
    pub const PSF6: u8 = 5u8;
    pub const PSF8: u8 = 6u8;
    pub const PSF10: u8 = 7u8;
    pub const PSF20: u8 = 8u8;
    pub const PSF30: u8 = 9u8;
    pub const PSF40: u8 = 10u8;
    pub const PSF50: u8 = 11u8;
    pub const PSF60: u8 = 12u8;
    pub const PSF80: u8 = 13u8;
    pub const PSF100: u8 = 14u8;
    pub const PSF200: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "31")]
pub struct DRX_Config_setupDrx_InactivityTimer(pub u8);
impl DRX_Config_setupDrx_InactivityTimer {
    pub const PSF1: u8 = 0u8;
    pub const PSF2: u8 = 1u8;
    pub const PSF3: u8 = 2u8;
    pub const PSF4: u8 = 3u8;
    pub const PSF5: u8 = 4u8;
    pub const PSF6: u8 = 5u8;
    pub const PSF8: u8 = 6u8;
    pub const PSF10: u8 = 7u8;
    pub const PSF20: u8 = 8u8;
    pub const PSF30: u8 = 9u8;
    pub const PSF40: u8 = 10u8;
    pub const PSF50: u8 = 11u8;
    pub const PSF60: u8 = 12u8;
    pub const PSF80: u8 = 13u8;
    pub const PSF100: u8 = 14u8;
    pub const PSF200: u8 = 15u8;
    pub const PSF300: u8 = 16u8;
    pub const PSF500: u8 = 17u8;
    pub const PSF750: u8 = 18u8;
    pub const PSF1280: u8 = 19u8;
    pub const PSF1920: u8 = 20u8;
    pub const PSF2560: u8 = 21u8;
    pub const PSF0_V1020: u8 = 22u8;
    pub const SPARE9: u8 = 23u8;
    pub const SPARE8: u8 = 24u8;
    pub const SPARE7: u8 = 25u8;
    pub const SPARE6: u8 = 26u8;
    pub const SPARE5: u8 = 27u8;
    pub const SPARE4: u8 = 28u8;
    pub const SPARE3: u8 = 29u8;
    pub const SPARE2: u8 = 30u8;
    pub const SPARE1: u8 = 31u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct DRX_Config_setupDrx_RetransmissionTimer(pub u8);
impl DRX_Config_setupDrx_RetransmissionTimer {
    pub const PSF1: u8 = 0u8;
    pub const PSF2: u8 = 1u8;
    pub const PSF4: u8 = 2u8;
    pub const PSF6: u8 = 3u8;
    pub const PSF8: u8 = 4u8;
    pub const PSF16: u8 = 5u8;
    pub const PSF24: u8 = 6u8;
    pub const PSF33: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "9")]
pub struct DRX_Config_setupLongDRX_CycleStartOffset_sf10(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "19")]
pub struct DRX_Config_setupLongDRX_CycleStartOffset_sf20(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct DRX_Config_setupLongDRX_CycleStartOffset_sf32(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "39")]
pub struct DRX_Config_setupLongDRX_CycleStartOffset_sf40(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63")]
pub struct DRX_Config_setupLongDRX_CycleStartOffset_sf64(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "79")]
pub struct DRX_Config_setupLongDRX_CycleStartOffset_sf80(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "127")]
pub struct DRX_Config_setupLongDRX_CycleStartOffset_sf128(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "159")]
pub struct DRX_Config_setupLongDRX_CycleStartOffset_sf160(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct DRX_Config_setupLongDRX_CycleStartOffset_sf256(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "319")]
pub struct DRX_Config_setupLongDRX_CycleStartOffset_sf320(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "511")]
pub struct DRX_Config_setupLongDRX_CycleStartOffset_sf512(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "639")]
pub struct DRX_Config_setupLongDRX_CycleStartOffset_sf640(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct DRX_Config_setupLongDRX_CycleStartOffset_sf1024(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1279")]
pub struct DRX_Config_setupLongDRX_CycleStartOffset_sf1280(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct DRX_Config_setupLongDRX_CycleStartOffset_sf2048(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2559")]
pub struct DRX_Config_setupLongDRX_CycleStartOffset_sf2560(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "15", extensible = false)]
pub enum DRX_Config_setupLongDRX_CycleStartOffset {
    #[asn(key = 0, extended = false)]
    Sf10(DRX_Config_setupLongDRX_CycleStartOffset_sf10),
    #[asn(key = 1, extended = false)]
    Sf20(DRX_Config_setupLongDRX_CycleStartOffset_sf20),
    #[asn(key = 2, extended = false)]
    Sf32(DRX_Config_setupLongDRX_CycleStartOffset_sf32),
    #[asn(key = 3, extended = false)]
    Sf40(DRX_Config_setupLongDRX_CycleStartOffset_sf40),
    #[asn(key = 4, extended = false)]
    Sf64(DRX_Config_setupLongDRX_CycleStartOffset_sf64),
    #[asn(key = 5, extended = false)]
    Sf80(DRX_Config_setupLongDRX_CycleStartOffset_sf80),
    #[asn(key = 6, extended = false)]
    Sf128(DRX_Config_setupLongDRX_CycleStartOffset_sf128),
    #[asn(key = 7, extended = false)]
    Sf160(DRX_Config_setupLongDRX_CycleStartOffset_sf160),
    #[asn(key = 8, extended = false)]
    Sf256(DRX_Config_setupLongDRX_CycleStartOffset_sf256),
    #[asn(key = 9, extended = false)]
    Sf320(DRX_Config_setupLongDRX_CycleStartOffset_sf320),
    #[asn(key = 10, extended = false)]
    Sf512(DRX_Config_setupLongDRX_CycleStartOffset_sf512),
    #[asn(key = 11, extended = false)]
    Sf640(DRX_Config_setupLongDRX_CycleStartOffset_sf640),
    #[asn(key = 12, extended = false)]
    Sf1024(DRX_Config_setupLongDRX_CycleStartOffset_sf1024),
    #[asn(key = 13, extended = false)]
    Sf1280(DRX_Config_setupLongDRX_CycleStartOffset_sf1280),
    #[asn(key = 14, extended = false)]
    Sf2048(DRX_Config_setupLongDRX_CycleStartOffset_sf2048),
    #[asn(key = 15, extended = false)]
    Sf2560(DRX_Config_setupLongDRX_CycleStartOffset_sf2560),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct DRX_Config_setupShortDRXShortDRX_Cycle(pub u8);
impl DRX_Config_setupShortDRXShortDRX_Cycle {
    pub const SF2: u8 = 0u8;
    pub const SF5: u8 = 1u8;
    pub const SF8: u8 = 2u8;
    pub const SF10: u8 = 3u8;
    pub const SF16: u8 = 4u8;
    pub const SF20: u8 = 5u8;
    pub const SF32: u8 = 6u8;
    pub const SF40: u8 = 7u8;
    pub const SF64: u8 = 8u8;
    pub const SF80: u8 = 9u8;
    pub const SF128: u8 = 10u8;
    pub const SF160: u8 = 11u8;
    pub const SF256: u8 = 12u8;
    pub const SF320: u8 = 13u8;
    pub const SF512: u8 = 14u8;
    pub const SF640: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct DRX_Config_setupShortDRXDrxShortCycleTimer(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DRX_Config_setupShortDRX {
    pub short_drx_cycle: DRX_Config_setupShortDRXShortDRX_Cycle,
    pub drx_short_cycle_timer: DRX_Config_setupShortDRXDrxShortCycleTimer,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct DRX_Config_setup {
    pub on_duration_timer: DRX_Config_setupOnDurationTimer,
    pub drx_inactivity_timer: DRX_Config_setupDrx_InactivityTimer,
    pub drx_retransmission_timer: DRX_Config_setupDrx_RetransmissionTimer,
    pub long_drx_cycle_start_offset: DRX_Config_setupLongDRX_CycleStartOffset,
    #[asn(optional_idx = 0)]
    pub short_drx: Option<DRX_Config_setupShortDRX>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct DRX_Config_r13OnDurationTimer_v1310(pub u8);
impl DRX_Config_r13OnDurationTimer_v1310 {
    pub const PSF300: u8 = 0u8;
    pub const PSF400: u8 = 1u8;
    pub const PSF500: u8 = 2u8;
    pub const PSF600: u8 = 3u8;
    pub const PSF800: u8 = 4u8;
    pub const PSF1000: u8 = 5u8;
    pub const PSF1200: u8 = 6u8;
    pub const PSF1600: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct DRX_Config_r13Drx_RetransmissionTimer_v1310(pub u8);
impl DRX_Config_r13Drx_RetransmissionTimer_v1310 {
    pub const PSF40: u8 = 0u8;
    pub const PSF64: u8 = 1u8;
    pub const PSF80: u8 = 2u8;
    pub const PSF96: u8 = 3u8;
    pub const PSF112: u8 = 4u8;
    pub const PSF128: u8 = 5u8;
    pub const PSF160: u8 = 6u8;
    pub const PSF320: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "16")]
pub struct DRX_Config_r13Drx_ULRetransmissionTimer_r13(pub u8);
impl DRX_Config_r13Drx_ULRetransmissionTimer_r13 {
    pub const PSF0: u8 = 0u8;
    pub const PSF1: u8 = 1u8;
    pub const PSF2: u8 = 2u8;
    pub const PSF4: u8 = 3u8;
    pub const PSF6: u8 = 4u8;
    pub const PSF8: u8 = 5u8;
    pub const PSF16: u8 = 6u8;
    pub const PSF24: u8 = 7u8;
    pub const PSF33: u8 = 8u8;
    pub const PSF40: u8 = 9u8;
    pub const PSF64: u8 = 10u8;
    pub const PSF80: u8 = 11u8;
    pub const PSF96: u8 = 12u8;
    pub const PSF112: u8 = 13u8;
    pub const PSF128: u8 = 14u8;
    pub const PSF160: u8 = 15u8;
    pub const PSF320: u8 = 16u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "9")]
pub struct DRX_Config_r15Drx_RetransmissionTimerShortTTI_r15(pub u8);
impl DRX_Config_r15Drx_RetransmissionTimerShortTTI_r15 {
    pub const TTI10: u8 = 0u8;
    pub const TTI20: u8 = 1u8;
    pub const TTI40: u8 = 2u8;
    pub const TTI64: u8 = 3u8;
    pub const TTI80: u8 = 4u8;
    pub const TTI96: u8 = 5u8;
    pub const TTI112: u8 = 6u8;
    pub const TTI128: u8 = 7u8;
    pub const TTI160: u8 = 8u8;
    pub const TTI320: u8 = 9u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "16")]
pub struct DRX_Config_r15Drx_UL_RetransmissionTimerShortTTI_r15(pub u8);
impl DRX_Config_r15Drx_UL_RetransmissionTimerShortTTI_r15 {
    pub const TTI0: u8 = 0u8;
    pub const TTI1: u8 = 1u8;
    pub const TTI2: u8 = 2u8;
    pub const TTI4: u8 = 3u8;
    pub const TTI6: u8 = 4u8;
    pub const TTI8: u8 = 5u8;
    pub const TTI16: u8 = 6u8;
    pub const TTI24: u8 = 7u8;
    pub const TTI33: u8 = 8u8;
    pub const TTI40: u8 = 9u8;
    pub const TTI64: u8 = 10u8;
    pub const TTI80: u8 = 11u8;
    pub const TTI96: u8 = 12u8;
    pub const TTI112: u8 = 13u8;
    pub const TTI128: u8 = 14u8;
    pub const TTI160: u8 = 15u8;
    pub const TTI320: u8 = 16u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct DRX_Config_v1130Drx_RetransmissionTimer_v1130(pub u8);
impl DRX_Config_v1130Drx_RetransmissionTimer_v1130 {
    pub const PSF0_V1130: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "59")]
pub struct DRX_Config_v1130LongDRX_CycleStartOffset_v1130_sf60_v1130(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "69")]
pub struct DRX_Config_v1130LongDRX_CycleStartOffset_v1130_sf70_v1130(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum DRX_Config_v1130LongDRX_CycleStartOffset_v1130 {
    #[asn(key = 0, extended = false)]
    Sf60_v1130(DRX_Config_v1130LongDRX_CycleStartOffset_v1130_sf60_v1130),
    #[asn(key = 1, extended = false)]
    Sf70_v1130(DRX_Config_v1130LongDRX_CycleStartOffset_v1130_sf70_v1130),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct DRX_Config_v1130ShortDRX_Cycle_v1130(pub u8);
impl DRX_Config_v1130ShortDRX_Cycle_v1130 {
    pub const SF4_V1130: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "59")]
pub struct DRX_Config_v1310LongDRX_CycleStartOffset_v1310Sf60_v1310(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DRX_Config_v1310LongDRX_CycleStartOffset_v1310 {
    pub sf60_v1310: DRX_Config_v1310LongDRX_CycleStartOffset_v1310Sf60_v1310,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "15")]
pub struct DataBLER_MCH_Result_r12Mch_Index_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "16")]
pub struct DelayBudgetReport_r14_type1(pub u8);
impl DelayBudgetReport_r14_type1 {
    pub const MS_MINUS1280: u8 = 0u8;
    pub const MS_MINUS640: u8 = 1u8;
    pub const MS_MINUS320: u8 = 2u8;
    pub const MS_MINUS160: u8 = 3u8;
    pub const MS_MINUS80: u8 = 4u8;
    pub const MS_MINUS60: u8 = 5u8;
    pub const MS_MINUS40: u8 = 6u8;
    pub const MS_MINUS20: u8 = 7u8;
    pub const MS0: u8 = 8u8;
    pub const MS20: u8 = 9u8;
    pub const MS40: u8 = 10u8;
    pub const MS60: u8 = 11u8;
    pub const MS80: u8 = 12u8;
    pub const MS160: u8 = 13u8;
    pub const MS320: u8 = 14u8;
    pub const MS640: u8 = 15u8;
    pub const MS1280: u8 = 16u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "16")]
pub struct DelayBudgetReport_r14_type2(pub u8);
impl DelayBudgetReport_r14_type2 {
    pub const MS_MINUS192: u8 = 0u8;
    pub const MS_MINUS168: u8 = 1u8;
    pub const MS_MINUS144: u8 = 2u8;
    pub const MS_MINUS120: u8 = 3u8;
    pub const MS_MINUS96: u8 = 4u8;
    pub const MS_MINUS72: u8 = 5u8;
    pub const MS_MINUS48: u8 = 6u8;
    pub const MS_MINUS24: u8 = 7u8;
    pub const MS0: u8 = 8u8;
    pub const MS24: u8 = 9u8;
    pub const MS48: u8 = 10u8;
    pub const MS72: u8 = 11u8;
    pub const MS96: u8 = 12u8;
    pub const MS120: u8 = 13u8;
    pub const MS144: u8 = 14u8;
    pub const MS168: u8 = 15u8;
    pub const MS192: u8 = 16u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct DeltaFList_PUCCHDeltaF_PUCCH_Format1(pub u8);
impl DeltaFList_PUCCHDeltaF_PUCCH_Format1 {
    pub const DELTA_F_2: u8 = 0u8;
    pub const DELTA_F0: u8 = 1u8;
    pub const DELTA_F2: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct DeltaFList_PUCCHDeltaF_PUCCH_Format1b(pub u8);
impl DeltaFList_PUCCHDeltaF_PUCCH_Format1b {
    pub const DELTA_F1: u8 = 0u8;
    pub const DELTA_F3: u8 = 1u8;
    pub const DELTA_F5: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct DeltaFList_PUCCHDeltaF_PUCCH_Format2(pub u8);
impl DeltaFList_PUCCHDeltaF_PUCCH_Format2 {
    pub const DELTA_F_2: u8 = 0u8;
    pub const DELTA_F0: u8 = 1u8;
    pub const DELTA_F1: u8 = 2u8;
    pub const DELTA_F2: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct DeltaFList_PUCCHDeltaF_PUCCH_Format2a(pub u8);
impl DeltaFList_PUCCHDeltaF_PUCCH_Format2a {
    pub const DELTA_F_2: u8 = 0u8;
    pub const DELTA_F0: u8 = 1u8;
    pub const DELTA_F2: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct DeltaFList_PUCCHDeltaF_PUCCH_Format2b(pub u8);
impl DeltaFList_PUCCHDeltaF_PUCCH_Format2b {
    pub const DELTA_F_2: u8 = 0u8;
    pub const DELTA_F0: u8 = 1u8;
    pub const DELTA_F2: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct DeltaFList_SPUCCH_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct DeltaFList_SPUCCH_r15_setupDeltaF_slotSPUCCH_Format1_r15(pub u8);
impl DeltaFList_SPUCCH_r15_setupDeltaF_slotSPUCCH_Format1_r15 {
    pub const DELTA_F_1: u8 = 0u8;
    pub const DELTA_F0: u8 = 1u8;
    pub const DELTA_F1: u8 = 2u8;
    pub const DELTA_F2: u8 = 3u8;
    pub const DELTA_F3: u8 = 4u8;
    pub const DELTA_F4: u8 = 5u8;
    pub const DELTA_F5: u8 = 6u8;
    pub const DELTA_F6: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct DeltaFList_SPUCCH_r15_setupDeltaF_slotSPUCCH_Format1a_r15(pub u8);
impl DeltaFList_SPUCCH_r15_setupDeltaF_slotSPUCCH_Format1a_r15 {
    pub const DELTA_F1: u8 = 0u8;
    pub const DELTA_F2: u8 = 1u8;
    pub const DELTA_F3: u8 = 2u8;
    pub const DELTA_F4: u8 = 3u8;
    pub const DELTA_F5: u8 = 4u8;
    pub const DELTA_F6: u8 = 5u8;
    pub const DELTA_F7: u8 = 6u8;
    pub const DELTA_F8: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct DeltaFList_SPUCCH_r15_setupDeltaF_slotSPUCCH_Format1b_r15(pub u8);
impl DeltaFList_SPUCCH_r15_setupDeltaF_slotSPUCCH_Format1b_r15 {
    pub const DELTA_F3: u8 = 0u8;
    pub const DELTA_F4: u8 = 1u8;
    pub const DELTA_F5: u8 = 2u8;
    pub const DELTA_F6: u8 = 3u8;
    pub const DELTA_F7: u8 = 4u8;
    pub const DELTA_F8: u8 = 5u8;
    pub const DELTA_F9: u8 = 6u8;
    pub const DELTA_F10: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct DeltaFList_SPUCCH_r15_setupDeltaF_slotSPUCCH_Format3_r15(pub u8);
impl DeltaFList_SPUCCH_r15_setupDeltaF_slotSPUCCH_Format3_r15 {
    pub const DELTA_F4: u8 = 0u8;
    pub const DELTA_F5: u8 = 1u8;
    pub const DELTA_F6: u8 = 2u8;
    pub const DELTA_F7: u8 = 3u8;
    pub const DELTA_F8: u8 = 4u8;
    pub const DELTA_F9: u8 = 5u8;
    pub const DELTA_F10: u8 = 6u8;
    pub const DELTA_F11: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct DeltaFList_SPUCCH_r15_setupDeltaF_slotSPUCCH_RM_Format4_r15(pub u8);
impl DeltaFList_SPUCCH_r15_setupDeltaF_slotSPUCCH_RM_Format4_r15 {
    pub const DELTA_F13: u8 = 0u8;
    pub const DELTA_F14: u8 = 1u8;
    pub const DELTA_F15: u8 = 2u8;
    pub const DELTA_F16: u8 = 3u8;
    pub const DELTA_F17: u8 = 4u8;
    pub const DELTA_F18: u8 = 5u8;
    pub const DELTA_F19: u8 = 6u8;
    pub const DELTA_F20: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct DeltaFList_SPUCCH_r15_setupDeltaF_slotSPUCCH_TBCC_Format4_r15(pub u8);
impl DeltaFList_SPUCCH_r15_setupDeltaF_slotSPUCCH_TBCC_Format4_r15 {
    pub const DELTA_F10: u8 = 0u8;
    pub const DELTA_F11: u8 = 1u8;
    pub const DELTA_F12: u8 = 2u8;
    pub const DELTA_F13: u8 = 3u8;
    pub const DELTA_F14: u8 = 4u8;
    pub const DELTA_F15: u8 = 5u8;
    pub const DELTA_F16: u8 = 6u8;
    pub const DELTA_F17: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct DeltaFList_SPUCCH_r15_setupDeltaF_subslotSPUCCH_Format1and1a_r15(pub u8);
impl DeltaFList_SPUCCH_r15_setupDeltaF_subslotSPUCCH_Format1and1a_r15 {
    pub const DELTA_F5: u8 = 0u8;
    pub const DELTA_F6: u8 = 1u8;
    pub const DELTA_F7: u8 = 2u8;
    pub const DELTA_F8: u8 = 3u8;
    pub const DELTA_F9: u8 = 4u8;
    pub const DELTA_F10: u8 = 5u8;
    pub const DELTA_F11: u8 = 6u8;
    pub const DELTA_F12: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct DeltaFList_SPUCCH_r15_setupDeltaF_subslotSPUCCH_Format1b_r15(pub u8);
impl DeltaFList_SPUCCH_r15_setupDeltaF_subslotSPUCCH_Format1b_r15 {
    pub const DELTA_F6: u8 = 0u8;
    pub const DELTA_F7: u8 = 1u8;
    pub const DELTA_F8: u8 = 2u8;
    pub const DELTA_F9: u8 = 3u8;
    pub const DELTA_F10: u8 = 4u8;
    pub const DELTA_F11: u8 = 5u8;
    pub const DELTA_F12: u8 = 6u8;
    pub const DELTA_F13: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct DeltaFList_SPUCCH_r15_setupDeltaF_subslotSPUCCH_RM_Format4_r15(pub u8);
impl DeltaFList_SPUCCH_r15_setupDeltaF_subslotSPUCCH_RM_Format4_r15 {
    pub const DELTA_F15: u8 = 0u8;
    pub const DELTA_F16: u8 = 1u8;
    pub const DELTA_F17: u8 = 2u8;
    pub const DELTA_F18: u8 = 3u8;
    pub const DELTA_F19: u8 = 4u8;
    pub const DELTA_F20: u8 = 5u8;
    pub const DELTA_F21: u8 = 6u8;
    pub const DELTA_F22: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct DeltaFList_SPUCCH_r15_setupDeltaF_subslotSPUCCH_TBCC_Format4_r15(pub u8);
impl DeltaFList_SPUCCH_r15_setupDeltaF_subslotSPUCCH_TBCC_Format4_r15 {
    pub const DELTA_F10: u8 = 0u8;
    pub const DELTA_F11: u8 = 1u8;
    pub const DELTA_F12: u8 = 2u8;
    pub const DELTA_F13: u8 = 3u8;
    pub const DELTA_F14: u8 = 4u8;
    pub const DELTA_F15: u8 = 5u8;
    pub const DELTA_F16: u8 = 6u8;
    pub const DELTA_F17: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 10)]
pub struct DeltaFList_SPUCCH_r15_setup {
    #[asn(optional_idx = 0)]
    pub delta_f_slot_spucch_format1_r15:
        Option<DeltaFList_SPUCCH_r15_setupDeltaF_slotSPUCCH_Format1_r15>,
    #[asn(optional_idx = 1)]
    pub delta_f_slot_spucch_format1a_r15:
        Option<DeltaFList_SPUCCH_r15_setupDeltaF_slotSPUCCH_Format1a_r15>,
    #[asn(optional_idx = 2)]
    pub delta_f_slot_spucch_format1b_r15:
        Option<DeltaFList_SPUCCH_r15_setupDeltaF_slotSPUCCH_Format1b_r15>,
    #[asn(optional_idx = 3)]
    pub delta_f_slot_spucch_format3_r15:
        Option<DeltaFList_SPUCCH_r15_setupDeltaF_slotSPUCCH_Format3_r15>,
    #[asn(optional_idx = 4)]
    pub delta_f_slot_spucch_rm_format4_r15:
        Option<DeltaFList_SPUCCH_r15_setupDeltaF_slotSPUCCH_RM_Format4_r15>,
    #[asn(optional_idx = 5)]
    pub delta_f_slot_spucch_tbcc_format4_r15:
        Option<DeltaFList_SPUCCH_r15_setupDeltaF_slotSPUCCH_TBCC_Format4_r15>,
    #[asn(optional_idx = 6)]
    pub delta_f_subslot_spucch_format1and1a_r15:
        Option<DeltaFList_SPUCCH_r15_setupDeltaF_subslotSPUCCH_Format1and1a_r15>,
    #[asn(optional_idx = 7)]
    pub delta_f_subslot_spucch_format1b_r15:
        Option<DeltaFList_SPUCCH_r15_setupDeltaF_subslotSPUCCH_Format1b_r15>,
    #[asn(optional_idx = 8)]
    pub delta_f_subslot_spucch_rm_format4_r15:
        Option<DeltaFList_SPUCCH_r15_setupDeltaF_subslotSPUCCH_RM_Format4_r15>,
    #[asn(optional_idx = 9)]
    pub delta_f_subslot_spucch_tbcc_format4_r15:
        Option<DeltaFList_SPUCCH_r15_setupDeltaF_subslotSPUCCH_TBCC_Format4_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct DeltaTxD_OffsetListPUCCH_r10DeltaTxD_OffsetPUCCH_Format1_r10(pub u8);
impl DeltaTxD_OffsetListPUCCH_r10DeltaTxD_OffsetPUCCH_Format1_r10 {
    pub const D_B0: u8 = 0u8;
    pub const D_B_2: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct DeltaTxD_OffsetListPUCCH_r10DeltaTxD_OffsetPUCCH_Format1a1b_r10(pub u8);
impl DeltaTxD_OffsetListPUCCH_r10DeltaTxD_OffsetPUCCH_Format1a1b_r10 {
    pub const D_B0: u8 = 0u8;
    pub const D_B_2: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct DeltaTxD_OffsetListPUCCH_r10DeltaTxD_OffsetPUCCH_Format22a2b_r10(pub u8);
impl DeltaTxD_OffsetListPUCCH_r10DeltaTxD_OffsetPUCCH_Format22a2b_r10 {
    pub const D_B0: u8 = 0u8;
    pub const D_B_2: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct DeltaTxD_OffsetListPUCCH_r10DeltaTxD_OffsetPUCCH_Format3_r10(pub u8);
impl DeltaTxD_OffsetListPUCCH_r10DeltaTxD_OffsetPUCCH_Format3_r10 {
    pub const D_B0: u8 = 0u8;
    pub const D_B_2: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct DeltaTxD_OffsetListPUCCH_v1130DeltaTxD_OffsetPUCCH_Format1bCS_r11(pub u8);
impl DeltaTxD_OffsetListPUCCH_v1130DeltaTxD_OffsetPUCCH_Format1bCS_r11 {
    pub const D_B0: u8 = 0u8;
    pub const D_B_1: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct DeltaTxD_OffsetListSPUCCH_r15DeltaTxD_OffsetSPUCCH_Format1_r15(pub u8);
impl DeltaTxD_OffsetListSPUCCH_r15DeltaTxD_OffsetSPUCCH_Format1_r15 {
    pub const D_B0: u8 = 0u8;
    pub const D_B_2: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct DeltaTxD_OffsetListSPUCCH_r15DeltaTxD_OffsetSPUCCH_Format1a_r15(pub u8);
impl DeltaTxD_OffsetListSPUCCH_r15DeltaTxD_OffsetSPUCCH_Format1a_r15 {
    pub const D_B0: u8 = 0u8;
    pub const D_B_2: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct DeltaTxD_OffsetListSPUCCH_r15DeltaTxD_OffsetSPUCCH_Format1b_r15(pub u8);
impl DeltaTxD_OffsetListSPUCCH_r15DeltaTxD_OffsetSPUCCH_Format1b_r15 {
    pub const D_B0: u8 = 0u8;
    pub const D_B_2: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct DeltaTxD_OffsetListSPUCCH_r15DeltaTxD_OffsetSPUCCH_Format3_r15(pub u8);
impl DeltaTxD_OffsetListSPUCCH_r15DeltaTxD_OffsetSPUCCH_Format3_r15 {
    pub const D_B0: u8 = 0u8;
    pub const D_B_2: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct E_CSFB_r9MessageContCDMA2000_1XRTT_r9(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct E_CSFB_r9MobilityCDMA2000_HRPD_r9(pub u8);
impl E_CSFB_r9MobilityCDMA2000_HRPD_r9 {
    pub const HANDOVER: u8 = 0u8;
    pub const REDIRECTION: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct E_CSFB_r9MessageContCDMA2000_HRPD_r9(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct EAB_Config_r11Eab_Category_r11(pub u8);
impl EAB_Config_r11Eab_Category_r11 {
    pub const A: u8 = 0u8;
    pub const B: u8 = 1u8;
    pub const C: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "10", sz_ub = "10")]
pub struct EAB_Config_r11Eab_BarringBitmap_r11(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63")]
pub struct EDT_PRACH_ParametersCE_r15Edt_PRACH_ParametersCE_r15Prach_ConfigIndex_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "94")]
pub struct EDT_PRACH_ParametersCE_r15Edt_PRACH_ParametersCE_r15Prach_FreqOffset_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct EDT_PRACH_ParametersCE_r15Edt_PRACH_ParametersCE_r15Prach_StartingSubframe_r15(pub u8);
impl EDT_PRACH_ParametersCE_r15Edt_PRACH_ParametersCE_r15Prach_StartingSubframe_r15 {
    pub const SF2: u8 = 0u8;
    pub const SF4: u8 = 1u8;
    pub const SF8: u8 = 2u8;
    pub const SF16: u8 = 3u8;
    pub const SF32: u8 = 4u8;
    pub const SF64: u8 = 5u8;
    pub const SF128: u8 = 6u8;
    pub const SF256: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct EDT_PRACH_ParametersCE_r15Edt_PRACH_ParametersCE_r15Mpdcch_NarrowbandsToMonitor_r15_Entry(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct EDT_PRACH_ParametersCE_r15Edt_PRACH_ParametersCE_r15Mpdcch_NarrowbandsToMonitor_r15(
    pub  Vec<
        EDT_PRACH_ParametersCE_r15Edt_PRACH_ParametersCE_r15Mpdcch_NarrowbandsToMonitor_r15_Entry,
    >,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct EDT_PRACH_ParametersCE_r15Edt_PRACH_ParametersCE_r15 {
    pub prach_config_index_r15:
        EDT_PRACH_ParametersCE_r15Edt_PRACH_ParametersCE_r15Prach_ConfigIndex_r15,
    pub prach_freq_offset_r15:
        EDT_PRACH_ParametersCE_r15Edt_PRACH_ParametersCE_r15Prach_FreqOffset_r15,
    #[asn(optional_idx = 0)]
    pub prach_starting_subframe_r15:
        Option<EDT_PRACH_ParametersCE_r15Edt_PRACH_ParametersCE_r15Prach_StartingSubframe_r15>,
    pub mpdcch_narrowbands_to_monitor_r15:
        EDT_PRACH_ParametersCE_r15Edt_PRACH_ParametersCE_r15Mpdcch_NarrowbandsToMonitor_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct EIMTA_MainConfig_r12_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct EIMTA_MainConfig_r12_setupEimta_CommandPeriodicity_r12(pub u8);
impl EIMTA_MainConfig_r12_setupEimta_CommandPeriodicity_r12 {
    pub const SF10: u8 = 0u8;
    pub const SF20: u8 = 1u8;
    pub const SF40: u8 = 2u8;
    pub const SF80: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "10", sz_ub = "10")]
pub struct EIMTA_MainConfig_r12_setupEimta_CommandSubframeSet_r12(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EIMTA_MainConfig_r12_setup {
    pub eimta_rnti_r12: C_RNTI,
    pub eimta_command_periodicity_r12: EIMTA_MainConfig_r12_setupEimta_CommandPeriodicity_r12,
    pub eimta_command_subframe_set_r12: EIMTA_MainConfig_r12_setupEimta_CommandSubframeSet_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct EIMTA_MainConfigServCell_r12_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "5")]
pub struct EIMTA_MainConfigServCell_r12_setupEimta_UL_DL_ConfigIndex_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct EIMTA_MainConfigServCell_r12_setupEimta_HARQ_ReferenceConfig_r12(pub u8);
impl EIMTA_MainConfigServCell_r12_setupEimta_HARQ_ReferenceConfig_r12 {
    pub const SA2: u8 = 0u8;
    pub const SA4: u8 = 1u8;
    pub const SA5: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct EIMTA_MainConfigServCell_r12_setupMbsfn_SubframeConfigList_v1250_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EIMTA_MainConfigServCell_r12_setupMbsfn_SubframeConfigList_v1250_setup {
    pub subframe_config_list_r12: MBSFN_SubframeConfigList,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum EIMTA_MainConfigServCell_r12_setupMbsfn_SubframeConfigList_v1250 {
    #[asn(key = 0, extended = false)]
    Release(EIMTA_MainConfigServCell_r12_setupMbsfn_SubframeConfigList_v1250_release),
    #[asn(key = 1, extended = false)]
    Setup(EIMTA_MainConfigServCell_r12_setupMbsfn_SubframeConfigList_v1250_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EIMTA_MainConfigServCell_r12_setup {
    pub eimta_ul_dl_config_index_r12: EIMTA_MainConfigServCell_r12_setupEimta_UL_DL_ConfigIndex_r12,
    pub eimta_harq_reference_config_r12:
        EIMTA_MainConfigServCell_r12_setupEimta_HARQ_ReferenceConfig_r12,
    pub mbsfn_subframe_config_list_v1250:
        EIMTA_MainConfigServCell_r12_setupMbsfn_SubframeConfigList_v1250,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct EPDCCH_Config_r11Config_r11_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct EPDCCH_Config_r11Config_r11_setupSubframePatternConfig_r11_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EPDCCH_Config_r11Config_r11_setupSubframePatternConfig_r11_setup {
    pub subframe_pattern_r11: MeasSubframePattern_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum EPDCCH_Config_r11Config_r11_setupSubframePatternConfig_r11 {
    #[asn(key = 0, extended = false)]
    Release(EPDCCH_Config_r11Config_r11_setupSubframePatternConfig_r11_release),
    #[asn(key = 1, extended = false)]
    Setup(EPDCCH_Config_r11Config_r11_setupSubframePatternConfig_r11_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4")]
pub struct EPDCCH_Config_r11Config_r11_setupStartSymbol_r11(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct EPDCCH_Config_r11Config_r11_setup {
    #[asn(optional_idx = 0)]
    pub subframe_pattern_config_r11:
        Option<EPDCCH_Config_r11Config_r11_setupSubframePatternConfig_r11>,
    #[asn(optional_idx = 1)]
    pub start_symbol_r11: Option<EPDCCH_Config_r11Config_r11_setupStartSymbol_r11>,
    #[asn(optional_idx = 2)]
    pub set_config_to_release_list_r11: Option<EPDCCH_SetConfigToReleaseList_r11>,
    #[asn(optional_idx = 3)]
    pub set_config_to_add_mod_list_r11: Option<EPDCCH_SetConfigToAddModList_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum EPDCCH_Config_r11Config_r11 {
    #[asn(key = 0, extended = false)]
    Release(EPDCCH_Config_r11Config_r11_release),
    #[asn(key = 1, extended = false)]
    Setup(EPDCCH_Config_r11Config_r11_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct EPDCCH_SetConfig_r11TransmissionType_r11(pub u8);
impl EPDCCH_SetConfig_r11TransmissionType_r11 {
    pub const LOCALISED: u8 = 0u8;
    pub const DISTRIBUTED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct EPDCCH_SetConfig_r11ResourceBlockAssignment_r11NumberPRB_Pairs_r11(pub u8);
impl EPDCCH_SetConfig_r11ResourceBlockAssignment_r11NumberPRB_Pairs_r11 {
    pub const N2: u8 = 0u8;
    pub const N4: u8 = 1u8;
    pub const N8: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "4", sz_ub = "38")]
pub struct EPDCCH_SetConfig_r11ResourceBlockAssignment_r11ResourceBlockAssignment_r11(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EPDCCH_SetConfig_r11ResourceBlockAssignment_r11 {
    pub number_prb_pairs_r11: EPDCCH_SetConfig_r11ResourceBlockAssignment_r11NumberPRB_Pairs_r11,
    pub resource_block_assignment_r11:
        EPDCCH_SetConfig_r11ResourceBlockAssignment_r11ResourceBlockAssignment_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "503")]
pub struct EPDCCH_SetConfig_r11Dmrs_ScramblingSequenceInt_r11(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct EPDCCH_SetConfig_r11Pucch_ResourceStartOffset_r11(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct EUTRA_5GC_Parameters_r15Eutra_5GC_r15(pub u8);
impl EUTRA_5GC_Parameters_r15Eutra_5GC_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct EUTRA_5GC_Parameters_r15Eutra_EPC_HO_EUTRA_5GC_r15(pub u8);
impl EUTRA_5GC_Parameters_r15Eutra_EPC_HO_EUTRA_5GC_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct EUTRA_5GC_Parameters_r15Ho_EUTRA_5GC_FDD_TDD_r15(pub u8);
impl EUTRA_5GC_Parameters_r15Ho_EUTRA_5GC_FDD_TDD_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct EUTRA_5GC_Parameters_r15Ho_InterfreqEUTRA_5GC_r15(pub u8);
impl EUTRA_5GC_Parameters_r15Ho_InterfreqEUTRA_5GC_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct EUTRA_5GC_Parameters_r15Ims_VoiceOverMCG_BearerEUTRA_5GC_r15(pub u8);
impl EUTRA_5GC_Parameters_r15Ims_VoiceOverMCG_BearerEUTRA_5GC_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct EUTRA_5GC_Parameters_r15InactiveState_r15(pub u8);
impl EUTRA_5GC_Parameters_r15InactiveState_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct EUTRA_5GC_Parameters_r15ReflectiveQoS_r15(pub u8);
impl EUTRA_5GC_Parameters_r15ReflectiveQoS_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct EUTRA_5GC_Parameters_v1610Ce_InactiveState_r16(pub u8);
impl EUTRA_5GC_Parameters_v1610Ce_InactiveState_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct EUTRA_5GC_Parameters_v1610Ce_EUTRA_5GC_r16(pub u8);
impl EUTRA_5GC_Parameters_v1610Ce_EUTRA_5GC_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct Enable256QAM_r14_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct Enable256QAM_r14_setup_tpc_SubframeSet_Configured_r14SubframeSet1_DCI_Format0_r14(
    pub bool,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct Enable256QAM_r14_setup_tpc_SubframeSet_Configured_r14SubframeSet1_DCI_Format4_r14(
    pub bool,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct Enable256QAM_r14_setup_tpc_SubframeSet_Configured_r14SubframeSet2_DCI_Format0_r14(
    pub bool,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct Enable256QAM_r14_setup_tpc_SubframeSet_Configured_r14SubframeSet2_DCI_Format4_r14(
    pub bool,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Enable256QAM_r14_setup_tpc_SubframeSet_Configured_r14 {
    pub subframe_set1_dci_format0_r14:
        Enable256QAM_r14_setup_tpc_SubframeSet_Configured_r14SubframeSet1_DCI_Format0_r14,
    pub subframe_set1_dci_format4_r14:
        Enable256QAM_r14_setup_tpc_SubframeSet_Configured_r14SubframeSet1_DCI_Format4_r14,
    pub subframe_set2_dci_format0_r14:
        Enable256QAM_r14_setup_tpc_SubframeSet_Configured_r14SubframeSet2_DCI_Format0_r14,
    pub subframe_set2_dci_format4_r14:
        Enable256QAM_r14_setup_tpc_SubframeSet_Configured_r14SubframeSet2_DCI_Format4_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct Enable256QAM_r14_setup_tpc_SubframeSet_NotConfigured_r14Dci_Format0_r14(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct Enable256QAM_r14_setup_tpc_SubframeSet_NotConfigured_r14Dci_Format4_r14(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Enable256QAM_r14_setup_tpc_SubframeSet_NotConfigured_r14 {
    pub dci_format0_r14: Enable256QAM_r14_setup_tpc_SubframeSet_NotConfigured_r14Dci_Format0_r14,
    pub dci_format4_r14: Enable256QAM_r14_setup_tpc_SubframeSet_NotConfigured_r14Dci_Format4_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum Enable256QAM_r14_setup {
    #[asn(key = 0, extended = false)]
    Tpc_SubframeSet_Configured_r14(Enable256QAM_r14_setup_tpc_SubframeSet_Configured_r14),
    #[asn(key = 1, extended = false)]
    Tpc_SubframeSet_NotConfigured_r14(Enable256QAM_r14_setup_tpc_SubframeSet_NotConfigured_r14),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "8589934591")]
pub struct EphemerisOrbitalParameters_r17SemiMajorAxis_r17(pub u64);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1048575")]
pub struct EphemerisOrbitalParameters_r17Eccentricity_r17(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "268435455")]
pub struct EphemerisOrbitalParameters_r17Periapsis_r17(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "268435455")]
pub struct EphemerisOrbitalParameters_r17Longitude_r17(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-67108864", ub = "67108863")]
pub struct EphemerisOrbitalParameters_r17Inclination_r17(pub i32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "268435455")]
pub struct EphemerisOrbitalParameters_r17Anomaly_r17(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct EthernetHeaderCompression_r16Ehc_Common_r16Ehc_CID_Length_r16(pub u8);
impl EthernetHeaderCompression_r16Ehc_Common_r16Ehc_CID_Length_r16 {
    pub const BITS7: u8 = 0u8;
    pub const BITS15: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EthernetHeaderCompression_r16Ehc_Common_r16 {
    pub ehc_cid_length_r16: EthernetHeaderCompression_r16Ehc_Common_r16Ehc_CID_Length_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct EthernetHeaderCompression_r16Ehc_Downlink_r16Drb_ContinueEHC_DL_r16(pub u8);
impl EthernetHeaderCompression_r16Ehc_Downlink_r16Drb_ContinueEHC_DL_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct EthernetHeaderCompression_r16Ehc_Downlink_r16 {
    #[asn(optional_idx = 0)]
    pub drb_continue_ehc_dl_r16:
        Option<EthernetHeaderCompression_r16Ehc_Downlink_r16Drb_ContinueEHC_DL_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32767")]
pub struct EthernetHeaderCompression_r16Ehc_Uplink_r16MaxCID_EHC_UL_r16(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct EthernetHeaderCompression_r16Ehc_Uplink_r16Drb_ContinueEHC_UL_r16(pub u8);
impl EthernetHeaderCompression_r16Ehc_Uplink_r16Drb_ContinueEHC_UL_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct EthernetHeaderCompression_r16Ehc_Uplink_r16 {
    pub max_cid_ehc_ul_r16: EthernetHeaderCompression_r16Ehc_Uplink_r16MaxCID_EHC_UL_r16,
    #[asn(optional_idx = 0)]
    pub drb_continue_ehc_ul_r16:
        Option<EthernetHeaderCompression_r16Ehc_Uplink_r16Drb_ContinueEHC_UL_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct EventType_r17_outOfCoverage;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EventType_r17_eventL1 {
    pub l1_threshold_r17: ThresholdEUTRA,
    pub hysteresis_r17: Hysteresis,
    pub time_to_trigger_r17: TimeToTrigger,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct ExcludedCellsToAddModCellIndex(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct FailedLogicalChannelIdentity_r16CellGroupIndication_r16(pub u8);
impl FailedLogicalChannelIdentity_r16CellGroupIndication_r16 {
    pub const MN: u8 = 0u8;
    pub const SN: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "10")]
pub struct FailedLogicalChannelIdentity_r16LogicalChannelIdentity_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "32", ub = "38")]
pub struct FailedLogicalChannelIdentity_r16LogicalChannelIdentityExt_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct FailedLogicalChannelInfo_r15FailedLogicalChannelIdentity_r15CellGroupIndication_r15(
    pub u8,
);
impl FailedLogicalChannelInfo_r15FailedLogicalChannelIdentity_r15CellGroupIndication_r15 {
    pub const MN: u8 = 0u8;
    pub const SN: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "10")]
pub struct FailedLogicalChannelInfo_r15FailedLogicalChannelIdentity_r15LogicalChannelIdentity_r15(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "32", ub = "38")]
pub struct FailedLogicalChannelInfo_r15FailedLogicalChannelIdentity_r15LogicalChannelIdentityExt_r15(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct FailedLogicalChannelInfo_r15FailedLogicalChannelIdentity_r15 {
    pub cell_group_indication_r15:
        FailedLogicalChannelInfo_r15FailedLogicalChannelIdentity_r15CellGroupIndication_r15,
    #[asn(optional_idx = 0)]
    pub logical_channel_identity_r15: Option<
        FailedLogicalChannelInfo_r15FailedLogicalChannelIdentity_r15LogicalChannelIdentity_r15,
    >,
    #[asn(optional_idx = 1)]
    pub logical_channel_identity_ext_r15: Option<
        FailedLogicalChannelInfo_r15FailedLogicalChannelIdentity_r15LogicalChannelIdentityExt_r15,
    >,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct FailedLogicalChannelInfo_r15FailureType(pub u8);
impl FailedLogicalChannelInfo_r15FailureType {
    pub const DUPLICATION: u8 = 0u8;
    pub const SPARE3: u8 = 1u8;
    pub const SPARE2: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FailureInformation_r16CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum FailureInformation_r16CriticalExtensions {
    #[asn(key = 0, extended = false)]
    FailureInformation_r16(FailureInformation_r16_IEs),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(FailureInformation_r16CriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct FailureInformation_r16_IEsFailureType_r16(pub u8);
impl FailureInformation_r16_IEsFailureType_r16 {
    pub const DUPLICATION: u8 = 0u8;
    pub const DAPS_HO_FAILURE: u8 = 1u8;
    pub const SPARE2: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FailureInformation_r16_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct FailureReportMCG_r16FailureType_r16(pub u8);
impl FailureReportMCG_r16FailureType_r16 {
    pub const T310_EXPIRY: u8 = 0u8;
    pub const RANDOM_ACCESS_PROBLEM: u8 = 1u8;
    pub const RLC_MAX_NUM_RETX: u8 = 2u8;
    pub const T312_EXPIRY: u8 = 3u8;
    pub const SPARE4: u8 = 4u8;
    pub const SPARE3: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct FailureReportMCG_r16MeasResultSCG_r16(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "6")]
pub struct FailureReportSCG_NR_r15FailureType_r15(pub u8);
impl FailureReportSCG_NR_r15FailureType_r15 {
    pub const T310_EXPIRY: u8 = 0u8;
    pub const RANDOM_ACCESS_PROBLEM: u8 = 1u8;
    pub const RLC_MAX_NUM_RETX: u8 = 2u8;
    pub const SYNCH_RECONFIG_FAILURE_SCG: u8 = 3u8;
    pub const SCG_RECONFIG_FAILURE: u8 = 4u8;
    pub const SRB3_INTEGRITY_FAILURE: u8 = 5u8;
    pub const DUMMY: u8 = 6u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct FailureReportSCG_NR_r15MeasResultSCG_r15(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct FailureReportSCG_r12FailureType_r12(pub u8);
impl FailureReportSCG_r12FailureType_r12 {
    pub const T313_EXPIRY: u8 = 0u8;
    pub const RANDOM_ACCESS_PROBLEM: u8 = 1u8;
    pub const RLC_MAX_NUM_RETX: u8 = 2u8;
    pub const SCG_CHANGE_FAILURE: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct FeMBMS_Unicast_Parameters_r14Unicast_fembmsMixedSCell_r14(pub u8);
impl FeMBMS_Unicast_Parameters_r14Unicast_fembmsMixedSCell_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct FeMBMS_Unicast_Parameters_r14EmptyUnicastRegion_r14(pub u8);
impl FeMBMS_Unicast_Parameters_r14EmptyUnicastRegion_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct FeatureSetDL_PerCC_r15FourLayerTM3_TM4_r15(pub u8);
impl FeatureSetDL_PerCC_r15FourLayerTM3_TM4_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct FeatureSetDL_PerCC_r15SupportedCSI_Proc_r15(pub u8);
impl FeatureSetDL_PerCC_r15SupportedCSI_Proc_r15 {
    pub const N1: u8 = 0u8;
    pub const N3: u8 = 1u8;
    pub const N4: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct FeatureSetDL_r15FeatureSetPerCC_ListDL_r15(pub Vec<FeatureSetDL_PerCC_Id_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct FeatureSetDL_v1550Dl_1024QAM_r15(pub u8);
impl FeatureSetDL_v1550Dl_1024QAM_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct FeatureSetUL_PerCC_r15Ul_256QAM_r15(pub u8);
impl FeatureSetUL_PerCC_r15Ul_256QAM_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct FeatureSetUL_r15FeatureSetPerCC_ListUL_r15(pub Vec<FeatureSetUL_PerCC_Id_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct FeatureSetsEUTRA_r15FeatureSetsDL_r15(pub Vec<FeatureSetDL_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct FeatureSetsEUTRA_r15FeatureSetsDL_PerCC_r15(pub Vec<FeatureSetDL_PerCC_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct FeatureSetsEUTRA_r15FeatureSetsUL_r15(pub Vec<FeatureSetUL_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct FeatureSetsEUTRA_r15FeatureSetsUL_PerCC_r15(pub Vec<FeatureSetUL_PerCC_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "20")]
pub struct FlightPathInfoReport_r15FlightPath_r15(pub Vec<WayPointLocation_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FlightPathInfoReport_r15Dummy {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "20")]
pub struct FlightPathInfoReportConfig_r15MaxWayPointNumber_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct FlightPathInfoReportConfig_r15IncludeTimeStamp_r15(pub u8);
impl FlightPathInfoReportConfig_r15IncludeTimeStamp_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "109")]
pub struct Format4_resource_r13StartingPRB_format4_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct Format4_resource_r13NumberOfPRB_format4_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "109")]
pub struct Format5_resource_r13StartingPRB_format5_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1")]
pub struct Format5_resource_r13Cdm_index_format5_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct FreqHoppingParameters_r13Dummy(pub u8);
impl FreqHoppingParameters_r13Dummy {
    pub const NB2: u8 = 0u8;
    pub const NB4: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct FreqHoppingParameters_r13Dummy2_interval_FDD_r13(pub u8);
impl FreqHoppingParameters_r13Dummy2_interval_FDD_r13 {
    pub const INT1: u8 = 0u8;
    pub const INT2: u8 = 1u8;
    pub const INT4: u8 = 2u8;
    pub const INT8: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct FreqHoppingParameters_r13Dummy2_interval_TDD_r13(pub u8);
impl FreqHoppingParameters_r13Dummy2_interval_TDD_r13 {
    pub const INT1: u8 = 0u8;
    pub const INT5: u8 = 1u8;
    pub const INT10: u8 = 2u8;
    pub const INT20: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum FreqHoppingParameters_r13Dummy2 {
    #[asn(key = 0, extended = false)]
    Interval_FDD_r13(FreqHoppingParameters_r13Dummy2_interval_FDD_r13),
    #[asn(key = 1, extended = false)]
    Interval_TDD_r13(FreqHoppingParameters_r13Dummy2_interval_TDD_r13),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct FreqHoppingParameters_r13Dummy3_interval_FDD_r13(pub u8);
impl FreqHoppingParameters_r13Dummy3_interval_FDD_r13 {
    pub const INT2: u8 = 0u8;
    pub const INT4: u8 = 1u8;
    pub const INT8: u8 = 2u8;
    pub const INT16: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct FreqHoppingParameters_r13Dummy3_interval_TDD_r13(pub u8);
impl FreqHoppingParameters_r13Dummy3_interval_TDD_r13 {
    pub const INT5: u8 = 0u8;
    pub const INT10: u8 = 1u8;
    pub const INT20: u8 = 2u8;
    pub const INT40: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum FreqHoppingParameters_r13Dummy3 {
    #[asn(key = 0, extended = false)]
    Interval_FDD_r13(FreqHoppingParameters_r13Dummy3_interval_FDD_r13),
    #[asn(key = 1, extended = false)]
    Interval_TDD_r13(FreqHoppingParameters_r13Dummy3_interval_TDD_r13),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct FreqHoppingParameters_r13Interval_ULHoppingConfigCommonModeA_r13_interval_FDD_r13(
    pub u8,
);
impl FreqHoppingParameters_r13Interval_ULHoppingConfigCommonModeA_r13_interval_FDD_r13 {
    pub const INT1: u8 = 0u8;
    pub const INT2: u8 = 1u8;
    pub const INT4: u8 = 2u8;
    pub const INT8: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct FreqHoppingParameters_r13Interval_ULHoppingConfigCommonModeA_r13_interval_TDD_r13(
    pub u8,
);
impl FreqHoppingParameters_r13Interval_ULHoppingConfigCommonModeA_r13_interval_TDD_r13 {
    pub const INT1: u8 = 0u8;
    pub const INT5: u8 = 1u8;
    pub const INT10: u8 = 2u8;
    pub const INT20: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum FreqHoppingParameters_r13Interval_ULHoppingConfigCommonModeA_r13 {
    #[asn(key = 0, extended = false)]
    Interval_FDD_r13(
        FreqHoppingParameters_r13Interval_ULHoppingConfigCommonModeA_r13_interval_FDD_r13,
    ),
    #[asn(key = 1, extended = false)]
    Interval_TDD_r13(
        FreqHoppingParameters_r13Interval_ULHoppingConfigCommonModeA_r13_interval_TDD_r13,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct FreqHoppingParameters_r13Interval_ULHoppingConfigCommonModeB_r13_interval_FDD_r13(
    pub u8,
);
impl FreqHoppingParameters_r13Interval_ULHoppingConfigCommonModeB_r13_interval_FDD_r13 {
    pub const INT2: u8 = 0u8;
    pub const INT4: u8 = 1u8;
    pub const INT8: u8 = 2u8;
    pub const INT16: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct FreqHoppingParameters_r13Interval_ULHoppingConfigCommonModeB_r13_interval_TDD_r13(
    pub u8,
);
impl FreqHoppingParameters_r13Interval_ULHoppingConfigCommonModeB_r13_interval_TDD_r13 {
    pub const INT5: u8 = 0u8;
    pub const INT10: u8 = 1u8;
    pub const INT20: u8 = 2u8;
    pub const INT40: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum FreqHoppingParameters_r13Interval_ULHoppingConfigCommonModeB_r13 {
    #[asn(key = 0, extended = false)]
    Interval_FDD_r13(
        FreqHoppingParameters_r13Interval_ULHoppingConfigCommonModeB_r13_interval_FDD_r13,
    ),
    #[asn(key = 1, extended = false)]
    Interval_TDD_r13(
        FreqHoppingParameters_r13Interval_ULHoppingConfigCommonModeB_r13_interval_TDD_r13,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct FreqHoppingParameters_r13Dummy4(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct GNSS_ID_r15Gnss_id_r15(pub u8);
impl GNSS_ID_r15Gnss_id_r15 {
    pub const GPS: u8 = 0u8;
    pub const SBAS: u8 = 1u8;
    pub const QZSS: u8 = 2u8;
    pub const GALILEO: u8 = 3u8;
    pub const GLONASS: u8 = 4u8;
    pub const BDS: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct GWUS_Config_r16GroupAlternation_r16(pub u8);
impl GWUS_Config_r16GroupAlternation_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct GWUS_Config_r16CommonSequence_r16(pub u8);
impl GWUS_Config_r16CommonSequence_r16 {
    pub const G0: u8 = 0u8;
    pub const G126: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct GWUS_GroupNarrowBandList_r16_Entry(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "31")]
pub struct GWUS_GroupsForServiceList_r16_Entry(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct GWUS_ResourceConfig_r16ResourceMappingPattern_r16_resourceLocationWithWUS(pub u8);
impl GWUS_ResourceConfig_r16ResourceMappingPattern_r16_resourceLocationWithWUS {
    pub const PRIMARY: u8 = 0u8;
    pub const SECONDARY: u8 = 1u8;
    pub const PRIMARY3_FDM: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct GWUS_ResourceConfig_r16ResourceMappingPattern_r16_resourceLocationWithoutWUS(pub u8);
impl GWUS_ResourceConfig_r16ResourceMappingPattern_r16_resourceLocationWithoutWUS {
    pub const N0: u8 = 0u8;
    pub const N2: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum GWUS_ResourceConfig_r16ResourceMappingPattern_r16 {
    #[asn(key = 0, extended = false)]
    ResourceLocationWithWUS(
        GWUS_ResourceConfig_r16ResourceMappingPattern_r16_resourceLocationWithWUS,
    ),
    #[asn(key = 1, extended = false)]
    ResourceLocationWithoutWUS(
        GWUS_ResourceConfig_r16ResourceMappingPattern_r16_resourceLocationWithoutWUS,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct GWUS_TimeParameters_r16MaxDurationFactor_r16(pub u8);
impl GWUS_TimeParameters_r16MaxDurationFactor_r16 {
    pub const ONE32TH: u8 = 0u8;
    pub const ONE16TH: u8 = 1u8;
    pub const ONE8TH: u8 = 2u8;
    pub const ONE4TH: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct GWUS_TimeParameters_r16NumPOs_r16(pub u8);
impl GWUS_TimeParameters_r16NumPOs_r16 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N4: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct GWUS_TimeParameters_r16TimeOffsetDRX_r16(pub u8);
impl GWUS_TimeParameters_r16TimeOffsetDRX_r16 {
    pub const MS40: u8 = 0u8;
    pub const MS80: u8 = 1u8;
    pub const MS160: u8 = 2u8;
    pub const MS240: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct GWUS_TimeParameters_r16TimeOffset_eDRX_Short_r16(pub u8);
impl GWUS_TimeParameters_r16TimeOffset_eDRX_Short_r16 {
    pub const MS40: u8 = 0u8;
    pub const MS80: u8 = 1u8;
    pub const MS160: u8 = 2u8;
    pub const MS240: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct GWUS_TimeParameters_r16TimeOffset_eDRX_Long_r16(pub u8);
impl GWUS_TimeParameters_r16TimeOffset_eDRX_Long_r16 {
    pub const MS1000: u8 = 0u8;
    pub const MS2000: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct GWUS_TimeParameters_r16NumDRX_CyclesRelaxed_r16(pub u8);
impl GWUS_TimeParameters_r16NumDRX_CyclesRelaxed_r16 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N4: u8 = 2u8;
    pub const N8: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct GWUS_TimeParameters_r16PowerBoost_r16(pub u8);
impl GWUS_TimeParameters_r16PowerBoost_r16 {
    pub const D_B0: u8 = 0u8;
    pub const D_B1DOT8: u8 = 1u8;
    pub const D_B3: u8 = 2u8;
    pub const D_B4DOT8: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "7")]
pub struct HandoverTargetRAT_Type(pub u8);
impl HandoverTargetRAT_Type {
    pub const UTRA: u8 = 0u8;
    pub const GERAN: u8 = 1u8;
    pub const CDMA2000_1XRTT: u8 = 2u8;
    pub const CDMA2000_HRPD: u8 = 3u8;
    pub const NR: u8 = 4u8;
    pub const EUTRA: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct HandoverTargetRAT_MessageContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "1", sz_ub = "1")]
pub struct HandoverNas_SecurityParamFromEUTRA(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct HandoverCommandCriticalExtensions_c1_spare7;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct HandoverCommandCriticalExtensions_c1_spare6;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct HandoverCommandCriticalExtensions_c1_spare5;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct HandoverCommandCriticalExtensions_c1_spare4;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct HandoverCommandCriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct HandoverCommandCriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct HandoverCommandCriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "7", extensible = false)]
pub enum HandoverCommandCriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    HandoverCommand_r8(HandoverCommand_r8_IEs),
    #[asn(key = 1, extended = false)]
    Spare7(HandoverCommandCriticalExtensions_c1_spare7),
    #[asn(key = 2, extended = false)]
    Spare6(HandoverCommandCriticalExtensions_c1_spare6),
    #[asn(key = 3, extended = false)]
    Spare5(HandoverCommandCriticalExtensions_c1_spare5),
    #[asn(key = 4, extended = false)]
    Spare4(HandoverCommandCriticalExtensions_c1_spare4),
    #[asn(key = 5, extended = false)]
    Spare3(HandoverCommandCriticalExtensions_c1_spare3),
    #[asn(key = 6, extended = false)]
    Spare2(HandoverCommandCriticalExtensions_c1_spare2),
    #[asn(key = 7, extended = false)]
    Spare1(HandoverCommandCriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverCommandCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum HandoverCommandCriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(HandoverCommandCriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(HandoverCommandCriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct HandoverCommand_r8_IEsHandoverCommandMessage(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverCommand_r8_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct HandoverFromEUTRAPreparationRequestCriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct HandoverFromEUTRAPreparationRequestCriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct HandoverFromEUTRAPreparationRequestCriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum HandoverFromEUTRAPreparationRequestCriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    HandoverFromEUTRAPreparationRequest_r8(HandoverFromEUTRAPreparationRequest_r8_IEs),
    #[asn(key = 1, extended = false)]
    Spare3(HandoverFromEUTRAPreparationRequestCriticalExtensions_c1_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(HandoverFromEUTRAPreparationRequestCriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(HandoverFromEUTRAPreparationRequestCriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverFromEUTRAPreparationRequestCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum HandoverFromEUTRAPreparationRequestCriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(HandoverFromEUTRAPreparationRequestCriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        HandoverFromEUTRAPreparationRequestCriticalExtensions_criticalExtensionsFuture,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct HandoverFromEUTRAPreparationRequest_v1020_IEsDualRxTxRedirectIndicator_r10(pub u8);
impl HandoverFromEUTRAPreparationRequest_v1020_IEsDualRxTxRedirectIndicator_r10 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverFromEUTRAPreparationRequest_v1020_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct HandoverFromEUTRAPreparationRequest_v890_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct HandoverFromEUTRAPreparationRequest_v920_IEsConcurrPrepCDMA2000_HRPD_r9(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct HandoverPreparationInformationCriticalExtensions_c1_spare7;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct HandoverPreparationInformationCriticalExtensions_c1_spare6;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct HandoverPreparationInformationCriticalExtensions_c1_spare5;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct HandoverPreparationInformationCriticalExtensions_c1_spare4;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct HandoverPreparationInformationCriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct HandoverPreparationInformationCriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct HandoverPreparationInformationCriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "7", extensible = false)]
pub enum HandoverPreparationInformationCriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    HandoverPreparationInformation_r8(HandoverPreparationInformation_r8_IEs),
    #[asn(key = 1, extended = false)]
    Spare7(HandoverPreparationInformationCriticalExtensions_c1_spare7),
    #[asn(key = 2, extended = false)]
    Spare6(HandoverPreparationInformationCriticalExtensions_c1_spare6),
    #[asn(key = 3, extended = false)]
    Spare5(HandoverPreparationInformationCriticalExtensions_c1_spare5),
    #[asn(key = 4, extended = false)]
    Spare4(HandoverPreparationInformationCriticalExtensions_c1_spare4),
    #[asn(key = 5, extended = false)]
    Spare3(HandoverPreparationInformationCriticalExtensions_c1_spare3),
    #[asn(key = 6, extended = false)]
    Spare2(HandoverPreparationInformationCriticalExtensions_c1_spare2),
    #[asn(key = 7, extended = false)]
    Spare1(HandoverPreparationInformationCriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverPreparationInformationCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum HandoverPreparationInformationCriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(HandoverPreparationInformationCriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        HandoverPreparationInformationCriticalExtensions_criticalExtensionsFuture,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct HandoverPreparationInformation_v10x0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverPreparationInformation_v13c0_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct HandoverPreparationInformation_v1430_IEsMakeBeforeBreakReq_r14(pub u8);
impl HandoverPreparationInformation_v1430_IEsMakeBeforeBreakReq_r14 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct HandoverPreparationInformation_v1540_IEsSourceRB_ConfigIntra5GC_r15(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverPreparationInformation_v1700_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "7")]
pub struct HandoverPreparationInformation_v920_IEsUe_ConfigRelease_r9(pub u8);
impl HandoverPreparationInformation_v920_IEsUe_ConfigRelease_r9 {
    pub const REL9: u8 = 0u8;
    pub const REL10: u8 = 1u8;
    pub const REL11: u8 = 2u8;
    pub const REL12: u8 = 3u8;
    pub const V10J0: u8 = 4u8;
    pub const V11E0: u8 = 5u8;
    pub const V1280: u8 = 6u8;
    pub const REL13: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct HandoverPreparationInformation_v9d0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct HandoverPreparationInformation_v9j0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct HighSpeedConfig_r14HighSpeedEnhancedMeasFlag_r14(pub u8);
impl HighSpeedConfig_r14HighSpeedEnhancedMeasFlag_r14 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct HighSpeedConfig_r14HighSpeedEnhancedDemodulationFlag_r14(pub u8);
impl HighSpeedConfig_r14HighSpeedEnhancedDemodulationFlag_r14 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct HighSpeedConfig_v1530HighSpeedMeasGapCE_ModeA_r15(pub u8);
impl HighSpeedConfig_v1530HighSpeedMeasGapCE_ModeA_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct HighSpeedConfig_v1610HighSpeedEnhMeasFlag2_r16(pub u8);
impl HighSpeedConfig_v1610HighSpeedEnhMeasFlag2_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct HighSpeedConfig_v1610HighSpeedEnhDemodFlag2_r16(pub u8);
impl HighSpeedConfig_v1610HighSpeedEnhDemodFlag2_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct HighSpeedConfigSCell_r14HighSpeedEnhancedDemodulationFlag_r14(pub u8);
impl HighSpeedConfigSCell_r14HighSpeedEnhancedDemodulationFlag_r14 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct HighSpeedEnhParameters_r14MeasurementEnhancements_r14(pub u8);
impl HighSpeedEnhParameters_r14MeasurementEnhancements_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct HighSpeedEnhParameters_r14DemodulationEnhancements_r14(pub u8);
impl HighSpeedEnhParameters_r14DemodulationEnhancements_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct HighSpeedEnhParameters_r14Prach_Enhancements_r14(pub u8);
impl HighSpeedEnhParameters_r14Prach_Enhancements_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct HighSpeedEnhParameters_v1610MeasurementEnhancementsSCell_r16(pub u8);
impl HighSpeedEnhParameters_v1610MeasurementEnhancementsSCell_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct HighSpeedEnhParameters_v1610MeasurementEnhancements2_r16(pub u8);
impl HighSpeedEnhParameters_v1610MeasurementEnhancements2_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct HighSpeedEnhParameters_v1610DemodulationEnhancements2_r16(pub u8);
impl HighSpeedEnhParameters_v1610DemodulationEnhancements2_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct HighSpeedEnhParameters_v1610InterRAT_enhancementNR_r16(pub u8);
impl HighSpeedEnhParameters_v1610InterRAT_enhancementNR_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IDC_Config_r11Idc_Indication_r11(pub u8);
impl IDC_Config_r11Idc_Indication_r11 {
    pub const SETUP: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct IDC_Config_r11AutonomousDenialParameters_r11AutonomousDenialSubframes_r11(pub u8);
impl IDC_Config_r11AutonomousDenialParameters_r11AutonomousDenialSubframes_r11 {
    pub const N2: u8 = 0u8;
    pub const N5: u8 = 1u8;
    pub const N10: u8 = 2u8;
    pub const N15: u8 = 3u8;
    pub const N20: u8 = 4u8;
    pub const N30: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct IDC_Config_r11AutonomousDenialParameters_r11AutonomousDenialValidity_r11(pub u8);
impl IDC_Config_r11AutonomousDenialParameters_r11AutonomousDenialValidity_r11 {
    pub const SF200: u8 = 0u8;
    pub const SF500: u8 = 1u8;
    pub const SF1000: u8 = 2u8;
    pub const SF2000: u8 = 3u8;
    pub const SPARE4: u8 = 4u8;
    pub const SPARE3: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IDC_Config_r11AutonomousDenialParameters_r11 {
    pub autonomous_denial_subframes_r11:
        IDC_Config_r11AutonomousDenialParameters_r11AutonomousDenialSubframes_r11,
    pub autonomous_denial_validity_r11:
        IDC_Config_r11AutonomousDenialParameters_r11AutonomousDenialValidity_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct IDC_SubframePattern_r11_subframePatternFDD_r11(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "70", sz_ub = "70")]
pub struct IDC_SubframePattern_r11_subframePatternTDD_r11_subframeConfig0_r11(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "10", sz_ub = "10")]
pub struct IDC_SubframePattern_r11_subframePatternTDD_r11_subframeConfig1_5_r11(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "60", sz_ub = "60")]
pub struct IDC_SubframePattern_r11_subframePatternTDD_r11_subframeConfig6_r11(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum IDC_SubframePattern_r11_subframePatternTDD_r11 {
    #[asn(key = 0, extended = false)]
    SubframeConfig0_r11(IDC_SubframePattern_r11_subframePatternTDD_r11_subframeConfig0_r11),
    #[asn(key = 1, extended = false)]
    SubframeConfig1_5_r11(IDC_SubframePattern_r11_subframePatternTDD_r11_subframeConfig1_5_r11),
    #[asn(key = 2, extended = false)]
    SubframeConfig6_r11(IDC_SubframePattern_r11_subframePatternTDD_r11_subframeConfig6_r11),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct IKE_Identity_r13IdI_r13(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct IP_Address_r13_ipv4_r13(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "BITSTRING",
    sz_extensible = false,
    sz_lb = "128",
    sz_ub = "128"
)]
pub struct IP_Address_r13_ipv6_r13(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct IRAT_ParametersCDMA2000_1XRTTTx_Config1XRTT(pub u8);
impl IRAT_ParametersCDMA2000_1XRTTTx_Config1XRTT {
    pub const SINGLE: u8 = 0u8;
    pub const DUAL: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct IRAT_ParametersCDMA2000_1XRTTRx_Config1XRTT(pub u8);
impl IRAT_ParametersCDMA2000_1XRTTRx_Config1XRTT {
    pub const SINGLE: u8 = 0u8;
    pub const DUAL: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersCDMA2000_1XRTT_v1020E_CSFB_dual_1XRTT_r10(pub u8);
impl IRAT_ParametersCDMA2000_1XRTT_v1020E_CSFB_dual_1XRTT_r10 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersCDMA2000_1XRTT_v920E_CSFB_1XRTT_r9(pub u8);
impl IRAT_ParametersCDMA2000_1XRTT_v920E_CSFB_1XRTT_r9 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersCDMA2000_1XRTT_v920E_CSFB_ConcPS_Mob1XRTT_r9(pub u8);
impl IRAT_ParametersCDMA2000_1XRTT_v920E_CSFB_ConcPS_Mob1XRTT_r9 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct IRAT_ParametersCDMA2000_HRPDTx_ConfigHRPD(pub u8);
impl IRAT_ParametersCDMA2000_HRPDTx_ConfigHRPD {
    pub const SINGLE: u8 = 0u8;
    pub const DUAL: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct IRAT_ParametersCDMA2000_HRPDRx_ConfigHRPD(pub u8);
impl IRAT_ParametersCDMA2000_HRPDRx_ConfigHRPD {
    pub const SINGLE: u8 = 0u8;
    pub const DUAL: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersCDMA2000_v1130Cdma2000_NW_Sharing_r11(pub u8);
impl IRAT_ParametersCDMA2000_v1130Cdma2000_NW_Sharing_r11 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct IRAT_ParametersGERANInterRAT_PS_HO_ToGERAN(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersGERAN_v920Dtm_r9(pub u8);
impl IRAT_ParametersGERAN_v920Dtm_r9 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersGERAN_v920E_RedirectionGERAN_r9(pub u8);
impl IRAT_ParametersGERAN_v920E_RedirectionGERAN_r9 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_r15En_DC_r15(pub u8);
impl IRAT_ParametersNR_r15En_DC_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_r15EventB2_r15(pub u8);
impl IRAT_ParametersNR_r15EventB2_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_v1540Eutra_5GC_HO_ToNR_FDD_FR1_r15(pub u8);
impl IRAT_ParametersNR_v1540Eutra_5GC_HO_ToNR_FDD_FR1_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_v1540Eutra_5GC_HO_ToNR_TDD_FR1_r15(pub u8);
impl IRAT_ParametersNR_v1540Eutra_5GC_HO_ToNR_TDD_FR1_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_v1540Eutra_5GC_HO_ToNR_FDD_FR2_r15(pub u8);
impl IRAT_ParametersNR_v1540Eutra_5GC_HO_ToNR_FDD_FR2_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_v1540Eutra_5GC_HO_ToNR_TDD_FR2_r15(pub u8);
impl IRAT_ParametersNR_v1540Eutra_5GC_HO_ToNR_TDD_FR2_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_v1540Eutra_EPC_HO_ToNR_FDD_FR1_r15(pub u8);
impl IRAT_ParametersNR_v1540Eutra_EPC_HO_ToNR_FDD_FR1_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_v1540Eutra_EPC_HO_ToNR_TDD_FR1_r15(pub u8);
impl IRAT_ParametersNR_v1540Eutra_EPC_HO_ToNR_TDD_FR1_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_v1540Eutra_EPC_HO_ToNR_FDD_FR2_r15(pub u8);
impl IRAT_ParametersNR_v1540Eutra_EPC_HO_ToNR_FDD_FR2_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_v1540Eutra_EPC_HO_ToNR_TDD_FR2_r15(pub u8);
impl IRAT_ParametersNR_v1540Eutra_EPC_HO_ToNR_TDD_FR2_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_v1540Ims_VoiceOverNR_FR1_r15(pub u8);
impl IRAT_ParametersNR_v1540Ims_VoiceOverNR_FR1_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_v1540Ims_VoiceOverNR_FR2_r15(pub u8);
impl IRAT_ParametersNR_v1540Ims_VoiceOverNR_FR2_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_v1540Sa_NR_r15(pub u8);
impl IRAT_ParametersNR_v1540Sa_NR_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_v1560Ng_EN_DC_r15(pub u8);
impl IRAT_ParametersNR_v1560Ng_EN_DC_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_v1570Ss_SINR_Meas_NR_FR1_r15(pub u8);
impl IRAT_ParametersNR_v1570Ss_SINR_Meas_NR_FR1_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_v1570Ss_SINR_Meas_NR_FR2_r15(pub u8);
impl IRAT_ParametersNR_v1570Ss_SINR_Meas_NR_FR2_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_v1610Nr_HO_ToEN_DC_r16(pub u8);
impl IRAT_ParametersNR_v1610Nr_HO_ToEN_DC_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_v1610Ce_EUTRA_5GC_HO_ToNR_FDD_FR1_r16(pub u8);
impl IRAT_ParametersNR_v1610Ce_EUTRA_5GC_HO_ToNR_FDD_FR1_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_v1610Ce_EUTRA_5GC_HO_ToNR_TDD_FR1_r16(pub u8);
impl IRAT_ParametersNR_v1610Ce_EUTRA_5GC_HO_ToNR_TDD_FR1_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_v1610Ce_EUTRA_5GC_HO_ToNR_FDD_FR2_r16(pub u8);
impl IRAT_ParametersNR_v1610Ce_EUTRA_5GC_HO_ToNR_FDD_FR2_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_v1610Ce_EUTRA_5GC_HO_ToNR_TDD_FR2_r16(pub u8);
impl IRAT_ParametersNR_v1610Ce_EUTRA_5GC_HO_ToNR_TDD_FR2_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_v1660ExtendedBand_n77_r16(pub u8);
impl IRAT_ParametersNR_v1660ExtendedBand_n77_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_v1700Eutra_5GC_HO_ToNR_TDD_FR2_2_r17(pub u8);
impl IRAT_ParametersNR_v1700Eutra_5GC_HO_ToNR_TDD_FR2_2_r17 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_v1700Eutra_EPC_HO_ToNR_TDD_FR2_2_r17(pub u8);
impl IRAT_ParametersNR_v1700Eutra_EPC_HO_ToNR_TDD_FR2_2_r17 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_v1700Ce_EUTRA_5GC_HO_ToNR_TDD_FR2_2_r17(pub u8);
impl IRAT_ParametersNR_v1700Ce_EUTRA_5GC_HO_ToNR_TDD_FR2_2_r17 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_v1700Ims_VoiceOverNR_FR2_2_r17(pub u8);
impl IRAT_ParametersNR_v1700Ims_VoiceOverNR_FR2_2_r17 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersNR_v1710ExtendedBand_n77_2_r17(pub u8);
impl IRAT_ParametersNR_v1710ExtendedBand_n77_2_r17 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersUTRA_TDD_v1020E_RedirectionUTRA_TDD_r10(pub u8);
impl IRAT_ParametersUTRA_TDD_v1020E_RedirectionUTRA_TDD_r10 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersUTRA_v920E_RedirectionUTRA_r9(pub u8);
impl IRAT_ParametersUTRA_v920E_RedirectionUTRA_r9 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersUTRA_v9c0VoiceOverPS_HS_UTRA_FDD_r9(pub u8);
impl IRAT_ParametersUTRA_v9c0VoiceOverPS_HS_UTRA_FDD_r9 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersUTRA_v9c0VoiceOverPS_HS_UTRA_TDD128_r9(pub u8);
impl IRAT_ParametersUTRA_v9c0VoiceOverPS_HS_UTRA_TDD128_r9 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersUTRA_v9c0Srvcc_FromUTRA_FDD_ToUTRA_FDD_r9(pub u8);
impl IRAT_ParametersUTRA_v9c0Srvcc_FromUTRA_FDD_ToUTRA_FDD_r9 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersUTRA_v9c0Srvcc_FromUTRA_FDD_ToGERAN_r9(pub u8);
impl IRAT_ParametersUTRA_v9c0Srvcc_FromUTRA_FDD_ToGERAN_r9 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersUTRA_v9c0Srvcc_FromUTRA_TDD128_ToUTRA_TDD128_r9(pub u8);
impl IRAT_ParametersUTRA_v9c0Srvcc_FromUTRA_TDD128_ToUTRA_TDD128_r9 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersUTRA_v9c0Srvcc_FromUTRA_TDD128_ToGERAN_r9(pub u8);
impl IRAT_ParametersUTRA_v9c0Srvcc_FromUTRA_TDD128_ToGERAN_r9 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IRAT_ParametersUTRA_v9h0Mfbi_UTRA_r9(pub u8);
impl IRAT_ParametersUTRA_v9h0Mfbi_UTRA_r9 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct IRAT_ParametersWLAN_r13SupportedBandListWLAN_r13(pub Vec<WLAN_BandIndicator_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct IdleModeMobilityControlInfoT320(pub u8);
impl IdleModeMobilityControlInfoT320 {
    pub const MIN5: u8 = 0u8;
    pub const MIN10: u8 = 1u8;
    pub const MIN20: u8 = 2u8;
    pub const MIN30: u8 = 3u8;
    pub const MIN60: u8 = 4u8;
    pub const MIN120: u8 = 5u8;
    pub const MIN180: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct IdleModeMobilityControlInfo_v9e0FreqPriorityListEUTRA_v9e0(
    pub Vec<FreqPriorityEUTRA_v9e0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct InDeviceCoexIndication_r11CriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct InDeviceCoexIndication_r11CriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct InDeviceCoexIndication_r11CriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum InDeviceCoexIndication_r11CriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    InDeviceCoexIndication_r11(InDeviceCoexIndication_r11_IEs),
    #[asn(key = 1, extended = false)]
    Spare3(InDeviceCoexIndication_r11CriticalExtensions_c1_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(InDeviceCoexIndication_r11CriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(InDeviceCoexIndication_r11CriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InDeviceCoexIndication_r11CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum InDeviceCoexIndication_r11CriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(InDeviceCoexIndication_r11CriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(InDeviceCoexIndication_r11CriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct InDeviceCoexIndication_r11_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct InDeviceCoexIndication_v11d0_IEsUl_CA_AssistanceInfo_r11 {
    #[asn(optional_idx = 0)]
    pub affected_carrier_freq_comb_list_r11: Option<AffectedCarrierFreqCombList_r11>,
    pub victim_system_type_r11: VictimSystemType_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct InDeviceCoexIndication_v1360_IEsHardwareSharingProblem_r13(pub u8);
impl InDeviceCoexIndication_v1360_IEsHardwareSharingProblem_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InDeviceCoexIndication_v1610_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "40", sz_ub = "40")]
pub struct InitialUE_Identity_randomValue(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "40", sz_ub = "40")]
pub struct InitialUE_Identity_5GC_r15_ng_5G_S_TMSI_Part1(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "40", sz_ub = "40")]
pub struct InitialUE_Identity_5GC_r15_randomValue(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct InterFreqBandInfoInterFreqNeedForGaps(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InterFreqCarrierFreqInfo_r12ThreshX_Q_r12 {
    pub thresh_x_high_q_r12: ReselectionThresholdQ_r9,
    pub thresh_x_low_q_r12: ReselectionThresholdQ_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct InterFreqCarrierFreqInfo_r12ReducedMeasPerformance_r12(pub u8);
impl InterFreqCarrierFreqInfo_r12ReducedMeasPerformance_r12 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct InterFreqCarrierFreqInfo_v1250ReducedMeasPerformance_r12(pub u8);
impl InterFreqCarrierFreqInfo_v1250ReducedMeasPerformance_r12 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct InterFreqCarrierFreqInfo_v1530Hsdn_Indication_r15(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct InterFreqRSTDMeasurementIndication_r10CriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct InterFreqRSTDMeasurementIndication_r10CriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct InterFreqRSTDMeasurementIndication_r10CriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum InterFreqRSTDMeasurementIndication_r10CriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    InterFreqRSTDMeasurementIndication_r10(InterFreqRSTDMeasurementIndication_r10_IEs),
    #[asn(key = 1, extended = false)]
    Spare3(InterFreqRSTDMeasurementIndication_r10CriticalExtensions_c1_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(InterFreqRSTDMeasurementIndication_r10CriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(InterFreqRSTDMeasurementIndication_r10CriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InterFreqRSTDMeasurementIndication_r10CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum InterFreqRSTDMeasurementIndication_r10CriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(InterFreqRSTDMeasurementIndication_r10CriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        InterFreqRSTDMeasurementIndication_r10CriticalExtensions_criticalExtensionsFuture,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InterFreqRSTDMeasurementIndication_r10_IEsRstd_InterFreqIndication_r10_start {
    pub rstd_inter_freq_info_list_r10: RSTD_InterFreqInfoList_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct InterFreqRSTDMeasurementIndication_r10_IEsRstd_InterFreqIndication_r10_stop;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum InterFreqRSTDMeasurementIndication_r10_IEsRstd_InterFreqIndication_r10 {
    #[asn(key = 0, extended = false)]
    Start(InterFreqRSTDMeasurementIndication_r10_IEsRstd_InterFreqIndication_r10_start),
    #[asn(key = 1, extended = false)]
    Stop(InterFreqRSTDMeasurementIndication_r10_IEsRstd_InterFreqIndication_r10_stop),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct InterFreqRSTDMeasurementIndication_r10_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InterFreqRSTDMeasurementIndication_r10_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct InterRAT_BandInfoInterRAT_NeedForGaps(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct InterRAT_BandInfoNR_r16InterRAT_NeedForGapsNR_r16(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct IntraBandContiguousCC_Info_r12FourLayerTM3_TM4_perCC_r12(pub u8);
impl IntraBandContiguousCC_Info_r12FourLayerTM3_TM4_perCC_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct IntraBandContiguousCC_Info_r12SupportedCSI_Proc_r12(pub u8);
impl IntraBandContiguousCC_Info_r12SupportedCSI_Proc_r12 {
    pub const N1: u8 = 0u8;
    pub const N3: u8 = 1u8;
    pub const N4: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LAA_Parameters_r13CrossCarrierSchedulingLAA_DL_r13(pub u8);
impl LAA_Parameters_r13CrossCarrierSchedulingLAA_DL_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LAA_Parameters_r13Csi_RS_DRS_RRM_MeasurementsLAA_r13(pub u8);
impl LAA_Parameters_r13Csi_RS_DRS_RRM_MeasurementsLAA_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LAA_Parameters_r13DownlinkLAA_r13(pub u8);
impl LAA_Parameters_r13DownlinkLAA_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LAA_Parameters_r13EndingDwPTS_r13(pub u8);
impl LAA_Parameters_r13EndingDwPTS_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LAA_Parameters_r13SecondSlotStartingPosition_r13(pub u8);
impl LAA_Parameters_r13SecondSlotStartingPosition_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LAA_Parameters_r13Tm9_LAA_r13(pub u8);
impl LAA_Parameters_r13Tm9_LAA_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LAA_Parameters_r13Tm10_LAA_r13(pub u8);
impl LAA_Parameters_r13Tm10_LAA_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LAA_Parameters_v1430CrossCarrierSchedulingLAA_UL_r14(pub u8);
impl LAA_Parameters_v1430CrossCarrierSchedulingLAA_UL_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LAA_Parameters_v1430UplinkLAA_r14(pub u8);
impl LAA_Parameters_v1430UplinkLAA_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct LAA_Parameters_v1430TwoStepSchedulingTimingInfo_r14(pub u8);
impl LAA_Parameters_v1430TwoStepSchedulingTimingInfo_r14 {
    pub const N_PLUS1: u8 = 0u8;
    pub const N_PLUS2: u8 = 1u8;
    pub const N_PLUS3: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LAA_Parameters_v1430Uss_BlindDecodingAdjustment_r14(pub u8);
impl LAA_Parameters_v1430Uss_BlindDecodingAdjustment_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LAA_Parameters_v1430Uss_BlindDecodingReduction_r14(pub u8);
impl LAA_Parameters_v1430Uss_BlindDecodingReduction_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LAA_Parameters_v1430OutOfSequenceGrantHandling_r14(pub u8);
impl LAA_Parameters_v1430OutOfSequenceGrantHandling_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LAA_Parameters_v1530Aul_r15(pub u8);
impl LAA_Parameters_v1530Aul_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LAA_Parameters_v1530Laa_PUSCH_Mode1_r15(pub u8);
impl LAA_Parameters_v1530Laa_PUSCH_Mode1_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LAA_Parameters_v1530Laa_PUSCH_Mode2_r15(pub u8);
impl LAA_Parameters_v1530Laa_PUSCH_Mode2_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LAA_Parameters_v1530Laa_PUSCH_Mode3_r15(pub u8);
impl LAA_Parameters_v1530Laa_PUSCH_Mode3_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct LAA_SCellConfiguration_r13SubframeStartPosition_r13(pub u8);
impl LAA_SCellConfiguration_r13SubframeStartPosition_r13 {
    pub const S0: u8 = 0u8;
    pub const S07: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct LAA_SCellConfiguration_r13Laa_SCellSubframeConfig_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct LAA_SCellConfiguration_v1430CrossCarrierSchedulingConfig_UL_r14_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LAA_SCellConfiguration_v1430CrossCarrierSchedulingConfig_UL_r14_setup {
    pub cross_carrier_scheduling_config_laa_ul_r14: CrossCarrierSchedulingConfigLAA_UL_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum LAA_SCellConfiguration_v1430CrossCarrierSchedulingConfig_UL_r14 {
    #[asn(key = 0, extended = false)]
    Release(LAA_SCellConfiguration_v1430CrossCarrierSchedulingConfig_UL_r14_release),
    #[asn(key = 1, extended = false)]
    Setup(LAA_SCellConfiguration_v1430CrossCarrierSchedulingConfig_UL_r14_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LAA_SCellConfiguration_v1430AbsenceOfAnyOtherTechnology_r14(pub u8);
impl LAA_SCellConfiguration_v1430AbsenceOfAnyOtherTechnology_r14 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-85", ub = "-52")]
pub struct LBT_Config_r14_maxEnergyDetectionThreshold_r14(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-13", ub = "20")]
pub struct LBT_Config_r14_energyDetectionThresholdOffset_r14(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct LWA_Config_r13Lwa_WT_Counter_r13(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct LWA_Configuration_r13_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LWA_Configuration_r13_setup {
    pub lwa_config_r13: LWA_Config_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LWA_Parameters_r13Lwa_r13(pub u8);
impl LWA_Parameters_r13Lwa_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LWA_Parameters_r13Lwa_SplitBearer_r13(pub u8);
impl LWA_Parameters_r13Lwa_SplitBearer_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "6", sz_ub = "6")]
pub struct LWA_Parameters_r13Wlan_MAC_Address_r13(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LWA_Parameters_r13Lwa_BufferSize_r13(pub u8);
impl LWA_Parameters_r13Lwa_BufferSize_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LWA_Parameters_v1430Lwa_HO_WithoutWT_Change_r14(pub u8);
impl LWA_Parameters_v1430Lwa_HO_WithoutWT_Change_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LWA_Parameters_v1430Lwa_UL_r14(pub u8);
impl LWA_Parameters_v1430Lwa_UL_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LWA_Parameters_v1430Wlan_PeriodicMeas_r14(pub u8);
impl LWA_Parameters_v1430Wlan_PeriodicMeas_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LWA_Parameters_v1430Wlan_ReportAnyWLAN_r14(pub u8);
impl LWA_Parameters_v1430Wlan_ReportAnyWLAN_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "2048")]
pub struct LWA_Parameters_v1430Wlan_SupportedDataRate_r14(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LWA_Parameters_v1440Lwa_RLC_UM_r14(pub u8);
impl LWA_Parameters_v1440Lwa_RLC_UM_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct LWIP_Configuration_r13_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LWIP_Configuration_r13_setup {
    pub lwip_config_r13: LWIP_Config_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LWIP_Parameters_r13Lwip_r13(pub u8);
impl LWIP_Parameters_r13Lwip_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LWIP_Parameters_v1430Lwip_Aggregation_DL_r14(pub u8);
impl LWIP_Parameters_v1430Lwip_Aggregation_DL_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LWIP_Parameters_v1430Lwip_Aggregation_UL_r14(pub u8);
impl LWIP_Parameters_v1430Lwip_Aggregation_UL_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct LocationInfo_r10LocationCoordinates_r10_ellipsoid_Point_r10(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct LocationInfo_r10LocationCoordinates_r10_ellipsoidPointWithAltitude_r10(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct LocationInfo_r10LocationCoordinates_r10_ellipsoidPointWithUncertaintyCircle_r11(
    pub Vec<u8>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct LocationInfo_r10LocationCoordinates_r10_ellipsoidPointWithUncertaintyEllipse_r11(
    pub Vec<u8>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct LocationInfo_r10LocationCoordinates_r10_ellipsoidPointWithAltitudeAndUncertaintyEllipsoid_r11(
    pub Vec<u8>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct LocationInfo_r10LocationCoordinates_r10_ellipsoidArc_r11(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct LocationInfo_r10LocationCoordinates_r10_polygon_r11(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum LocationInfo_r10LocationCoordinates_r10 {
    # [asn (key = 0 , extended = false)] Ellipsoid_Point_r10 (LocationInfo_r10LocationCoordinates_r10_ellipsoid_Point_r10) , # [asn (key = 1 , extended = false)] EllipsoidPointWithAltitude_r10 (LocationInfo_r10LocationCoordinates_r10_ellipsoidPointWithAltitude_r10) , # [asn (key = 0 , extended = true)] EllipsoidPointWithUncertaintyCircle_r11 (LocationInfo_r10LocationCoordinates_r10_ellipsoidPointWithUncertaintyCircle_r11) , # [asn (key = 1 , extended = true)] EllipsoidPointWithUncertaintyEllipse_r11 (LocationInfo_r10LocationCoordinates_r10_ellipsoidPointWithUncertaintyEllipse_r11) , # [asn (key = 2 , extended = true)] EllipsoidPointWithAltitudeAndUncertaintyEllipsoid_r11 (LocationInfo_r10LocationCoordinates_r10_ellipsoidPointWithAltitudeAndUncertaintyEllipsoid_r11) , # [asn (key = 3 , extended = true)] EllipsoidArc_r11 (LocationInfo_r10LocationCoordinates_r10_ellipsoidArc_r11) , # [asn (key = 4 , extended = true)] Polygon_r11 (LocationInfo_r10LocationCoordinates_r10_polygon_r11) , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct LocationInfo_r10HorizontalVelocity_r10(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct LocationInfo_r10Gnss_TOD_msec_r10(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7200")]
pub struct LogMeasInfo_r10RelativeTimeStamp_r10(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LogMeasInfo_r10MeasResultServCell_r10 {
    pub rsrp_result_r10: RSRP_Range,
    pub rsrq_result_r10: RSRQ_Range,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct LogMeasInfo_r10MeasResultNeighCells_r10 {
    #[asn(optional_idx = 0)]
    pub meas_result_list_eutra_r10: Option<MeasResultList2EUTRA_r9>,
    #[asn(optional_idx = 1)]
    pub meas_result_list_utra_r10: Option<MeasResultList2UTRA_r9>,
    #[asn(optional_idx = 2)]
    pub meas_result_list_geran_r10: Option<MeasResultList2GERAN_r10>,
    #[asn(optional_idx = 3)]
    pub meas_result_list_cdma2000_r10: Option<MeasResultList2CDMA2000_r9>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct LogMeasReport_r10TraceRecordingSessionRef_r10(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "1", sz_ub = "1")]
pub struct LogMeasReport_r10Tce_Id_r10(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LogMeasReport_r10LogMeasAvailable_r10(pub u8);
impl LogMeasReport_r10LogMeasAvailable_r10 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "48", sz_ub = "48")]
pub struct LogMeasResultBT_r15Bt_Addr_r15(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-128", ub = "127")]
pub struct LogMeasResultBT_r15Rssi_BT_r15(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct LoggedMeasurementConfiguration_r10CriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct LoggedMeasurementConfiguration_r10CriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct LoggedMeasurementConfiguration_r10CriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum LoggedMeasurementConfiguration_r10CriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    LoggedMeasurementConfiguration_r10(LoggedMeasurementConfiguration_r10_IEs),
    #[asn(key = 1, extended = false)]
    Spare3(LoggedMeasurementConfiguration_r10CriticalExtensions_c1_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(LoggedMeasurementConfiguration_r10CriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(LoggedMeasurementConfiguration_r10CriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LoggedMeasurementConfiguration_r10CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum LoggedMeasurementConfiguration_r10CriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(LoggedMeasurementConfiguration_r10CriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        LoggedMeasurementConfiguration_r10CriticalExtensions_criticalExtensionsFuture,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct LoggedMeasurementConfiguration_r10_IEsTraceRecordingSessionRef_r10(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "1", sz_ub = "1")]
pub struct LoggedMeasurementConfiguration_r10_IEsTce_Id_r10(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct LoggedMeasurementConfiguration_v1080_IEsLateNonCriticalExtension_r10(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct LoggedMeasurementConfiguration_v1700_IEsMeasUncomBarPre_r17(pub u8);
impl LoggedMeasurementConfiguration_v1700_IEsMeasUncomBarPre_r17 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LoggedMeasurementConfiguration_v1700_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct LogicalChannelConfigUl_SpecificParametersPriority(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct LogicalChannelConfigUl_SpecificParametersPrioritisedBitRate(pub u8);
impl LogicalChannelConfigUl_SpecificParametersPrioritisedBitRate {
    pub const K_BPS0: u8 = 0u8;
    pub const K_BPS8: u8 = 1u8;
    pub const K_BPS16: u8 = 2u8;
    pub const K_BPS32: u8 = 3u8;
    pub const K_BPS64: u8 = 4u8;
    pub const K_BPS128: u8 = 5u8;
    pub const K_BPS256: u8 = 6u8;
    pub const INFINITY: u8 = 7u8;
    pub const K_BPS512_V1020: u8 = 8u8;
    pub const K_BPS1024_V1020: u8 = 9u8;
    pub const K_BPS2048_V1020: u8 = 10u8;
    pub const SPARE5: u8 = 11u8;
    pub const SPARE4: u8 = 12u8;
    pub const SPARE3: u8 = 13u8;
    pub const SPARE2: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct LogicalChannelConfigUl_SpecificParametersBucketSizeDuration(pub u8);
impl LogicalChannelConfigUl_SpecificParametersBucketSizeDuration {
    pub const MS50: u8 = 0u8;
    pub const MS100: u8 = 1u8;
    pub const MS150: u8 = 2u8;
    pub const MS300: u8 = 3u8;
    pub const MS500: u8 = 4u8;
    pub const MS1000: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct LogicalChannelConfigUl_SpecificParametersLogicalChannelGroup(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct LogicalChannelConfigUl_SpecificParameters {
    pub priority: LogicalChannelConfigUl_SpecificParametersPriority,
    pub prioritised_bit_rate: LogicalChannelConfigUl_SpecificParametersPrioritisedBitRate,
    pub bucket_size_duration: LogicalChannelConfigUl_SpecificParametersBucketSizeDuration,
    #[asn(optional_idx = 0)]
    pub logical_channel_group: Option<LogicalChannelConfigUl_SpecificParametersLogicalChannelGroup>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct MAC_MainConfigUl_SCH_ConfigMaxHARQ_Tx(pub u8);
impl MAC_MainConfigUl_SCH_ConfigMaxHARQ_Tx {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N3: u8 = 2u8;
    pub const N4: u8 = 3u8;
    pub const N5: u8 = 4u8;
    pub const N6: u8 = 5u8;
    pub const N7: u8 = 6u8;
    pub const N8: u8 = 7u8;
    pub const N10: u8 = 8u8;
    pub const N12: u8 = 9u8;
    pub const N16: u8 = 10u8;
    pub const N20: u8 = 11u8;
    pub const N24: u8 = 12u8;
    pub const N28: u8 = 13u8;
    pub const SPARE2: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct MAC_MainConfigUl_SCH_ConfigTtiBundling(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MAC_MainConfigUl_SCH_Config {
    #[asn(optional_idx = 0)]
    pub max_harq_tx: Option<MAC_MainConfigUl_SCH_ConfigMaxHARQ_Tx>,
    #[asn(optional_idx = 1)]
    pub periodic_bsr_timer: Option<PeriodicBSR_Timer_r12>,
    pub retx_bsr_timer: RetxBSR_Timer_r12,
    pub tti_bundling: MAC_MainConfigUl_SCH_ConfigTtiBundling,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct MAC_MainConfigPhr_Config_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct MAC_MainConfigPhr_Config_setupPeriodicPHR_Timer(pub u8);
impl MAC_MainConfigPhr_Config_setupPeriodicPHR_Timer {
    pub const SF10: u8 = 0u8;
    pub const SF20: u8 = 1u8;
    pub const SF50: u8 = 2u8;
    pub const SF100: u8 = 3u8;
    pub const SF200: u8 = 4u8;
    pub const SF500: u8 = 5u8;
    pub const SF1000: u8 = 6u8;
    pub const INFINITY: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct MAC_MainConfigPhr_Config_setupProhibitPHR_Timer(pub u8);
impl MAC_MainConfigPhr_Config_setupProhibitPHR_Timer {
    pub const SF0: u8 = 0u8;
    pub const SF10: u8 = 1u8;
    pub const SF20: u8 = 2u8;
    pub const SF50: u8 = 3u8;
    pub const SF100: u8 = 4u8;
    pub const SF200: u8 = 5u8;
    pub const SF500: u8 = 6u8;
    pub const SF1000: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct MAC_MainConfigPhr_Config_setupDl_PathlossChange(pub u8);
impl MAC_MainConfigPhr_Config_setupDl_PathlossChange {
    pub const D_B1: u8 = 0u8;
    pub const D_B3: u8 = 1u8;
    pub const D_B6: u8 = 2u8;
    pub const INFINITY: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MAC_MainConfigPhr_Config_setup {
    pub periodic_phr_timer: MAC_MainConfigPhr_Config_setupPeriodicPHR_Timer,
    pub prohibit_phr_timer: MAC_MainConfigPhr_Config_setupProhibitPHR_Timer,
    pub dl_pathloss_change: MAC_MainConfigPhr_Config_setupDl_PathlossChange,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MAC_MainConfigPhr_Config {
    #[asn(key = 0, extended = false)]
    Release(MAC_MainConfigPhr_Config_release),
    #[asn(key = 1, extended = false)]
    Setup(MAC_MainConfigPhr_Config_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MAC_Parameters_r12LogicalChannelSR_ProhibitTimer_r12(pub u8);
impl MAC_Parameters_r12LogicalChannelSR_ProhibitTimer_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MAC_Parameters_r12LongDRX_Command_r12(pub u8);
impl MAC_Parameters_r12LongDRX_Command_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MAC_Parameters_v1310ExtendedMAC_LengthField_r13(pub u8);
impl MAC_Parameters_v1310ExtendedMAC_LengthField_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MAC_Parameters_v1310ExtendedLongDRX_r13(pub u8);
impl MAC_Parameters_v1310ExtendedLongDRX_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MAC_Parameters_v1430ShortSPS_IntervalFDD_r14(pub u8);
impl MAC_Parameters_v1430ShortSPS_IntervalFDD_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MAC_Parameters_v1430ShortSPS_IntervalTDD_r14(pub u8);
impl MAC_Parameters_v1430ShortSPS_IntervalTDD_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MAC_Parameters_v1430SkipUplinkDynamic_r14(pub u8);
impl MAC_Parameters_v1430SkipUplinkDynamic_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MAC_Parameters_v1430SkipUplinkSPS_r14(pub u8);
impl MAC_Parameters_v1430SkipUplinkSPS_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MAC_Parameters_v1430MultipleUplinkSPS_r14(pub u8);
impl MAC_Parameters_v1430MultipleUplinkSPS_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MAC_Parameters_v1430DataInactMon_r14(pub u8);
impl MAC_Parameters_v1430DataInactMon_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MAC_Parameters_v1440Rai_Support_r14(pub u8);
impl MAC_Parameters_v1440Rai_Support_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct MAC_Parameters_v1530Min_Proc_TimelineSubslot_r15(pub Vec<ProcessingTimelineSet_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MAC_Parameters_v1530EarlyData_UP_r15(pub u8);
impl MAC_Parameters_v1530EarlyData_UP_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MAC_Parameters_v1530DormantSCellState_r15(pub u8);
impl MAC_Parameters_v1530DormantSCellState_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MAC_Parameters_v1530DirectSCellActivation_r15(pub u8);
impl MAC_Parameters_v1530DirectSCellActivation_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MAC_Parameters_v1530DirectSCellHibernation_r15(pub u8);
impl MAC_Parameters_v1530DirectSCellHibernation_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MAC_Parameters_v1530ExtendedLCID_Duplication_r15(pub u8);
impl MAC_Parameters_v1530ExtendedLCID_Duplication_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MAC_Parameters_v1530Sps_ServingCell_r15(pub u8);
impl MAC_Parameters_v1530Sps_ServingCell_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MAC_Parameters_v1550ELCID_Support_r15(pub u8);
impl MAC_Parameters_v1550ELCID_Support_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MAC_Parameters_v1610DirectMCG_SCellActivationResume_r16(pub u8);
impl MAC_Parameters_v1610DirectMCG_SCellActivationResume_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MAC_Parameters_v1610DirectSCG_SCellActivationResume_r16(pub u8);
impl MAC_Parameters_v1610DirectSCG_SCellActivationResume_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MAC_Parameters_v1610EarlyData_UP_5GC_r16(pub u8);
impl MAC_Parameters_v1610EarlyData_UP_5GC_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MAC_Parameters_v1610Rai_SupportEnh_r16(pub u8);
impl MAC_Parameters_v1610Rai_SupportEnh_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MAC_Parameters_v1630DirectSCG_SCellActivationNEDC_r16(pub u8);
impl MAC_Parameters_v1630DirectSCG_SCellActivationNEDC_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct MBMS_CarrierType_r14CarrierType_r14(pub u8);
impl MBMS_CarrierType_r14CarrierType_r14 {
    pub const MBMS: u8 = 0u8;
    pub const FEMBMS_MIXED: u8 = 1u8;
    pub const FEMBMS_DEDICATED: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct MBMS_CarrierType_r14FrameOffset_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct MBMS_NotificationConfig_r9NotificationRepetitionCoeff_r9(pub u8);
impl MBMS_NotificationConfig_r9NotificationRepetitionCoeff_r9 {
    pub const N2: u8 = 0u8;
    pub const N4: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "10")]
pub struct MBMS_NotificationConfig_r9NotificationOffset_r9(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "6")]
pub struct MBMS_NotificationConfig_r9NotificationSF_Index_r9(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "7", ub = "10")]
pub struct MBMS_NotificationConfig_v1430NotificationSF_Index_v1430(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MBMS_Parameters_r11Mbms_SCell_r11(pub u8);
impl MBMS_Parameters_r11Mbms_SCell_r11 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MBMS_Parameters_r11Mbms_NonServingCell_r11(pub u8);
impl MBMS_Parameters_r11Mbms_NonServingCell_r11 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MBMS_Parameters_v1250Mbms_AsyncDC_r12(pub u8);
impl MBMS_Parameters_v1250Mbms_AsyncDC_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MBMS_Parameters_v1430FembmsDedicatedCell_r14(pub u8);
impl MBMS_Parameters_v1430FembmsDedicatedCell_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MBMS_Parameters_v1430FembmsMixedCell_r14(pub u8);
impl MBMS_Parameters_v1430FembmsMixedCell_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MBMS_Parameters_v1430SubcarrierSpacingMBMS_khz7dot5_r14(pub u8);
impl MBMS_Parameters_v1430SubcarrierSpacingMBMS_khz7dot5_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MBMS_Parameters_v1430SubcarrierSpacingMBMS_khz1dot25_r14(pub u8);
impl MBMS_Parameters_v1430SubcarrierSpacingMBMS_khz1dot25_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct MBMS_Parameters_v1470Mbms_MaxBW_r14_implicitValue;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "2", ub = "20")]
pub struct MBMS_Parameters_v1470Mbms_MaxBW_r14_explicitValue(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MBMS_Parameters_v1470Mbms_MaxBW_r14 {
    #[asn(key = 0, extended = false)]
    ImplicitValue(MBMS_Parameters_v1470Mbms_MaxBW_r14_implicitValue),
    #[asn(key = 1, extended = false)]
    ExplicitValue(MBMS_Parameters_v1470Mbms_MaxBW_r14_explicitValue),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct MBMS_Parameters_v1470Mbms_ScalingFactor1dot25_r14(pub u8);
impl MBMS_Parameters_v1470Mbms_ScalingFactor1dot25_r14 {
    pub const N3: u8 = 0u8;
    pub const N6: u8 = 1u8;
    pub const N9: u8 = 2u8;
    pub const N12: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct MBMS_Parameters_v1470Mbms_ScalingFactor7dot5_r14(pub u8);
impl MBMS_Parameters_v1470Mbms_ScalingFactor7dot5_r14 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N3: u8 = 2u8;
    pub const N4: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct MBMS_Parameters_v1610Mbms_ScalingFactor2dot5_r16(pub u8);
impl MBMS_Parameters_v1610Mbms_ScalingFactor2dot5_r16 {
    pub const N2: u8 = 0u8;
    pub const N4: u8 = 1u8;
    pub const N6: u8 = 2u8;
    pub const N8: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct MBMS_Parameters_v1610Mbms_ScalingFactor0dot37_r16(pub u8);
impl MBMS_Parameters_v1610Mbms_ScalingFactor0dot37_r16 {
    pub const N12: u8 = 0u8;
    pub const N16: u8 = 1u8;
    pub const N20: u8 = 2u8;
    pub const N24: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct MBMS_Parameters_v1610Mbms_SupportedBandInfoList_r16(pub Vec<MBMS_SupportedBandInfo_r16>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct MBMS_Parameters_v1700Mbms_SupportedBandInfoList_v1700(
    pub Vec<MBMS_SupportedBandInfo_v1700>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct MBMS_ROM_Info_r15Mbms_ROM_SubcarrierSpacing_r15(pub u8);
impl MBMS_ROM_Info_r15Mbms_ROM_SubcarrierSpacing_r15 {
    pub const K_HZ15: u8 = 0u8;
    pub const K_HZ7DOT5: u8 = 1u8;
    pub const K_HZ1DOT25: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct MBMS_ROM_Info_r15Mbms_Bandwidth_r15(pub u8);
impl MBMS_ROM_Info_r15Mbms_Bandwidth_r15 {
    pub const N6: u8 = 0u8;
    pub const N15: u8 = 1u8;
    pub const N25: u8 = 2u8;
    pub const N50: u8 = 3u8;
    pub const N75: u8 = 4u8;
    pub const N100: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct MBMS_ROM_Info_r16Mbms_ROM_SubcarrierSpacing_r16(pub u8);
impl MBMS_ROM_Info_r16Mbms_ROM_SubcarrierSpacing_r16 {
    pub const K_HZ2DOT5: u8 = 0u8;
    pub const K_HZ0DOT37: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct MBMS_ROM_Info_r16Mbms_Bandwidth_r16(pub u8);
impl MBMS_ROM_Info_r16Mbms_Bandwidth_r16 {
    pub const N6: u8 = 0u8;
    pub const N15: u8 = 1u8;
    pub const N25: u8 = 2u8;
    pub const N50: u8 = 3u8;
    pub const N75: u8 = 4u8;
    pub const N100: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "1", sz_ub = "1")]
pub struct MBMS_SessionInfo_r9SessionId_r9(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "28")]
pub struct MBMS_SessionInfo_r9LogicalChannelIdentity_r9(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MBMS_SupportedBandInfo_r16SubcarrierSpacingMBMS_khz2dot5_r16(pub u8);
impl MBMS_SupportedBandInfo_r16SubcarrierSpacingMBMS_khz2dot5_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MBMS_SupportedBandInfo_r16SubcarrierSpacingMBMS_khz0dot37_r16TimeSeparationSlot2_r16(
    pub u8,
);
impl MBMS_SupportedBandInfo_r16SubcarrierSpacingMBMS_khz0dot37_r16TimeSeparationSlot2_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MBMS_SupportedBandInfo_r16SubcarrierSpacingMBMS_khz0dot37_r16TimeSeparationSlot4_r16(
    pub u8,
);
impl MBMS_SupportedBandInfo_r16SubcarrierSpacingMBMS_khz0dot37_r16TimeSeparationSlot4_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MBMS_SupportedBandInfo_r16SubcarrierSpacingMBMS_khz0dot37_r16 {
    #[asn(optional_idx = 0)]
    pub time_separation_slot2_r16: Option<
        MBMS_SupportedBandInfo_r16SubcarrierSpacingMBMS_khz0dot37_r16TimeSeparationSlot2_r16,
    >,
    #[asn(optional_idx = 1)]
    pub time_separation_slot4_r16: Option<
        MBMS_SupportedBandInfo_r16SubcarrierSpacingMBMS_khz0dot37_r16TimeSeparationSlot4_r16,
    >,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MBMS_SupportedBandInfo_v1700Pmch_Bandwidth_n40_r17(pub u8);
impl MBMS_SupportedBandInfo_v1700Pmch_Bandwidth_n40_r17 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MBMS_SupportedBandInfo_v1700Pmch_Bandwidth_n35_r17(pub u8);
impl MBMS_SupportedBandInfo_v1700Pmch_Bandwidth_n35_r17 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MBMS_SupportedBandInfo_v1700Pmch_Bandwidth_n30_r17(pub u8);
impl MBMS_SupportedBandInfo_v1700Pmch_Bandwidth_n30_r17 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct MBMSCountingRequest_r10LateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MBMSCountingRequest_r10NonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct MBMSCountingResponse_r10CriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct MBMSCountingResponse_r10CriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct MBMSCountingResponse_r10CriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum MBMSCountingResponse_r10CriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    CountingResponse_r10(MBMSCountingResponse_r10_IEs),
    #[asn(key = 1, extended = false)]
    Spare3(MBMSCountingResponse_r10CriticalExtensions_c1_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(MBMSCountingResponse_r10CriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(MBMSCountingResponse_r10CriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MBMSCountingResponse_r10CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MBMSCountingResponse_r10CriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(MBMSCountingResponse_r10CriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(MBMSCountingResponse_r10CriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct MBMSCountingResponse_r10_IEsMbsfn_AreaIndex_r10(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct MBMSCountingResponse_r10_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MBMSCountingResponse_r10_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct MBMSInterestIndication_r11CriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct MBMSInterestIndication_r11CriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct MBMSInterestIndication_r11CriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum MBMSInterestIndication_r11CriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    InterestIndication_r11(MBMSInterestIndication_r11_IEs),
    #[asn(key = 1, extended = false)]
    Spare3(MBMSInterestIndication_r11CriticalExtensions_c1_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(MBMSInterestIndication_r11CriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(MBMSInterestIndication_r11CriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MBMSInterestIndication_r11CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MBMSInterestIndication_r11CriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(MBMSInterestIndication_r11CriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(MBMSInterestIndication_r11CriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MBMSInterestIndication_r11_IEsMbms_Priority_r11(pub u8);
impl MBMSInterestIndication_r11_IEsMbms_Priority_r11 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct MBMSInterestIndication_r11_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "15")]
pub struct MBMSInterestIndication_v1540_IEsMbms_ROM_InfoList_r15(pub Vec<MBMS_ROM_Info_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "15")]
pub struct MBMSInterestIndication_v1610_IEsMbms_ROM_InfoList_r16(pub Vec<MBMS_ROM_Info_r16>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MBMSInterestIndication_v1610_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "1", sz_ub = "1")]
pub struct MBMSSessionInfo_r13SessionId_r13(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct MBSFN_AreaInfo_r16NotificationIndicator_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct MBSFN_AreaInfo_r16Mcch_Config_r16Mcch_RepetitionPeriod_r16(pub u8);
impl MBSFN_AreaInfo_r16Mcch_Config_r16Mcch_RepetitionPeriod_r16 {
    pub const RF1: u8 = 0u8;
    pub const RF2: u8 = 1u8;
    pub const RF4: u8 = 2u8;
    pub const RF8: u8 = 3u8;
    pub const RF16: u8 = 4u8;
    pub const RF32: u8 = 5u8;
    pub const RF64: u8 = 6u8;
    pub const RF128: u8 = 7u8;
    pub const RF256: u8 = 8u8;
    pub const SPARE7: u8 = 9u8;
    pub const SPARE6: u8 = 10u8;
    pub const SPARE5: u8 = 11u8;
    pub const SPARE4: u8 = 12u8;
    pub const SPARE3: u8 = 13u8;
    pub const SPARE2: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct MBSFN_AreaInfo_r16Mcch_Config_r16Mcch_ModificationPeriod_r16(pub u8);
impl MBSFN_AreaInfo_r16Mcch_Config_r16Mcch_ModificationPeriod_r16 {
    pub const RF1: u8 = 0u8;
    pub const RF2: u8 = 1u8;
    pub const RF4: u8 = 2u8;
    pub const RF8: u8 = 3u8;
    pub const RF16: u8 = 4u8;
    pub const RF32: u8 = 5u8;
    pub const RF64: u8 = 6u8;
    pub const RF128: u8 = 7u8;
    pub const RF256: u8 = 8u8;
    pub const RF512: u8 = 9u8;
    pub const RF1024: u8 = 10u8;
    pub const SPARE5: u8 = 11u8;
    pub const SPARE4: u8 = 12u8;
    pub const SPARE3: u8 = 13u8;
    pub const SPARE2: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "10")]
pub struct MBSFN_AreaInfo_r16Mcch_Config_r16Mcch_Offset_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "10", sz_ub = "10")]
pub struct MBSFN_AreaInfo_r16Mcch_Config_r16Sf_AllocInfo_r16(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct MBSFN_AreaInfo_r16Mcch_Config_r16SignallingMCS_r16(pub u8);
impl MBSFN_AreaInfo_r16Mcch_Config_r16SignallingMCS_r16 {
    pub const N2: u8 = 0u8;
    pub const N7: u8 = 1u8;
    pub const N13: u8 = 2u8;
    pub const N19: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MBSFN_AreaInfo_r16Mcch_Config_r16 {
    pub mcch_repetition_period_r16: MBSFN_AreaInfo_r16Mcch_Config_r16Mcch_RepetitionPeriod_r16,
    pub mcch_modification_period_r16: MBSFN_AreaInfo_r16Mcch_Config_r16Mcch_ModificationPeriod_r16,
    pub mcch_offset_r16: MBSFN_AreaInfo_r16Mcch_Config_r16Mcch_Offset_r16,
    pub sf_alloc_info_r16: MBSFN_AreaInfo_r16Mcch_Config_r16Sf_AllocInfo_r16,
    pub signalling_mcs_r16: MBSFN_AreaInfo_r16Mcch_Config_r16SignallingMCS_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct MBSFN_AreaInfo_r16SubcarrierSpacingMBMS_r16(pub u8);
impl MBSFN_AreaInfo_r16SubcarrierSpacingMBMS_r16 {
    pub const K_HZ7DOT5: u8 = 0u8;
    pub const K_HZ2DOT5: u8 = 1u8;
    pub const K_HZ1DOT25: u8 = 2u8;
    pub const K_HZ0DOT37: u8 = 3u8;
    pub const K_HZ15_V1710: u8 = 4u8;
    pub const SPARE3: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct MBSFN_AreaInfo_r16TimeSeparation_r16(pub u8);
impl MBSFN_AreaInfo_r16TimeSeparation_r16 {
    pub const SL2: u8 = 0u8;
    pub const SL4: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct MBSFN_AreaInfo_r17Pmch_Bandwidth_r17(pub u8);
impl MBSFN_AreaInfo_r17Pmch_Bandwidth_r17 {
    pub const N40: u8 = 0u8;
    pub const N35: u8 = 1u8;
    pub const N30: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct MBSFN_AreaInfo_r9Non_MBSFNregionLength(pub u8);
impl MBSFN_AreaInfo_r9Non_MBSFNregionLength {
    pub const S1: u8 = 0u8;
    pub const S2: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct MBSFN_AreaInfo_r9NotificationIndicator_r9(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct MBSFN_AreaInfo_r9Mcch_Config_r9Mcch_RepetitionPeriod_r9(pub u8);
impl MBSFN_AreaInfo_r9Mcch_Config_r9Mcch_RepetitionPeriod_r9 {
    pub const RF32: u8 = 0u8;
    pub const RF64: u8 = 1u8;
    pub const RF128: u8 = 2u8;
    pub const RF256: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "10")]
pub struct MBSFN_AreaInfo_r9Mcch_Config_r9Mcch_Offset_r9(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct MBSFN_AreaInfo_r9Mcch_Config_r9Mcch_ModificationPeriod_r9(pub u8);
impl MBSFN_AreaInfo_r9Mcch_Config_r9Mcch_ModificationPeriod_r9 {
    pub const RF512: u8 = 0u8;
    pub const RF1024: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "6", sz_ub = "6")]
pub struct MBSFN_AreaInfo_r9Mcch_Config_r9Sf_AllocInfo_r9(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct MBSFN_AreaInfo_r9Mcch_Config_r9SignallingMCS_r9(pub u8);
impl MBSFN_AreaInfo_r9Mcch_Config_r9SignallingMCS_r9 {
    pub const N2: u8 = 0u8;
    pub const N7: u8 = 1u8;
    pub const N13: u8 = 2u8;
    pub const N19: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MBSFN_AreaInfo_r9Mcch_Config_r9 {
    pub mcch_repetition_period_r9: MBSFN_AreaInfo_r9Mcch_Config_r9Mcch_RepetitionPeriod_r9,
    pub mcch_offset_r9: MBSFN_AreaInfo_r9Mcch_Config_r9Mcch_Offset_r9,
    pub mcch_modification_period_r9: MBSFN_AreaInfo_r9Mcch_Config_r9Mcch_ModificationPeriod_r9,
    pub sf_alloc_info_r9: MBSFN_AreaInfo_r9Mcch_Config_r9Sf_AllocInfo_r9,
    pub signalling_mcs_r9: MBSFN_AreaInfo_r9Mcch_Config_r9SignallingMCS_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct MBSFN_SubframeConfigRadioframeAllocationPeriod(pub u8);
impl MBSFN_SubframeConfigRadioframeAllocationPeriod {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N4: u8 = 2u8;
    pub const N8: u8 = 3u8;
    pub const N16: u8 = 4u8;
    pub const N32: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct MBSFN_SubframeConfigRadioframeAllocationOffset(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "6", sz_ub = "6")]
pub struct MBSFN_SubframeConfigSubframeAllocation_oneFrame(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "24", sz_ub = "24")]
pub struct MBSFN_SubframeConfigSubframeAllocation_fourFrames(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MBSFN_SubframeConfigSubframeAllocation {
    #[asn(key = 0, extended = false)]
    OneFrame(MBSFN_SubframeConfigSubframeAllocation_oneFrame),
    #[asn(key = 1, extended = false)]
    FourFrames(MBSFN_SubframeConfigSubframeAllocation_fourFrames),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct MBSFN_SubframeConfig_v1430SubframeAllocation_v1430_oneFrame_v1430(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct MBSFN_SubframeConfig_v1430SubframeAllocation_v1430_fourFrames_v1430(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MBSFN_SubframeConfig_v1430SubframeAllocation_v1430 {
    #[asn(key = 0, extended = false)]
    OneFrame_v1430(MBSFN_SubframeConfig_v1430SubframeAllocation_v1430_oneFrame_v1430),
    #[asn(key = 1, extended = false)]
    FourFrames_v1430(MBSFN_SubframeConfig_v1430SubframeAllocation_v1430_fourFrames_v1430),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct MBSFN_SubframeConfig_v1610SubframeAllocation_v1610_oneFrame_v1610(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct MBSFN_SubframeConfig_v1610SubframeAllocation_v1610_fourFrames_v1610(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MBSFN_SubframeConfig_v1610SubframeAllocation_v1610 {
    #[asn(key = 0, extended = false)]
    OneFrame_v1610(MBSFN_SubframeConfig_v1610SubframeAllocation_v1610_oneFrame_v1610),
    #[asn(key = 1, extended = false)]
    FourFrames_v1610(MBSFN_SubframeConfig_v1610SubframeAllocation_v1610_fourFrames_v1610),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "6")]
pub struct MBSFNAreaConfiguration_r9CommonSF_AllocPeriod_r9(pub u8);
impl MBSFNAreaConfiguration_r9CommonSF_AllocPeriod_r9 {
    pub const RF4: u8 = 0u8;
    pub const RF8: u8 = 1u8;
    pub const RF16: u8 = 2u8;
    pub const RF32: u8 = 3u8;
    pub const RF64: u8 = 4u8;
    pub const RF128: u8 = 5u8;
    pub const RF256: u8 = 6u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MBSFNAreaConfiguration_v1610_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct MBSFNAreaConfiguration_v930_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = false)]
pub enum MCCH_MessageType_c1 {
    #[asn(key = 0, extended = false)]
    MbsfnAreaConfiguration_r9(MBSFNAreaConfiguration_r9),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = false)]
pub enum MCCH_MessageType_later_c2 {
    #[asn(key = 0, extended = false)]
    MbmsCountingRequest_r10(MBMSCountingRequest_r10),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MCCH_MessageType_later_messageClassExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MCCH_MessageType_later {
    #[asn(key = 0, extended = false)]
    C2(MCCH_MessageType_later_c2),
    #[asn(key = 1, extended = false)]
    MessageClassExtension(MCCH_MessageType_later_messageClassExtension),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MCGFailureInformation_r16CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MCGFailureInformation_r16CriticalExtensions {
    #[asn(key = 0, extended = false)]
    McgFailureInformation(MCGFailureInformation_r16_IEs),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(MCGFailureInformation_r16CriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct MCGFailureInformation_r16_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MCGFailureInformation_r16_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct MCS_PSSCH_Range_r15MinMCS_PSSCH_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct MCS_PSSCH_Range_r15MaxMCS_PSSCH_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8")]
pub struct MIMO_BeamformedCapabilities_r13K_Max_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "1", sz_ub = "7")]
pub struct MIMO_BeamformedCapabilities_r13N_MaxList_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MIMO_CA_ParametersPerBoBCPerTM_r13Dmrs_Enhancements_r13(pub u8);
impl MIMO_CA_ParametersPerBoBCPerTM_r13Dmrs_Enhancements_r13 {
    pub const DIFFERENT: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MIMO_CA_ParametersPerBoBCPerTM_r15Dmrs_Enhancements_r13(pub u8);
impl MIMO_CA_ParametersPerBoBCPerTM_r15Dmrs_Enhancements_r13 {
    pub const DIFFERENT: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MIMO_CA_ParametersPerBoBCPerTM_r15Csi_ReportingNP_r14(pub u8);
impl MIMO_CA_ParametersPerBoBCPerTM_r15Csi_ReportingNP_r14 {
    pub const DIFFERENT: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MIMO_CA_ParametersPerBoBCPerTM_r15Csi_ReportingAdvanced_r14(pub u8);
impl MIMO_CA_ParametersPerBoBCPerTM_r15Csi_ReportingAdvanced_r14 {
    pub const DIFFERENT: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MIMO_CA_ParametersPerBoBCPerTM_v1430Csi_ReportingNP_r14(pub u8);
impl MIMO_CA_ParametersPerBoBCPerTM_v1430Csi_ReportingNP_r14 {
    pub const DIFFERENT: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MIMO_CA_ParametersPerBoBCPerTM_v1430Csi_ReportingAdvanced_r14(pub u8);
impl MIMO_CA_ParametersPerBoBCPerTM_v1430Csi_ReportingAdvanced_r14 {
    pub const DIFFERENT: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct MIMO_CA_ParametersPerBoBCPerTM_v1470Csi_ReportingAdvancedMaxPorts_r14(pub u8);
impl MIMO_CA_ParametersPerBoBCPerTM_v1470Csi_ReportingAdvancedMaxPorts_r14 {
    pub const N8: u8 = 0u8;
    pub const N12: u8 = 1u8;
    pub const N16: u8 = 2u8;
    pub const N20: u8 = 3u8;
    pub const N24: u8 = 4u8;
    pub const N28: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MIMO_NonPrecodedCapabilities_r13Config1_r13(pub u8);
impl MIMO_NonPrecodedCapabilities_r13Config1_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MIMO_NonPrecodedCapabilities_r13Config2_r13(pub u8);
impl MIMO_NonPrecodedCapabilities_r13Config2_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MIMO_NonPrecodedCapabilities_r13Config3_r13(pub u8);
impl MIMO_NonPrecodedCapabilities_r13Config3_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MIMO_NonPrecodedCapabilities_r13Config4_r13(pub u8);
impl MIMO_NonPrecodedCapabilities_r13Config4_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MIMO_UE_BeamformedCapabilities_r13AltCodebook_r13(pub u8);
impl MIMO_UE_BeamformedCapabilities_r13AltCodebook_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MIMO_UE_Parameters_r13Srs_EnhancementsTDD_r13(pub u8);
impl MIMO_UE_Parameters_r13Srs_EnhancementsTDD_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MIMO_UE_Parameters_r13Srs_Enhancements_r13(pub u8);
impl MIMO_UE_Parameters_r13Srs_Enhancements_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MIMO_UE_Parameters_r13InterferenceMeasRestriction_r13(pub u8);
impl MIMO_UE_Parameters_r13InterferenceMeasRestriction_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MIMO_UE_ParametersPerTM_r13ChannelMeasRestriction_r13(pub u8);
impl MIMO_UE_ParametersPerTM_r13ChannelMeasRestriction_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MIMO_UE_ParametersPerTM_r13Dmrs_Enhancements_r13(pub u8);
impl MIMO_UE_ParametersPerTM_r13Dmrs_Enhancements_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MIMO_UE_ParametersPerTM_r13Csi_RS_EnhancementsTDD_r13(pub u8);
impl MIMO_UE_ParametersPerTM_r13Csi_RS_EnhancementsTDD_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "5", ub = "32")]
pub struct MIMO_UE_ParametersPerTM_v1430Nzp_CSI_RS_AperiodicInfo_r14NMaxProc_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct MIMO_UE_ParametersPerTM_v1430Nzp_CSI_RS_AperiodicInfo_r14NMaxResource_r14(pub u8);
impl MIMO_UE_ParametersPerTM_v1430Nzp_CSI_RS_AperiodicInfo_r14NMaxResource_r14 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N4: u8 = 2u8;
    pub const N8: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MIMO_UE_ParametersPerTM_v1430Nzp_CSI_RS_AperiodicInfo_r14 {
    pub n_max_proc_r14: MIMO_UE_ParametersPerTM_v1430Nzp_CSI_RS_AperiodicInfo_r14NMaxProc_r14,
    pub n_max_resource_r14:
        MIMO_UE_ParametersPerTM_v1430Nzp_CSI_RS_AperiodicInfo_r14NMaxResource_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct MIMO_UE_ParametersPerTM_v1430Nzp_CSI_RS_PeriodicInfo_r14NMaxResource_r14(pub u8);
impl MIMO_UE_ParametersPerTM_v1430Nzp_CSI_RS_PeriodicInfo_r14NMaxResource_r14 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N4: u8 = 2u8;
    pub const N8: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MIMO_UE_ParametersPerTM_v1430Nzp_CSI_RS_PeriodicInfo_r14 {
    pub n_max_resource_r14:
        MIMO_UE_ParametersPerTM_v1430Nzp_CSI_RS_PeriodicInfo_r14NMaxResource_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MIMO_UE_ParametersPerTM_v1430Zp_CSI_RS_AperiodicInfo_r14(pub u8);
impl MIMO_UE_ParametersPerTM_v1430Zp_CSI_RS_AperiodicInfo_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MIMO_UE_ParametersPerTM_v1430Ul_dmrs_Enhancements_r14(pub u8);
impl MIMO_UE_ParametersPerTM_v1430Ul_dmrs_Enhancements_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MIMO_UE_ParametersPerTM_v1430DensityReductionNP_r14(pub u8);
impl MIMO_UE_ParametersPerTM_v1430DensityReductionNP_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MIMO_UE_ParametersPerTM_v1430DensityReductionBF_r14(pub u8);
impl MIMO_UE_ParametersPerTM_v1430DensityReductionBF_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MIMO_UE_ParametersPerTM_v1430HybridCSI_r14(pub u8);
impl MIMO_UE_ParametersPerTM_v1430HybridCSI_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MIMO_UE_ParametersPerTM_v1430SemiOL_r14(pub u8);
impl MIMO_UE_ParametersPerTM_v1430SemiOL_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MIMO_UE_ParametersPerTM_v1430Csi_ReportingNP_r14(pub u8);
impl MIMO_UE_ParametersPerTM_v1430Csi_ReportingNP_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MIMO_UE_ParametersPerTM_v1430Csi_ReportingAdvanced_r14(pub u8);
impl MIMO_UE_ParametersPerTM_v1430Csi_ReportingAdvanced_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct MIMO_UE_ParametersPerTM_v1470Csi_ReportingAdvancedMaxPorts_r14(pub u8);
impl MIMO_UE_ParametersPerTM_v1470Csi_ReportingAdvancedMaxPorts_r14 {
    pub const N8: u8 = 0u8;
    pub const N12: u8 = 1u8;
    pub const N16: u8 = 2u8;
    pub const N20: u8 = 3u8;
    pub const N24: u8 = 4u8;
    pub const N28: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct MIMO_WeightedLayersCapabilities_r13RelWeightTwoLayers_r13(pub u8);
impl MIMO_WeightedLayersCapabilities_r13RelWeightTwoLayers_r13 {
    pub const V1: u8 = 0u8;
    pub const V1DOT25: u8 = 1u8;
    pub const V1DOT5: u8 = 2u8;
    pub const V1DOT75: u8 = 3u8;
    pub const V2: u8 = 4u8;
    pub const V2DOT5: u8 = 5u8;
    pub const V3: u8 = 6u8;
    pub const V4: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct MIMO_WeightedLayersCapabilities_r13RelWeightFourLayers_r13(pub u8);
impl MIMO_WeightedLayersCapabilities_r13RelWeightFourLayers_r13 {
    pub const V1: u8 = 0u8;
    pub const V1DOT25: u8 = 1u8;
    pub const V1DOT5: u8 = 2u8;
    pub const V1DOT75: u8 = 3u8;
    pub const V2: u8 = 4u8;
    pub const V2DOT5: u8 = 5u8;
    pub const V3: u8 = 6u8;
    pub const V4: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct MIMO_WeightedLayersCapabilities_r13RelWeightEightLayers_r13(pub u8);
impl MIMO_WeightedLayersCapabilities_r13RelWeightEightLayers_r13 {
    pub const V1: u8 = 0u8;
    pub const V1DOT25: u8 = 1u8;
    pub const V1DOT5: u8 = 2u8;
    pub const V1DOT75: u8 = 3u8;
    pub const V2: u8 = 4u8;
    pub const V2DOT5: u8 = 5u8;
    pub const V3: u8 = 6u8;
    pub const V4: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "2", ub = "128")]
pub struct MIMO_WeightedLayersCapabilities_r13TotalWeightedLayers_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MMTEL_Parameters_r14DelayBudgetReporting_r14(pub u8);
impl MMTEL_Parameters_r14DelayBudgetReporting_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MMTEL_Parameters_r14Pusch_Enhancements_r14(pub u8);
impl MMTEL_Parameters_r14Pusch_Enhancements_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MMTEL_Parameters_r14RecommendedBitRate_r14(pub u8);
impl MMTEL_Parameters_r14RecommendedBitRate_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MMTEL_Parameters_r14RecommendedBitRateQuery_r14(pub u8);
impl MMTEL_Parameters_r14RecommendedBitRateQuery_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MMTEL_Parameters_v1610RecommendedBitRateMultiplier_r16(pub u8);
impl MMTEL_Parameters_v1610RecommendedBitRateMultiplier_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct MRDC_AssistanceInfo_r15AffectedCarrierFreqCombInfoListMRDC_r15(
    pub Vec<AffectedCarrierFreqCombInfoMRDC_r15>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4")]
pub struct MTC_SSB_NR_r15PeriodicityAndOffset_r15_sf5_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "9")]
pub struct MTC_SSB_NR_r15PeriodicityAndOffset_r15_sf10_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "19")]
pub struct MTC_SSB_NR_r15PeriodicityAndOffset_r15_sf20_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "39")]
pub struct MTC_SSB_NR_r15PeriodicityAndOffset_r15_sf40_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "79")]
pub struct MTC_SSB_NR_r15PeriodicityAndOffset_r15_sf80_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "159")]
pub struct MTC_SSB_NR_r15PeriodicityAndOffset_r15_sf160_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "5", extensible = false)]
pub enum MTC_SSB_NR_r15PeriodicityAndOffset_r15 {
    #[asn(key = 0, extended = false)]
    Sf5_r15(MTC_SSB_NR_r15PeriodicityAndOffset_r15_sf5_r15),
    #[asn(key = 1, extended = false)]
    Sf10_r15(MTC_SSB_NR_r15PeriodicityAndOffset_r15_sf10_r15),
    #[asn(key = 2, extended = false)]
    Sf20_r15(MTC_SSB_NR_r15PeriodicityAndOffset_r15_sf20_r15),
    #[asn(key = 3, extended = false)]
    Sf40_r15(MTC_SSB_NR_r15PeriodicityAndOffset_r15_sf40_r15),
    #[asn(key = 4, extended = false)]
    Sf80_r15(MTC_SSB_NR_r15PeriodicityAndOffset_r15_sf80_r15),
    #[asn(key = 5, extended = false)]
    Sf160_r15(MTC_SSB_NR_r15PeriodicityAndOffset_r15_sf160_r15),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "4")]
pub struct MTC_SSB_NR_r15Ssb_Duration_r15(pub u8);
impl MTC_SSB_NR_r15Ssb_Duration_r15 {
    pub const SF1: u8 = 0u8;
    pub const SF2: u8 = 1u8;
    pub const SF3: u8 = 2u8;
    pub const SF4: u8 = 3u8;
    pub const SF5: u8 = 4u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct MTC_SSB2_LP_NR_r16Pci_List_r16(pub Vec<PhysCellIdNR_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct MTC_SSB2_LP_NR_r16Periodicity_r16(pub u8);
impl MTC_SSB2_LP_NR_r16Periodicity_r16 {
    pub const SF10: u8 = 0u8;
    pub const SF20: u8 = 1u8;
    pub const SF40: u8 = 2u8;
    pub const SF80: u8 = 3u8;
    pub const SF160: u8 = 4u8;
    pub const SPARE3: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MUST_Parameters_r14Must_TM234_UpTo2Tx_r14(pub u8);
impl MUST_Parameters_r14Must_TM234_UpTo2Tx_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MUST_Parameters_r14Must_TM89_UpToOneInterferingLayer_r14(pub u8);
impl MUST_Parameters_r14Must_TM89_UpToOneInterferingLayer_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MUST_Parameters_r14Must_TM10_UpToOneInterferingLayer_r14(pub u8);
impl MUST_Parameters_r14Must_TM10_UpToOneInterferingLayer_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MUST_Parameters_r14Must_TM89_UpToThreeInterferingLayers_r14(pub u8);
impl MUST_Parameters_r14Must_TM89_UpToThreeInterferingLayers_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MUST_Parameters_r14Must_TM10_UpToThreeInterferingLayers_r14(pub u8);
impl MUST_Parameters_r14Must_TM10_UpToThreeInterferingLayers_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct MasterInformationBlockDl_Bandwidth(pub u8);
impl MasterInformationBlockDl_Bandwidth {
    pub const N6: u8 = 0u8;
    pub const N15: u8 = 1u8;
    pub const N25: u8 = 2u8;
    pub const N50: u8 = 3u8;
    pub const N75: u8 = 4u8;
    pub const N100: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct MasterInformationBlockSystemFrameNumber(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct MasterInformationBlockSchedulingInfoSIB1_BR_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct MasterInformationBlockSystemInfoUnchanged_BR_r15(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct MasterInformationBlockPartEARFCN_17_spare(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct MasterInformationBlockPartEARFCN_17_earfcn_LSB(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MasterInformationBlockPartEARFCN_17 {
    #[asn(key = 0, extended = false)]
    Spare(MasterInformationBlockPartEARFCN_17_spare),
    #[asn(key = 1, extended = false)]
    Earfcn_LSB(MasterInformationBlockPartEARFCN_17_earfcn_LSB),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "1", sz_ub = "1")]
pub struct MasterInformationBlockSpare(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct MasterInformationBlock_MBMS_r14Dl_Bandwidth_MBMS_r14(pub u8);
impl MasterInformationBlock_MBMS_r14Dl_Bandwidth_MBMS_r14 {
    pub const N6: u8 = 0u8;
    pub const N15: u8 = 1u8;
    pub const N25: u8 = 2u8;
    pub const N50: u8 = 3u8;
    pub const N75: u8 = 4u8;
    pub const N100: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "6", sz_ub = "6")]
pub struct MasterInformationBlock_MBMS_r14SystemFrameNumber_r14(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct MasterInformationBlock_MBMS_r14AdditionalNonMBSFNSubframes_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct MasterInformationBlock_MBMS_r14SemiStaticCFI_MBMS_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "11", sz_ub = "11")]
pub struct MasterInformationBlock_MBMS_r14Spare(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct MasterInformationBlock_SLSl_Bandwidth_r12(pub u8);
impl MasterInformationBlock_SLSl_Bandwidth_r12 {
    pub const N6: u8 = 0u8;
    pub const N15: u8 = 1u8;
    pub const N25: u8 = 2u8;
    pub const N50: u8 = 3u8;
    pub const N75: u8 = 4u8;
    pub const N100: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "10", sz_ub = "10")]
pub struct MasterInformationBlock_SLDirectFrameNumber_r12(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "9")]
pub struct MasterInformationBlock_SLDirectSubframeNumber_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct MasterInformationBlock_SLInCoverage_r12(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "19", sz_ub = "19")]
pub struct MasterInformationBlock_SLReserved_r12(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct MasterInformationBlock_SL_V2X_r14Sl_Bandwidth_r14(pub u8);
impl MasterInformationBlock_SL_V2X_r14Sl_Bandwidth_r14 {
    pub const N6: u8 = 0u8;
    pub const N15: u8 = 1u8;
    pub const N25: u8 = 2u8;
    pub const N50: u8 = 3u8;
    pub const N75: u8 = 4u8;
    pub const N100: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "10", sz_ub = "10")]
pub struct MasterInformationBlock_SL_V2X_r14DirectFrameNumber_r14(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "9")]
pub struct MasterInformationBlock_SL_V2X_r14DirectSubframeNumber_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct MasterInformationBlock_SL_V2X_r14InCoverage_r14(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "27", sz_ub = "27")]
pub struct MasterInformationBlock_SL_V2X_r14Reserved_r14(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "503")]
pub struct MeasCSI_RS_Config_r12PhysCellId_r12(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "503")]
pub struct MeasCSI_RS_Config_r12ScramblingIdentity_r12(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct MeasCSI_RS_Config_r12ResourceConfig_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4")]
pub struct MeasCSI_RS_Config_r12SubframeOffset_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct MeasConfigSpeedStatePars_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasConfigSpeedStatePars_setup {
    pub mobility_state_parameters: MobilityStateParameters,
    pub time_to_trigger_sf: SpeedStateScaleFactors,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MeasConfigSpeedStatePars {
    #[asn(key = 0, extended = false)]
    Release(MeasConfigSpeedStatePars_release),
    #[asn(key = 1, extended = false)]
    Setup(MeasConfigSpeedStatePars_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct MeasDS_Config_r12_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "39")]
pub struct MeasDS_Config_r12_setupDmtc_PeriodOffset_r12_ms40_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "79")]
pub struct MeasDS_Config_r12_setupDmtc_PeriodOffset_r12_ms80_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "159")]
pub struct MeasDS_Config_r12_setupDmtc_PeriodOffset_r12_ms160_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum MeasDS_Config_r12_setupDmtc_PeriodOffset_r12 {
    #[asn(key = 0, extended = false)]
    Ms40_r12(MeasDS_Config_r12_setupDmtc_PeriodOffset_r12_ms40_r12),
    #[asn(key = 1, extended = false)]
    Ms80_r12(MeasDS_Config_r12_setupDmtc_PeriodOffset_r12_ms80_r12),
    #[asn(key = 2, extended = false)]
    Ms160_r12(MeasDS_Config_r12_setupDmtc_PeriodOffset_r12_ms160_r12),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "5")]
pub struct MeasDS_Config_r12_setupDs_OccasionDuration_r12_durationFDD_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "2", ub = "5")]
pub struct MeasDS_Config_r12_setupDs_OccasionDuration_r12_durationTDD_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MeasDS_Config_r12_setupDs_OccasionDuration_r12 {
    #[asn(key = 0, extended = false)]
    DurationFDD_r12(MeasDS_Config_r12_setupDs_OccasionDuration_r12_durationFDD_r12),
    #[asn(key = 1, extended = false)]
    DurationTDD_r12(MeasDS_Config_r12_setupDs_OccasionDuration_r12_durationTDD_r12),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct MeasDS_Config_r12_setup {
    pub dmtc_period_offset_r12: MeasDS_Config_r12_setupDmtc_PeriodOffset_r12,
    pub ds_occasion_duration_r12: MeasDS_Config_r12_setupDs_OccasionDuration_r12,
    #[asn(optional_idx = 0)]
    pub meas_csi_rs_to_remove_list_r12: Option<MeasCSI_RS_ToRemoveList_r12>,
    #[asn(optional_idx = 1)]
    pub meas_csi_rs_to_add_mod_list_r12: Option<MeasCSI_RS_ToAddModList_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct MeasGapConfig_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "39")]
pub struct MeasGapConfig_setupGapOffset_gp0(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "79")]
pub struct MeasGapConfig_setupGapOffset_gp1(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "39")]
pub struct MeasGapConfig_setupGapOffset_gp2_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "79")]
pub struct MeasGapConfig_setupGapOffset_gp3_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "39")]
pub struct MeasGapConfig_setupGapOffset_gp_ncsg0_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "79")]
pub struct MeasGapConfig_setupGapOffset_gp_ncsg1_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "39")]
pub struct MeasGapConfig_setupGapOffset_gp_ncsg2_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "79")]
pub struct MeasGapConfig_setupGapOffset_gp_ncsg3_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1279")]
pub struct MeasGapConfig_setupGapOffset_gp_nonUniform1_r14(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2559")]
pub struct MeasGapConfig_setupGapOffset_gp_nonUniform2_r14(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "5119")]
pub struct MeasGapConfig_setupGapOffset_gp_nonUniform3_r14(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "10239")]
pub struct MeasGapConfig_setupGapOffset_gp_nonUniform4_r14(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "19")]
pub struct MeasGapConfig_setupGapOffset_gp4_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "159")]
pub struct MeasGapConfig_setupGapOffset_gp5_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "19")]
pub struct MeasGapConfig_setupGapOffset_gp6_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "39")]
pub struct MeasGapConfig_setupGapOffset_gp7_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "79")]
pub struct MeasGapConfig_setupGapOffset_gp8_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "159")]
pub struct MeasGapConfig_setupGapOffset_gp9_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "19")]
pub struct MeasGapConfig_setupGapOffset_gp10_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "159")]
pub struct MeasGapConfig_setupGapOffset_gp11_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum MeasGapConfig_setupGapOffset {
    #[asn(key = 0, extended = false)]
    Gp0(MeasGapConfig_setupGapOffset_gp0),
    #[asn(key = 1, extended = false)]
    Gp1(MeasGapConfig_setupGapOffset_gp1),
    #[asn(key = 0, extended = true)]
    Gp2_r14(MeasGapConfig_setupGapOffset_gp2_r14),
    #[asn(key = 1, extended = true)]
    Gp3_r14(MeasGapConfig_setupGapOffset_gp3_r14),
    #[asn(key = 2, extended = true)]
    Gp_ncsg0_r14(MeasGapConfig_setupGapOffset_gp_ncsg0_r14),
    #[asn(key = 3, extended = true)]
    Gp_ncsg1_r14(MeasGapConfig_setupGapOffset_gp_ncsg1_r14),
    #[asn(key = 4, extended = true)]
    Gp_ncsg2_r14(MeasGapConfig_setupGapOffset_gp_ncsg2_r14),
    #[asn(key = 5, extended = true)]
    Gp_ncsg3_r14(MeasGapConfig_setupGapOffset_gp_ncsg3_r14),
    #[asn(key = 6, extended = true)]
    Gp_nonUniform1_r14(MeasGapConfig_setupGapOffset_gp_nonUniform1_r14),
    #[asn(key = 7, extended = true)]
    Gp_nonUniform2_r14(MeasGapConfig_setupGapOffset_gp_nonUniform2_r14),
    #[asn(key = 8, extended = true)]
    Gp_nonUniform3_r14(MeasGapConfig_setupGapOffset_gp_nonUniform3_r14),
    #[asn(key = 9, extended = true)]
    Gp_nonUniform4_r14(MeasGapConfig_setupGapOffset_gp_nonUniform4_r14),
    #[asn(key = 10, extended = true)]
    Gp4_r15(MeasGapConfig_setupGapOffset_gp4_r15),
    #[asn(key = 11, extended = true)]
    Gp5_r15(MeasGapConfig_setupGapOffset_gp5_r15),
    #[asn(key = 12, extended = true)]
    Gp6_r15(MeasGapConfig_setupGapOffset_gp6_r15),
    #[asn(key = 13, extended = true)]
    Gp7_r15(MeasGapConfig_setupGapOffset_gp7_r15),
    #[asn(key = 14, extended = true)]
    Gp8_r15(MeasGapConfig_setupGapOffset_gp8_r15),
    #[asn(key = 15, extended = true)]
    Gp9_r15(MeasGapConfig_setupGapOffset_gp9_r15),
    #[asn(key = 16, extended = true)]
    Gp10_r15(MeasGapConfig_setupGapOffset_gp10_r15),
    #[asn(key = 17, extended = true)]
    Gp11_r15(MeasGapConfig_setupGapOffset_gp11_r15),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasGapConfig_setup {
    pub gap_offset: MeasGapConfig_setupGapOffset,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct MeasGapConfigDensePRS_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "79")]
pub struct MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd0_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "159")]
pub struct MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd1_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "319")]
pub struct MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd2_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "639")]
pub struct MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd3_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1279")]
pub struct MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd4_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "159")]
pub struct MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd5_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "319")]
pub struct MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd6_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "639")]
pub struct MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd7_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1279")]
pub struct MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd8_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "319")]
pub struct MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd9_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "639")]
pub struct MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd10_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1279")]
pub struct MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd11_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "319")]
pub struct MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd12_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "639")]
pub struct MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd13_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1279")]
pub struct MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd14_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "639")]
pub struct MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd15_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1279")]
pub struct MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd16_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "639")]
pub struct MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd17_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1279")]
pub struct MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd18_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "639")]
pub struct MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd19_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1279")]
pub struct MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd20_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "20", extensible = true)]
pub enum MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15 {
    #[asn(key = 0, extended = false)]
    Rstd0_r15(MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd0_r15),
    #[asn(key = 1, extended = false)]
    Rstd1_r15(MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd1_r15),
    #[asn(key = 2, extended = false)]
    Rstd2_r15(MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd2_r15),
    #[asn(key = 3, extended = false)]
    Rstd3_r15(MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd3_r15),
    #[asn(key = 4, extended = false)]
    Rstd4_r15(MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd4_r15),
    #[asn(key = 5, extended = false)]
    Rstd5_r15(MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd5_r15),
    #[asn(key = 6, extended = false)]
    Rstd6_r15(MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd6_r15),
    #[asn(key = 7, extended = false)]
    Rstd7_r15(MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd7_r15),
    #[asn(key = 8, extended = false)]
    Rstd8_r15(MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd8_r15),
    #[asn(key = 9, extended = false)]
    Rstd9_r15(MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd9_r15),
    #[asn(key = 10, extended = false)]
    Rstd10_r15(MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd10_r15),
    #[asn(key = 11, extended = false)]
    Rstd11_r15(MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd11_r15),
    #[asn(key = 12, extended = false)]
    Rstd12_r15(MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd12_r15),
    #[asn(key = 13, extended = false)]
    Rstd13_r15(MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd13_r15),
    #[asn(key = 14, extended = false)]
    Rstd14_r15(MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd14_r15),
    #[asn(key = 15, extended = false)]
    Rstd15_r15(MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd15_r15),
    #[asn(key = 16, extended = false)]
    Rstd16_r15(MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd16_r15),
    #[asn(key = 17, extended = false)]
    Rstd17_r15(MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd17_r15),
    #[asn(key = 18, extended = false)]
    Rstd18_r15(MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd18_r15),
    #[asn(key = 19, extended = false)]
    Rstd19_r15(MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd19_r15),
    #[asn(key = 20, extended = false)]
    Rstd20_r15(MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15_rstd20_r15),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasGapConfigDensePRS_r15_setup {
    pub gap_offset_dense_prs_r15: MeasGapConfigDensePRS_r15_setupGapOffsetDensePRS_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct MeasGapConfigPerCC_List_r14_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MeasGapConfigPerCC_List_r14_setup {
    #[asn(optional_idx = 0)]
    pub meas_gap_config_to_remove_list_r14: Option<MeasGapConfigToRemoveList_r14>,
    #[asn(optional_idx = 1)]
    pub meas_gap_config_to_add_mod_list_r14: Option<MeasGapConfigToAddModList_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct MeasGapSharingConfig_r14_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct MeasGapSharingConfig_r14_setupMeasGapSharingScheme_r14(pub u8);
impl MeasGapSharingConfig_r14_setupMeasGapSharingScheme_r14 {
    pub const SCHEME00: u8 = 0u8;
    pub const SCHEME01: u8 = 1u8;
    pub const SCHEME10: u8 = 2u8;
    pub const SCHEME11: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasGapSharingConfig_r14_setup {
    pub meas_gap_sharing_scheme_r14: MeasGapSharingConfig_r14_setupMeasGapSharingScheme_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct MeasIdleCarrierEUTRA_r15ReportQuantities(pub u8);
impl MeasIdleCarrierEUTRA_r15ReportQuantities {
    pub const RSRP: u8 = 0u8;
    pub const RSRQ: u8 = 1u8;
    pub const BOTH: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MeasIdleCarrierEUTRA_r15QualityThreshold_r15 {
    #[asn(optional_idx = 0)]
    pub idle_rsrp_threshold_r15: Option<RSRP_Range>,
    #[asn(optional_idx = 1)]
    pub idle_rsrq_threshold_r15: Option<RSRQ_Range_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct MeasIdleCarrierNR_r16SubcarrierSpacingSSB_r16(pub u8);
impl MeasIdleCarrierNR_r16SubcarrierSpacingSSB_r16 {
    pub const K_HZ15: u8 = 0u8;
    pub const K_HZ30: u8 = 1u8;
    pub const K_HZ120: u8 = 2u8;
    pub const K_HZ240: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct MeasIdleCarrierNR_r16ReportQuantitiesNR_r16(pub u8);
impl MeasIdleCarrierNR_r16ReportQuantitiesNR_r16 {
    pub const RSRP: u8 = 0u8;
    pub const RSRQ: u8 = 1u8;
    pub const BOTH: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct MeasIdleCarrierNR_r16QualityThresholdNR_r16 {
    #[asn(optional_idx = 0)]
    pub idle_rsrp_threshold_nr_r16: Option<RSRP_RangeNR_r15>,
    #[asn(optional_idx = 1)]
    pub idle_rsrq_threshold_nr_r16: Option<RSRQ_RangeNR_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct MeasIdleCarrierNR_r16Ssb_MeasConfig_r16DeriveSSB_IndexFromCell_r16(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct MeasIdleCarrierNR_r16Ssb_MeasConfig_r16 {
    #[asn(optional_idx = 0)]
    pub max_rs_index_cell_qual_r16: Option<MaxRS_IndexCellQualNR_r15>,
    #[asn(optional_idx = 1)]
    pub thresh_rs_index_r16: Option<ThresholdListNR_r15>,
    #[asn(optional_idx = 2)]
    pub meas_timing_config_r16: Option<MTC_SSB_NR_r15>,
    #[asn(optional_idx = 3)]
    pub ssb_to_measure_r16: Option<SSB_ToMeasure_r15>,
    pub derive_ssb_index_from_cell_r16:
        MeasIdleCarrierNR_r16Ssb_MeasConfig_r16DeriveSSB_IndexFromCell_r16,
    #[asn(optional_idx = 4)]
    pub ss_rssi_measurement_r16: Option<SS_RSSI_Measurement_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct MeasIdleConfigDedicated_r15MeasIdleDuration_r15(pub u8);
impl MeasIdleConfigDedicated_r15MeasIdleDuration_r15 {
    pub const SEC10: u8 = 0u8;
    pub const SEC30: u8 = 1u8;
    pub const SEC60: u8 = 2u8;
    pub const SEC120: u8 = 3u8;
    pub const SEC180: u8 = 4u8;
    pub const SEC240: u8 = 5u8;
    pub const SEC300: u8 = 6u8;
    pub const SPARE: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct MeasObjectCDMA2000SearchWindowSize(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct MeasObjectGERANNcc_Permitted(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "2")]
pub struct MeasObjectNR_r15QuantityConfigSet_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct MeasObjectNR_r15CellsForWhichToReportSFTD_r15(pub Vec<PhysCellIdNR_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = true)]
pub enum MeasObjectToAddModMeasObject {
    #[asn(key = 0, extended = false)]
    MeasObjectEUTRA(MeasObjectEUTRA),
    #[asn(key = 1, extended = false)]
    MeasObjectUTRA(MeasObjectUTRA),
    #[asn(key = 2, extended = false)]
    MeasObjectGERAN(MeasObjectGERAN),
    #[asn(key = 3, extended = false)]
    MeasObjectCDMA2000(MeasObjectCDMA2000),
    #[asn(key = 0, extended = true)]
    MeasObjectWLAN_r13(MeasObjectWLAN_r13),
    #[asn(key = 1, extended = true)]
    MeasObjectNR_r15(MeasObjectNR_r15),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = true)]
pub enum MeasObjectToAddModExt_r13MeasObject_r13 {
    #[asn(key = 0, extended = false)]
    MeasObjectEUTRA_r13(MeasObjectEUTRA),
    #[asn(key = 1, extended = false)]
    MeasObjectUTRA_r13(MeasObjectUTRA),
    #[asn(key = 2, extended = false)]
    MeasObjectGERAN_r13(MeasObjectGERAN),
    #[asn(key = 3, extended = false)]
    MeasObjectCDMA2000_r13(MeasObjectCDMA2000),
    #[asn(key = 0, extended = true)]
    MeasObjectWLAN_v1320(MeasObjectWLAN_r13),
    #[asn(key = 1, extended = true)]
    MeasObjectNR_r15(MeasObjectNR_r15),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MeasObjectUTRACellsToAddModList {
    #[asn(key = 0, extended = false)]
    CellsToAddModListUTRA_FDD(CellsToAddModListUTRA_FDD),
    #[asn(key = 1, extended = false)]
    CellsToAddModListUTRA_TDD(CellsToAddModListUTRA_TDD),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MeasObjectUTRACellForWhichToReportCGI {
    #[asn(key = 0, extended = false)]
    Utra_FDD(PhysCellIdUTRA_FDD),
    #[asn(key = 1, extended = false)]
    Utra_TDD(PhysCellIdUTRA_TDD),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MeasObjectWLAN_r13CarrierFreq_r13_bandIndicatorListWLAN_r13(
    pub Vec<WLAN_BandIndicator_r13>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MeasObjectWLAN_r13CarrierFreq_r13_carrierInfoListWLAN_r13(pub Vec<WLAN_CarrierInfo_r13>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MeasObjectWLAN_r13CarrierFreq_r13 {
    #[asn(key = 0, extended = false)]
    BandIndicatorListWLAN_r13(MeasObjectWLAN_r13CarrierFreq_r13_bandIndicatorListWLAN_r13),
    #[asn(key = 1, extended = false)]
    CarrierInfoListWLAN_r13(MeasObjectWLAN_r13CarrierFreq_r13_carrierInfoListWLAN_r13),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1130RsrqMeasWideband_r11(pub u8);
impl MeasParameters_v1130RsrqMeasWideband_r11 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v11a0BenefitsFromInterruption_r11(pub u8);
impl MeasParameters_v11a0BenefitsFromInterruption_r11 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1250TimerT312_r12(pub u8);
impl MeasParameters_v1250TimerT312_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1250AlternativeTimeToTrigger_r12(pub u8);
impl MeasParameters_v1250AlternativeTimeToTrigger_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1250IncMonEUTRA_r12(pub u8);
impl MeasParameters_v1250IncMonEUTRA_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1250IncMonUTRA_r12(pub u8);
impl MeasParameters_v1250IncMonUTRA_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1250ExtendedMaxMeasId_r12(pub u8);
impl MeasParameters_v1250ExtendedMaxMeasId_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1250ExtendedRSRQ_LowerRange_r12(pub u8);
impl MeasParameters_v1250ExtendedRSRQ_LowerRange_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1250Rsrq_OnAllSymbols_r12(pub u8);
impl MeasParameters_v1250Rsrq_OnAllSymbols_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1250Crs_DiscoverySignalsMeas_r12(pub u8);
impl MeasParameters_v1250Crs_DiscoverySignalsMeas_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1250Csi_RS_DiscoverySignalsMeas_r12(pub u8);
impl MeasParameters_v1250Csi_RS_DiscoverySignalsMeas_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1310Rs_SINR_Meas_r13(pub u8);
impl MeasParameters_v1310Rs_SINR_Meas_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1310AllowedCellList_r13(pub u8);
impl MeasParameters_v1310AllowedCellList_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1310ExtendedMaxObjectId_r13(pub u8);
impl MeasParameters_v1310ExtendedMaxObjectId_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1310Ul_PDCP_Delay_r13(pub u8);
impl MeasParameters_v1310Ul_PDCP_Delay_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1310ExtendedFreqPriorities_r13(pub u8);
impl MeasParameters_v1310ExtendedFreqPriorities_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1310MultiBandInfoReport_r13(pub u8);
impl MeasParameters_v1310MultiBandInfoReport_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1310Rssi_AndChannelOccupancyReporting_r13(pub u8);
impl MeasParameters_v1310Rssi_AndChannelOccupancyReporting_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1430CeMeasurements_r14(pub u8);
impl MeasParameters_v1430CeMeasurements_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1430Ncsg_r14(pub u8);
impl MeasParameters_v1430Ncsg_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1430ShortMeasurementGap_r14(pub u8);
impl MeasParameters_v1430ShortMeasurementGap_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1430PerServingCellMeasurementGap_r14(pub u8);
impl MeasParameters_v1430PerServingCellMeasurementGap_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1430NonUniformGap_r14(pub u8);
impl MeasParameters_v1430NonUniformGap_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct MeasParameters_v1520MeasGapPatterns_r15(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1530Qoe_MeasReport_r15(pub u8);
impl MeasParameters_v1530Qoe_MeasReport_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1530Qoe_MTSI_MeasReport_r15(pub u8);
impl MeasParameters_v1530Qoe_MTSI_MeasReport_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1530Ca_IdleModeMeasurements_r15(pub u8);
impl MeasParameters_v1530Ca_IdleModeMeasurements_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1530Ca_IdleModeValidityArea_r15(pub u8);
impl MeasParameters_v1530Ca_IdleModeValidityArea_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1530HeightMeas_r15(pub u8);
impl MeasParameters_v1530HeightMeas_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1530MultipleCellsMeasExtension_r15(pub u8);
impl MeasParameters_v1530MultipleCellsMeasExtension_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct MeasParameters_v1610BandInfoNR_v1610(pub Vec<MeasGapInfoNR_r16>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1610AltFreqPriority_r16(pub u8);
impl MeasParameters_v1610AltFreqPriority_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1610Ce_DL_ChannelQualityReporting_r16(pub u8);
impl MeasParameters_v1610Ce_DL_ChannelQualityReporting_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1610Ce_MeasRSS_Dedicated_r16(pub u8);
impl MeasParameters_v1610Ce_MeasRSS_Dedicated_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1610Eutra_IdleInactiveMeasurements_r16(pub u8);
impl MeasParameters_v1610Eutra_IdleInactiveMeasurements_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1610Nr_IdleInactiveMeasFR1_r16(pub u8);
impl MeasParameters_v1610Nr_IdleInactiveMeasFR1_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1610Nr_IdleInactiveMeasFR2_r16(pub u8);
impl MeasParameters_v1610Nr_IdleInactiveMeasFR2_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1610IdleInactiveValidityAreaList_r16(pub u8);
impl MeasParameters_v1610IdleInactiveValidityAreaList_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1610MeasGapPatterns_NRonly_r16(pub u8);
impl MeasParameters_v1610MeasGapPatterns_NRonly_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1610MeasGapPatterns_NRonly_ENDC_r16(pub u8);
impl MeasParameters_v1610MeasGapPatterns_NRonly_ENDC_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1630Nr_IdleInactiveBeamMeasFR1_r16(pub u8);
impl MeasParameters_v1630Nr_IdleInactiveBeamMeasFR1_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1630Nr_IdleInactiveBeamMeasFR2_r16(pub u8);
impl MeasParameters_v1630Nr_IdleInactiveBeamMeasFR2_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v1630Ce_MeasRSS_DedicatedSameRBs_r16(pub u8);
impl MeasParameters_v1630Ce_MeasRSS_DedicatedSameRBs_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasParameters_v16c0Nr_CellIndividualOffset_r16(pub u8);
impl MeasParameters_v16c0Nr_CellIndividualOffset_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "1024"
)]
pub struct MeasParameters_v1700SharedSpectrumMeasNR_EN_DC_r17(pub Vec<SharedSpectrumMeasNR_r17>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "1024"
)]
pub struct MeasParameters_v1700SharedSpectrumMeasNR_SA_r17(pub Vec<SharedSpectrumMeasNR_r17>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasReportAppLayer_r15CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MeasReportAppLayer_r15CriticalExtensions {
    #[asn(key = 0, extended = false)]
    MeasReportAppLayer_r15(MeasReportAppLayer_r15_IEs),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(MeasReportAppLayer_r15CriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "8000"
)]
pub struct MeasReportAppLayer_r15_IEsMeasReportAppLayerContainer_r15(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct MeasReportAppLayer_r15_IEsServiceType_r15(pub u8);
impl MeasReportAppLayer_r15_IEsServiceType_r15 {
    pub const QOE: u8 = 0u8;
    pub const QOEMTSI: u8 = 1u8;
    pub const SPARE6: u8 = 2u8;
    pub const SPARE5: u8 = 3u8;
    pub const SPARE4: u8 = 4u8;
    pub const SPARE3: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct MeasReportAppLayer_v1590_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasReportAppLayer_v1590_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "32767")]
pub struct MeasResultCDMA2000MeasResultPilotPnPhase(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63")]
pub struct MeasResultCDMA2000MeasResultPilotStrength(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct MeasResultCDMA2000MeasResult {
    #[asn(optional_idx = 0)]
    pub pilot_pn_phase: Option<MeasResultCDMA2000MeasResultPilotPnPhase>,
    pub pilot_strength: MeasResultCDMA2000MeasResultPilotStrength,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct MeasResultCellSFTD_r15Sfn_OffsetResult_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-30720", ub = "30719")]
pub struct MeasResultCellSFTD_r15FrameBoundaryOffsetResult_r15(pub i16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MeasResultEUTRACgi_Info {
    pub cell_global_id: CellGlobalIdEUTRA,
    pub tracking_area_code: TrackingAreaCode,
    #[asn(optional_idx = 0)]
    pub plmn_identity_list: Option<PLMN_IdentityList2>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct MeasResultEUTRAMeasResult {
    #[asn(optional_idx = 0)]
    pub rsrp_result: Option<RSRP_Range>,
    #[asn(optional_idx = 1)]
    pub rsrq_result: Option<RSRQ_Range>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct MeasResultForECID_r9Ue_RxTxTimeDiffResult_r9(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "10", sz_ub = "10")]
pub struct MeasResultForECID_r9CurrentSFN_r9(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct MeasResultForRSSI_NR_r16ChannelOccupancyNR_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct MeasResultForRSSI_r13ChannelOccupancy_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct MeasResultGERANCgi_InfoRoutingAreaCode(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MeasResultGERANCgi_Info {
    pub cell_global_id: CellGlobalIdGERAN,
    #[asn(optional_idx = 0)]
    pub routing_area_code: Option<MeasResultGERANCgi_InfoRoutingAreaCode>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63")]
pub struct MeasResultGERANMeasResultRssi(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MeasResultGERANMeasResult {
    pub rssi: MeasResultGERANMeasResultRssi,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasResultIdle_r15MeasResultServingCell_r15 {
    pub rsrp_result_r15: RSRP_Range,
    pub rsrq_result_r15: RSRQ_Range_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = true)]
pub enum MeasResultIdle_r15MeasResultNeighCells_r15 {
    #[asn(key = 0, extended = false)]
    MeasResultIdleListEUTRA_r15(MeasResultIdleListEUTRA_r15),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasResultIdleEUTRA_r15MeasResult_r15 {
    pub rsrp_result_r15: RSRP_Range,
    pub rsrq_result_r15: RSRQ_Range_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MeasResultIdleNR_r16MeasResultsPerCellListIdleNR_r16(
    pub Vec<MeasResultsPerCellIdleNR_r16>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasResultMBSFN_r12Mbsfn_Area_r12 {
    pub mbsfn_area_id_r12: MBSFN_AreaId_r12,
    pub carrier_freq_r12: ARFCN_ValueEUTRA_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct MeasResultSSTD_r13Sfn_OffsetResult_r13(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-5", ub = "4")]
pub struct MeasResultSSTD_r13FrameBoundaryOffsetResult_r13(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "127")]
pub struct MeasResultSSTD_r13SubframeBoundaryOffsetResult_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "10239")]
pub struct MeasResultSensing_r15Sl_SubframeRef_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "400"
)]
pub struct MeasResultSensing_r15SensingResult_r15(pub Vec<SensingResult_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasResultServCellSCG_r12MeasResultSCell_r12 {
    pub rsrp_result_s_cell_r12: RSRP_Range,
    pub rsrq_result_s_cell_r12: RSRQ_Range,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasResultServFreq_r10MeasResultSCell_r10 {
    pub rsrp_result_s_cell_r10: RSRP_Range,
    pub rsrq_result_s_cell_r10: RSRQ_Range,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasResultServFreq_r10MeasResultBestNeighCell_r10 {
    pub phys_cell_id_r10: PhysCellId,
    pub rsrp_result_n_cell_r10: RSRP_Range,
    pub rsrq_result_n_cell_r10: RSRQ_Range,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MeasResultServFreq_r13MeasResultSCell_r13 {
    pub rsrp_result_s_cell_r13: RSRP_Range,
    pub rsrq_result_s_cell_r13: RSRQ_Range_r13,
    #[asn(optional_idx = 0)]
    pub rs_sinr_result_r13: Option<RS_SINR_Range_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MeasResultServFreq_r13MeasResultBestNeighCell_r13 {
    pub phys_cell_id_r13: PhysCellId,
    pub rsrp_result_n_cell_r13: RSRP_Range,
    pub rsrq_result_n_cell_r13: RSRQ_Range_r13,
    #[asn(optional_idx = 0)]
    pub rs_sinr_result_r13: Option<RS_SINR_Range_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MeasResultUTRAPhysCellId {
    #[asn(key = 0, extended = false)]
    Fdd(PhysCellIdUTRA_FDD),
    #[asn(key = 1, extended = false)]
    Tdd(PhysCellIdUTRA_TDD),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct MeasResultUTRACgi_InfoLocationAreaCode(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct MeasResultUTRACgi_InfoRoutingAreaCode(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct MeasResultUTRACgi_Info {
    pub cell_global_id: CellGlobalIdUTRA,
    #[asn(optional_idx = 0)]
    pub location_area_code: Option<MeasResultUTRACgi_InfoLocationAreaCode>,
    #[asn(optional_idx = 1)]
    pub routing_area_code: Option<MeasResultUTRACgi_InfoRoutingAreaCode>,
    #[asn(optional_idx = 2)]
    pub plmn_identity_list: Option<PLMN_IdentityList2>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-5", ub = "91")]
pub struct MeasResultUTRAMeasResultUtra_RSCP(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "49")]
pub struct MeasResultUTRAMeasResultUtra_EcN0(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct MeasResultUTRAMeasResult {
    #[asn(optional_idx = 0)]
    pub utra_rscp: Option<MeasResultUTRAMeasResultUtra_RSCP>,
    #[asn(optional_idx = 1)]
    pub utra_ec_n0: Option<MeasResultUTRAMeasResultUtra_EcN0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31250")]
pub struct MeasResultWLAN_r13AvailableAdmissionCapacityWLAN_r13(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct MeasResultWLAN_r13ChannelUtilizationWLAN_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct MeasResultWLAN_r13StationCountWLAN_r13(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MeasResultWLAN_r13ConnectedWLAN_r13(pub u8);
impl MeasResultWLAN_r13ConnectedWLAN_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasResultsMeasResultPCell {
    pub rsrp_result: RSRP_Range,
    pub rsrq_result: RSRQ_Range,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = true)]
pub enum MeasResultsMeasResultNeighCells {
    #[asn(key = 0, extended = false)]
    MeasResultListEUTRA(MeasResultListEUTRA),
    #[asn(key = 1, extended = false)]
    MeasResultListUTRA(MeasResultListUTRA),
    #[asn(key = 2, extended = false)]
    MeasResultListGERAN(MeasResultListGERAN),
    #[asn(key = 3, extended = false)]
    MeasResultsCDMA2000(MeasResultsCDMA2000),
    #[asn(key = 0, extended = true)]
    MeasResultNeighCellListNR_r15(MeasResultCellListNR_r15),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct MeasResultsCDMA2000PreRegistrationStatusHRPD(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct MeasResultsPerCellIdleNR_r16MeasIdleResultNR_r16 {
    #[asn(optional_idx = 0)]
    pub rsrp_result_nr_r16: Option<RSRP_RangeNR_r15>,
    #[asn(optional_idx = 1)]
    pub rsrq_result_nr_r16: Option<RSRQ_RangeNR_r15>,
    #[asn(optional_idx = 2)]
    pub result_rs_index_list_r16: Option<ResultsPerSSB_IndexList_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "20")]
pub struct MeasSensing_Config_r15SensingSubchannelNumber_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "11")]
pub struct MeasSensing_Config_r15SensingPeriodicity_r15(pub u8);
impl MeasSensing_Config_r15SensingPeriodicity_r15 {
    pub const MS20: u8 = 0u8;
    pub const MS50: u8 = 1u8;
    pub const MS100: u8 = 2u8;
    pub const MS200: u8 = 3u8;
    pub const MS300: u8 = 4u8;
    pub const MS400: u8 = 5u8;
    pub const MS500: u8 = 6u8;
    pub const MS600: u8 = 7u8;
    pub const MS700: u8 = 8u8;
    pub const MS800: u8 = 9u8;
    pub const MS900: u8 = 10u8;
    pub const MS1000: u8 = 11u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "5", ub = "75")]
pub struct MeasSensing_Config_r15SensingReselectionCounter_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8")]
pub struct MeasSensing_Config_r15SensingPriority_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "40", sz_ub = "40")]
pub struct MeasSubframePattern_r10_subframePatternFDD_r10(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "20", sz_ub = "20")]
pub struct MeasSubframePattern_r10_subframePatternTDD_r10_subframeConfig1_5_r10(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "70", sz_ub = "70")]
pub struct MeasSubframePattern_r10_subframePatternTDD_r10_subframeConfig0_r10(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "60", sz_ub = "60")]
pub struct MeasSubframePattern_r10_subframePatternTDD_r10_subframeConfig6_r10(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum MeasSubframePattern_r10_subframePatternTDD_r10 {
    #[asn(key = 0, extended = false)]
    SubframeConfig1_5_r10(MeasSubframePattern_r10_subframePatternTDD_r10_subframeConfig1_5_r10),
    #[asn(key = 1, extended = false)]
    SubframeConfig0_r10(MeasSubframePattern_r10_subframePatternTDD_r10_subframeConfig0_r10),
    #[asn(key = 2, extended = false)]
    SubframeConfig6_r10(MeasSubframePattern_r10_subframePatternTDD_r10_subframeConfig6_r10),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct MeasSubframePatternConfigNeigh_r10_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct MeasSubframePatternConfigNeigh_r10_setup {
    pub meas_subframe_pattern_neigh_r10: MeasSubframePattern_r10,
    #[asn(optional_idx = 0)]
    pub meas_subframe_cell_list_r10: Option<MeasSubframeCellList_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct MeasSubframePatternPCell_r10_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct MeasurementReportCriticalExtensions_c1_spare7;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct MeasurementReportCriticalExtensions_c1_spare6;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct MeasurementReportCriticalExtensions_c1_spare5;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct MeasurementReportCriticalExtensions_c1_spare4;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct MeasurementReportCriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct MeasurementReportCriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct MeasurementReportCriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "7", extensible = false)]
pub enum MeasurementReportCriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    MeasurementReport_r8(MeasurementReport_r8_IEs),
    #[asn(key = 1, extended = false)]
    Spare7(MeasurementReportCriticalExtensions_c1_spare7),
    #[asn(key = 2, extended = false)]
    Spare6(MeasurementReportCriticalExtensions_c1_spare6),
    #[asn(key = 3, extended = false)]
    Spare5(MeasurementReportCriticalExtensions_c1_spare5),
    #[asn(key = 4, extended = false)]
    Spare4(MeasurementReportCriticalExtensions_c1_spare4),
    #[asn(key = 5, extended = false)]
    Spare3(MeasurementReportCriticalExtensions_c1_spare3),
    #[asn(key = 6, extended = false)]
    Spare2(MeasurementReportCriticalExtensions_c1_spare2),
    #[asn(key = 7, extended = false)]
    Spare1(MeasurementReportCriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasurementReportCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MeasurementReportCriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(MeasurementReportCriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(MeasurementReportCriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct MeasurementReport_v8a0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasurementReport_v8a0_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct MobilityControlInfoT304(pub u8);
impl MobilityControlInfoT304 {
    pub const MS50: u8 = 0u8;
    pub const MS100: u8 = 1u8;
    pub const MS150: u8 = 2u8;
    pub const MS200: u8 = 3u8;
    pub const MS500: u8 = 4u8;
    pub const MS1000: u8 = 5u8;
    pub const MS2000: u8 = 6u8;
    pub const MS10000_V1310: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct MobilityControlInfoSCG_r12T307_r12(pub u8);
impl MobilityControlInfoSCG_r12T307_r12 {
    pub const MS50: u8 = 0u8;
    pub const MS100: u8 = 1u8;
    pub const MS150: u8 = 2u8;
    pub const MS200: u8 = 3u8;
    pub const MS500: u8 = 4u8;
    pub const MS1000: u8 = 5u8;
    pub const MS2000: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct MobilityFromEUTRACommandCriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct MobilityFromEUTRACommandCriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum MobilityFromEUTRACommandCriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    MobilityFromEUTRACommand_r8(MobilityFromEUTRACommand_r8_IEs),
    #[asn(key = 1, extended = false)]
    MobilityFromEUTRACommand_r9(MobilityFromEUTRACommand_r9_IEs),
    #[asn(key = 2, extended = false)]
    Spare2(MobilityFromEUTRACommandCriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(MobilityFromEUTRACommandCriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MobilityFromEUTRACommandCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MobilityFromEUTRACommandCriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(MobilityFromEUTRACommandCriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(MobilityFromEUTRACommandCriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct MobilityFromEUTRACommand_r8_IEsCs_FallbackIndicator(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum MobilityFromEUTRACommand_r8_IEsPurpose {
    #[asn(key = 0, extended = false)]
    Handover(Handover),
    #[asn(key = 1, extended = false)]
    CellChangeOrder(CellChangeOrder),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct MobilityFromEUTRACommand_r9_IEsCs_FallbackIndicator(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum MobilityFromEUTRACommand_r9_IEsPurpose {
    #[asn(key = 0, extended = false)]
    Handover(Handover),
    #[asn(key = 1, extended = false)]
    CellChangeOrder(CellChangeOrder),
    #[asn(key = 2, extended = false)]
    E_CSFB_r9(E_CSFB_r9),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MobilityFromEUTRACommand_v1530_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct MobilityFromEUTRACommand_v8a0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MobilityFromEUTRACommand_v8d0_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct MobilityFromEUTRACommand_v930_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MobilityParameters_r14MakeBeforeBreak_r14(pub u8);
impl MobilityParameters_r14MakeBeforeBreak_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MobilityParameters_r14Rach_Less_r14(pub u8);
impl MobilityParameters_r14Rach_Less_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MobilityParameters_v1610Cho_r16(pub u8);
impl MobilityParameters_v1610Cho_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MobilityParameters_v1610Cho_FDD_TDD_r16(pub u8);
impl MobilityParameters_v1610Cho_FDD_TDD_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MobilityParameters_v1610Cho_Failure_r16(pub u8);
impl MobilityParameters_v1610Cho_Failure_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct MobilityParameters_v1610Cho_TwoTriggerEvents_r16(pub u8);
impl MobilityParameters_v1610Cho_TwoTriggerEvents_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct MobilityStateParametersT_Evaluation(pub u8);
impl MobilityStateParametersT_Evaluation {
    pub const S30: u8 = 0u8;
    pub const S60: u8 = 1u8;
    pub const S120: u8 = 2u8;
    pub const S180: u8 = 3u8;
    pub const S240: u8 = 4u8;
    pub const SPARE3: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct MobilityStateParametersT_HystNormal(pub u8);
impl MobilityStateParametersT_HystNormal {
    pub const S30: u8 = 0u8;
    pub const S60: u8 = 1u8;
    pub const S120: u8 = 2u8;
    pub const S180: u8 = 3u8;
    pub const S240: u8 = 4u8;
    pub const SPARE3: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct MobilityStateParametersN_CellChangeMedium(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct MobilityStateParametersN_CellChangeHigh(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct N1PUCCH_AN_CS_r10_Entry(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct N1PUCCH_AN_InfoList_r13_Entry(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct N1PUCCH_AN_PersistentList_Entry(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct N1SPUCCH_AN_PersistentList_r15_Entry(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "109")]
pub struct N4SPUCCH_Resource_r15N4startingPRB_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct N4SPUCCH_Resource_r15N4numberOfPRB_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct NAICS_AssistanceInfo_r12_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct NAICS_AssistanceInfo_r12_setup {
    #[asn(optional_idx = 0)]
    pub neigh_cells_to_release_list_r12: Option<NeighCellsToReleaseList_r12>,
    #[asn(optional_idx = 1)]
    pub neigh_cells_to_add_mod_list_r12: Option<NeighCellsToAddModList_r12>,
    #[asn(optional_idx = 2)]
    pub serv_cellp_a_r12: Option<P_a>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "5")]
pub struct NAICS_Capability_Entry_r12NumberOfNAICS_CapableCC_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct NAICS_Capability_Entry_r12NumberOfAggregatedPRB_r12(pub u8);
impl NAICS_Capability_Entry_r12NumberOfAggregatedPRB_r12 {
    pub const N50: u8 = 0u8;
    pub const N75: u8 = 1u8;
    pub const N100: u8 = 2u8;
    pub const N125: u8 = 3u8;
    pub const N150: u8 = 4u8;
    pub const N175: u8 = 5u8;
    pub const N200: u8 = 6u8;
    pub const N225: u8 = 7u8;
    pub const N250: u8 = 8u8;
    pub const N275: u8 = 9u8;
    pub const N300: u8 = 10u8;
    pub const N350: u8 = 11u8;
    pub const N400: u8 = 12u8;
    pub const N450: u8 = 13u8;
    pub const N500: u8 = 14u8;
    pub const SPARE: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct NTN_Parameters_r17Ntn_Connectivity_EPC_r17(pub u8);
impl NTN_Parameters_r17Ntn_Connectivity_EPC_r17 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct NTN_Parameters_r17Ntn_TA_Report_r17(pub u8);
impl NTN_Parameters_r17Ntn_TA_Report_r17 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct NTN_Parameters_r17Ntn_PUR_TimerDelay_r17(pub u8);
impl NTN_Parameters_r17Ntn_PUR_TimerDelay_r17 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct NTN_Parameters_r17Ntn_OffsetTimingEnh_r17(pub u8);
impl NTN_Parameters_r17Ntn_OffsetTimingEnh_r17 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct NTN_Parameters_r17Ntn_ScenarioSupport_r17(pub u8);
impl NTN_Parameters_r17Ntn_ScenarioSupport_r17 {
    pub const NGSO: u8 = 0u8;
    pub const GSO: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct NTN_Parameters_v1720Ntn_SegmentedPrecompensationGaps_r17(pub u8);
impl NTN_Parameters_v1720Ntn_SegmentedPrecompensationGaps_r17 {
    pub const SYM1: u8 = 0u8;
    pub const SL1: u8 = 1u8;
    pub const SF1: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct NeighCellCDMA2000_r11NeighFreqInfoList_r11(pub Vec<NeighCellsPerBandclassCDMA2000_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct NeighCellSI_AcquisitionParameters_r9IntraFreqSI_AcquisitionForHO_r9(pub u8);
impl NeighCellSI_AcquisitionParameters_r9IntraFreqSI_AcquisitionForHO_r9 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct NeighCellSI_AcquisitionParameters_r9InterFreqSI_AcquisitionForHO_r9(pub u8);
impl NeighCellSI_AcquisitionParameters_r9InterFreqSI_AcquisitionForHO_r9 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct NeighCellSI_AcquisitionParameters_r9Utran_SI_AcquisitionForHO_r9(pub u8);
impl NeighCellSI_AcquisitionParameters_r9Utran_SI_AcquisitionForHO_r9 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct NeighCellSI_AcquisitionParameters_v1530ReportCGI_NR_EN_DC_r15(pub u8);
impl NeighCellSI_AcquisitionParameters_v1530ReportCGI_NR_EN_DC_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct NeighCellSI_AcquisitionParameters_v1530ReportCGI_NR_NoEN_DC_r15(pub u8);
impl NeighCellSI_AcquisitionParameters_v1530ReportCGI_NR_NoEN_DC_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct NeighCellSI_AcquisitionParameters_v1550Eutra_CGI_Reporting_ENDC_r15(pub u8);
impl NeighCellSI_AcquisitionParameters_v1550Eutra_CGI_Reporting_ENDC_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct NeighCellSI_AcquisitionParameters_v1550Utra_GERAN_CGI_Reporting_ENDC_r15(pub u8);
impl NeighCellSI_AcquisitionParameters_v1550Utra_GERAN_CGI_Reporting_ENDC_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct NeighCellSI_AcquisitionParameters_v15a0Eutra_CGI_Reporting_NEDC_r15(pub u8);
impl NeighCellSI_AcquisitionParameters_v15a0Eutra_CGI_Reporting_NEDC_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct NeighCellSI_AcquisitionParameters_v1610Eutra_SI_AcquisitionForHO_ENDC_r16(pub u8);
impl NeighCellSI_AcquisitionParameters_v1610Eutra_SI_AcquisitionForHO_ENDC_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct NeighCellSI_AcquisitionParameters_v1610Nr_AutonomousGaps_ENDC_FR1_r16(pub u8);
impl NeighCellSI_AcquisitionParameters_v1610Nr_AutonomousGaps_ENDC_FR1_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct NeighCellSI_AcquisitionParameters_v1610Nr_AutonomousGaps_ENDC_FR2_r16(pub u8);
impl NeighCellSI_AcquisitionParameters_v1610Nr_AutonomousGaps_ENDC_FR2_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct NeighCellSI_AcquisitionParameters_v1610Nr_AutonomousGaps_FR1_r16(pub u8);
impl NeighCellSI_AcquisitionParameters_v1610Nr_AutonomousGaps_FR1_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct NeighCellSI_AcquisitionParameters_v1610Nr_AutonomousGaps_FR2_r16(pub u8);
impl NeighCellSI_AcquisitionParameters_v1610Nr_AutonomousGaps_FR2_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct NeighCellSI_AcquisitionParameters_v1710GNB_ID_Length_Reporting_NR_EN_DC_r17(pub u8);
impl NeighCellSI_AcquisitionParameters_v1710GNB_ID_Length_Reporting_NR_EN_DC_r17 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct NeighCellSI_AcquisitionParameters_v1710GNB_ID_Length_Reporting_NR_NoEN_DC_r17(pub u8);
impl NeighCellSI_AcquisitionParameters_v1710GNB_ID_Length_Reporting_NR_NoEN_DC_r17 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct NeighCellsCRS_Info_r11_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct NeighCellsCRS_Info_r13_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct NeighCellsCRS_Info_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct NeighCellsInfo_r12P_b_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct NeighCellsInfo_r12Crs_PortsCount_r12(pub u8);
impl NeighCellsInfo_r12Crs_PortsCount_r12 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N4: u8 = 2u8;
    pub const SPARE: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct NeighCellsInfo_r12P_aList_r12(pub Vec<P_a>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct NeighCellsInfo_r12TransmissionModeList_r12(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4")]
pub struct NeighCellsInfo_r12ResAllocGranularity_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "40")]
pub struct NeighCellsPerBandclassCDMA2000_r11PhysCellIdList_r11(pub Vec<PhysCellIdCDMA2000>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct NonContiguousUL_RA_WithinCC_r10NonContiguousUL_RA_WithinCC_Info_r10(pub u8);
impl NonContiguousUL_RA_WithinCC_r10NonContiguousUL_RA_WithinCC_Info_r10 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "6")]
pub struct NonMBSFN_SubframeConfig_r14RadioFrameAllocationPeriod_r14(pub u8);
impl NonMBSFN_SubframeConfig_r14RadioFrameAllocationPeriod_r14 {
    pub const RF4: u8 = 0u8;
    pub const RF8: u8 = 1u8;
    pub const RF16: u8 = 2u8;
    pub const RF32: u8 = 3u8;
    pub const RF64: u8 = 4u8;
    pub const RF128: u8 = 5u8;
    pub const RF512: u8 = 6u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct NonMBSFN_SubframeConfig_r14RadioFrameAllocationOffset_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "9", sz_ub = "9")]
pub struct NonMBSFN_SubframeConfig_r14SubframeAllocation_r14(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct OTDOA_PositioningCapabilities_r10Otdoa_UE_Assisted_r10(pub u8);
impl OTDOA_PositioningCapabilities_r10Otdoa_UE_Assisted_r10 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct OTDOA_PositioningCapabilities_r10InterFreqRSTD_Measurement_r10(pub u8);
impl OTDOA_PositioningCapabilities_r10InterFreqRSTD_Measurement_r10 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct ObtainLocationConfig_r11ObtainLocation_r11(pub u8);
impl ObtainLocationConfig_r11ObtainLocation_r11 {
    pub const SETUP: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct Other_Parameters_r11InDeviceCoexInd_r11(pub u8);
impl Other_Parameters_r11InDeviceCoexInd_r11 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct Other_Parameters_r11PowerPrefInd_r11(pub u8);
impl Other_Parameters_r11PowerPrefInd_r11 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct Other_Parameters_r11Ue_Rx_TxTimeDiffMeasurements_r11(pub u8);
impl Other_Parameters_r11Ue_Rx_TxTimeDiffMeasurements_r11 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct Other_Parameters_v11d0InDeviceCoexInd_UL_CA_r11(pub u8);
impl Other_Parameters_v11d0InDeviceCoexInd_UL_CA_r11 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct Other_Parameters_v1360InDeviceCoexInd_HardwareSharingInd_r13(pub u8);
impl Other_Parameters_v1360InDeviceCoexInd_HardwareSharingInd_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct Other_Parameters_v1430BwPrefInd_r14(pub u8);
impl Other_Parameters_v1430BwPrefInd_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct Other_Parameters_v1430Rlm_ReportSupport_r14(pub u8);
impl Other_Parameters_v1430Rlm_ReportSupport_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct Other_Parameters_v1460NonCSG_SI_Reporting_r14(pub u8);
impl Other_Parameters_v1460NonCSG_SI_Reporting_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct Other_Parameters_v1530AssistInfoBitForLC_r15(pub u8);
impl Other_Parameters_v1530AssistInfoBitForLC_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct Other_Parameters_v1530TimeReferenceProvision_r15(pub u8);
impl Other_Parameters_v1530TimeReferenceProvision_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct Other_Parameters_v1530FlightPathPlan_r15(pub u8);
impl Other_Parameters_v1530FlightPathPlan_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct Other_Parameters_v1540InDeviceCoexInd_ENDC_r15(pub u8);
impl Other_Parameters_v1540InDeviceCoexInd_ENDC_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct Other_Parameters_v1610ResumeWithStoredMCG_SCells_r16(pub u8);
impl Other_Parameters_v1610ResumeWithStoredMCG_SCells_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct Other_Parameters_v1610ResumeWithMCG_SCellConfig_r16(pub u8);
impl Other_Parameters_v1610ResumeWithMCG_SCellConfig_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct Other_Parameters_v1610ResumeWithStoredSCG_r16(pub u8);
impl Other_Parameters_v1610ResumeWithStoredSCG_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct Other_Parameters_v1610ResumeWithSCG_Config_r16(pub u8);
impl Other_Parameters_v1610ResumeWithSCG_Config_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct Other_Parameters_v1610McgRLF_RecoveryViaSCG_r16(pub u8);
impl Other_Parameters_v1610McgRLF_RecoveryViaSCG_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct Other_Parameters_v1610OverheatingIndForSCG_r16(pub u8);
impl Other_Parameters_v1610OverheatingIndForSCG_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct Other_Parameters_v1650MpsPriorityIndication_r16(pub u8);
impl Other_Parameters_v1650MpsPriorityIndication_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct Other_Parameters_v1690Ul_RRC_Segmentation_r16(pub u8);
impl Other_Parameters_v1690Ul_RRC_Segmentation_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct OtherParameters_v1450OverheatingInd_r14(pub u8);
impl OtherParameters_v1450OverheatingInd_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "19")]
pub struct OverheatingAssistance_r14ReducedUE_CategoryReducedUE_CategoryDL(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "21")]
pub struct OverheatingAssistance_r14ReducedUE_CategoryReducedUE_CategoryUL(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct OverheatingAssistance_r14ReducedUE_Category {
    pub reduced_ue_category_dl: OverheatingAssistance_r14ReducedUE_CategoryReducedUE_CategoryDL,
    pub reduced_ue_category_ul: OverheatingAssistance_r14ReducedUE_CategoryReducedUE_CategoryUL,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct OverheatingAssistance_r14ReducedMaxCCsReducedCCsDL(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct OverheatingAssistance_r14ReducedMaxCCsReducedCCsUL(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct OverheatingAssistance_r14ReducedMaxCCs {
    pub reduced_c_cs_dl: OverheatingAssistance_r14ReducedMaxCCsReducedCCsDL,
    pub reduced_c_cs_ul: OverheatingAssistance_r14ReducedMaxCCsReducedCCsUL,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OverheatingAssistance_v1610OverheatingAssistanceForSCG_r16(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OverheatingAssistance_v1710OverheatingAssistanceForSCG_FR2_2_r17(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-8", ub = "15")]
pub struct P_C_AndCBSR_r11P_C_r11(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING")]
pub struct P_C_AndCBSR_r11CodebookSubsetRestriction_r11(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-8", ub = "15")]
pub struct P_C_AndCBSR_r13P_C_r13(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING")]
pub struct P_C_AndCBSR_r13Cbsr_Selection_r13_nonPrecoded_r13CodebookSubsetRestriction1_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING")]
pub struct P_C_AndCBSR_r13Cbsr_Selection_r13_nonPrecoded_r13CodebookSubsetRestriction2_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct P_C_AndCBSR_r13Cbsr_Selection_r13_nonPrecoded_r13 {
    pub codebook_subset_restriction1_r13:
        P_C_AndCBSR_r13Cbsr_Selection_r13_nonPrecoded_r13CodebookSubsetRestriction1_r13,
    pub codebook_subset_restriction2_r13:
        P_C_AndCBSR_r13Cbsr_Selection_r13_nonPrecoded_r13CodebookSubsetRestriction2_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING")]
pub struct P_C_AndCBSR_r13Cbsr_Selection_r13_beamformedK1a_r13CodebookSubsetRestriction3_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct P_C_AndCBSR_r13Cbsr_Selection_r13_beamformedK1a_r13 {
    pub codebook_subset_restriction3_r13:
        P_C_AndCBSR_r13Cbsr_Selection_r13_beamformedK1a_r13CodebookSubsetRestriction3_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING")]
pub struct P_C_AndCBSR_r13Cbsr_Selection_r13_beamformedKN_r13CodebookSubsetRestriction_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct P_C_AndCBSR_r13Cbsr_Selection_r13_beamformedKN_r13 {
    pub codebook_subset_restriction_r13:
        P_C_AndCBSR_r13Cbsr_Selection_r13_beamformedKN_r13CodebookSubsetRestriction_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum P_C_AndCBSR_r13Cbsr_Selection_r13 {
    #[asn(key = 0, extended = false)]
    NonPrecoded_r13(P_C_AndCBSR_r13Cbsr_Selection_r13_nonPrecoded_r13),
    #[asn(key = 1, extended = false)]
    BeamformedK1a_r13(P_C_AndCBSR_r13Cbsr_Selection_r13_beamformedK1a_r13),
    #[asn(key = 2, extended = false)]
    BeamformedKN_r13(P_C_AndCBSR_r13Cbsr_Selection_r13_beamformedKN_r13),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-8", ub = "15")]
pub struct P_C_AndCBSR_r15P_C_r15(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING")]
pub struct P_C_AndCBSR_r15CodebookSubsetRestriction4_r15(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct PCCH_ConfigDefaultPagingCycle(pub u8);
impl PCCH_ConfigDefaultPagingCycle {
    pub const RF32: u8 = 0u8;
    pub const RF64: u8 = 1u8;
    pub const RF128: u8 = 2u8;
    pub const RF256: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct PCCH_ConfigNB(pub u8);
impl PCCH_ConfigNB {
    pub const FOUR_T: u8 = 0u8;
    pub const TWO_T: u8 = 1u8;
    pub const ONE_T: u8 = 2u8;
    pub const HALF_T: u8 = 3u8;
    pub const QUARTER_T: u8 = 4u8;
    pub const ONE_EIGHTH_T: u8 = 5u8;
    pub const ONE_SIXTEENTH_T: u8 = 6u8;
    pub const ONE_THIRTY_SECOND_T: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct PCCH_Config_v1310Paging_narrowBands_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "8")]
pub struct PCCH_Config_v1310Mpdcch_NumRepetition_Paging_r13(pub u8);
impl PCCH_Config_v1310Mpdcch_NumRepetition_Paging_r13 {
    pub const R1: u8 = 0u8;
    pub const R2: u8 = 1u8;
    pub const R4: u8 = 2u8;
    pub const R8: u8 = 3u8;
    pub const R16: u8 = 4u8;
    pub const R32: u8 = 5u8;
    pub const R64: u8 = 6u8;
    pub const R128: u8 = 7u8;
    pub const R256: u8 = 8u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct PCCH_Config_v1310NB_v1310(pub u8);
impl PCCH_Config_v1310NB_v1310 {
    pub const ONE64TH_T: u8 = 0u8;
    pub const ONE128TH_T: u8 = 1u8;
    pub const ONE256TH_T: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PCCH_Config_v1700RanPagingInIdlePO_r17(pub u8);
impl PCCH_Config_v1700RanPagingInIdlePO_r17 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = false)]
pub enum PCCH_MessageType_c1 {
    #[asn(key = 0, extended = false)]
    Paging(Paging),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PCCH_MessageType_messageClassExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PDCCH_CandidateReductions_r13_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDCCH_CandidateReductions_r13_setup {
    pub pdcch_candidate_reduction_al1_r13: PDCCH_CandidateReductionValue_r13,
    pub pdcch_candidate_reduction_al2_r13: PDCCH_CandidateReductionValue_r13,
    pub pdcch_candidate_reduction_al3_r13: PDCCH_CandidateReductionValue_r13,
    pub pdcch_candidate_reduction_al4_r13: PDCCH_CandidateReductionValue_r13,
    pub pdcch_candidate_reduction_al5_r13: PDCCH_CandidateReductionValue_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PDCCH_CandidateReductionsLAA_UL_r14_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDCCH_CandidateReductionsLAA_UL_r14_setup {
    pub pdcch_candidate_reduction_al1_r14: PDCCH_CandidateReductionValue_r13,
    pub pdcch_candidate_reduction_al2_r14: PDCCH_CandidateReductionValue_r13,
    pub pdcch_candidate_reduction_al3_r14: PDCCH_CandidateReductionValue_r14,
    pub pdcch_candidate_reduction_al4_r14: PDCCH_CandidateReductionValue_r14,
    pub pdcch_candidate_reduction_al5_r14: PDCCH_CandidateReductionValue_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct PDCCH_ConfigLAA_r14MaxNumberOfSchedSubframes_Format0B_r14(pub u8);
impl PDCCH_ConfigLAA_r14MaxNumberOfSchedSubframes_Format0B_r14 {
    pub const SF2: u8 = 0u8;
    pub const SF3: u8 = 1u8;
    pub const SF4: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct PDCCH_ConfigLAA_r14MaxNumberOfSchedSubframes_Format4B_r14(pub u8);
impl PDCCH_ConfigLAA_r14MaxNumberOfSchedSubframes_Format4B_r14 {
    pub const SF2: u8 = 0u8;
    pub const SF3: u8 = 1u8;
    pub const SF4: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDCCH_ConfigLAA_r14SkipMonitoringDCI_Format0A_r14(pub u8);
impl PDCCH_ConfigLAA_r14SkipMonitoringDCI_Format0A_r14 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDCCH_ConfigLAA_r14SkipMonitoringDCI_Format4A_r14(pub u8);
impl PDCCH_ConfigLAA_r14SkipMonitoringDCI_Format4A_r14 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDCCH_ConfigSCell_r13SkipMonitoringDCI_format0_1A_r13(pub u8);
impl PDCCH_ConfigSCell_r13SkipMonitoringDCI_format0_1A_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct PDCP_ConfigDiscardTimer(pub u8);
impl PDCP_ConfigDiscardTimer {
    pub const MS50: u8 = 0u8;
    pub const MS100: u8 = 1u8;
    pub const MS150: u8 = 2u8;
    pub const MS300: u8 = 3u8;
    pub const MS500: u8 = 4u8;
    pub const MS750: u8 = 5u8;
    pub const MS1500: u8 = 6u8;
    pub const INFINITY: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PDCP_ConfigRlc_AMStatusReportRequired(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDCP_ConfigRlc_AM {
    pub status_report_required: PDCP_ConfigRlc_AMStatusReportRequired,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct PDCP_ConfigRlc_UMPdcp_SN_Size(pub u8);
impl PDCP_ConfigRlc_UMPdcp_SN_Size {
    pub const LEN7BITS: u8 = 0u8;
    pub const LEN12BITS: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDCP_ConfigRlc_UM {
    pub pdcp_sn_size: PDCP_ConfigRlc_UMPdcp_SN_Size,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PDCP_ConfigHeaderCompression_notUsed;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16383")]
pub struct PDCP_ConfigHeaderCompression_rohcMaxCID(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PDCP_ConfigHeaderCompression_rohcProfilesProfile0x0001(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PDCP_ConfigHeaderCompression_rohcProfilesProfile0x0002(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PDCP_ConfigHeaderCompression_rohcProfilesProfile0x0003(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PDCP_ConfigHeaderCompression_rohcProfilesProfile0x0004(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PDCP_ConfigHeaderCompression_rohcProfilesProfile0x0006(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PDCP_ConfigHeaderCompression_rohcProfilesProfile0x0101(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PDCP_ConfigHeaderCompression_rohcProfilesProfile0x0102(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PDCP_ConfigHeaderCompression_rohcProfilesProfile0x0103(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PDCP_ConfigHeaderCompression_rohcProfilesProfile0x0104(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDCP_ConfigHeaderCompression_rohcProfiles {
    pub profile0x0001: PDCP_ConfigHeaderCompression_rohcProfilesProfile0x0001,
    pub profile0x0002: PDCP_ConfigHeaderCompression_rohcProfilesProfile0x0002,
    pub profile0x0003: PDCP_ConfigHeaderCompression_rohcProfilesProfile0x0003,
    pub profile0x0004: PDCP_ConfigHeaderCompression_rohcProfilesProfile0x0004,
    pub profile0x0006: PDCP_ConfigHeaderCompression_rohcProfilesProfile0x0006,
    pub profile0x0101: PDCP_ConfigHeaderCompression_rohcProfilesProfile0x0101,
    pub profile0x0102: PDCP_ConfigHeaderCompression_rohcProfilesProfile0x0102,
    pub profile0x0103: PDCP_ConfigHeaderCompression_rohcProfilesProfile0x0103,
    pub profile0x0104: PDCP_ConfigHeaderCompression_rohcProfilesProfile0x0104,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDCP_ConfigHeaderCompression_rohc {
    #[asn(optional_idx = 0)]
    pub max_cid: Option<PDCP_ConfigHeaderCompression_rohcMaxCID>,
    pub profiles: PDCP_ConfigHeaderCompression_rohcProfiles,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PDCP_ConfigHeaderCompression {
    #[asn(key = 0, extended = false)]
    NotUsed(PDCP_ConfigHeaderCompression_notUsed),
    #[asn(key = 1, extended = false)]
    Rohc(PDCP_ConfigHeaderCompression_rohc),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct PDCP_ParametersMaxNumberROHC_ContextSessions(pub u8);
impl PDCP_ParametersMaxNumberROHC_ContextSessions {
    pub const CS2: u8 = 0u8;
    pub const CS4: u8 = 1u8;
    pub const CS8: u8 = 2u8;
    pub const CS12: u8 = 3u8;
    pub const CS16: u8 = 4u8;
    pub const CS24: u8 = 5u8;
    pub const CS32: u8 = 6u8;
    pub const CS48: u8 = 7u8;
    pub const CS64: u8 = 8u8;
    pub const CS128: u8 = 9u8;
    pub const CS256: u8 = 10u8;
    pub const CS512: u8 = 11u8;
    pub const CS1024: u8 = 12u8;
    pub const CS16384: u8 = 13u8;
    pub const SPARE2: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDCP_Parameters_v1130Pdcp_SN_Extension_r11(pub u8);
impl PDCP_Parameters_v1130Pdcp_SN_Extension_r11 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDCP_Parameters_v1130SupportRohcContextContinue_r11(pub u8);
impl PDCP_Parameters_v1130SupportRohcContextContinue_r11 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDCP_Parameters_v1310Pdcp_SN_Extension_18bits_r13(pub u8);
impl PDCP_Parameters_v1310Pdcp_SN_Extension_18bits_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PDCP_Parameters_v1430SupportedUplinkOnlyROHC_Profiles_r14Profile0x0006_r14(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDCP_Parameters_v1430SupportedUplinkOnlyROHC_Profiles_r14 {
    pub profile0x0006_r14:
        PDCP_Parameters_v1430SupportedUplinkOnlyROHC_Profiles_r14Profile0x0006_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct PDCP_Parameters_v1430MaxNumberROHC_ContextSessions_r14(pub u8);
impl PDCP_Parameters_v1430MaxNumberROHC_ContextSessions_r14 {
    pub const CS2: u8 = 0u8;
    pub const CS4: u8 = 1u8;
    pub const CS8: u8 = 2u8;
    pub const CS12: u8 = 3u8;
    pub const CS16: u8 = 4u8;
    pub const CS24: u8 = 5u8;
    pub const CS32: u8 = 6u8;
    pub const CS48: u8 = 7u8;
    pub const CS64: u8 = 8u8;
    pub const CS128: u8 = 9u8;
    pub const CS256: u8 = 10u8;
    pub const CS512: u8 = 11u8;
    pub const CS1024: u8 = 12u8;
    pub const CS16384: u8 = 13u8;
    pub const SPARE2: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDCP_Parameters_v1530Pdcp_Duplication_r15(pub u8);
impl PDCP_Parameters_v1530Pdcp_Duplication_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDCP_Parameters_v1610Pdcp_VersionChangeWithoutHO_r16(pub u8);
impl PDCP_Parameters_v1610Pdcp_VersionChangeWithoutHO_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDCP_Parameters_v1610Ehc_r16(pub u8);
impl PDCP_Parameters_v1610Ehc_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDCP_Parameters_v1610ContinueEHC_Context_r16(pub u8);
impl PDCP_Parameters_v1610ContinueEHC_Context_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct PDCP_Parameters_v1610MaxNumberEHC_Contexts_r16(pub u8);
impl PDCP_Parameters_v1610MaxNumberEHC_Contexts_r16 {
    pub const CS2: u8 = 0u8;
    pub const CS4: u8 = 1u8;
    pub const CS8: u8 = 2u8;
    pub const CS16: u8 = 3u8;
    pub const CS32: u8 = 4u8;
    pub const CS64: u8 = 5u8;
    pub const CS128: u8 = 6u8;
    pub const CS256: u8 = 7u8;
    pub const CS512: u8 = 8u8;
    pub const CS1024: u8 = 9u8;
    pub const CS2048: u8 = 10u8;
    pub const CS4096: u8 = 11u8;
    pub const CS8192: u8 = 12u8;
    pub const CS16384: u8 = 13u8;
    pub const CS32768: u8 = 14u8;
    pub const CS65536: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDCP_Parameters_v1610JointEHC_ROHC_Config_r16(pub u8);
impl PDCP_Parameters_v1610JointEHC_ROHC_Config_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct PDCP_ParametersNR_r15Rohc_ContextMaxSessions_r15(pub u8);
impl PDCP_ParametersNR_r15Rohc_ContextMaxSessions_r15 {
    pub const CS2: u8 = 0u8;
    pub const CS4: u8 = 1u8;
    pub const CS8: u8 = 2u8;
    pub const CS12: u8 = 3u8;
    pub const CS16: u8 = 4u8;
    pub const CS24: u8 = 5u8;
    pub const CS32: u8 = 6u8;
    pub const CS48: u8 = 7u8;
    pub const CS64: u8 = 8u8;
    pub const CS128: u8 = 9u8;
    pub const CS256: u8 = 10u8;
    pub const CS512: u8 = 11u8;
    pub const CS1024: u8 = 12u8;
    pub const CS16384: u8 = 13u8;
    pub const SPARE2: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PDCP_ParametersNR_r15Rohc_ProfilesUL_Only_r15Profile0x0006_r15(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDCP_ParametersNR_r15Rohc_ProfilesUL_Only_r15 {
    pub profile0x0006_r15: PDCP_ParametersNR_r15Rohc_ProfilesUL_Only_r15Profile0x0006_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDCP_ParametersNR_r15Rohc_ContextContinue_r15(pub u8);
impl PDCP_ParametersNR_r15Rohc_ContextContinue_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDCP_ParametersNR_r15OutOfOrderDelivery_r15(pub u8);
impl PDCP_ParametersNR_r15OutOfOrderDelivery_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDCP_ParametersNR_r15Sn_SizeLo_r15(pub u8);
impl PDCP_ParametersNR_r15Sn_SizeLo_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDCP_ParametersNR_r15Ims_VoiceOverNR_PDCP_MCG_Bearer_r15(pub u8);
impl PDCP_ParametersNR_r15Ims_VoiceOverNR_PDCP_MCG_Bearer_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDCP_ParametersNR_r15Ims_VoiceOverNR_PDCP_SCG_Bearer_r15(pub u8);
impl PDCP_ParametersNR_r15Ims_VoiceOverNR_PDCP_SCG_Bearer_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDCP_ParametersNR_v1560Ims_VoNR_PDCP_SCG_NGENDC_r15(pub u8);
impl PDCP_ParametersNR_v1560Ims_VoNR_PDCP_SCG_NGENDC_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-60", ub = "50")]
pub struct PDSCH_ConfigCommonReferenceSignalPower(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct PDSCH_ConfigCommonP_b(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct PDSCH_ConfigCommon_v1310Pdsch_maxNumRepetitionCEmodeA_r13(pub u8);
impl PDSCH_ConfigCommon_v1310Pdsch_maxNumRepetitionCEmodeA_r13 {
    pub const R16: u8 = 0u8;
    pub const R32: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct PDSCH_ConfigCommon_v1310Pdsch_maxNumRepetitionCEmodeB_r13(pub u8);
impl PDSCH_ConfigCommon_v1310Pdsch_maxNumRepetitionCEmodeB_r13 {
    pub const R192: u8 = 0u8;
    pub const R256: u8 = 1u8;
    pub const R384: u8 = 2u8;
    pub const R512: u8 = 3u8;
    pub const R768: u8 = 4u8;
    pub const R1024: u8 = 5u8;
    pub const R1536: u8 = 6u8;
    pub const R2048: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct PDSCH_ConfigDedicatedP_a(pub u8);
impl PDSCH_ConfigDedicatedP_a {
    pub const D_B_6: u8 = 0u8;
    pub const D_B_4DOT77: u8 = 1u8;
    pub const D_B_3: u8 = 2u8;
    pub const D_B_1DOT77: u8 = 3u8;
    pub const D_B0: u8 = 4u8;
    pub const D_B1: u8 = 5u8;
    pub const D_B2: u8 = 6u8;
    pub const D_B3: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct PDSCH_ConfigDedicated_v1130Qcl_Operation(pub u8);
impl PDSCH_ConfigDedicated_v1130Qcl_Operation {
    pub const TYPE_A: u8 = 0u8;
    pub const TYPE_B: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct PDSCH_ConfigDedicated_v1280TbsIndexAlt_r12(pub u8);
impl PDSCH_ConfigDedicated_v1280TbsIndexAlt_r12 {
    pub const A26: u8 = 0u8;
    pub const A33: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct PDSCH_ConfigDedicated_v1430Ce_PDSCH_MaxBandwidth_r14(pub u8);
impl PDSCH_ConfigDedicated_v1430Ce_PDSCH_MaxBandwidth_r14 {
    pub const BW5: u8 = 0u8;
    pub const BW20: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDSCH_ConfigDedicated_v1430Ce_PDSCH_TenProcesses_r14(pub u8);
impl PDSCH_ConfigDedicated_v1430Ce_PDSCH_TenProcesses_r14 {
    pub const ON: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDSCH_ConfigDedicated_v1430Ce_HARQ_AckBundling_r14(pub u8);
impl PDSCH_ConfigDedicated_v1430Ce_HARQ_AckBundling_r14 {
    pub const ON: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct PDSCH_ConfigDedicated_v1430Ce_SchedulingEnhancement_r14(pub u8);
impl PDSCH_ConfigDedicated_v1430Ce_SchedulingEnhancement_r14 {
    pub const RANGE1: u8 = 0u8;
    pub const RANGE2: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDSCH_ConfigDedicated_v1430TbsIndexAlt2_r14(pub u8);
impl PDSCH_ConfigDedicated_v1430TbsIndexAlt2_r14 {
    pub const B33: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDSCH_ConfigDedicated_v1530Qcl_Operation_v1530(pub u8);
impl PDSCH_ConfigDedicated_v1530Qcl_Operation_v1530 {
    pub const TYPE_C: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDSCH_ConfigDedicated_v1530Tbs_IndexAlt3_r15(pub u8);
impl PDSCH_ConfigDedicated_v1530Tbs_IndexAlt3_r15 {
    pub const A37: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDSCH_ConfigDedicated_v1530Ce_CQI_AlternativeTableConfig_r15(pub u8);
impl PDSCH_ConfigDedicated_v1530Ce_CQI_AlternativeTableConfig_r15 {
    pub const ON: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDSCH_ConfigDedicated_v1530Ce_PDSCH_64QAM_Config_r15(pub u8);
impl PDSCH_ConfigDedicated_v1530Ce_PDSCH_64QAM_Config_r15 {
    pub const ON: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDSCH_ConfigDedicated_v1530Ce_PDSCH_FlexibleStartPRB_AllocConfig_r15(pub u8);
impl PDSCH_ConfigDedicated_v1530Ce_PDSCH_FlexibleStartPRB_AllocConfig_r15 {
    pub const ON: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct PDSCH_ConfigDedicated_v1530AltMCS_TableScalingConfig_r15(pub u8);
impl PDSCH_ConfigDedicated_v1530AltMCS_TableScalingConfig_r15 {
    pub const O_DOT5: u8 = 0u8;
    pub const O_DOT625: u8 = 1u8;
    pub const O_DOT75: u8 = 2u8;
    pub const O_DOT875: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PDSCH_ConfigDedicated_v1610Ce_PDSCH_MultiTB_Config_r16_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PDSCH_ConfigDedicated_v1610Ce_PDSCH_MultiTB_Config_r16 {
    #[asn(key = 0, extended = false)]
    Release(PDSCH_ConfigDedicated_v1610Ce_PDSCH_MultiTB_Config_r16_release),
    #[asn(key = 1, extended = false)]
    Setup(CE_PDSCH_MultiTB_Config_r16),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PDSCH_ConfigDedicated_v1700Ce_PDSCH_14HARQ_Config_r17_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PDSCH_ConfigDedicated_v1700Ce_PDSCH_14HARQ_Config_r17 {
    #[asn(key = 0, extended = false)]
    Release(PDSCH_ConfigDedicated_v1700Ce_PDSCH_14HARQ_Config_r17_release),
    #[asn(key = 1, extended = false)]
    Setup(CE_PDSCH_14HARQ_Config_r17),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDSCH_ConfigDedicated_v1700Ce_PDSCH_maxTBS_r17(pub u8);
impl PDSCH_ConfigDedicated_v1700Ce_PDSCH_maxTBS_r17 {
    pub const ENABLED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PDSCH_ConfigDedicatedSCell_v1430TbsIndexAlt2_r14(pub u8);
impl PDSCH_ConfigDedicatedSCell_v1430TbsIndexAlt2_r14 {
    pub const B33: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct PDSCH_RE_MappingQCL_Config_r11OptionalSetOfFields_r11Crs_PortsCount_r11(pub u8);
impl PDSCH_RE_MappingQCL_Config_r11OptionalSetOfFields_r11Crs_PortsCount_r11 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N4: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "5")]
pub struct PDSCH_RE_MappingQCL_Config_r11OptionalSetOfFields_r11Crs_FreqShift_r11(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PDSCH_RE_MappingQCL_Config_r11OptionalSetOfFields_r11Mbsfn_SubframeConfigList_r11_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDSCH_RE_MappingQCL_Config_r11OptionalSetOfFields_r11Mbsfn_SubframeConfigList_r11_setup {
    pub subframe_config_list: MBSFN_SubframeConfigList,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PDSCH_RE_MappingQCL_Config_r11OptionalSetOfFields_r11Mbsfn_SubframeConfigList_r11 {
    #[asn(key = 0, extended = false)]
    Release(
        PDSCH_RE_MappingQCL_Config_r11OptionalSetOfFields_r11Mbsfn_SubframeConfigList_r11_release,
    ),
    #[asn(key = 1, extended = false)]
    Setup(PDSCH_RE_MappingQCL_Config_r11OptionalSetOfFields_r11Mbsfn_SubframeConfigList_r11_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct PDSCH_RE_MappingQCL_Config_r11OptionalSetOfFields_r11Pdsch_Start_r11(pub u8);
impl PDSCH_RE_MappingQCL_Config_r11OptionalSetOfFields_r11Pdsch_Start_r11 {
    pub const RESERVED: u8 = 0u8;
    pub const N1: u8 = 1u8;
    pub const N2: u8 = 2u8;
    pub const N3: u8 = 3u8;
    pub const N4: u8 = 4u8;
    pub const ASSIGNED: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PDSCH_RE_MappingQCL_Config_r11OptionalSetOfFields_r11 {
    pub crs_ports_count_r11:
        PDSCH_RE_MappingQCL_Config_r11OptionalSetOfFields_r11Crs_PortsCount_r11,
    pub crs_freq_shift_r11: PDSCH_RE_MappingQCL_Config_r11OptionalSetOfFields_r11Crs_FreqShift_r11,
    #[asn(optional_idx = 0)]
    pub mbsfn_subframe_config_list_r11:
        Option<PDSCH_RE_MappingQCL_Config_r11OptionalSetOfFields_r11Mbsfn_SubframeConfigList_r11>,
    pub pdsch_start_r11: PDSCH_RE_MappingQCL_Config_r11OptionalSetOfFields_r11Pdsch_Start_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct PHICH_ConfigPhich_Duration(pub u8);
impl PHICH_ConfigPhich_Duration {
    pub const NORMAL: u8 = 0u8;
    pub const EXTENDED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct PHICH_ConfigPhich_Resource(pub u8);
impl PHICH_ConfigPhich_Resource {
    pub const ONE_SIXTH: u8 = 0u8;
    pub const HALF: u8 = 1u8;
    pub const ONE: u8 = 2u8;
    pub const TWO: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct PLMN_IdentityInfoCellReservedForOperatorUse(pub u8);
impl PLMN_IdentityInfoCellReservedForOperatorUse {
    pub const RESERVED: u8 = 0u8;
    pub const NOT_RESERVED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "6")]
pub struct PLMN_IdentityInfo_r15Plmn_Identity_5GC_r15_plmn_Index_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PLMN_IdentityInfo_r15Plmn_Identity_5GC_r15 {
    #[asn(key = 0, extended = false)]
    Plmn_Identity_r15(PLMN_Identity),
    #[asn(key = 1, extended = false)]
    Plmn_Index_r15(PLMN_IdentityInfo_r15Plmn_Identity_5GC_r15_plmn_Index_r15),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct PLMN_IdentityInfo_r15CellReservedForOperatorUse_r15(pub u8);
impl PLMN_IdentityInfo_r15CellReservedForOperatorUse_r15 {
    pub const RESERVED: u8 = 0u8;
    pub const NOT_RESERVED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct PLMN_IdentityInfo_r15CellReservedForOperatorUse_CRS_r15(pub u8);
impl PLMN_IdentityInfo_r15CellReservedForOperatorUse_CRS_r15 {
    pub const RESERVED: u8 = 0u8;
    pub const NOT_RESERVED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct PLMN_IdentityInfo_v1530CellReservedForOperatorUse_CRS_r15(pub u8);
impl PLMN_IdentityInfo_v1530CellReservedForOperatorUse_CRS_r15 {
    pub const RESERVED: u8 = 0u8;
    pub const NOT_RESERVED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PLMN_IdentityInfo_v1610Cp_CIoT_5GS_Optimisation_r16(pub u8);
impl PLMN_IdentityInfo_v1610Cp_CIoT_5GS_Optimisation_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PLMN_IdentityInfo_v1610Up_CIoT_5GS_Optimisation_r16(pub u8);
impl PLMN_IdentityInfo_v1610Up_CIoT_5GS_Optimisation_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PLMN_IdentityInfo_v1610Iab_Support_r16(pub u8);
impl PLMN_IdentityInfo_v1610Iab_Support_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "6")]
pub struct PLMN_IdentityInfo2_r12_plmn_Index_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "22", ub = "32")]
pub struct PLMN_IdentityInfoNR_v1710GNB_ID_Length_r17(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PLMN_Info_r15UpperLayerIndication_r15(pub u8);
impl PLMN_Info_r15UpperLayerIndication_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "10", sz_ub = "10")]
pub struct PLMN_Info_r16Nr_BandList_r16(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct PLMN_RAN_AreaCell_r15Ran_AreaCells_r15(pub Vec<CellIdentity>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct PLMN_RAN_AreaConfig_r15Ran_Area_r15(pub Vec<RAN_AreaConfig_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1535")]
pub struct PMCH_Config_r12Sf_AllocEnd_r12(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "28")]
pub struct PMCH_Config_r12DataMCS_r12_normal_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "27")]
pub struct PMCH_Config_r12DataMCS_r12_higerOrder_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PMCH_Config_r12DataMCS_r12 {
    #[asn(key = 0, extended = false)]
    Normal_r12(PMCH_Config_r12DataMCS_r12_normal_r12),
    #[asn(key = 1, extended = false)]
    HigerOrder_r12(PMCH_Config_r12DataMCS_r12_higerOrder_r12),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "8")]
pub struct PMCH_Config_r12Mch_SchedulingPeriod_r12(pub u8);
impl PMCH_Config_r12Mch_SchedulingPeriod_r12 {
    pub const RF4: u8 = 0u8;
    pub const RF8: u8 = 1u8;
    pub const RF16: u8 = 2u8;
    pub const RF32: u8 = 3u8;
    pub const RF64: u8 = 4u8;
    pub const RF128: u8 = 5u8;
    pub const RF256: u8 = 6u8;
    pub const RF512: u8 = 7u8;
    pub const RF1024: u8 = 8u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1535")]
pub struct PMCH_Config_r9Sf_AllocEnd_r9(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "28")]
pub struct PMCH_Config_r9DataMCS_r9(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct PMCH_Config_r9Mch_SchedulingPeriod_r9(pub u8);
impl PMCH_Config_r9Mch_SchedulingPeriod_r9 {
    pub const RF8: u8 = 0u8;
    pub const RF16: u8 = 1u8;
    pub const RF32: u8 = 2u8;
    pub const RF64: u8 = 3u8;
    pub const RF128: u8 = 4u8;
    pub const RF256: u8 = 5u8;
    pub const RF512: u8 = 6u8;
    pub const RF1024: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "837")]
pub struct PRACH_ConfigRootSequenceIndex(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct PRACH_Config_v1310Mpdcch_startSF_CSS_RA_r13_fdd_r13(pub u8);
impl PRACH_Config_v1310Mpdcch_startSF_CSS_RA_r13_fdd_r13 {
    pub const V1: u8 = 0u8;
    pub const V1DOT5: u8 = 1u8;
    pub const V2: u8 = 2u8;
    pub const V2DOT5: u8 = 3u8;
    pub const V4: u8 = 4u8;
    pub const V5: u8 = 5u8;
    pub const V8: u8 = 6u8;
    pub const V10: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct PRACH_Config_v1310Mpdcch_startSF_CSS_RA_r13_tdd_r13(pub u8);
impl PRACH_Config_v1310Mpdcch_startSF_CSS_RA_r13_tdd_r13 {
    pub const V1: u8 = 0u8;
    pub const V2: u8 = 1u8;
    pub const V4: u8 = 2u8;
    pub const V5: u8 = 3u8;
    pub const V8: u8 = 4u8;
    pub const V10: u8 = 5u8;
    pub const V20: u8 = 6u8;
    pub const SPARE: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PRACH_Config_v1310Mpdcch_startSF_CSS_RA_r13 {
    #[asn(key = 0, extended = false)]
    Fdd_r13(PRACH_Config_v1310Mpdcch_startSF_CSS_RA_r13_fdd_r13),
    #[asn(key = 1, extended = false)]
    Tdd_r13(PRACH_Config_v1310Mpdcch_startSF_CSS_RA_r13_tdd_r13),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "94")]
pub struct PRACH_Config_v1310Prach_HoppingOffset_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct PRACH_Config_v1310Initial_CE_level_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "837")]
pub struct PRACH_Config_v1430RootSequenceIndexHighSpeed_r14(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "12")]
pub struct PRACH_Config_v1430ZeroCorrelationZoneConfigHighSpeed_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63")]
pub struct PRACH_Config_v1430Prach_ConfigIndexHighSpeed_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "94")]
pub struct PRACH_Config_v1430Prach_FreqOffsetHighSpeed_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63")]
pub struct PRACH_ConfigInfoPrach_ConfigIndex(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PRACH_ConfigInfoHighSpeedFlag(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PRACH_ConfigInfoZeroCorrelationZoneConfig(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "94")]
pub struct PRACH_ConfigInfoPrach_FreqOffset(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63")]
pub struct PRACH_ConfigSCell_r10Prach_ConfigIndex_r10(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "837")]
pub struct PRACH_ConfigSIBRootSequenceIndex(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct PRACH_ConfigSIB_v1310Mpdcch_startSF_CSS_RA_r13_fdd_r13(pub u8);
impl PRACH_ConfigSIB_v1310Mpdcch_startSF_CSS_RA_r13_fdd_r13 {
    pub const V1: u8 = 0u8;
    pub const V1DOT5: u8 = 1u8;
    pub const V2: u8 = 2u8;
    pub const V2DOT5: u8 = 3u8;
    pub const V4: u8 = 4u8;
    pub const V5: u8 = 5u8;
    pub const V8: u8 = 6u8;
    pub const V10: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct PRACH_ConfigSIB_v1310Mpdcch_startSF_CSS_RA_r13_tdd_r13(pub u8);
impl PRACH_ConfigSIB_v1310Mpdcch_startSF_CSS_RA_r13_tdd_r13 {
    pub const V1: u8 = 0u8;
    pub const V2: u8 = 1u8;
    pub const V4: u8 = 2u8;
    pub const V5: u8 = 3u8;
    pub const V8: u8 = 4u8;
    pub const V10: u8 = 5u8;
    pub const V20: u8 = 6u8;
    pub const SPARE: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PRACH_ConfigSIB_v1310Mpdcch_startSF_CSS_RA_r13 {
    #[asn(key = 0, extended = false)]
    Fdd_r13(PRACH_ConfigSIB_v1310Mpdcch_startSF_CSS_RA_r13_fdd_r13),
    #[asn(key = 1, extended = false)]
    Tdd_r13(PRACH_ConfigSIB_v1310Mpdcch_startSF_CSS_RA_r13_tdd_r13),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "94")]
pub struct PRACH_ConfigSIB_v1310Prach_HoppingOffset_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct PRACH_ConfigSIB_v1530Edt_PRACH_ParametersListCE_r15(pub Vec<EDT_PRACH_ParametersCE_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63")]
pub struct PRACH_ParametersCE_r13Prach_ConfigIndex_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "94")]
pub struct PRACH_ParametersCE_r13Prach_FreqOffset_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct PRACH_ParametersCE_r13Prach_StartingSubframe_r13(pub u8);
impl PRACH_ParametersCE_r13Prach_StartingSubframe_r13 {
    pub const SF2: u8 = 0u8;
    pub const SF4: u8 = 1u8;
    pub const SF8: u8 = 2u8;
    pub const SF16: u8 = 3u8;
    pub const SF32: u8 = 4u8;
    pub const SF64: u8 = 5u8;
    pub const SF128: u8 = 6u8;
    pub const SF256: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "6")]
pub struct PRACH_ParametersCE_r13MaxNumPreambleAttemptCE_r13(pub u8);
impl PRACH_ParametersCE_r13MaxNumPreambleAttemptCE_r13 {
    pub const N3: u8 = 0u8;
    pub const N4: u8 = 1u8;
    pub const N5: u8 = 2u8;
    pub const N6: u8 = 3u8;
    pub const N7: u8 = 4u8;
    pub const N8: u8 = 5u8;
    pub const N10: u8 = 6u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct PRACH_ParametersCE_r13NumRepetitionPerPreambleAttempt_r13(pub u8);
impl PRACH_ParametersCE_r13NumRepetitionPerPreambleAttempt_r13 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N4: u8 = 2u8;
    pub const N8: u8 = 3u8;
    pub const N16: u8 = 4u8;
    pub const N32: u8 = 5u8;
    pub const N64: u8 = 6u8;
    pub const N128: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct PRACH_ParametersCE_r13Mpdcch_NarrowbandsToMonitor_r13_Entry(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct PRACH_ParametersCE_r13Mpdcch_NarrowbandsToMonitor_r13(
    pub Vec<PRACH_ParametersCE_r13Mpdcch_NarrowbandsToMonitor_r13_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "8")]
pub struct PRACH_ParametersCE_r13Mpdcch_NumRepetition_RA_r13(pub u8);
impl PRACH_ParametersCE_r13Mpdcch_NumRepetition_RA_r13 {
    pub const R1: u8 = 0u8;
    pub const R2: u8 = 1u8;
    pub const R4: u8 = 2u8;
    pub const R8: u8 = 3u8;
    pub const R16: u8 = 4u8;
    pub const R32: u8 = 5u8;
    pub const R64: u8 = 6u8;
    pub const R128: u8 = 7u8;
    pub const R256: u8 = 8u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct PRACH_ParametersCE_r13Prach_HoppingConfig_r13(pub u8);
impl PRACH_ParametersCE_r13Prach_HoppingConfig_r13 {
    pub const ON: u8 = 0u8;
    pub const OFF: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct PRACH_TxDuration_r17Prach_TxDuration_r17(pub u8);
impl PRACH_TxDuration_r17Prach_TxDuration_r17 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N4: u8 = 2u8;
    pub const N8: u8 = 3u8;
    pub const N16: u8 = 4u8;
    pub const N32: u8 = 5u8;
    pub const N64: u8 = 6u8;
    pub const N128: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PSCellToAddMod_r12CellIdentification_r12 {
    pub phys_cell_id_r12: PhysCellId,
    pub dl_carrier_freq_r12: ARFCN_ValueEUTRA_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct PUCCH_ConfigCommonDeltaPUCCH_Shift(pub u8);
impl PUCCH_ConfigCommonDeltaPUCCH_Shift {
    pub const DS1: u8 = 0u8;
    pub const DS2: u8 = 1u8;
    pub const DS3: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "98")]
pub struct PUCCH_ConfigCommonNRB_CQI(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct PUCCH_ConfigCommonNCS_AN(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct PUCCH_ConfigCommonN1PUCCH_AN(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct PUCCH_ConfigCommon_v1310Pucch_NumRepetitionCE_Msg4_Level0_r13(pub u8);
impl PUCCH_ConfigCommon_v1310Pucch_NumRepetitionCE_Msg4_Level0_r13 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N4: u8 = 2u8;
    pub const N8: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct PUCCH_ConfigCommon_v1310Pucch_NumRepetitionCE_Msg4_Level1_r13(pub u8);
impl PUCCH_ConfigCommon_v1310Pucch_NumRepetitionCE_Msg4_Level1_r13 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N4: u8 = 2u8;
    pub const N8: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct PUCCH_ConfigCommon_v1310Pucch_NumRepetitionCE_Msg4_Level2_r13(pub u8);
impl PUCCH_ConfigCommon_v1310Pucch_NumRepetitionCE_Msg4_Level2_r13 {
    pub const N4: u8 = 0u8;
    pub const N8: u8 = 1u8;
    pub const N16: u8 = 2u8;
    pub const N32: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct PUCCH_ConfigCommon_v1310Pucch_NumRepetitionCE_Msg4_Level3_r13(pub u8);
impl PUCCH_ConfigCommon_v1310Pucch_NumRepetitionCE_Msg4_Level3_r13 {
    pub const N4: u8 = 0u8;
    pub const N8: u8 = 1u8;
    pub const N16: u8 = 2u8;
    pub const N32: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct PUCCH_ConfigCommon_v1430Pucch_NumRepetitionCE_Msg4_Level3_r14(pub u8);
impl PUCCH_ConfigCommon_v1430Pucch_NumRepetitionCE_Msg4_Level3_r14 {
    pub const N64: u8 = 0u8;
    pub const N128: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PUCCH_ConfigDedicatedAckNackRepetition_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct PUCCH_ConfigDedicatedAckNackRepetition_setupRepetitionFactor(pub u8);
impl PUCCH_ConfigDedicatedAckNackRepetition_setupRepetitionFactor {
    pub const N2: u8 = 0u8;
    pub const N4: u8 = 1u8;
    pub const N6: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct PUCCH_ConfigDedicatedAckNackRepetition_setupN1PUCCH_AN_Rep(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUCCH_ConfigDedicatedAckNackRepetition_setup {
    pub repetition_factor: PUCCH_ConfigDedicatedAckNackRepetition_setupRepetitionFactor,
    pub n1pucch_an_rep: PUCCH_ConfigDedicatedAckNackRepetition_setupN1PUCCH_AN_Rep,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUCCH_ConfigDedicatedAckNackRepetition {
    #[asn(key = 0, extended = false)]
    Release(PUCCH_ConfigDedicatedAckNackRepetition_release),
    #[asn(key = 1, extended = false)]
    Setup(PUCCH_ConfigDedicatedAckNackRepetition_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct PUCCH_ConfigDedicatedTdd_AckNackFeedbackMode(pub u8);
impl PUCCH_ConfigDedicatedTdd_AckNackFeedbackMode {
    pub const BUNDLING: u8 = 0u8;
    pub const MULTIPLEXING: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PUCCH_ConfigDedicated_r13AckNackRepetition_r13_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct PUCCH_ConfigDedicated_r13AckNackRepetition_r13_setupRepetitionFactor_r13(pub u8);
impl PUCCH_ConfigDedicated_r13AckNackRepetition_r13_setupRepetitionFactor_r13 {
    pub const N2: u8 = 0u8;
    pub const N4: u8 = 1u8;
    pub const N6: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct PUCCH_ConfigDedicated_r13AckNackRepetition_r13_setupN1PUCCH_AN_Rep_r13(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUCCH_ConfigDedicated_r13AckNackRepetition_r13_setup {
    pub repetition_factor_r13:
        PUCCH_ConfigDedicated_r13AckNackRepetition_r13_setupRepetitionFactor_r13,
    pub n1pucch_an_rep_r13: PUCCH_ConfigDedicated_r13AckNackRepetition_r13_setupN1PUCCH_AN_Rep_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUCCH_ConfigDedicated_r13AckNackRepetition_r13 {
    #[asn(key = 0, extended = false)]
    Release(PUCCH_ConfigDedicated_r13AckNackRepetition_r13_release),
    #[asn(key = 1, extended = false)]
    Setup(PUCCH_ConfigDedicated_r13AckNackRepetition_r13_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct PUCCH_ConfigDedicated_r13Tdd_AckNackFeedbackMode_r13(pub u8);
impl PUCCH_ConfigDedicated_r13Tdd_AckNackFeedbackMode_r13 {
    pub const BUNDLING: u8 = 0u8;
    pub const MULTIPLEXING: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "549")]
pub struct PUCCH_ConfigDedicated_r13Pucch_Format_r13_format3_r13N3PUCCH_AN_List_r13_Entry(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct PUCCH_ConfigDedicated_r13Pucch_Format_r13_format3_r13N3PUCCH_AN_List_r13(
    pub Vec<PUCCH_ConfigDedicated_r13Pucch_Format_r13_format3_r13N3PUCCH_AN_List_r13_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PUCCH_ConfigDedicated_r13Pucch_Format_r13_format3_r13TwoAntennaPortActivatedPUCCH_Format3_r13_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "549")]
pub struct PUCCH_ConfigDedicated_r13Pucch_Format_r13_format3_r13TwoAntennaPortActivatedPUCCH_Format3_r13_setupN3PUCCH_AN_ListP1_r13_Entry(
    pub u16,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct PUCCH_ConfigDedicated_r13Pucch_Format_r13_format3_r13TwoAntennaPortActivatedPUCCH_Format3_r13_setupN3PUCCH_AN_ListP1_r13 (pub Vec < PUCCH_ConfigDedicated_r13Pucch_Format_r13_format3_r13TwoAntennaPortActivatedPUCCH_Format3_r13_setupN3PUCCH_AN_ListP1_r13_Entry >) ;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUCCH_ConfigDedicated_r13Pucch_Format_r13_format3_r13TwoAntennaPortActivatedPUCCH_Format3_r13_setup { pub n3pucch_an_list_p1_r13 : PUCCH_ConfigDedicated_r13Pucch_Format_r13_format3_r13TwoAntennaPortActivatedPUCCH_Format3_r13_setupN3PUCCH_AN_ListP1_r13 , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUCCH_ConfigDedicated_r13Pucch_Format_r13_format3_r13TwoAntennaPortActivatedPUCCH_Format3_r13
{
    # [asn (key = 0 , extended = false)] Release (PUCCH_ConfigDedicated_r13Pucch_Format_r13_format3_r13TwoAntennaPortActivatedPUCCH_Format3_r13_release) , # [asn (key = 1 , extended = false)] Setup (PUCCH_ConfigDedicated_r13Pucch_Format_r13_format3_r13TwoAntennaPortActivatedPUCCH_Format3_r13_setup) , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct PUCCH_ConfigDedicated_r13Pucch_Format_r13_format3_r13 { # [asn (optional_idx = 0 ,)] pub n3pucch_an_list_r13 : Option < PUCCH_ConfigDedicated_r13Pucch_Format_r13_format3_r13N3PUCCH_AN_List_r13 > , # [asn (optional_idx = 1 ,)] pub two_antenna_port_activated_pucch_format3_r13 : Option < PUCCH_ConfigDedicated_r13Pucch_Format_r13_format3_r13TwoAntennaPortActivatedPUCCH_Format3_r13 > , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PUCCH_ConfigDedicated_r13Pucch_Format_r13_channelSelection_r13N1PUCCH_AN_CS_r13_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct PUCCH_ConfigDedicated_r13Pucch_Format_r13_channelSelection_r13N1PUCCH_AN_CS_r13_setupN1PUCCH_AN_CS_List_r13(
    pub Vec<N1PUCCH_AN_CS_r10>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct PUCCH_ConfigDedicated_r13Pucch_Format_r13_channelSelection_r13N1PUCCH_AN_CS_r13_setupDummy1_Entry(
    pub u16,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "2", sz_ub = "4")]
pub struct PUCCH_ConfigDedicated_r13Pucch_Format_r13_channelSelection_r13N1PUCCH_AN_CS_r13_setupDummy1 (pub Vec < PUCCH_ConfigDedicated_r13Pucch_Format_r13_channelSelection_r13N1PUCCH_AN_CS_r13_setupDummy1_Entry >) ;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUCCH_ConfigDedicated_r13Pucch_Format_r13_channelSelection_r13N1PUCCH_AN_CS_r13_setup { pub n1pucch_an_cs_list_r13 : PUCCH_ConfigDedicated_r13Pucch_Format_r13_channelSelection_r13N1PUCCH_AN_CS_r13_setupN1PUCCH_AN_CS_List_r13 , pub dummy1 : PUCCH_ConfigDedicated_r13Pucch_Format_r13_channelSelection_r13N1PUCCH_AN_CS_r13_setupDummy1 , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUCCH_ConfigDedicated_r13Pucch_Format_r13_channelSelection_r13N1PUCCH_AN_CS_r13 {
    #[asn(key = 0, extended = false)]
    Release(
        PUCCH_ConfigDedicated_r13Pucch_Format_r13_channelSelection_r13N1PUCCH_AN_CS_r13_release,
    ),
    #[asn(key = 1, extended = false)]
    Setup(PUCCH_ConfigDedicated_r13Pucch_Format_r13_channelSelection_r13N1PUCCH_AN_CS_r13_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PUCCH_ConfigDedicated_r13Pucch_Format_r13_channelSelection_r13 {
    #[asn(optional_idx = 0)]
    pub n1pucch_an_cs_r13:
        Option<PUCCH_ConfigDedicated_r13Pucch_Format_r13_channelSelection_r13N1PUCCH_AN_CS_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct PUCCH_ConfigDedicated_r13Pucch_Format_r13_format4_r13Format4_resourceConfiguration_r13(
    pub Vec<Format4_resource_r13>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct PUCCH_ConfigDedicated_r13Pucch_Format_r13_format4_r13Format4_MultiCSI_resourceConfiguration_r13(
    pub Vec<Format4_resource_r13>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PUCCH_ConfigDedicated_r13Pucch_Format_r13_format4_r13 { pub format4_resource_configuration_r13 : PUCCH_ConfigDedicated_r13Pucch_Format_r13_format4_r13Format4_resourceConfiguration_r13 , # [asn (optional_idx = 0 ,)] pub format4_multi_csi_resource_configuration_r13 : Option < PUCCH_ConfigDedicated_r13Pucch_Format_r13_format4_r13Format4_MultiCSI_resourceConfiguration_r13 > , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct PUCCH_ConfigDedicated_r13Pucch_Format_r13_format5_r13Format5_resourceConfiguration_r13(
    pub Vec<Format5_resource_r13>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PUCCH_ConfigDedicated_r13Pucch_Format_r13_format5_r13 {
    pub format5_resource_configuration_r13:
        PUCCH_ConfigDedicated_r13Pucch_Format_r13_format5_r13Format5_resourceConfiguration_r13,
    #[asn(optional_idx = 0)]
    pub format5_multi_csi_resource_configuration_r13: Option<Format5_resource_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum PUCCH_ConfigDedicated_r13Pucch_Format_r13 {
    #[asn(key = 0, extended = false)]
    Format3_r13(PUCCH_ConfigDedicated_r13Pucch_Format_r13_format3_r13),
    #[asn(key = 1, extended = false)]
    ChannelSelection_r13(PUCCH_ConfigDedicated_r13Pucch_Format_r13_channelSelection_r13),
    #[asn(key = 2, extended = false)]
    Format4_r13(PUCCH_ConfigDedicated_r13Pucch_Format_r13_format4_r13),
    #[asn(key = 3, extended = false)]
    Format5_r13(PUCCH_ConfigDedicated_r13Pucch_Format_r13_format5_r13),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUCCH_ConfigDedicated_r13TwoAntennaPortActivatedPUCCH_Format1a1b_r13(pub u8);
impl PUCCH_ConfigDedicated_r13TwoAntennaPortActivatedPUCCH_Format1a1b_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUCCH_ConfigDedicated_r13SimultaneousPUCCH_PUSCH_r13(pub u8);
impl PUCCH_ConfigDedicated_r13SimultaneousPUCCH_PUSCH_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct PUCCH_ConfigDedicated_r13N1PUCCH_AN_RepP1_r13(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PUCCH_ConfigDedicated_r13NPUCCH_Param_r13_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "503")]
pub struct PUCCH_ConfigDedicated_r13NPUCCH_Param_r13_setupNPUCCH_Identity_r13(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct PUCCH_ConfigDedicated_r13NPUCCH_Param_r13_setupN1PUCCH_AN_r13(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUCCH_ConfigDedicated_r13NPUCCH_Param_r13_setup {
    pub npucch_identity_r13: PUCCH_ConfigDedicated_r13NPUCCH_Param_r13_setupNPUCCH_Identity_r13,
    pub n1pucch_an_r13: PUCCH_ConfigDedicated_r13NPUCCH_Param_r13_setupN1PUCCH_AN_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUCCH_ConfigDedicated_r13NPUCCH_Param_r13 {
    #[asn(key = 0, extended = false)]
    Release(PUCCH_ConfigDedicated_r13NPUCCH_Param_r13_release),
    #[asn(key = 1, extended = false)]
    Setup(PUCCH_ConfigDedicated_r13NPUCCH_Param_r13_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PUCCH_ConfigDedicated_r13NkaPUCCH_Param_r13_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct PUCCH_ConfigDedicated_r13NkaPUCCH_Param_r13_setupNkaPUCCH_AN_r13(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUCCH_ConfigDedicated_r13NkaPUCCH_Param_r13_setup {
    pub nka_pucch_an_r13: PUCCH_ConfigDedicated_r13NkaPUCCH_Param_r13_setupNkaPUCCH_AN_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUCCH_ConfigDedicated_r13NkaPUCCH_Param_r13 {
    #[asn(key = 0, extended = false)]
    Release(PUCCH_ConfigDedicated_r13NkaPUCCH_Param_r13_release),
    #[asn(key = 1, extended = false)]
    Setup(PUCCH_ConfigDedicated_r13NkaPUCCH_Param_r13_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PUCCH_ConfigDedicated_r13SpatialBundlingPUCCH_r13(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PUCCH_ConfigDedicated_r13SpatialBundlingPUSCH_r13(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PUCCH_ConfigDedicated_r13Harq_TimingTDD_r13(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct PUCCH_ConfigDedicated_r13CodebooksizeDetermination_r13(pub u8);
impl PUCCH_ConfigDedicated_r13CodebooksizeDetermination_r13 {
    pub const DAI: u8 = 0u8;
    pub const CC: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct PUCCH_ConfigDedicated_r13MaximumPayloadCoderate_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PUCCH_ConfigDedicated_r13Pucch_NumRepetitionCE_r13_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct PUCCH_ConfigDedicated_r13Pucch_NumRepetitionCE_r13_setup_modeAPucch_NumRepetitionCE_format1_r13(
    pub u8,
);
impl
    PUCCH_ConfigDedicated_r13Pucch_NumRepetitionCE_r13_setup_modeAPucch_NumRepetitionCE_format1_r13
{
    pub const R1: u8 = 0u8;
    pub const R2: u8 = 1u8;
    pub const R4: u8 = 2u8;
    pub const R8: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct PUCCH_ConfigDedicated_r13Pucch_NumRepetitionCE_r13_setup_modeAPucch_NumRepetitionCE_format2_r13(
    pub u8,
);
impl
    PUCCH_ConfigDedicated_r13Pucch_NumRepetitionCE_r13_setup_modeAPucch_NumRepetitionCE_format2_r13
{
    pub const R1: u8 = 0u8;
    pub const R2: u8 = 1u8;
    pub const R4: u8 = 2u8;
    pub const R8: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUCCH_ConfigDedicated_r13Pucch_NumRepetitionCE_r13_setup_modeA { pub pucch_num_repetition_ce_format1_r13 : PUCCH_ConfigDedicated_r13Pucch_NumRepetitionCE_r13_setup_modeAPucch_NumRepetitionCE_format1_r13 , pub pucch_num_repetition_ce_format2_r13 : PUCCH_ConfigDedicated_r13Pucch_NumRepetitionCE_r13_setup_modeAPucch_NumRepetitionCE_format2_r13 , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct PUCCH_ConfigDedicated_r13Pucch_NumRepetitionCE_r13_setup_modeBPucch_NumRepetitionCE_format1_r13(
    pub u8,
);
impl
    PUCCH_ConfigDedicated_r13Pucch_NumRepetitionCE_r13_setup_modeBPucch_NumRepetitionCE_format1_r13
{
    pub const R4: u8 = 0u8;
    pub const R8: u8 = 1u8;
    pub const R16: u8 = 2u8;
    pub const R32: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct PUCCH_ConfigDedicated_r13Pucch_NumRepetitionCE_r13_setup_modeBPucch_NumRepetitionCE_format2_r13(
    pub u8,
);
impl
    PUCCH_ConfigDedicated_r13Pucch_NumRepetitionCE_r13_setup_modeBPucch_NumRepetitionCE_format2_r13
{
    pub const R4: u8 = 0u8;
    pub const R8: u8 = 1u8;
    pub const R16: u8 = 2u8;
    pub const R32: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUCCH_ConfigDedicated_r13Pucch_NumRepetitionCE_r13_setup_modeB { pub pucch_num_repetition_ce_format1_r13 : PUCCH_ConfigDedicated_r13Pucch_NumRepetitionCE_r13_setup_modeBPucch_NumRepetitionCE_format1_r13 , pub pucch_num_repetition_ce_format2_r13 : PUCCH_ConfigDedicated_r13Pucch_NumRepetitionCE_r13_setup_modeBPucch_NumRepetitionCE_format2_r13 , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUCCH_ConfigDedicated_r13Pucch_NumRepetitionCE_r13_setup {
    #[asn(key = 0, extended = false)]
    ModeA(PUCCH_ConfigDedicated_r13Pucch_NumRepetitionCE_r13_setup_modeA),
    #[asn(key = 1, extended = false)]
    ModeB(PUCCH_ConfigDedicated_r13Pucch_NumRepetitionCE_r13_setup_modeB),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUCCH_ConfigDedicated_r13Pucch_NumRepetitionCE_r13 {
    #[asn(key = 0, extended = false)]
    Release(PUCCH_ConfigDedicated_r13Pucch_NumRepetitionCE_r13_release),
    #[asn(key = 1, extended = false)]
    Setup(PUCCH_ConfigDedicated_r13Pucch_NumRepetitionCE_r13_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PUCCH_ConfigDedicated_v1020Pucch_Format_r10_channelSelection_r10N1PUCCH_AN_CS_r10_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct PUCCH_ConfigDedicated_v1020Pucch_Format_r10_channelSelection_r10N1PUCCH_AN_CS_r10_setupN1PUCCH_AN_CS_List_r10(
    pub Vec<N1PUCCH_AN_CS_r10>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUCCH_ConfigDedicated_v1020Pucch_Format_r10_channelSelection_r10N1PUCCH_AN_CS_r10_setup { pub n1pucch_an_cs_list_r10 : PUCCH_ConfigDedicated_v1020Pucch_Format_r10_channelSelection_r10N1PUCCH_AN_CS_r10_setupN1PUCCH_AN_CS_List_r10 , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUCCH_ConfigDedicated_v1020Pucch_Format_r10_channelSelection_r10N1PUCCH_AN_CS_r10 {
    #[asn(key = 0, extended = false)]
    Release(
        PUCCH_ConfigDedicated_v1020Pucch_Format_r10_channelSelection_r10N1PUCCH_AN_CS_r10_release,
    ),
    #[asn(key = 1, extended = false)]
    Setup(PUCCH_ConfigDedicated_v1020Pucch_Format_r10_channelSelection_r10N1PUCCH_AN_CS_r10_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PUCCH_ConfigDedicated_v1020Pucch_Format_r10_channelSelection_r10 {
    #[asn(optional_idx = 0)]
    pub n1pucch_an_cs_r10:
        Option<PUCCH_ConfigDedicated_v1020Pucch_Format_r10_channelSelection_r10N1PUCCH_AN_CS_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUCCH_ConfigDedicated_v1020Pucch_Format_r10 {
    #[asn(key = 0, extended = false)]
    Format3_r10(PUCCH_Format3_Conf_r13),
    #[asn(key = 1, extended = false)]
    ChannelSelection_r10(PUCCH_ConfigDedicated_v1020Pucch_Format_r10_channelSelection_r10),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUCCH_ConfigDedicated_v1020TwoAntennaPortActivatedPUCCH_Format1a1b_r10(pub u8);
impl PUCCH_ConfigDedicated_v1020TwoAntennaPortActivatedPUCCH_Format1a1b_r10 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUCCH_ConfigDedicated_v1020SimultaneousPUCCH_PUSCH_r10(pub u8);
impl PUCCH_ConfigDedicated_v1020SimultaneousPUCCH_PUSCH_r10 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct PUCCH_ConfigDedicated_v1020N1PUCCH_AN_RepP1_r10(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PUCCH_ConfigDedicated_v1130N1PUCCH_AN_CS_v1130_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct PUCCH_ConfigDedicated_v1130N1PUCCH_AN_CS_v1130_setupN1PUCCH_AN_CS_ListP1_r11_Entry(
    pub u16,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "2", sz_ub = "4")]
pub struct PUCCH_ConfigDedicated_v1130N1PUCCH_AN_CS_v1130_setupN1PUCCH_AN_CS_ListP1_r11(
    pub Vec<PUCCH_ConfigDedicated_v1130N1PUCCH_AN_CS_v1130_setupN1PUCCH_AN_CS_ListP1_r11_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUCCH_ConfigDedicated_v1130N1PUCCH_AN_CS_v1130_setup {
    pub n1pucch_an_cs_list_p1_r11:
        PUCCH_ConfigDedicated_v1130N1PUCCH_AN_CS_v1130_setupN1PUCCH_AN_CS_ListP1_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUCCH_ConfigDedicated_v1130N1PUCCH_AN_CS_v1130 {
    #[asn(key = 0, extended = false)]
    Release(PUCCH_ConfigDedicated_v1130N1PUCCH_AN_CS_v1130_release),
    #[asn(key = 1, extended = false)]
    Setup(PUCCH_ConfigDedicated_v1130N1PUCCH_AN_CS_v1130_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PUCCH_ConfigDedicated_v1130NPUCCH_Param_r11_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "503")]
pub struct PUCCH_ConfigDedicated_v1130NPUCCH_Param_r11_setupNPUCCH_Identity_r11(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct PUCCH_ConfigDedicated_v1130NPUCCH_Param_r11_setupN1PUCCH_AN_r11(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUCCH_ConfigDedicated_v1130NPUCCH_Param_r11_setup {
    pub npucch_identity_r11: PUCCH_ConfigDedicated_v1130NPUCCH_Param_r11_setupNPUCCH_Identity_r11,
    pub n1pucch_an_r11: PUCCH_ConfigDedicated_v1130NPUCCH_Param_r11_setupN1PUCCH_AN_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUCCH_ConfigDedicated_v1130NPUCCH_Param_r11 {
    #[asn(key = 0, extended = false)]
    Release(PUCCH_ConfigDedicated_v1130NPUCCH_Param_r11_release),
    #[asn(key = 1, extended = false)]
    Setup(PUCCH_ConfigDedicated_v1130NPUCCH_Param_r11_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PUCCH_ConfigDedicated_v1250NkaPUCCH_Param_r12_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct PUCCH_ConfigDedicated_v1250NkaPUCCH_Param_r12_setupNkaPUCCH_AN_r12(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUCCH_ConfigDedicated_v1250NkaPUCCH_Param_r12_setup {
    pub nka_pucch_an_r12: PUCCH_ConfigDedicated_v1250NkaPUCCH_Param_r12_setupNkaPUCCH_AN_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUCCH_ConfigDedicated_v1250NkaPUCCH_Param_r12 {
    #[asn(key = 0, extended = false)]
    Release(PUCCH_ConfigDedicated_v1250NkaPUCCH_Param_r12_release),
    #[asn(key = 1, extended = false)]
    Setup(PUCCH_ConfigDedicated_v1250NkaPUCCH_Param_r12_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PUCCH_ConfigDedicated_v1370Pucch_Format_v1370_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUCCH_ConfigDedicated_v1370Pucch_Format_v1370 {
    #[asn(key = 0, extended = false)]
    Release(PUCCH_ConfigDedicated_v1370Pucch_Format_v1370_release),
    #[asn(key = 1, extended = false)]
    Setup(PUCCH_Format3_Conf_r13),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PUCCH_ConfigDedicated_v13c0ChannelSelection_v13c0N1PUCCH_AN_CS_v13c0_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct PUCCH_ConfigDedicated_v13c0ChannelSelection_v13c0N1PUCCH_AN_CS_v13c0_setupN1PUCCH_AN_CS_ListP1_v13c0_Entry(
    pub u16,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "2", sz_ub = "4")]
pub struct PUCCH_ConfigDedicated_v13c0ChannelSelection_v13c0N1PUCCH_AN_CS_v13c0_setupN1PUCCH_AN_CS_ListP1_v13c0 (pub Vec < PUCCH_ConfigDedicated_v13c0ChannelSelection_v13c0N1PUCCH_AN_CS_v13c0_setupN1PUCCH_AN_CS_ListP1_v13c0_Entry >) ;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUCCH_ConfigDedicated_v13c0ChannelSelection_v13c0N1PUCCH_AN_CS_v13c0_setup { pub n1pucch_an_cs_list_p1_v13c0 : PUCCH_ConfigDedicated_v13c0ChannelSelection_v13c0N1PUCCH_AN_CS_v13c0_setupN1PUCCH_AN_CS_ListP1_v13c0 , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUCCH_ConfigDedicated_v13c0ChannelSelection_v13c0N1PUCCH_AN_CS_v13c0 {
    #[asn(key = 0, extended = false)]
    Release(PUCCH_ConfigDedicated_v13c0ChannelSelection_v13c0N1PUCCH_AN_CS_v13c0_release),
    #[asn(key = 1, extended = false)]
    Setup(PUCCH_ConfigDedicated_v13c0ChannelSelection_v13c0N1PUCCH_AN_CS_v13c0_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUCCH_ConfigDedicated_v13c0ChannelSelection_v13c0 {
    pub n1pucch_an_cs_v13c0: PUCCH_ConfigDedicated_v13c0ChannelSelection_v13c0N1PUCCH_AN_CS_v13c0,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct PUCCH_ConfigDedicated_v1430Pucch_NumRepetitionCE_format1_r14(pub u8);
impl PUCCH_ConfigDedicated_v1430Pucch_NumRepetitionCE_format1_r14 {
    pub const R64: u8 = 0u8;
    pub const R128: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct PUCCH_ConfigDedicated_v1530N1PUCCH_AN_SPT_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct PUCCH_ConfigDedicated_v1530CodebooksizeDeterminationSTTI_r15(pub u8);
impl PUCCH_ConfigDedicated_v1530CodebooksizeDeterminationSTTI_r15 {
    pub const DAI: u8 = 0u8;
    pub const CC: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "549")]
pub struct PUCCH_Format3_Conf_r13N3PUCCH_AN_List_r13_Entry(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct PUCCH_Format3_Conf_r13N3PUCCH_AN_List_r13(
    pub Vec<PUCCH_Format3_Conf_r13N3PUCCH_AN_List_r13_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PUCCH_Format3_Conf_r13TwoAntennaPortActivatedPUCCH_Format3_r13_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "549")]
pub struct PUCCH_Format3_Conf_r13TwoAntennaPortActivatedPUCCH_Format3_r13_setupN3PUCCH_AN_ListP1_r13_Entry(
    pub u16,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct PUCCH_Format3_Conf_r13TwoAntennaPortActivatedPUCCH_Format3_r13_setupN3PUCCH_AN_ListP1_r13 (pub Vec < PUCCH_Format3_Conf_r13TwoAntennaPortActivatedPUCCH_Format3_r13_setupN3PUCCH_AN_ListP1_r13_Entry >) ;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUCCH_Format3_Conf_r13TwoAntennaPortActivatedPUCCH_Format3_r13_setup {
    pub n3pucch_an_list_p1_r13:
        PUCCH_Format3_Conf_r13TwoAntennaPortActivatedPUCCH_Format3_r13_setupN3PUCCH_AN_ListP1_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUCCH_Format3_Conf_r13TwoAntennaPortActivatedPUCCH_Format3_r13 {
    #[asn(key = 0, extended = false)]
    Release(PUCCH_Format3_Conf_r13TwoAntennaPortActivatedPUCCH_Format3_r13_release),
    #[asn(key = 1, extended = false)]
    Setup(PUCCH_Format3_Conf_r13TwoAntennaPortActivatedPUCCH_Format3_r13_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "6")]
pub struct PUCCH_TxDuration_r17Pucch_TxDuration_r17(pub u8);
impl PUCCH_TxDuration_r17Pucch_TxDuration_r17 {
    pub const SF2: u8 = 0u8;
    pub const SF4: u8 = 1u8;
    pub const SF8: u8 = 2u8;
    pub const SF16: u8 = 3u8;
    pub const SF32: u8 = 4u8;
    pub const SF64: u8 = 5u8;
    pub const SF128: u8 = 6u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct PUR_Config_r16Pur_ImplicitReleaseAfter_r16(pub u8);
impl PUR_Config_r16Pur_ImplicitReleaseAfter_r16 {
    pub const N2: u8 = 0u8;
    pub const N4: u8 = 1u8;
    pub const N8: u8 = 2u8;
    pub const SPARE: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct PUR_Config_r16Pur_StartTimeParameters_r16StartSFN_r16(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "9")]
pub struct PUR_Config_r16Pur_StartTimeParameters_r16StartSubFrame_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "1", sz_ub = "1")]
pub struct PUR_Config_r16Pur_StartTimeParameters_r16Hsfn_LSB_Info_r16(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUR_Config_r16Pur_StartTimeParameters_r16 {
    pub periodicity_and_offset_r16: PUR_PeriodicityAndOffset_r16,
    pub start_sfn_r16: PUR_Config_r16Pur_StartTimeParameters_r16StartSFN_r16,
    pub start_sub_frame_r16: PUR_Config_r16Pur_StartTimeParameters_r16StartSubFrame_r16,
    pub hsfn_lsb_info_r16: PUR_Config_r16Pur_StartTimeParameters_r16Hsfn_LSB_Info_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct PUR_Config_r16Pur_NumOccasions_r16(pub u8);
impl PUR_Config_r16Pur_NumOccasions_r16 {
    pub const ONE: u8 = 0u8;
    pub const INFINITE: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8")]
pub struct PUR_Config_r16Pur_TimeAlignmentTimer_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PUR_Config_r16Pur_RSRP_ChangeThreshold_r16_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUR_Config_r16Pur_RSRP_ChangeThreshold_r16 {
    #[asn(key = 0, extended = false)]
    Release(PUR_Config_r16Pur_RSRP_ChangeThreshold_r16_release),
    #[asn(key = 1, extended = false)]
    Setup(PUR_RSRP_ChangeThreshold_r16),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct PUR_Config_r16Pur_ResponseWindowTimer_r16(pub u8);
impl PUR_Config_r16Pur_ResponseWindowTimer_r16 {
    pub const SF240: u8 = 0u8;
    pub const SF480: u8 = 1u8;
    pub const SF960: u8 = 2u8;
    pub const SF1920: u8 = 3u8;
    pub const SF3840: u8 = 4u8;
    pub const SF5760: u8 = 5u8;
    pub const SF7680: u8 = 6u8;
    pub const SF10240: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PUR_Config_r16Pur_PDSCH_FreqHopping_r16(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PUR_MPDCCH_Config_r16Mpdcch_FreqHopping_r16(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct PUR_MPDCCH_Config_r16Mpdcch_Narrowband_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct PUR_MPDCCH_Config_r16Mpdcch_PRB_PairsConfig_r16NumberPRB_Pairs_r16(pub u8);
impl PUR_MPDCCH_Config_r16Mpdcch_PRB_PairsConfig_r16NumberPRB_Pairs_r16 {
    pub const N2: u8 = 0u8;
    pub const N4: u8 = 1u8;
    pub const N6: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct PUR_MPDCCH_Config_r16Mpdcch_PRB_PairsConfig_r16ResourceBlockAssignment_r16(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUR_MPDCCH_Config_r16Mpdcch_PRB_PairsConfig_r16 {
    pub number_prb_pairs_r16: PUR_MPDCCH_Config_r16Mpdcch_PRB_PairsConfig_r16NumberPRB_Pairs_r16,
    pub resource_block_assignment_r16:
        PUR_MPDCCH_Config_r16Mpdcch_PRB_PairsConfig_r16ResourceBlockAssignment_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "8")]
pub struct PUR_MPDCCH_Config_r16Mpdcch_NumRepetition_r16(pub u8);
impl PUR_MPDCCH_Config_r16Mpdcch_NumRepetition_r16 {
    pub const R1: u8 = 0u8;
    pub const R2: u8 = 1u8;
    pub const R4: u8 = 2u8;
    pub const R8: u8 = 3u8;
    pub const R16: u8 = 4u8;
    pub const R32: u8 = 5u8;
    pub const R64: u8 = 6u8;
    pub const R128: u8 = 7u8;
    pub const R256: u8 = 8u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct PUR_MPDCCH_Config_r16Mpdcch_StartSF_UESS_r16_fdd(pub u8);
impl PUR_MPDCCH_Config_r16Mpdcch_StartSF_UESS_r16_fdd {
    pub const V1: u8 = 0u8;
    pub const V1DOT5: u8 = 1u8;
    pub const V2: u8 = 2u8;
    pub const V2DOT5: u8 = 3u8;
    pub const V4: u8 = 4u8;
    pub const V5: u8 = 5u8;
    pub const V8: u8 = 6u8;
    pub const V10: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct PUR_MPDCCH_Config_r16Mpdcch_StartSF_UESS_r16_tdd(pub u8);
impl PUR_MPDCCH_Config_r16Mpdcch_StartSF_UESS_r16_tdd {
    pub const V1: u8 = 0u8;
    pub const V2: u8 = 1u8;
    pub const V4: u8 = 2u8;
    pub const V5: u8 = 3u8;
    pub const V8: u8 = 4u8;
    pub const V10: u8 = 5u8;
    pub const V20: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUR_MPDCCH_Config_r16Mpdcch_StartSF_UESS_r16 {
    #[asn(key = 0, extended = false)]
    Fdd(PUR_MPDCCH_Config_r16Mpdcch_StartSF_UESS_r16_fdd),
    #[asn(key = 1, extended = false)]
    Tdd(PUR_MPDCCH_Config_r16Mpdcch_StartSF_UESS_r16_tdd),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct PUR_MPDCCH_Config_r16Mpdcch_Offset_PUR_SS_r16(pub u8);
impl PUR_MPDCCH_Config_r16Mpdcch_Offset_PUR_SS_r16 {
    pub const ZERO: u8 = 0u8;
    pub const ONE_EIGHTH: u8 = 1u8;
    pub const ONE_QUARTER: u8 = 2u8;
    pub const THREE_EIGHTH: u8 = 3u8;
    pub const ONE_HALF: u8 = 4u8;
    pub const FIVE_EIGHTH: u8 = 5u8;
    pub const THREE_QUARTER: u8 = 6u8;
    pub const SEVEN_EIGHTH: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct PUR_PUCCH_Config_r16N1PUCCH_AN_r16(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct PUR_PUCCH_Config_r16Pucch_NumRepetitionCE_Format1_r16(pub u8);
impl PUR_PUCCH_Config_r16Pucch_NumRepetitionCE_Format1_r16 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N4: u8 = 2u8;
    pub const N8: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct PUR_PUSCH_Config_r16Pur_GrantInfo_r16_ce_ModeANumRUs_r16(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "10", sz_ub = "10")]
pub struct PUR_PUSCH_Config_r16Pur_GrantInfo_r16_ce_ModeAPrb_AllocationInfo_r16(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct PUR_PUSCH_Config_r16Pur_GrantInfo_r16_ce_ModeAMcs_r16(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct PUR_PUSCH_Config_r16Pur_GrantInfo_r16_ce_ModeANumRepetitions_r16(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUR_PUSCH_Config_r16Pur_GrantInfo_r16_ce_ModeA {
    pub num_r_us_r16: PUR_PUSCH_Config_r16Pur_GrantInfo_r16_ce_ModeANumRUs_r16,
    pub prb_allocation_info_r16:
        PUR_PUSCH_Config_r16Pur_GrantInfo_r16_ce_ModeAPrb_AllocationInfo_r16,
    pub mcs_r16: PUR_PUSCH_Config_r16Pur_GrantInfo_r16_ce_ModeAMcs_r16,
    pub num_repetitions_r16: PUR_PUSCH_Config_r16Pur_GrantInfo_r16_ce_ModeANumRepetitions_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PUR_PUSCH_Config_r16Pur_GrantInfo_r16_ce_ModeBSubPRB_Allocation_r16(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PUR_PUSCH_Config_r16Pur_GrantInfo_r16_ce_ModeBNumRUs_r16(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct PUR_PUSCH_Config_r16Pur_GrantInfo_r16_ce_ModeBPrb_AllocationInfo_r16(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct PUR_PUSCH_Config_r16Pur_GrantInfo_r16_ce_ModeBMcs_r16(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct PUR_PUSCH_Config_r16Pur_GrantInfo_r16_ce_ModeBNumRepetitions_r16(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUR_PUSCH_Config_r16Pur_GrantInfo_r16_ce_ModeB {
    pub sub_prb_allocation_r16: PUR_PUSCH_Config_r16Pur_GrantInfo_r16_ce_ModeBSubPRB_Allocation_r16,
    pub num_r_us_r16: PUR_PUSCH_Config_r16Pur_GrantInfo_r16_ce_ModeBNumRUs_r16,
    pub prb_allocation_info_r16:
        PUR_PUSCH_Config_r16Pur_GrantInfo_r16_ce_ModeBPrb_AllocationInfo_r16,
    pub mcs_r16: PUR_PUSCH_Config_r16Pur_GrantInfo_r16_ce_ModeBMcs_r16,
    pub num_repetitions_r16: PUR_PUSCH_Config_r16Pur_GrantInfo_r16_ce_ModeBNumRepetitions_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUR_PUSCH_Config_r16Pur_GrantInfo_r16 {
    #[asn(key = 0, extended = false)]
    Ce_ModeA(PUR_PUSCH_Config_r16Pur_GrantInfo_r16_ce_ModeA),
    #[asn(key = 1, extended = false)]
    Ce_ModeB(PUR_PUSCH_Config_r16Pur_GrantInfo_r16_ce_ModeB),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PUR_PUSCH_Config_r16Pur_PUSCH_FreqHopping_r16(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-8", ub = "7")]
pub struct PUR_PUSCH_Config_r16P0_UE_PUSCH_r16(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct PUR_PUSCH_Config_r16Pusch_CyclicShift_r16(pub u8);
impl PUR_PUSCH_Config_r16Pusch_CyclicShift_r16 {
    pub const N0: u8 = 0u8;
    pub const N6: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PUR_PUSCH_Config_r16Pusch_NB_MaxTBS_r16(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "5")]
pub struct PUR_PUSCH_Config_r16LocationCE_ModeB_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUR_Parameters_r16Pur_CP_5GC_CE_ModeA_r16(pub u8);
impl PUR_Parameters_r16Pur_CP_5GC_CE_ModeA_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUR_Parameters_r16Pur_CP_5GC_CE_ModeB_r16(pub u8);
impl PUR_Parameters_r16Pur_CP_5GC_CE_ModeB_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUR_Parameters_r16Pur_UP_5GC_CE_ModeA_r16(pub u8);
impl PUR_Parameters_r16Pur_UP_5GC_CE_ModeA_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUR_Parameters_r16Pur_UP_5GC_CE_ModeB_r16(pub u8);
impl PUR_Parameters_r16Pur_UP_5GC_CE_ModeB_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUR_Parameters_r16Pur_CP_EPC_CE_ModeA_r16(pub u8);
impl PUR_Parameters_r16Pur_CP_EPC_CE_ModeA_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUR_Parameters_r16Pur_CP_EPC_CE_ModeB_r16(pub u8);
impl PUR_Parameters_r16Pur_CP_EPC_CE_ModeB_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUR_Parameters_r16Pur_UP_EPC_CE_ModeA_r16(pub u8);
impl PUR_Parameters_r16Pur_UP_EPC_CE_ModeA_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUR_Parameters_r16Pur_UP_EPC_CE_ModeB_r16(pub u8);
impl PUR_Parameters_r16Pur_UP_EPC_CE_ModeB_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUR_Parameters_r16Pur_CP_L1Ack_r16(pub u8);
impl PUR_Parameters_r16Pur_CP_L1Ack_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUR_Parameters_r16Pur_FrequencyHopping_r16(pub u8);
impl PUR_Parameters_r16Pur_FrequencyHopping_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUR_Parameters_r16Pur_PUSCH_NB_MaxTBS_r16(pub u8);
impl PUR_Parameters_r16Pur_PUSCH_NB_MaxTBS_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUR_Parameters_r16Pur_RSRP_Validation_r16(pub u8);
impl PUR_Parameters_r16Pur_RSRP_Validation_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUR_Parameters_r16Pur_SubPRB_CE_ModeA_r16(pub u8);
impl PUR_Parameters_r16Pur_SubPRB_CE_ModeA_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUR_Parameters_r16Pur_SubPRB_CE_ModeB_r16(pub u8);
impl PUR_Parameters_r16Pur_SubPRB_CE_ModeB_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "7")]
pub struct PUR_PeriodicityAndOffset_r16_periodicity8(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "15")]
pub struct PUR_PeriodicityAndOffset_r16_periodicity16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "31")]
pub struct PUR_PeriodicityAndOffset_r16_periodicity32(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "63")]
pub struct PUR_PeriodicityAndOffset_r16_periodicity64(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "127")]
pub struct PUR_PeriodicityAndOffset_r16_periodicity128(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "255")]
pub struct PUR_PeriodicityAndOffset_r16_periodicity256(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "511")]
pub struct PUR_PeriodicityAndOffset_r16_periodicity512(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "1023")]
pub struct PUR_PeriodicityAndOffset_r16_periodicity1024(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "2047")]
pub struct PUR_PeriodicityAndOffset_r16_periodicity2048(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4095")]
pub struct PUR_PeriodicityAndOffset_r16_periodicity4096(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8191")]
pub struct PUR_PeriodicityAndOffset_r16_periodicity8192(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PURConfigurationRequest_r16CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PURConfigurationRequest_r16CriticalExtensions {
    #[asn(key = 0, extended = false)]
    PurConfigurationRequest(PURConfigurationRequest_r16_IEs),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        PURConfigurationRequest_r16CriticalExtensions_criticalExtensionsFuture,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PURConfigurationRequest_r16_IEsPur_ConfigRequest_r16_pur_ReleaseRequest;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct PURConfigurationRequest_r16_IEsPur_ConfigRequest_r16_pur_SetupRequestRequestedNumOccasions_r16(
    pub u8,
);
impl
    PURConfigurationRequest_r16_IEsPur_ConfigRequest_r16_pur_SetupRequestRequestedNumOccasions_r16
{
    pub const ONE: u8 = 0u8;
    pub const INFINITE: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "63")]
pub struct PURConfigurationRequest_r16_IEsPur_ConfigRequest_r16_pur_SetupRequestRequestedTBS_r16(
    pub u8,
);
impl PURConfigurationRequest_r16_IEsPur_ConfigRequest_r16_pur_SetupRequestRequestedTBS_r16 {
    pub const B328: u8 = 0u8;
    pub const B344: u8 = 1u8;
    pub const B376: u8 = 2u8;
    pub const B392: u8 = 3u8;
    pub const B408: u8 = 4u8;
    pub const B424: u8 = 5u8;
    pub const B440: u8 = 6u8;
    pub const B456: u8 = 7u8;
    pub const B472: u8 = 8u8;
    pub const B488: u8 = 9u8;
    pub const B504: u8 = 10u8;
    pub const B536: u8 = 11u8;
    pub const B568: u8 = 12u8;
    pub const B584: u8 = 13u8;
    pub const B616: u8 = 14u8;
    pub const B648: u8 = 15u8;
    pub const B680: u8 = 16u8;
    pub const B712: u8 = 17u8;
    pub const B744: u8 = 18u8;
    pub const B776: u8 = 19u8;
    pub const B808: u8 = 20u8;
    pub const B840: u8 = 21u8;
    pub const B872: u8 = 22u8;
    pub const B904: u8 = 23u8;
    pub const B936: u8 = 24u8;
    pub const B968: u8 = 25u8;
    pub const B1000: u8 = 26u8;
    pub const B1032: u8 = 27u8;
    pub const B1064: u8 = 28u8;
    pub const B1096: u8 = 29u8;
    pub const B1128: u8 = 30u8;
    pub const B1160: u8 = 31u8;
    pub const B1192: u8 = 32u8;
    pub const B1224: u8 = 33u8;
    pub const B1256: u8 = 34u8;
    pub const B1288: u8 = 35u8;
    pub const B1320: u8 = 36u8;
    pub const B1352: u8 = 37u8;
    pub const B1384: u8 = 38u8;
    pub const B1416: u8 = 39u8;
    pub const B1480: u8 = 40u8;
    pub const B1544: u8 = 41u8;
    pub const B1608: u8 = 42u8;
    pub const B1672: u8 = 43u8;
    pub const B1736: u8 = 44u8;
    pub const B1800: u8 = 45u8;
    pub const B1864: u8 = 46u8;
    pub const B1928: u8 = 47u8;
    pub const B1992: u8 = 48u8;
    pub const B2024: u8 = 49u8;
    pub const B2088: u8 = 50u8;
    pub const B2152: u8 = 51u8;
    pub const B2216: u8 = 52u8;
    pub const B2280: u8 = 53u8;
    pub const B2344: u8 = 54u8;
    pub const B2408: u8 = 55u8;
    pub const B2472: u8 = 56u8;
    pub const B2536: u8 = 57u8;
    pub const B2600: u8 = 58u8;
    pub const B2664: u8 = 59u8;
    pub const B2728: u8 = 60u8;
    pub const B2792: u8 = 61u8;
    pub const B2856: u8 = 62u8;
    pub const B2984: u8 = 63u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PURConfigurationRequest_r16_IEsPur_ConfigRequest_r16_pur_SetupRequestRrc_ACK_r16(pub u8);
impl PURConfigurationRequest_r16_IEsPur_ConfigRequest_r16_pur_SetupRequestRrc_ACK_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct PURConfigurationRequest_r16_IEsPur_ConfigRequest_r16_pur_SetupRequest { pub requested_num_occasions_r16 : PURConfigurationRequest_r16_IEsPur_ConfigRequest_r16_pur_SetupRequestRequestedNumOccasions_r16 , # [asn (optional_idx = 0 ,)] pub requested_periodicity_and_offset_r16 : Option < PUR_PeriodicityAndOffset_r16 > , pub requested_tbs_r16 : PURConfigurationRequest_r16_IEsPur_ConfigRequest_r16_pur_SetupRequestRequestedTBS_r16 , # [asn (optional_idx = 1 ,)] pub rrc_ack_r16 : Option < PURConfigurationRequest_r16_IEsPur_ConfigRequest_r16_pur_SetupRequestRrc_ACK_r16 > , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PURConfigurationRequest_r16_IEsPur_ConfigRequest_r16 {
    #[asn(key = 0, extended = false)]
    Pur_ReleaseRequest(PURConfigurationRequest_r16_IEsPur_ConfigRequest_r16_pur_ReleaseRequest),
    #[asn(key = 1, extended = false)]
    Pur_SetupRequest(PURConfigurationRequest_r16_IEsPur_ConfigRequest_r16_pur_SetupRequest),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PURConfigurationRequest_r16_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PURConfigurationRequest_r16_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4")]
pub struct PUSCH_ConfigCommonPusch_ConfigBasicN_SB(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct PUSCH_ConfigCommonPusch_ConfigBasicHoppingMode(pub u8);
impl PUSCH_ConfigCommonPusch_ConfigBasicHoppingMode {
    pub const INTER_SUB_FRAME: u8 = 0u8;
    pub const INTRA_AND_INTER_SUB_FRAME: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "98")]
pub struct PUSCH_ConfigCommonPusch_ConfigBasicPusch_HoppingOffset(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PUSCH_ConfigCommonPusch_ConfigBasicEnable64QAM(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUSCH_ConfigCommonPusch_ConfigBasic {
    pub n_sb: PUSCH_ConfigCommonPusch_ConfigBasicN_SB,
    pub hopping_mode: PUSCH_ConfigCommonPusch_ConfigBasicHoppingMode,
    pub pusch_hopping_offset: PUSCH_ConfigCommonPusch_ConfigBasicPusch_HoppingOffset,
    pub enable64_qam: PUSCH_ConfigCommonPusch_ConfigBasicEnable64QAM,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUSCH_ConfigCommon_v1270Enable64QAM_v1270(pub u8);
impl PUSCH_ConfigCommon_v1270Enable64QAM_v1270 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct PUSCH_ConfigCommon_v1310Pusch_maxNumRepetitionCEmodeA_r13(pub u8);
impl PUSCH_ConfigCommon_v1310Pusch_maxNumRepetitionCEmodeA_r13 {
    pub const R8: u8 = 0u8;
    pub const R16: u8 = 1u8;
    pub const R32: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct PUSCH_ConfigCommon_v1310Pusch_maxNumRepetitionCEmodeB_r13(pub u8);
impl PUSCH_ConfigCommon_v1310Pusch_maxNumRepetitionCEmodeB_r13 {
    pub const R192: u8 = 0u8;
    pub const R256: u8 = 1u8;
    pub const R384: u8 = 2u8;
    pub const R512: u8 = 3u8;
    pub const R768: u8 = 4u8;
    pub const R1024: u8 = 5u8;
    pub const R1536: u8 = 6u8;
    pub const R2048: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct PUSCH_ConfigCommon_v1310Pusch_HoppingOffset_v1310(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicatedBetaOffset_ACK_Index(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicatedBetaOffset_RI_Index(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicatedBetaOffset_CQI_Index(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicated_r13BetaOffset_ACK_Index_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicated_r13BetaOffset2_ACK_Index_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicated_r13BetaOffset_RI_Index_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicated_r13BetaOffset_CQI_Index_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicated_r13BetaOffsetMC_r13BetaOffset_ACK_Index_MC_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicated_r13BetaOffsetMC_r13BetaOffset2_ACK_Index_MC_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicated_r13BetaOffsetMC_r13BetaOffset_RI_Index_MC_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicated_r13BetaOffsetMC_r13BetaOffset_CQI_Index_MC_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PUSCH_ConfigDedicated_r13BetaOffsetMC_r13 {
    pub beta_offset_ack_index_mc_r13:
        PUSCH_ConfigDedicated_r13BetaOffsetMC_r13BetaOffset_ACK_Index_MC_r13,
    #[asn(optional_idx = 0)]
    pub beta_offset2_ack_index_mc_r13:
        Option<PUSCH_ConfigDedicated_r13BetaOffsetMC_r13BetaOffset2_ACK_Index_MC_r13>,
    pub beta_offset_ri_index_mc_r13:
        PUSCH_ConfigDedicated_r13BetaOffsetMC_r13BetaOffset_RI_Index_MC_r13,
    pub beta_offset_cqi_index_mc_r13:
        PUSCH_ConfigDedicated_r13BetaOffsetMC_r13BetaOffset_CQI_Index_MC_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUSCH_ConfigDedicated_r13GroupHoppingDisabled_r13(pub u8);
impl PUSCH_ConfigDedicated_r13GroupHoppingDisabled_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUSCH_ConfigDedicated_r13Dmrs_WithOCC_Activated_r13(pub u8);
impl PUSCH_ConfigDedicated_r13Dmrs_WithOCC_Activated_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PUSCH_ConfigDedicated_r13Pusch_DMRS_r11_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "509")]
pub struct PUSCH_ConfigDedicated_r13Pusch_DMRS_r11_setupNPUSCH_Identity_r13(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "509")]
pub struct PUSCH_ConfigDedicated_r13Pusch_DMRS_r11_setupNDMRS_CSH_Identity_r13(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUSCH_ConfigDedicated_r13Pusch_DMRS_r11_setup {
    pub npusch_identity_r13: PUSCH_ConfigDedicated_r13Pusch_DMRS_r11_setupNPUSCH_Identity_r13,
    pub ndmrs_csh_identity_r13: PUSCH_ConfigDedicated_r13Pusch_DMRS_r11_setupNDMRS_CSH_Identity_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUSCH_ConfigDedicated_r13Pusch_DMRS_r11 {
    #[asn(key = 0, extended = false)]
    Release(PUSCH_ConfigDedicated_r13Pusch_DMRS_r11_release),
    #[asn(key = 1, extended = false)]
    Setup(PUSCH_ConfigDedicated_r13Pusch_DMRS_r11_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PUSCH_ConfigDedicated_r13UciOnPUSCH_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicated_r13UciOnPUSCH_setupBetaOffset_ACK_Index_SubframeSet2_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicated_r13UciOnPUSCH_setupBetaOffset2_ACK_Index_SubframeSet2_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicated_r13UciOnPUSCH_setupBetaOffset_RI_Index_SubframeSet2_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicated_r13UciOnPUSCH_setupBetaOffset_CQI_Index_SubframeSet2_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicated_r13UciOnPUSCH_setupBetaOffsetMC_r12BetaOffset_ACK_Index_MC_SubframeSet2_r13(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicated_r13UciOnPUSCH_setupBetaOffsetMC_r12BetaOffset2_ACK_Index_MC_SubframeSet2_r13(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicated_r13UciOnPUSCH_setupBetaOffsetMC_r12BetaOffset_RI_Index_MC_SubframeSet2_r13(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicated_r13UciOnPUSCH_setupBetaOffsetMC_r12BetaOffset_CQI_Index_MC_SubframeSet2_r13(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PUSCH_ConfigDedicated_r13UciOnPUSCH_setupBetaOffsetMC_r12 { pub beta_offset_ack_index_mc_subframe_set2_r13 : PUSCH_ConfigDedicated_r13UciOnPUSCH_setupBetaOffsetMC_r12BetaOffset_ACK_Index_MC_SubframeSet2_r13 , # [asn (optional_idx = 0 ,)] pub beta_offset2_ack_index_mc_subframe_set2_r13 : Option < PUSCH_ConfigDedicated_r13UciOnPUSCH_setupBetaOffsetMC_r12BetaOffset2_ACK_Index_MC_SubframeSet2_r13 > , pub beta_offset_ri_index_mc_subframe_set2_r13 : PUSCH_ConfigDedicated_r13UciOnPUSCH_setupBetaOffsetMC_r12BetaOffset_RI_Index_MC_SubframeSet2_r13 , pub beta_offset_cqi_index_mc_subframe_set2_r13 : PUSCH_ConfigDedicated_r13UciOnPUSCH_setupBetaOffsetMC_r12BetaOffset_CQI_Index_MC_SubframeSet2_r13 , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct PUSCH_ConfigDedicated_r13UciOnPUSCH_setup {
    pub beta_offset_ack_index_subframe_set2_r13:
        PUSCH_ConfigDedicated_r13UciOnPUSCH_setupBetaOffset_ACK_Index_SubframeSet2_r13,
    #[asn(optional_idx = 0)]
    pub beta_offset2_ack_index_subframe_set2_r13:
        Option<PUSCH_ConfigDedicated_r13UciOnPUSCH_setupBetaOffset2_ACK_Index_SubframeSet2_r13>,
    pub beta_offset_ri_index_subframe_set2_r13:
        PUSCH_ConfigDedicated_r13UciOnPUSCH_setupBetaOffset_RI_Index_SubframeSet2_r13,
    pub beta_offset_cqi_index_subframe_set2_r13:
        PUSCH_ConfigDedicated_r13UciOnPUSCH_setupBetaOffset_CQI_Index_SubframeSet2_r13,
    #[asn(optional_idx = 1)]
    pub beta_offset_mc_r12: Option<PUSCH_ConfigDedicated_r13UciOnPUSCH_setupBetaOffsetMC_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUSCH_ConfigDedicated_r13UciOnPUSCH {
    #[asn(key = 0, extended = false)]
    Release(PUSCH_ConfigDedicated_r13UciOnPUSCH_release),
    #[asn(key = 1, extended = false)]
    Setup(PUSCH_ConfigDedicated_r13UciOnPUSCH_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUSCH_ConfigDedicated_r13Pusch_HoppingConfig_r13(pub u8);
impl PUSCH_ConfigDedicated_r13Pusch_HoppingConfig_r13 {
    pub const ON: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicated_v1020BetaOffsetMC_r10BetaOffset_ACK_Index_MC_r10(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicated_v1020BetaOffsetMC_r10BetaOffset_RI_Index_MC_r10(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicated_v1020BetaOffsetMC_r10BetaOffset_CQI_Index_MC_r10(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUSCH_ConfigDedicated_v1020BetaOffsetMC_r10 {
    pub beta_offset_ack_index_mc_r10:
        PUSCH_ConfigDedicated_v1020BetaOffsetMC_r10BetaOffset_ACK_Index_MC_r10,
    pub beta_offset_ri_index_mc_r10:
        PUSCH_ConfigDedicated_v1020BetaOffsetMC_r10BetaOffset_RI_Index_MC_r10,
    pub beta_offset_cqi_index_mc_r10:
        PUSCH_ConfigDedicated_v1020BetaOffsetMC_r10BetaOffset_CQI_Index_MC_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUSCH_ConfigDedicated_v1020GroupHoppingDisabled_r10(pub u8);
impl PUSCH_ConfigDedicated_v1020GroupHoppingDisabled_r10 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUSCH_ConfigDedicated_v1020Dmrs_WithOCC_Activated_r10(pub u8);
impl PUSCH_ConfigDedicated_v1020Dmrs_WithOCC_Activated_r10 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PUSCH_ConfigDedicated_v1130Pusch_DMRS_r11_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "509")]
pub struct PUSCH_ConfigDedicated_v1130Pusch_DMRS_r11_setupNPUSCH_Identity_r11(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "509")]
pub struct PUSCH_ConfigDedicated_v1130Pusch_DMRS_r11_setupNDMRS_CSH_Identity_r11(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUSCH_ConfigDedicated_v1130Pusch_DMRS_r11_setup {
    pub npusch_identity_r11: PUSCH_ConfigDedicated_v1130Pusch_DMRS_r11_setupNPUSCH_Identity_r11,
    pub ndmrs_csh_identity_r11:
        PUSCH_ConfigDedicated_v1130Pusch_DMRS_r11_setupNDMRS_CSH_Identity_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUSCH_ConfigDedicated_v1130Pusch_DMRS_r11 {
    #[asn(key = 0, extended = false)]
    Release(PUSCH_ConfigDedicated_v1130Pusch_DMRS_r11_release),
    #[asn(key = 1, extended = false)]
    Setup(PUSCH_ConfigDedicated_v1130Pusch_DMRS_r11_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PUSCH_ConfigDedicated_v1250UciOnPUSCH_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicated_v1250UciOnPUSCH_setupBetaOffset_ACK_Index_SubframeSet2_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicated_v1250UciOnPUSCH_setupBetaOffset_RI_Index_SubframeSet2_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicated_v1250UciOnPUSCH_setupBetaOffset_CQI_Index_SubframeSet2_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicated_v1250UciOnPUSCH_setupBetaOffsetMC_r12BetaOffset_ACK_Index_MC_SubframeSet2_r12(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicated_v1250UciOnPUSCH_setupBetaOffsetMC_r12BetaOffset_RI_Index_MC_SubframeSet2_r12(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicated_v1250UciOnPUSCH_setupBetaOffsetMC_r12BetaOffset_CQI_Index_MC_SubframeSet2_r12(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUSCH_ConfigDedicated_v1250UciOnPUSCH_setupBetaOffsetMC_r12 { pub beta_offset_ack_index_mc_subframe_set2_r12 : PUSCH_ConfigDedicated_v1250UciOnPUSCH_setupBetaOffsetMC_r12BetaOffset_ACK_Index_MC_SubframeSet2_r12 , pub beta_offset_ri_index_mc_subframe_set2_r12 : PUSCH_ConfigDedicated_v1250UciOnPUSCH_setupBetaOffsetMC_r12BetaOffset_RI_Index_MC_SubframeSet2_r12 , pub beta_offset_cqi_index_mc_subframe_set2_r12 : PUSCH_ConfigDedicated_v1250UciOnPUSCH_setupBetaOffsetMC_r12BetaOffset_CQI_Index_MC_SubframeSet2_r12 , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PUSCH_ConfigDedicated_v1250UciOnPUSCH_setup {
    pub beta_offset_ack_index_subframe_set2_r12:
        PUSCH_ConfigDedicated_v1250UciOnPUSCH_setupBetaOffset_ACK_Index_SubframeSet2_r12,
    pub beta_offset_ri_index_subframe_set2_r12:
        PUSCH_ConfigDedicated_v1250UciOnPUSCH_setupBetaOffset_RI_Index_SubframeSet2_r12,
    pub beta_offset_cqi_index_subframe_set2_r12:
        PUSCH_ConfigDedicated_v1250UciOnPUSCH_setupBetaOffset_CQI_Index_SubframeSet2_r12,
    #[asn(optional_idx = 0)]
    pub beta_offset_mc_r12: Option<PUSCH_ConfigDedicated_v1250UciOnPUSCH_setupBetaOffsetMC_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUSCH_ConfigDedicated_v1250UciOnPUSCH {
    #[asn(key = 0, extended = false)]
    Release(PUSCH_ConfigDedicated_v1250UciOnPUSCH_release),
    #[asn(key = 1, extended = false)]
    Setup(PUSCH_ConfigDedicated_v1250UciOnPUSCH_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUSCH_ConfigDedicated_v1430Ce_PUSCH_NB_MaxTBS_r14(pub u8);
impl PUSCH_ConfigDedicated_v1430Ce_PUSCH_NB_MaxTBS_r14 {
    pub const ON: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUSCH_ConfigDedicated_v1430Ce_PUSCH_MaxBandwidth_r14(pub u8);
impl PUSCH_ConfigDedicated_v1430Ce_PUSCH_MaxBandwidth_r14 {
    pub const BW5: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PUSCH_ConfigDedicated_v1430Ul_DMRS_IFDMA_r14(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PUSCH_ConfigDedicated_v1530Ce_PUSCH_FlexibleStartPRB_AllocConfig_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-1", ub = "3")]
pub struct PUSCH_ConfigDedicated_v1530Ce_PUSCH_FlexibleStartPRB_AllocConfig_r15_setupOffsetCE_ModeB_r15(
    pub i8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PUSCH_ConfigDedicated_v1530Ce_PUSCH_FlexibleStartPRB_AllocConfig_r15_setup { # [asn (optional_idx = 0 ,)] pub offset_ce_mode_b_r15 : Option < PUSCH_ConfigDedicated_v1530Ce_PUSCH_FlexibleStartPRB_AllocConfig_r15_setupOffsetCE_ModeB_r15 > , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUSCH_ConfigDedicated_v1530Ce_PUSCH_FlexibleStartPRB_AllocConfig_r15 {
    #[asn(key = 0, extended = false)]
    Release(PUSCH_ConfigDedicated_v1530Ce_PUSCH_FlexibleStartPRB_AllocConfig_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(PUSCH_ConfigDedicated_v1530Ce_PUSCH_FlexibleStartPRB_AllocConfig_r15_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PUSCH_ConfigDedicated_v1530Ce_PUSCH_SubPRB_Config_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "5")]
pub struct PUSCH_ConfigDedicated_v1530Ce_PUSCH_SubPRB_Config_r15_setupLocationCE_ModeB_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct PUSCH_ConfigDedicated_v1530Ce_PUSCH_SubPRB_Config_r15_setupSixToneCyclicShift_r15(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2")]
pub struct PUSCH_ConfigDedicated_v1530Ce_PUSCH_SubPRB_Config_r15_setupThreeToneCyclicShift_r15(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PUSCH_ConfigDedicated_v1530Ce_PUSCH_SubPRB_Config_r15_setup {
    #[asn(optional_idx = 0)]
    pub location_ce_mode_b_r15:
        Option<PUSCH_ConfigDedicated_v1530Ce_PUSCH_SubPRB_Config_r15_setupLocationCE_ModeB_r15>,
    pub six_tone_cyclic_shift_r15:
        PUSCH_ConfigDedicated_v1530Ce_PUSCH_SubPRB_Config_r15_setupSixToneCyclicShift_r15,
    pub three_tone_cyclic_shift_r15:
        PUSCH_ConfigDedicated_v1530Ce_PUSCH_SubPRB_Config_r15_setupThreeToneCyclicShift_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUSCH_ConfigDedicated_v1530Ce_PUSCH_SubPRB_Config_r15 {
    #[asn(key = 0, extended = false)]
    Release(PUSCH_ConfigDedicated_v1530Ce_PUSCH_SubPRB_Config_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(PUSCH_ConfigDedicated_v1530Ce_PUSCH_SubPRB_Config_r15_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PUSCH_ConfigDedicated_v1610Ce_PUSCH_MultiTB_Config_r16_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUSCH_ConfigDedicated_v1610Ce_PUSCH_MultiTB_Config_r16 {
    #[asn(key = 0, extended = false)]
    Release(PUSCH_ConfigDedicated_v1610Ce_PUSCH_MultiTB_Config_r16_release),
    #[asn(key = 1, extended = false)]
    Setup(CE_PUSCH_MultiTB_Config_r16),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUSCH_ConfigDedicatedSCell_r10GroupHoppingDisabled_r10(pub u8);
impl PUSCH_ConfigDedicatedSCell_r10GroupHoppingDisabled_r10 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PUSCH_ConfigDedicatedSCell_r10Dmrs_WithOCC_Activated_r10(pub u8);
impl PUSCH_ConfigDedicatedSCell_r10Dmrs_WithOCC_Activated_r10 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PUSCH_ConfigDedicatedScell_v1530Uci_OnPUSCH_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PUSCH_ConfigDedicatedScell_v1530Uci_OnPUSCH_r15_setupBetaOffsetAUL_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PUSCH_ConfigDedicatedScell_v1530Uci_OnPUSCH_r15_setup {
    pub beta_offset_aul_r15: PUSCH_ConfigDedicatedScell_v1530Uci_OnPUSCH_r15_setupBetaOffsetAUL_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUSCH_ConfigDedicatedScell_v1530Uci_OnPUSCH_r15 {
    #[asn(key = 0, extended = false)]
    Release(PUSCH_ConfigDedicatedScell_v1530Uci_OnPUSCH_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(PUSCH_ConfigDedicatedScell_v1530Uci_OnPUSCH_r15_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PUSCH_EnhancementsConfig_r14_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "100")]
pub struct PUSCH_EnhancementsConfig_r14_setupPusch_HoppingOffsetPUSCH_Enh_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct PUSCH_EnhancementsConfig_r14_setupInterval_ULHoppingPUSCH_Enh_r14_interval_FDD_PUSCH_Enh_r14(
    pub u8,
);
impl PUSCH_EnhancementsConfig_r14_setupInterval_ULHoppingPUSCH_Enh_r14_interval_FDD_PUSCH_Enh_r14 {
    pub const INT1: u8 = 0u8;
    pub const INT2: u8 = 1u8;
    pub const INT4: u8 = 2u8;
    pub const INT8: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct PUSCH_EnhancementsConfig_r14_setupInterval_ULHoppingPUSCH_Enh_r14_interval_TDD_PUSCH_Enh_r14(
    pub u8,
);
impl PUSCH_EnhancementsConfig_r14_setupInterval_ULHoppingPUSCH_Enh_r14_interval_TDD_PUSCH_Enh_r14 {
    pub const INT1: u8 = 0u8;
    pub const INT5: u8 = 1u8;
    pub const INT10: u8 = 2u8;
    pub const INT20: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PUSCH_EnhancementsConfig_r14_setupInterval_ULHoppingPUSCH_Enh_r14 {
    # [asn (key = 0 , extended = false)] Interval_FDD_PUSCH_Enh_r14 (PUSCH_EnhancementsConfig_r14_setupInterval_ULHoppingPUSCH_Enh_r14_interval_FDD_PUSCH_Enh_r14) , # [asn (key = 1 , extended = false)] Interval_TDD_PUSCH_Enh_r14 (PUSCH_EnhancementsConfig_r14_setupInterval_ULHoppingPUSCH_Enh_r14_interval_TDD_PUSCH_Enh_r14) , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct PUSCH_EnhancementsConfig_r14_setup {
    #[asn(optional_idx = 0)]
    pub pusch_hopping_offset_pusch_enh_r14:
        Option<PUSCH_EnhancementsConfig_r14_setupPusch_HoppingOffsetPUSCH_Enh_r14>,
    #[asn(optional_idx = 1)]
    pub interval_ul_hopping_pusch_enh_r14:
        Option<PUSCH_EnhancementsConfig_r14_setupInterval_ULHoppingPUSCH_Enh_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PUSCH_ModeConfigLAA_r15Laa_PUSCH_Mode1(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PUSCH_ModeConfigLAA_r15Laa_PUSCH_Mode2(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PUSCH_ModeConfigLAA_r15Laa_PUSCH_Mode3(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct PUSCH_TxDuration_r17Pusch_TxDuration_r17(pub u8);
impl PUSCH_TxDuration_r17Pusch_TxDuration_r17 {
    pub const N2: u8 = 0u8;
    pub const N4: u8 = 1u8;
    pub const N8: u8 = 2u8;
    pub const N16: u8 = 3u8;
    pub const N32: u8 = 4u8;
    pub const N64: u8 = 5u8;
    pub const N128: u8 = 6u8;
    pub const N256: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PagingSystemInfoModification(pub u8);
impl PagingSystemInfoModification {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PagingEtws_Indication(pub u8);
impl PagingEtws_Indication {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct Paging_v1130_IEsEab_ParamModification_r11(pub u8);
impl Paging_v1130_IEsEab_ParamModification_r11 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct Paging_v1310_IEsRedistributionIndication_r13(pub u8);
impl Paging_v1310_IEsRedistributionIndication_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct Paging_v1310_IEsSystemInfoModification_eDRX_r13(pub u8);
impl Paging_v1310_IEsSystemInfoModification_eDRX_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct Paging_v1530_IEsAccessType(pub u8);
impl Paging_v1530_IEsAccessType {
    pub const NON3_GPP: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct Paging_v1610_IEsUac_ParamModification_r16(pub u8);
impl Paging_v1610_IEsUac_ParamModification_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Paging_v1700_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct Paging_v890_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct Paging_v920_IEsCmas_Indication_r9(pub u8);
impl Paging_v920_IEsCmas_Indication_r9 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct PagingRecordCn_Domain(pub u8);
impl PagingRecordCn_Domain {
    pub const PS: u8 = 0u8;
    pub const CS: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PagingRecord_v1610AccessType_r16(pub u8);
impl PagingRecord_v1610AccessType_r16 {
    pub const NON3_GPP: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PagingRecord_v1610Mt_EDT_r16(pub u8);
impl PagingRecord_v1610Mt_EDT_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PagingRecord_v1700PagingCause_r17(pub u8);
impl PagingRecord_v1700PagingCause_r17 {
    pub const VOICE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct ParametersCDMA2000_r11SystemTimeInfo_r11_defaultValue;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum ParametersCDMA2000_r11SystemTimeInfo_r11 {
    #[asn(key = 0, extended = false)]
    ExplicitValue(SystemTimeInfoCDMA2000),
    #[asn(key = 1, extended = false)]
    DefaultValue(ParametersCDMA2000_r11SystemTimeInfo_r11_defaultValue),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct ParametersCDMA2000_r11SearchWindowSize_r11(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct ParametersCDMA2000_r11ParametersHRPD_r11 {
    pub pre_registration_info_hrpd_r11: PreRegistrationInfoHRPD,
    #[asn(optional_idx = 0)]
    pub cell_reselection_parameters_hrpd_r11: Option<CellReselectionParametersCDMA2000_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "42", sz_ub = "42")]
pub struct ParametersCDMA2000_r11Parameters1XRTT_r11LongCodeState1XRTT_r11(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct ParametersCDMA2000_r11Parameters1XRTT_r11Csfb_SupportForDualRxUEs_r11(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct ParametersCDMA2000_r11Parameters1XRTT_r11Csfb_DualRxTxSupport_r11(pub u8);
impl ParametersCDMA2000_r11Parameters1XRTT_r11Csfb_DualRxTxSupport_r11 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 7)]
pub struct ParametersCDMA2000_r11Parameters1XRTT_r11 {
    #[asn(optional_idx = 0)]
    pub csfb_registration_param1_xrtt_r11: Option<CSFB_RegistrationParam1XRTT>,
    #[asn(optional_idx = 1)]
    pub csfb_registration_param1_xrtt_ext_r11: Option<CSFB_RegistrationParam1XRTT_v920>,
    #[asn(optional_idx = 2)]
    pub long_code_state1_xrtt_r11:
        Option<ParametersCDMA2000_r11Parameters1XRTT_r11LongCodeState1XRTT_r11>,
    #[asn(optional_idx = 3)]
    pub cell_reselection_parameters1_xrtt_r11: Option<CellReselectionParametersCDMA2000_r11>,
    #[asn(optional_idx = 4)]
    pub ac_barring_config1_xrtt_r11: Option<AC_BarringConfig1XRTT_r9>,
    #[asn(optional_idx = 5)]
    pub csfb_support_for_dual_rx_u_es_r11:
        Option<ParametersCDMA2000_r11Parameters1XRTT_r11Csfb_SupportForDualRxUEs_r11>,
    #[asn(optional_idx = 6)]
    pub csfb_dual_rx_tx_support_r11:
        Option<ParametersCDMA2000_r11Parameters1XRTT_r11Csfb_DualRxTxSupport_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct PerCC_GapIndication_r14GapIndication_r14(pub u8);
impl PerCC_GapIndication_r14GapIndication_r14 {
    pub const GAP: u8 = 0u8;
    pub const NCSG: u8 = 1u8;
    pub const NOGAP_NO_NCSG: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PeriodicityStartPos_r16_periodicity10ms;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1")]
pub struct PeriodicityStartPos_r16_periodicity20ms(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct PeriodicityStartPos_r16_periodicity40ms(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct PeriodicityStartPos_r16_periodicity80ms(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PeriodicityStartPos_r16_periodicity160ms(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PeriodicityStartPos_r16_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PeriodicityStartPos_r16_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PeriodicityStartPos_r16_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PhyLayerParametersUe_TxAntennaSelectionSupported(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PhyLayerParametersUe_SpecificRefSigsSupported(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1020TwoAntennaPortsForPUCCH_r10(pub u8);
impl PhyLayerParameters_v1020TwoAntennaPortsForPUCCH_r10 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1020Tm9_With_8Tx_FDD_r10(pub u8);
impl PhyLayerParameters_v1020Tm9_With_8Tx_FDD_r10 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1020Pmi_Disabling_r10(pub u8);
impl PhyLayerParameters_v1020Pmi_Disabling_r10 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1020CrossCarrierScheduling_r10(pub u8);
impl PhyLayerParameters_v1020CrossCarrierScheduling_r10 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1020SimultaneousPUCCH_PUSCH_r10(pub u8);
impl PhyLayerParameters_v1020SimultaneousPUCCH_PUSCH_r10 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1020MultiClusterPUSCH_WithinCC_r10(pub u8);
impl PhyLayerParameters_v1020MultiClusterPUSCH_WithinCC_r10 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1130Crs_InterfHandl_r11(pub u8);
impl PhyLayerParameters_v1130Crs_InterfHandl_r11 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1130EPDCCH_r11(pub u8);
impl PhyLayerParameters_v1130EPDCCH_r11 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1130MultiACK_CSI_Reporting_r11(pub u8);
impl PhyLayerParameters_v1130MultiACK_CSI_Reporting_r11 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1130Ss_CCH_InterfHandl_r11(pub u8);
impl PhyLayerParameters_v1130Ss_CCH_InterfHandl_r11 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1130Tdd_SpecialSubframe_r11(pub u8);
impl PhyLayerParameters_v1130Tdd_SpecialSubframe_r11 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1130TxDiv_PUCCH1b_ChSelect_r11(pub u8);
impl PhyLayerParameters_v1130TxDiv_PUCCH1b_ChSelect_r11 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1130Ul_CoMP_r11(pub u8);
impl PhyLayerParameters_v1130Ul_CoMP_r11 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct PhyLayerParameters_v1170InterBandTDD_CA_WithDifferentConfig_r11(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1250E_HARQ_Pattern_FDD_r12(pub u8);
impl PhyLayerParameters_v1250E_HARQ_Pattern_FDD_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1250Enhanced_4TxCodebook_r12(pub u8);
impl PhyLayerParameters_v1250Enhanced_4TxCodebook_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct PhyLayerParameters_v1250Tdd_FDD_CA_PCellDuplex_r12(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1250Phy_TDD_ReConfig_TDD_PCell_r12(pub u8);
impl PhyLayerParameters_v1250Phy_TDD_ReConfig_TDD_PCell_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1250Phy_TDD_ReConfig_FDD_PCell_r12(pub u8);
impl PhyLayerParameters_v1250Phy_TDD_ReConfig_FDD_PCell_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1250Pusch_FeedbackMode_r12(pub u8);
impl PhyLayerParameters_v1250Pusch_FeedbackMode_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1250Pusch_SRS_PowerControl_SubframeSet_r12(pub u8);
impl PhyLayerParameters_v1250Pusch_SRS_PowerControl_SubframeSet_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1250Csi_SubframeSet_r12(pub u8);
impl PhyLayerParameters_v1250Csi_SubframeSet_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1250NoResourceRestrictionForTTIBundling_r12(pub u8);
impl PhyLayerParameters_v1250NoResourceRestrictionForTTIBundling_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1250DiscoverySignalsInDeactSCell_r12(pub u8);
impl PhyLayerParameters_v1250DiscoverySignalsInDeactSCell_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1280AlternativeTBS_Indices_r12(pub u8);
impl PhyLayerParameters_v1280AlternativeTBS_Indices_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct PhyLayerParameters_v1310AperiodicCSI_Reporting_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct PhyLayerParameters_v1310Codebook_HARQ_ACK_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1310CrossCarrierScheduling_B5C_r13(pub u8);
impl PhyLayerParameters_v1310CrossCarrierScheduling_B5C_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1310Fdd_HARQ_TimingTDD_r13(pub u8);
impl PhyLayerParameters_v1310Fdd_HARQ_TimingTDD_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "5", ub = "32")]
pub struct PhyLayerParameters_v1310MaxNumberUpdatedCSI_Proc_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1310Pucch_Format4_r13(pub u8);
impl PhyLayerParameters_v1310Pucch_Format4_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1310Pucch_Format5_r13(pub u8);
impl PhyLayerParameters_v1310Pucch_Format5_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1310Pucch_SCell_r13(pub u8);
impl PhyLayerParameters_v1310Pucch_SCell_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1310SpatialBundling_HARQ_ACK_r13(pub u8);
impl PhyLayerParameters_v1310SpatialBundling_HARQ_ACK_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct PhyLayerParameters_v1310SupportedBlindDecoding_r13MaxNumberDecoding_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1310SupportedBlindDecoding_r13Pdcch_CandidateReductions_r13(pub u8);
impl PhyLayerParameters_v1310SupportedBlindDecoding_r13Pdcch_CandidateReductions_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1310SupportedBlindDecoding_r13SkipMonitoringDCI_Format0_1A_r13(
    pub u8,
);
impl PhyLayerParameters_v1310SupportedBlindDecoding_r13SkipMonitoringDCI_Format0_1A_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct PhyLayerParameters_v1310SupportedBlindDecoding_r13 {
    #[asn(optional_idx = 0)]
    pub max_number_decoding_r13:
        Option<PhyLayerParameters_v1310SupportedBlindDecoding_r13MaxNumberDecoding_r13>,
    #[asn(optional_idx = 1)]
    pub pdcch_candidate_reductions_r13:
        Option<PhyLayerParameters_v1310SupportedBlindDecoding_r13Pdcch_CandidateReductions_r13>,
    #[asn(optional_idx = 2)]
    pub skip_monitoring_dci_format0_1a_r13:
        Option<PhyLayerParameters_v1310SupportedBlindDecoding_r13SkipMonitoringDCI_Format0_1A_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1310Uci_PUSCH_Ext_r13(pub u8);
impl PhyLayerParameters_v1310Uci_PUSCH_Ext_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1310Crs_InterfMitigationTM10_r13(pub u8);
impl PhyLayerParameters_v1310Crs_InterfMitigationTM10_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1310Pdsch_CollisionHandling_r13(pub u8);
impl PhyLayerParameters_v1310Pdsch_CollisionHandling_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1330Cch_InterfMitigation_RefRecTypeA_r13(pub u8);
impl PhyLayerParameters_v1330Cch_InterfMitigation_RefRecTypeA_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1330Cch_InterfMitigation_RefRecTypeB_r13(pub u8);
impl PhyLayerParameters_v1330Cch_InterfMitigation_RefRecTypeB_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct PhyLayerParameters_v1330Cch_InterfMitigation_MaxNumCCs_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct PhyLayerParameters_v1330Crs_InterfMitigationTM1toTM9_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1430Ce_PUSCH_NB_MaxTBS_r14(pub u8);
impl PhyLayerParameters_v1430Ce_PUSCH_NB_MaxTBS_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct PhyLayerParameters_v1430Ce_PDSCH_PUSCH_MaxBandwidth_r14(pub u8);
impl PhyLayerParameters_v1430Ce_PDSCH_PUSCH_MaxBandwidth_r14 {
    pub const BW5: u8 = 0u8;
    pub const BW20: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1430Ce_HARQ_AckBundling_r14(pub u8);
impl PhyLayerParameters_v1430Ce_HARQ_AckBundling_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1430Ce_PDSCH_TenProcesses_r14(pub u8);
impl PhyLayerParameters_v1430Ce_PDSCH_TenProcesses_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct PhyLayerParameters_v1430Ce_RetuningSymbols_r14(pub u8);
impl PhyLayerParameters_v1430Ce_RetuningSymbols_r14 {
    pub const N0: u8 = 0u8;
    pub const N1: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1430Ce_PDSCH_PUSCH_Enhancement_r14(pub u8);
impl PhyLayerParameters_v1430Ce_PDSCH_PUSCH_Enhancement_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1430Ce_SchedulingEnhancement_r14(pub u8);
impl PhyLayerParameters_v1430Ce_SchedulingEnhancement_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1430Ce_SRS_Enhancement_r14(pub u8);
impl PhyLayerParameters_v1430Ce_SRS_Enhancement_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1430Ce_PUCCH_Enhancement_r14(pub u8);
impl PhyLayerParameters_v1430Ce_PUCCH_Enhancement_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1430Ce_ClosedLoopTxAntennaSelection_r14(pub u8);
impl PhyLayerParameters_v1430Ce_ClosedLoopTxAntennaSelection_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1430Tdd_SpecialSubframe_r14(pub u8);
impl PhyLayerParameters_v1430Tdd_SpecialSubframe_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1430Tdd_TTI_Bundling_r14(pub u8);
impl PhyLayerParameters_v1430Tdd_TTI_Bundling_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1430Dmrs_LessUpPTS_r14(pub u8);
impl PhyLayerParameters_v1430Dmrs_LessUpPTS_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1430AlternativeTBS_Index_r14(pub u8);
impl PhyLayerParameters_v1430AlternativeTBS_Index_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1450Ce_SRS_EnhancementWithoutComb4_r14(pub u8);
impl PhyLayerParameters_v1450Ce_SRS_EnhancementWithoutComb4_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1450Crs_LessDwPTS_r14(pub u8);
impl PhyLayerParameters_v1450Crs_LessDwPTS_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1470Srs_UpPTS_6sym_r14(pub u8);
impl PhyLayerParameters_v1470Srs_UpPTS_6sym_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v14a0Ssp10_TDD_Only_r14(pub u8);
impl PhyLayerParameters_v14a0Ssp10_TDD_Only_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15AperiodicCsi_ReportingSTTI_r15(pub u8);
impl PhyLayerParameters_v1530Stti_SPT_Capabilities_r15AperiodicCsi_ReportingSTTI_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Dmrs_BasedSPDCCH_MBSFN_r15(pub u8);
impl PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Dmrs_BasedSPDCCH_MBSFN_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Dmrs_BasedSPDCCH_nonMBSFN_r15(pub u8);
impl PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Dmrs_BasedSPDCCH_nonMBSFN_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Dmrs_PositionPattern_r15(pub u8);
impl PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Dmrs_PositionPattern_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Dmrs_SharingSubslotPDSCH_r15(pub u8);
impl PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Dmrs_SharingSubslotPDSCH_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Dmrs_RepetitionSubslotPDSCH_r15(pub u8);
impl PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Dmrs_RepetitionSubslotPDSCH_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Epdcch_SPT_differentCells_r15(pub u8);
impl PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Epdcch_SPT_differentCells_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Epdcch_STTI_differentCells_r15(pub u8);
impl PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Epdcch_STTI_differentCells_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15MaxLayersSlotOrSubslotPUSCH_r15(pub u8);
impl PhyLayerParameters_v1530Stti_SPT_Capabilities_r15MaxLayersSlotOrSubslotPUSCH_r15 {
    pub const ONE_LAYER: u8 = 0u8;
    pub const TWO_LAYERS: u8 = 1u8;
    pub const FOUR_LAYERS: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "5", ub = "32")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15MaxNumberUpdatedCSI_Proc_SPT_r15(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15MaxNumberUpdatedCSI_Proc_STTI_Comb77_r15(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15MaxNumberUpdatedCSI_Proc_STTI_Comb27_r15(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15MaxNumberUpdatedCSI_Proc_STTI_Comb22_Set1_r15(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15MaxNumberUpdatedCSI_Proc_STTI_Comb22_Set2_r15(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "4", ub = "32")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15NumberOfBlindDecodesUSS_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Pdsch_SlotSubslotPDSCH_Decoding_r15(
    pub u8,
);
impl PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Pdsch_SlotSubslotPDSCH_Decoding_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15PowerUCI_SlotPUSCH(pub u8);
impl PhyLayerParameters_v1530Stti_SPT_Capabilities_r15PowerUCI_SlotPUSCH {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15PowerUCI_SubslotPUSCH(pub u8);
impl PhyLayerParameters_v1530Stti_SPT_Capabilities_r15PowerUCI_SubslotPUSCH {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15SlotPDSCH_TxDiv_TM9and10(pub u8);
impl PhyLayerParameters_v1530Stti_SPT_Capabilities_r15SlotPDSCH_TxDiv_TM9and10 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15SubslotPDSCH_TxDiv_TM9and10(pub u8);
impl PhyLayerParameters_v1530Stti_SPT_Capabilities_r15SubslotPDSCH_TxDiv_TM9and10 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Spdcch_differentRS_types_r15(pub u8);
impl PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Spdcch_differentRS_types_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Srs_DCI7_TriggeringFS2_r15(pub u8);
impl PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Srs_DCI7_TriggeringFS2_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Sps_cyclicShift_r15(pub u8);
impl PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Sps_cyclicShift_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Spdcch_Reuse_r15(pub u8);
impl PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Spdcch_Reuse_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Sps_STTI_r15(pub u8);
impl PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Sps_STTI_r15 {
    pub const SLOT: u8 = 0u8;
    pub const SUBSLOT: u8 = 1u8;
    pub const SLOT_AND_SUBSLOT: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Tm8_slotPDSCH_r15(pub u8);
impl PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Tm8_slotPDSCH_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Tm9_slotSubslot_r15(pub u8);
impl PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Tm9_slotSubslot_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Tm9_slotSubslotMBSFN_r15(pub u8);
impl PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Tm9_slotSubslotMBSFN_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Tm10_slotSubslot_r15(pub u8);
impl PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Tm10_slotSubslot_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Tm10_slotSubslotMBSFN_r15(pub u8);
impl PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Tm10_slotSubslotMBSFN_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15TxDiv_SPUCCH_r15(pub u8);
impl PhyLayerParameters_v1530Stti_SPT_Capabilities_r15TxDiv_SPUCCH_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Ul_AsyncHarqSharingDiff_TTI_Lengths_r15(
    pub u8,
);
impl PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Ul_AsyncHarqSharingDiff_TTI_Lengths_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 34)]
pub struct PhyLayerParameters_v1530Stti_SPT_Capabilities_r15 { # [asn (optional_idx = 0 ,)] pub aperiodic_csi_reporting_stti_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15AperiodicCsi_ReportingSTTI_r15 > , # [asn (optional_idx = 1 ,)] pub dmrs_based_spdcch_mbsfn_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Dmrs_BasedSPDCCH_MBSFN_r15 > , # [asn (optional_idx = 2 ,)] pub dmrs_based_spdcch_non_mbsfn_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Dmrs_BasedSPDCCH_nonMBSFN_r15 > , # [asn (optional_idx = 3 ,)] pub dmrs_position_pattern_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Dmrs_PositionPattern_r15 > , # [asn (optional_idx = 4 ,)] pub dmrs_sharing_subslot_pdsch_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Dmrs_SharingSubslotPDSCH_r15 > , # [asn (optional_idx = 5 ,)] pub dmrs_repetition_subslot_pdsch_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Dmrs_RepetitionSubslotPDSCH_r15 > , # [asn (optional_idx = 6 ,)] pub epdcch_spt_different_cells_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Epdcch_SPT_differentCells_r15 > , # [asn (optional_idx = 7 ,)] pub epdcch_stti_different_cells_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Epdcch_STTI_differentCells_r15 > , # [asn (optional_idx = 8 ,)] pub max_layers_slot_or_subslot_pusch_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15MaxLayersSlotOrSubslotPUSCH_r15 > , # [asn (optional_idx = 9 ,)] pub max_number_updated_csi_proc_spt_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15MaxNumberUpdatedCSI_Proc_SPT_r15 > , # [asn (optional_idx = 10 ,)] pub max_number_updated_csi_proc_stti_comb77_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15MaxNumberUpdatedCSI_Proc_STTI_Comb77_r15 > , # [asn (optional_idx = 11 ,)] pub max_number_updated_csi_proc_stti_comb27_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15MaxNumberUpdatedCSI_Proc_STTI_Comb27_r15 > , # [asn (optional_idx = 12 ,)] pub max_number_updated_csi_proc_stti_comb22_set1_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15MaxNumberUpdatedCSI_Proc_STTI_Comb22_Set1_r15 > , # [asn (optional_idx = 13 ,)] pub max_number_updated_csi_proc_stti_comb22_set2_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15MaxNumberUpdatedCSI_Proc_STTI_Comb22_Set2_r15 > , # [asn (optional_idx = 14 ,)] pub mimo_ue_parameters_stti_r15 : Option < MIMO_UE_Parameters_r13 > , # [asn (optional_idx = 15 ,)] pub mimo_ue_parameters_stti_v1530 : Option < MIMO_UE_Parameters_v1430 > , # [asn (optional_idx = 16 ,)] pub number_of_blind_decodes_uss_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15NumberOfBlindDecodesUSS_r15 > , # [asn (optional_idx = 17 ,)] pub pdsch_slot_subslot_pdsch_decoding_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Pdsch_SlotSubslotPDSCH_Decoding_r15 > , # [asn (optional_idx = 18 ,)] pub power_uci_slot_pusch : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15PowerUCI_SlotPUSCH > , # [asn (optional_idx = 19 ,)] pub power_uci_subslot_pusch : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15PowerUCI_SubslotPUSCH > , # [asn (optional_idx = 20 ,)] pub slot_pdsch_tx_div_tm9and10 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15SlotPDSCH_TxDiv_TM9and10 > , # [asn (optional_idx = 21 ,)] pub subslot_pdsch_tx_div_tm9and10 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15SubslotPDSCH_TxDiv_TM9and10 > , # [asn (optional_idx = 22 ,)] pub spdcch_different_rs_types_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Spdcch_differentRS_types_r15 > , # [asn (optional_idx = 23 ,)] pub srs_dci7_triggering_fs2_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Srs_DCI7_TriggeringFS2_r15 > , # [asn (optional_idx = 24 ,)] pub sps_cyclic_shift_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Sps_cyclicShift_r15 > , # [asn (optional_idx = 25 ,)] pub spdcch_reuse_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Spdcch_Reuse_r15 > , # [asn (optional_idx = 26 ,)] pub sps_stti_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Sps_STTI_r15 > , # [asn (optional_idx = 27 ,)] pub tm8_slot_pdsch_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Tm8_slotPDSCH_r15 > , # [asn (optional_idx = 28 ,)] pub tm9_slot_subslot_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Tm9_slotSubslot_r15 > , # [asn (optional_idx = 29 ,)] pub tm9_slot_subslot_mbsfn_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Tm9_slotSubslotMBSFN_r15 > , # [asn (optional_idx = 30 ,)] pub tm10_slot_subslot_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Tm10_slotSubslot_r15 > , # [asn (optional_idx = 31 ,)] pub tm10_slot_subslot_mbsfn_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Tm10_slotSubslotMBSFN_r15 > , # [asn (optional_idx = 32 ,)] pub tx_div_spucch_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15TxDiv_SPUCCH_r15 > , # [asn (optional_idx = 33 ,)] pub ul_async_harq_sharing_diff_tti_lengths_r15 : Option < PhyLayerParameters_v1530Stti_SPT_Capabilities_r15Ul_AsyncHarqSharingDiff_TTI_Lengths_r15 > , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Ce_Capabilities_r15Ce_CRS_IntfMitig_r15(pub u8);
impl PhyLayerParameters_v1530Ce_Capabilities_r15Ce_CRS_IntfMitig_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Ce_Capabilities_r15Ce_CQI_AlternativeTable_r15(pub u8);
impl PhyLayerParameters_v1530Ce_Capabilities_r15Ce_CQI_AlternativeTable_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Ce_Capabilities_r15Ce_PDSCH_FlexibleStartPRB_CE_ModeA_r15(
    pub u8,
);
impl PhyLayerParameters_v1530Ce_Capabilities_r15Ce_PDSCH_FlexibleStartPRB_CE_ModeA_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Ce_Capabilities_r15Ce_PDSCH_FlexibleStartPRB_CE_ModeB_r15(
    pub u8,
);
impl PhyLayerParameters_v1530Ce_Capabilities_r15Ce_PDSCH_FlexibleStartPRB_CE_ModeB_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Ce_Capabilities_r15Ce_PDSCH_64QAM_r15(pub u8);
impl PhyLayerParameters_v1530Ce_Capabilities_r15Ce_PDSCH_64QAM_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Ce_Capabilities_r15Ce_PUSCH_FlexibleStartPRB_CE_ModeA_r15(
    pub u8,
);
impl PhyLayerParameters_v1530Ce_Capabilities_r15Ce_PUSCH_FlexibleStartPRB_CE_ModeA_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Ce_Capabilities_r15Ce_PUSCH_FlexibleStartPRB_CE_ModeB_r15(
    pub u8,
);
impl PhyLayerParameters_v1530Ce_Capabilities_r15Ce_PUSCH_FlexibleStartPRB_CE_ModeB_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Ce_Capabilities_r15Ce_PUSCH_SubPRB_Allocation_r15(pub u8);
impl PhyLayerParameters_v1530Ce_Capabilities_r15Ce_PUSCH_SubPRB_Allocation_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Ce_Capabilities_r15Ce_UL_HARQ_ACK_Feedback_r15(pub u8);
impl PhyLayerParameters_v1530Ce_Capabilities_r15Ce_UL_HARQ_ACK_Feedback_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 9)]
pub struct PhyLayerParameters_v1530Ce_Capabilities_r15 {
    #[asn(optional_idx = 0)]
    pub ce_crs_intf_mitig_r15:
        Option<PhyLayerParameters_v1530Ce_Capabilities_r15Ce_CRS_IntfMitig_r15>,
    #[asn(optional_idx = 1)]
    pub ce_cqi_alternative_table_r15:
        Option<PhyLayerParameters_v1530Ce_Capabilities_r15Ce_CQI_AlternativeTable_r15>,
    #[asn(optional_idx = 2)]
    pub ce_pdsch_flexible_start_prb_ce_mode_a_r15:
        Option<PhyLayerParameters_v1530Ce_Capabilities_r15Ce_PDSCH_FlexibleStartPRB_CE_ModeA_r15>,
    #[asn(optional_idx = 3)]
    pub ce_pdsch_flexible_start_prb_ce_mode_b_r15:
        Option<PhyLayerParameters_v1530Ce_Capabilities_r15Ce_PDSCH_FlexibleStartPRB_CE_ModeB_r15>,
    #[asn(optional_idx = 4)]
    pub ce_pdsch_64qam_r15: Option<PhyLayerParameters_v1530Ce_Capabilities_r15Ce_PDSCH_64QAM_r15>,
    #[asn(optional_idx = 5)]
    pub ce_pusch_flexible_start_prb_ce_mode_a_r15:
        Option<PhyLayerParameters_v1530Ce_Capabilities_r15Ce_PUSCH_FlexibleStartPRB_CE_ModeA_r15>,
    #[asn(optional_idx = 6)]
    pub ce_pusch_flexible_start_prb_ce_mode_b_r15:
        Option<PhyLayerParameters_v1530Ce_Capabilities_r15Ce_PUSCH_FlexibleStartPRB_CE_ModeB_r15>,
    #[asn(optional_idx = 7)]
    pub ce_pusch_sub_prb_allocation_r15:
        Option<PhyLayerParameters_v1530Ce_Capabilities_r15Ce_PUSCH_SubPRB_Allocation_r15>,
    #[asn(optional_idx = 8)]
    pub ce_ul_harq_ack_feedback_r15:
        Option<PhyLayerParameters_v1530Ce_Capabilities_r15Ce_UL_HARQ_ACK_Feedback_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530ShortCQI_ForSCellActivation_r15(pub u8);
impl PhyLayerParameters_v1530ShortCQI_ForSCellActivation_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Mimo_CBSR_AdvancedCSI_r15(pub u8);
impl PhyLayerParameters_v1530Mimo_CBSR_AdvancedCSI_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Crs_IntfMitig_r15(pub u8);
impl PhyLayerParameters_v1530Crs_IntfMitig_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Ul_PowerControlEnhancements_r15(pub u8);
impl PhyLayerParameters_v1530Ul_PowerControlEnhancements_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Urllc_Capabilities_r15Pdsch_RepSubframe_r15(pub u8);
impl PhyLayerParameters_v1530Urllc_Capabilities_r15Pdsch_RepSubframe_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Urllc_Capabilities_r15Pdsch_RepSlot_r15(pub u8);
impl PhyLayerParameters_v1530Urllc_Capabilities_r15Pdsch_RepSlot_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Urllc_Capabilities_r15Pdsch_RepSubslot_r15(pub u8);
impl PhyLayerParameters_v1530Urllc_Capabilities_r15Pdsch_RepSubslot_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "6")]
pub struct PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_MultiConfigSubframe_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_MaxConfigSubframe_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "6")]
pub struct PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_MultiConfigSlot_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_MaxConfigSlot_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "6")]
pub struct PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_MultiConfigSubslot_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_MaxConfigSubslot_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SlotRepPCell_r15(pub u8);
impl PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SlotRepPCell_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SlotRepPSCell_r15(pub u8);
impl PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SlotRepPSCell_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SlotRepSCell_r15(pub u8);
impl PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SlotRepSCell_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SubframeRepPCell_r15(pub u8);
impl PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SubframeRepPCell_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SubframeRepPSCell_r15(pub u8);
impl PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SubframeRepPSCell_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SubframeRepSCell_r15(pub u8);
impl PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SubframeRepSCell_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SubslotRepPCell_r15(pub u8);
impl PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SubslotRepPCell_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SubslotRepPSCell_r15(pub u8);
impl PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SubslotRepPSCell_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SubslotRepSCell_r15(pub u8);
impl PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SubslotRepSCell_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Urllc_Capabilities_r15SemiStaticCFI_r15(pub u8);
impl PhyLayerParameters_v1530Urllc_Capabilities_r15SemiStaticCFI_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530Urllc_Capabilities_r15SemiStaticCFI_Pattern_r15(pub u8);
impl PhyLayerParameters_v1530Urllc_Capabilities_r15SemiStaticCFI_Pattern_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 20)]
pub struct PhyLayerParameters_v1530Urllc_Capabilities_r15 {
    #[asn(optional_idx = 0)]
    pub pdsch_rep_subframe_r15:
        Option<PhyLayerParameters_v1530Urllc_Capabilities_r15Pdsch_RepSubframe_r15>,
    #[asn(optional_idx = 1)]
    pub pdsch_rep_slot_r15: Option<PhyLayerParameters_v1530Urllc_Capabilities_r15Pdsch_RepSlot_r15>,
    #[asn(optional_idx = 2)]
    pub pdsch_rep_subslot_r15:
        Option<PhyLayerParameters_v1530Urllc_Capabilities_r15Pdsch_RepSubslot_r15>,
    #[asn(optional_idx = 3)]
    pub pusch_sps_multi_config_subframe_r15:
        Option<PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_MultiConfigSubframe_r15>,
    #[asn(optional_idx = 4)]
    pub pusch_sps_max_config_subframe_r15:
        Option<PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_MaxConfigSubframe_r15>,
    #[asn(optional_idx = 5)]
    pub pusch_sps_multi_config_slot_r15:
        Option<PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_MultiConfigSlot_r15>,
    #[asn(optional_idx = 6)]
    pub pusch_sps_max_config_slot_r15:
        Option<PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_MaxConfigSlot_r15>,
    #[asn(optional_idx = 7)]
    pub pusch_sps_multi_config_subslot_r15:
        Option<PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_MultiConfigSubslot_r15>,
    #[asn(optional_idx = 8)]
    pub pusch_sps_max_config_subslot_r15:
        Option<PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_MaxConfigSubslot_r15>,
    #[asn(optional_idx = 9)]
    pub pusch_sps_slot_rep_p_cell_r15:
        Option<PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SlotRepPCell_r15>,
    #[asn(optional_idx = 10)]
    pub pusch_sps_slot_rep_ps_cell_r15:
        Option<PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SlotRepPSCell_r15>,
    #[asn(optional_idx = 11)]
    pub pusch_sps_slot_rep_s_cell_r15:
        Option<PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SlotRepSCell_r15>,
    #[asn(optional_idx = 12)]
    pub pusch_sps_subframe_rep_p_cell_r15:
        Option<PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SubframeRepPCell_r15>,
    #[asn(optional_idx = 13)]
    pub pusch_sps_subframe_rep_ps_cell_r15:
        Option<PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SubframeRepPSCell_r15>,
    #[asn(optional_idx = 14)]
    pub pusch_sps_subframe_rep_s_cell_r15:
        Option<PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SubframeRepSCell_r15>,
    #[asn(optional_idx = 15)]
    pub pusch_sps_subslot_rep_p_cell_r15:
        Option<PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SubslotRepPCell_r15>,
    #[asn(optional_idx = 16)]
    pub pusch_sps_subslot_rep_ps_cell_r15:
        Option<PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SubslotRepPSCell_r15>,
    #[asn(optional_idx = 17)]
    pub pusch_sps_subslot_rep_s_cell_r15:
        Option<PhyLayerParameters_v1530Urllc_Capabilities_r15Pusch_SPS_SubslotRepSCell_r15>,
    #[asn(optional_idx = 18)]
    pub semi_static_cfi_r15:
        Option<PhyLayerParameters_v1530Urllc_Capabilities_r15SemiStaticCFI_r15>,
    #[asn(optional_idx = 19)]
    pub semi_static_cfi_pattern_r15:
        Option<PhyLayerParameters_v1530Urllc_Capabilities_r15SemiStaticCFI_Pattern_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1530AltMCS_Table_r15(pub u8);
impl PhyLayerParameters_v1530AltMCS_Table_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1540Stti_SPT_Capabilities_v1540SlotPDSCH_TxDiv_TM8_r15(pub u8);
impl PhyLayerParameters_v1540Stti_SPT_Capabilities_v1540SlotPDSCH_TxDiv_TM8_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PhyLayerParameters_v1540Stti_SPT_Capabilities_v1540 {
    pub slot_pdsch_tx_div_tm8_r15:
        PhyLayerParameters_v1540Stti_SPT_Capabilities_v1540SlotPDSCH_TxDiv_TM8_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1540Crs_IM_TM1_toTM9_OneRX_Port_v1540(pub u8);
impl PhyLayerParameters_v1540Crs_IM_TM1_toTM9_OneRX_Port_v1540 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1540Cch_IM_RefRecTypeA_OneRX_Port_v1540(pub u8);
impl PhyLayerParameters_v1540Cch_IM_RefRecTypeA_OneRX_Port_v1540 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1550Dmrs_OverheadReduction_r15(pub u8);
impl PhyLayerParameters_v1550Dmrs_OverheadReduction_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1610Ce_Capabilities_v1610Ce_CSI_RS_Feedback_r16(pub u8);
impl PhyLayerParameters_v1610Ce_Capabilities_v1610Ce_CSI_RS_Feedback_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1610Ce_Capabilities_v1610Ce_CSI_RS_FeedbackCodebookRestriction_r16(
    pub u8,
);
impl PhyLayerParameters_v1610Ce_Capabilities_v1610Ce_CSI_RS_FeedbackCodebookRestriction_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1610Ce_Capabilities_v1610Crs_ChEstMPDCCH_CE_ModeA_r16(pub u8);
impl PhyLayerParameters_v1610Ce_Capabilities_v1610Crs_ChEstMPDCCH_CE_ModeA_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1610Ce_Capabilities_v1610Crs_ChEstMPDCCH_CE_ModeB_r16(pub u8);
impl PhyLayerParameters_v1610Ce_Capabilities_v1610Crs_ChEstMPDCCH_CE_ModeB_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1610Ce_Capabilities_v1610Crs_ChEstMPDCCH_CSI_r16(pub u8);
impl PhyLayerParameters_v1610Ce_Capabilities_v1610Crs_ChEstMPDCCH_CSI_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1610Ce_Capabilities_v1610Crs_ChEstMPDCCH_ReciprocityTDD_r16(pub u8);
impl PhyLayerParameters_v1610Ce_Capabilities_v1610Crs_ChEstMPDCCH_ReciprocityTDD_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1610Ce_Capabilities_v1610Etws_CMAS_RxInConnCE_ModeA_r16(pub u8);
impl PhyLayerParameters_v1610Ce_Capabilities_v1610Etws_CMAS_RxInConnCE_ModeA_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1610Ce_Capabilities_v1610Etws_CMAS_RxInConnCE_ModeB_r16(pub u8);
impl PhyLayerParameters_v1610Ce_Capabilities_v1610Etws_CMAS_RxInConnCE_ModeB_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1610Ce_Capabilities_v1610Mpdcch_InLteControlRegionCE_ModeA_r16(
    pub u8,
);
impl PhyLayerParameters_v1610Ce_Capabilities_v1610Mpdcch_InLteControlRegionCE_ModeA_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1610Ce_Capabilities_v1610Mpdcch_InLteControlRegionCE_ModeB_r16(
    pub u8,
);
impl PhyLayerParameters_v1610Ce_Capabilities_v1610Mpdcch_InLteControlRegionCE_ModeB_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1610Ce_Capabilities_v1610Pdsch_InLteControlRegionCE_ModeA_r16(
    pub u8,
);
impl PhyLayerParameters_v1610Ce_Capabilities_v1610Pdsch_InLteControlRegionCE_ModeA_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1610Ce_Capabilities_v1610Pdsch_InLteControlRegionCE_ModeB_r16(
    pub u8,
);
impl PhyLayerParameters_v1610Ce_Capabilities_v1610Pdsch_InLteControlRegionCE_ModeB_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 14)]
pub struct PhyLayerParameters_v1610Ce_Capabilities_v1610 {
    #[asn(optional_idx = 0)]
    pub ce_csi_rs_feedback_r16:
        Option<PhyLayerParameters_v1610Ce_Capabilities_v1610Ce_CSI_RS_Feedback_r16>,
    #[asn(optional_idx = 1)]
    pub ce_csi_rs_feedback_codebook_restriction_r16: Option<
        PhyLayerParameters_v1610Ce_Capabilities_v1610Ce_CSI_RS_FeedbackCodebookRestriction_r16,
    >,
    #[asn(optional_idx = 2)]
    pub crs_ch_est_mpdcch_ce_mode_a_r16:
        Option<PhyLayerParameters_v1610Ce_Capabilities_v1610Crs_ChEstMPDCCH_CE_ModeA_r16>,
    #[asn(optional_idx = 3)]
    pub crs_ch_est_mpdcch_ce_mode_b_r16:
        Option<PhyLayerParameters_v1610Ce_Capabilities_v1610Crs_ChEstMPDCCH_CE_ModeB_r16>,
    #[asn(optional_idx = 4)]
    pub crs_ch_est_mpdcch_csi_r16:
        Option<PhyLayerParameters_v1610Ce_Capabilities_v1610Crs_ChEstMPDCCH_CSI_r16>,
    #[asn(optional_idx = 5)]
    pub crs_ch_est_mpdcch_reciprocity_tdd_r16:
        Option<PhyLayerParameters_v1610Ce_Capabilities_v1610Crs_ChEstMPDCCH_ReciprocityTDD_r16>,
    #[asn(optional_idx = 6)]
    pub etws_cmas_rx_in_conn_ce_mode_a_r16:
        Option<PhyLayerParameters_v1610Ce_Capabilities_v1610Etws_CMAS_RxInConnCE_ModeA_r16>,
    #[asn(optional_idx = 7)]
    pub etws_cmas_rx_in_conn_ce_mode_b_r16:
        Option<PhyLayerParameters_v1610Ce_Capabilities_v1610Etws_CMAS_RxInConnCE_ModeB_r16>,
    #[asn(optional_idx = 8)]
    pub mpdcch_in_lte_control_region_ce_mode_a_r16:
        Option<PhyLayerParameters_v1610Ce_Capabilities_v1610Mpdcch_InLteControlRegionCE_ModeA_r16>,
    #[asn(optional_idx = 9)]
    pub mpdcch_in_lte_control_region_ce_mode_b_r16:
        Option<PhyLayerParameters_v1610Ce_Capabilities_v1610Mpdcch_InLteControlRegionCE_ModeB_r16>,
    #[asn(optional_idx = 10)]
    pub pdsch_in_lte_control_region_ce_mode_a_r16:
        Option<PhyLayerParameters_v1610Ce_Capabilities_v1610Pdsch_InLteControlRegionCE_ModeA_r16>,
    #[asn(optional_idx = 11)]
    pub pdsch_in_lte_control_region_ce_mode_b_r16:
        Option<PhyLayerParameters_v1610Ce_Capabilities_v1610Pdsch_InLteControlRegionCE_ModeB_r16>,
    #[asn(optional_idx = 12)]
    pub multi_tb_parameters_r16: Option<CE_MultiTB_Parameters_r16>,
    #[asn(optional_idx = 13)]
    pub resource_resv_parameters_r16: Option<CE_ResourceResvParameters_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1610WidebandPRG_Slot_r16(pub u8);
impl PhyLayerParameters_v1610WidebandPRG_Slot_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1610WidebandPRG_Subslot_r16(pub u8);
impl PhyLayerParameters_v1610WidebandPRG_Subslot_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1610WidebandPRG_Subframe_r16(pub u8);
impl PhyLayerParameters_v1610WidebandPRG_Subframe_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1610AddSRS_r16AddSRS_FrequencyHopping_r16(pub u8);
impl PhyLayerParameters_v1610AddSRS_r16AddSRS_FrequencyHopping_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1610AddSRS_r16AddSRS_AntennaSwitching_r16(pub u8);
impl PhyLayerParameters_v1610AddSRS_r16AddSRS_AntennaSwitching_r16 {
    pub const USE_BASIC: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1610AddSRS_r16AddSRS_CarrierSwitching_r16(pub u8);
impl PhyLayerParameters_v1610AddSRS_r16AddSRS_CarrierSwitching_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct PhyLayerParameters_v1610AddSRS_r16 {
    #[asn(optional_idx = 0)]
    pub add_srs_frequency_hopping_r16:
        Option<PhyLayerParameters_v1610AddSRS_r16AddSRS_FrequencyHopping_r16>,
    #[asn(optional_idx = 1)]
    pub add_srs_antenna_switching_r16:
        Option<PhyLayerParameters_v1610AddSRS_r16AddSRS_AntennaSwitching_r16>,
    #[asn(optional_idx = 2)]
    pub add_srs_carrier_switching_r16:
        Option<PhyLayerParameters_v1610AddSRS_r16AddSRS_CarrierSwitching_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1610VirtualCellID_BasicSRS_r16(pub u8);
impl PhyLayerParameters_v1610VirtualCellID_BasicSRS_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1610VirtualCellID_AddSRS_r16(pub u8);
impl PhyLayerParameters_v1610VirtualCellID_AddSRS_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1700Ce_Capabilities_v1700Ce_PDSCH_14HARQProcesses_r17(pub u8);
impl PhyLayerParameters_v1700Ce_Capabilities_v1700Ce_PDSCH_14HARQProcesses_r17 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1700Ce_Capabilities_v1700Ce_PDSCH_14HARQProcesses_Alt2_r17(pub u8);
impl PhyLayerParameters_v1700Ce_Capabilities_v1700Ce_PDSCH_14HARQProcesses_Alt2_r17 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1700Ce_Capabilities_v1700Ce_PDSCH_MaxTBS_r17(pub u8);
impl PhyLayerParameters_v1700Ce_Capabilities_v1700Ce_PDSCH_MaxTBS_r17 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct PhyLayerParameters_v1700Ce_Capabilities_v1700 {
    #[asn(optional_idx = 0)]
    pub ce_pdsch_14harq_processes_r17:
        Option<PhyLayerParameters_v1700Ce_Capabilities_v1700Ce_PDSCH_14HARQProcesses_r17>,
    #[asn(optional_idx = 1)]
    pub ce_pdsch_14harq_processes_alt2_r17:
        Option<PhyLayerParameters_v1700Ce_Capabilities_v1700Ce_PDSCH_14HARQProcesses_Alt2_r17>,
    #[asn(optional_idx = 2)]
    pub ce_pdsch_max_tbs_r17:
        Option<PhyLayerParameters_v1700Ce_Capabilities_v1700Ce_PDSCH_MaxTBS_r17>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v1730Csi_SubframeSet2ForDormantSCell_r17(pub u8);
impl PhyLayerParameters_v1730Csi_SubframeSet2ForDormantSCell_r17 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v920EnhancedDualLayerFDD_r9(pub u8);
impl PhyLayerParameters_v920EnhancedDualLayerFDD_r9 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v920EnhancedDualLayerTDD_r9(pub u8);
impl PhyLayerParameters_v920EnhancedDualLayerTDD_r9 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v9d0Tm5_FDD_r9(pub u8);
impl PhyLayerParameters_v9d0Tm5_FDD_r9 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PhyLayerParameters_v9d0Tm5_TDD_r9(pub u8);
impl PhyLayerParameters_v9d0Tm5_TDD_r9 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct PhysCellIdGERANNetworkColourCode(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct PhysCellIdGERANBaseStationColourCode(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct PhysCellIdRangeRange(pub u8);
impl PhysCellIdRangeRange {
    pub const N4: u8 = 0u8;
    pub const N8: u8 = 1u8;
    pub const N12: u8 = 2u8;
    pub const N16: u8 = 3u8;
    pub const N24: u8 = 4u8;
    pub const N32: u8 = 5u8;
    pub const N48: u8 = 6u8;
    pub const N64: u8 = 7u8;
    pub const N84: u8 = 8u8;
    pub const N96: u8 = 9u8;
    pub const N128: u8 = 10u8;
    pub const N168: u8 = 11u8;
    pub const N252: u8 = 12u8;
    pub const N504: u8 = 13u8;
    pub const SPARE2: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct PhysCellIdRangeNR_r16Range(pub u8);
impl PhysCellIdRangeNR_r16Range {
    pub const N4: u8 = 0u8;
    pub const N8: u8 = 1u8;
    pub const N12: u8 = 2u8;
    pub const N16: u8 = 3u8;
    pub const N24: u8 = 4u8;
    pub const N32: u8 = 5u8;
    pub const N48: u8 = 6u8;
    pub const N64: u8 = 7u8;
    pub const N84: u8 = 8u8;
    pub const N96: u8 = 9u8;
    pub const N128: u8 = 10u8;
    pub const N168: u8 = 11u8;
    pub const N252: u8 = 12u8;
    pub const N504: u8 = 13u8;
    pub const N1008: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "2", ub = "512")]
pub struct PhysCellIdRangeUTRA_FDD_r9Range_r9(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PhysicalConfigDedicatedAntennaInfo_defaultValue;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PhysicalConfigDedicatedAntennaInfo {
    #[asn(key = 0, extended = false)]
    ExplicitValue(AntennaInfoDedicated),
    #[asn(key = 1, extended = false)]
    DefaultValue(PhysicalConfigDedicatedAntennaInfo_defaultValue),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct PhysicalConfigDedicatedSCell_r10NonUL_Configuration_r10 {
    #[asn(optional_idx = 0)]
    pub antenna_info_r10: Option<AntennaInfoDedicated_r10>,
    #[asn(optional_idx = 1)]
    pub cross_carrier_scheduling_config_r10: Option<CrossCarrierSchedulingConfig_r10>,
    #[asn(optional_idx = 2)]
    pub csi_rs_config_r10: Option<CSI_RS_Config_r10>,
    #[asn(optional_idx = 3)]
    pub pdsch_config_dedicated_r10: Option<PDSCH_ConfigDedicated>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 7)]
pub struct PhysicalConfigDedicatedSCell_r10Ul_Configuration_r10 {
    #[asn(optional_idx = 0)]
    pub antenna_info_ul_r10: Option<AntennaInfoUL_r10>,
    #[asn(optional_idx = 1)]
    pub pusch_config_dedicated_s_cell_r10: Option<PUSCH_ConfigDedicatedSCell_r10>,
    #[asn(optional_idx = 2)]
    pub uplink_power_control_dedicated_s_cell_r10: Option<UplinkPowerControlDedicatedSCell_r10>,
    #[asn(optional_idx = 3)]
    pub cqi_report_config_s_cell_r10: Option<CQI_ReportConfigSCell_r10>,
    #[asn(optional_idx = 4)]
    pub sounding_rs_ul_config_dedicated_r10: Option<SoundingRS_UL_ConfigDedicated>,
    #[asn(optional_idx = 5)]
    pub sounding_rs_ul_config_dedicated_v1020: Option<SoundingRS_UL_ConfigDedicated_v1020>,
    #[asn(optional_idx = 6)]
    pub sounding_rs_ul_config_dedicated_aperiodic_r10:
        Option<SoundingRS_UL_ConfigDedicatedAperiodic_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PhysicalConfigDedicatedSCell_v1370Pucch_SCell_v1370_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct PhysicalConfigDedicatedSCell_v1370Pucch_SCell_v1370_setup {
    #[asn(optional_idx = 0)]
    pub pucch_config_dedicated_v1370: Option<PUCCH_ConfigDedicated_v1370>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PhysicalConfigDedicatedSCell_v1370Pucch_SCell_v1370 {
    #[asn(key = 0, extended = false)]
    Release(PhysicalConfigDedicatedSCell_v1370Pucch_SCell_v1370_release),
    #[asn(key = 1, extended = false)]
    Setup(PhysicalConfigDedicatedSCell_v1370Pucch_SCell_v1370_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PhysicalConfigDedicatedSCell_v13c0Pucch_SCell_v13c0_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PhysicalConfigDedicatedSCell_v13c0Pucch_SCell_v13c0_setup {
    pub pucch_config_dedicated_v13c0: PUCCH_ConfigDedicated_v13c0,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PhysicalConfigDedicatedSCell_v13c0Pucch_SCell_v13c0 {
    #[asn(key = 0, extended = false)]
    Release(PhysicalConfigDedicatedSCell_v13c0Pucch_SCell_v13c0_release),
    #[asn(key = 1, extended = false)]
    Setup(PhysicalConfigDedicatedSCell_v13c0Pucch_SCell_v13c0_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PhysicalConfigDedicatedSCell_v1730Cqi_ReportPeriodicSCell_v1730_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PhysicalConfigDedicatedSCell_v1730Cqi_ReportPeriodicSCell_v1730 {
    #[asn(key = 0, extended = false)]
    Release(PhysicalConfigDedicatedSCell_v1730Cqi_ReportPeriodicSCell_v1730_release),
    #[asn(key = 1, extended = false)]
    Setup(CQI_ReportPeriodicSCell_v1730),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PhysicalConfigDedicatedSTTI_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PhysicalConfigDedicatedSTTI_r15_setupSemiOpenLoopSTTI_r15(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PhysicalConfigDedicatedSTTI_r15_setupSrs_DCI7_TriggeringConfig_r15(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PhysicalConfigDedicatedSTTI_r15_setupShortProcessingTime_r15(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 19)]
pub struct PhysicalConfigDedicatedSTTI_r15_setup {
    #[asn(optional_idx = 0)]
    pub antenna_info_dedicated_stti_r15: Option<AntennaInfoDedicatedSTTI_r15>,
    #[asn(optional_idx = 1)]
    pub antenna_info_ul_stti_r15: Option<AntennaInfoUL_STTI_r15>,
    #[asn(optional_idx = 2)]
    pub pucch_config_dedicated_v1530: Option<PUCCH_ConfigDedicated_v1530>,
    #[asn(optional_idx = 3)]
    pub scheduling_request_config_v1530: Option<SchedulingRequestConfig_v1530>,
    #[asn(optional_idx = 4)]
    pub uplink_power_control_dedicated_stti_r15: Option<UplinkPowerControlDedicatedSTTI_r15>,
    #[asn(optional_idx = 5)]
    pub cqi_report_config_r15: Option<CQI_ReportConfig_r15>,
    #[asn(optional_idx = 6)]
    pub csi_rs_config_r15: Option<CSI_RS_Config_r15>,
    #[asn(optional_idx = 7)]
    pub csi_rs_config_nzp_to_release_list_r15: Option<CSI_RS_ConfigNZPToReleaseList_r15>,
    #[asn(optional_idx = 8)]
    pub csi_rs_config_nzp_to_add_mod_list_r15: Option<CSI_RS_ConfigNZPToAddModList_r15>,
    #[asn(optional_idx = 9)]
    pub csi_rs_config_zp_to_release_list_r15: Option<CSI_RS_ConfigZPToReleaseList_r11>,
    #[asn(optional_idx = 10)]
    pub csi_rs_config_zp_to_add_mod_list_r11: Option<CSI_RS_ConfigZPToAddModList_r11>,
    #[asn(optional_idx = 11)]
    pub csi_rs_config_zp_ap_list_r15: Option<CSI_RS_ConfigZP_ApList_r14>,
    #[asn(optional_idx = 12)]
    pub eimta_main_config_r12: Option<EIMTA_MainConfig_r12>,
    #[asn(optional_idx = 13)]
    pub eimta_main_config_serv_cell_r15: Option<EIMTA_MainConfigServCell_r12>,
    pub semi_open_loop_stti_r15: PhysicalConfigDedicatedSTTI_r15_setupSemiOpenLoopSTTI_r15,
    #[asn(optional_idx = 14)]
    pub slot_or_subslot_pdsch_config_r15: Option<SlotOrSubslotPDSCH_Config_r15>,
    #[asn(optional_idx = 15)]
    pub slot_or_subslot_pusch_config_r15: Option<SlotOrSubslotPUSCH_Config_r15>,
    #[asn(optional_idx = 16)]
    pub spdcch_config_r15: Option<SPDCCH_Config_r15>,
    #[asn(optional_idx = 17)]
    pub spucch_config_r15: Option<SPUCCH_Config_r15>,
    pub srs_dci7_triggering_config_r15:
        PhysicalConfigDedicatedSTTI_r15_setupSrs_DCI7_TriggeringConfig_r15,
    pub short_processing_time_r15: PhysicalConfigDedicatedSTTI_r15_setupShortProcessingTime_r15,
    #[asn(optional_idx = 18)]
    pub short_tti_r15: Option<ShortTTI_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct PosSIB_Type_r15Encrypted_r15(pub u8);
impl PosSIB_Type_r15Encrypted_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "26")]
pub struct PosSIB_Type_r15PosSibType_r15(pub u8);
impl PosSIB_Type_r15PosSibType_r15 {
    pub const POS_SIB_TYPE1_1: u8 = 0u8;
    pub const POS_SIB_TYPE1_2: u8 = 1u8;
    pub const POS_SIB_TYPE1_3: u8 = 2u8;
    pub const POS_SIB_TYPE1_4: u8 = 3u8;
    pub const POS_SIB_TYPE1_5: u8 = 4u8;
    pub const POS_SIB_TYPE1_6: u8 = 5u8;
    pub const POS_SIB_TYPE1_7: u8 = 6u8;
    pub const POS_SIB_TYPE2_1: u8 = 7u8;
    pub const POS_SIB_TYPE2_2: u8 = 8u8;
    pub const POS_SIB_TYPE2_3: u8 = 9u8;
    pub const POS_SIB_TYPE2_4: u8 = 10u8;
    pub const POS_SIB_TYPE2_5: u8 = 11u8;
    pub const POS_SIB_TYPE2_6: u8 = 12u8;
    pub const POS_SIB_TYPE2_7: u8 = 13u8;
    pub const POS_SIB_TYPE2_8: u8 = 14u8;
    pub const POS_SIB_TYPE2_9: u8 = 15u8;
    pub const POS_SIB_TYPE2_10: u8 = 16u8;
    pub const POS_SIB_TYPE2_11: u8 = 17u8;
    pub const POS_SIB_TYPE2_12: u8 = 18u8;
    pub const POS_SIB_TYPE2_13: u8 = 19u8;
    pub const POS_SIB_TYPE2_14: u8 = 20u8;
    pub const POS_SIB_TYPE2_15: u8 = 21u8;
    pub const POS_SIB_TYPE2_16: u8 = 22u8;
    pub const POS_SIB_TYPE2_17: u8 = 23u8;
    pub const POS_SIB_TYPE2_18: u8 = 24u8;
    pub const POS_SIB_TYPE2_19: u8 = 25u8;
    pub const POS_SIB_TYPE3_1: u8 = 26u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "6")]
pub struct PosSchedulingInfo_r15PosSI_Periodicity_r15(pub u8);
impl PosSchedulingInfo_r15PosSI_Periodicity_r15 {
    pub const RF8: u8 = 0u8;
    pub const RF16: u8 = 1u8;
    pub const RF32: u8 = 2u8;
    pub const RF64: u8 = 3u8;
    pub const RF128: u8 = 4u8;
    pub const RF256: u8 = 5u8;
    pub const RF512: u8 = 6u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "26", extensible = true)]
pub enum PosSystemInformation_r15_IEsPosSIB_TypeAndInfo_r15_Entry {
    #[asn(key = 0, extended = false)]
    PosSib1_1_r15(SystemInformationBlockPos_r15),
    #[asn(key = 1, extended = false)]
    PosSib1_2_r15(SystemInformationBlockPos_r15),
    #[asn(key = 2, extended = false)]
    PosSib1_3_r15(SystemInformationBlockPos_r15),
    #[asn(key = 3, extended = false)]
    PosSib1_4_r15(SystemInformationBlockPos_r15),
    #[asn(key = 4, extended = false)]
    PosSib1_5_r15(SystemInformationBlockPos_r15),
    #[asn(key = 5, extended = false)]
    PosSib1_6_r15(SystemInformationBlockPos_r15),
    #[asn(key = 6, extended = false)]
    PosSib1_7_r15(SystemInformationBlockPos_r15),
    #[asn(key = 7, extended = false)]
    PosSib2_1_r15(SystemInformationBlockPos_r15),
    #[asn(key = 8, extended = false)]
    PosSib2_2_r15(SystemInformationBlockPos_r15),
    #[asn(key = 9, extended = false)]
    PosSib2_3_r15(SystemInformationBlockPos_r15),
    #[asn(key = 10, extended = false)]
    PosSib2_4_r15(SystemInformationBlockPos_r15),
    #[asn(key = 11, extended = false)]
    PosSib2_5_r15(SystemInformationBlockPos_r15),
    #[asn(key = 12, extended = false)]
    PosSib2_6_r15(SystemInformationBlockPos_r15),
    #[asn(key = 13, extended = false)]
    PosSib2_7_r15(SystemInformationBlockPos_r15),
    #[asn(key = 14, extended = false)]
    PosSib2_8_r15(SystemInformationBlockPos_r15),
    #[asn(key = 15, extended = false)]
    PosSib2_9_r15(SystemInformationBlockPos_r15),
    #[asn(key = 16, extended = false)]
    PosSib2_10_r15(SystemInformationBlockPos_r15),
    #[asn(key = 17, extended = false)]
    PosSib2_11_r15(SystemInformationBlockPos_r15),
    #[asn(key = 18, extended = false)]
    PosSib2_12_r15(SystemInformationBlockPos_r15),
    #[asn(key = 19, extended = false)]
    PosSib2_13_r15(SystemInformationBlockPos_r15),
    #[asn(key = 20, extended = false)]
    PosSib2_14_r15(SystemInformationBlockPos_r15),
    #[asn(key = 21, extended = false)]
    PosSib2_15_r15(SystemInformationBlockPos_r15),
    #[asn(key = 22, extended = false)]
    PosSib2_16_r15(SystemInformationBlockPos_r15),
    #[asn(key = 23, extended = false)]
    PosSib2_17_r15(SystemInformationBlockPos_r15),
    #[asn(key = 24, extended = false)]
    PosSib2_18_r15(SystemInformationBlockPos_r15),
    #[asn(key = 25, extended = false)]
    PosSib2_19_r15(SystemInformationBlockPos_r15),
    #[asn(key = 26, extended = false)]
    PosSib3_1_r15(SystemInformationBlockPos_r15),
    #[asn(key = 0, extended = true)]
    PosSib1_8_v1610(SystemInformationBlockPos_r15),
    #[asn(key = 1, extended = true)]
    PosSib2_20_v1610(SystemInformationBlockPos_r15),
    #[asn(key = 2, extended = true)]
    PosSib2_21_v1610(SystemInformationBlockPos_r15),
    #[asn(key = 3, extended = true)]
    PosSib2_22_v1610(SystemInformationBlockPos_r15),
    #[asn(key = 4, extended = true)]
    PosSib2_23_v1610(SystemInformationBlockPos_r15),
    #[asn(key = 5, extended = true)]
    PosSib2_24_v1610(SystemInformationBlockPos_r15),
    #[asn(key = 6, extended = true)]
    PosSib2_25_v1610(SystemInformationBlockPos_r15),
    #[asn(key = 7, extended = true)]
    PosSib4_1_v1610(SystemInformationBlockPos_r15),
    #[asn(key = 8, extended = true)]
    PosSib5_1_v1610(SystemInformationBlockPos_r15),
    #[asn(key = 9, extended = true)]
    PosSib1_9_v1700(SystemInformationBlockPos_r15),
    #[asn(key = 10, extended = true)]
    PosSib1_10_v1700(SystemInformationBlockPos_r15),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct PosSystemInformation_r15_IEsPosSIB_TypeAndInfo_r15(
    pub Vec<PosSystemInformation_r15_IEsPosSIB_TypeAndInfo_r15_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PosSystemInformation_r15_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PosSystemInformation_r15_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct PowerCoordinationInfo_r12P_MeNB_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct PowerCoordinationInfo_r12P_SeNB_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "2")]
pub struct PowerCoordinationInfo_r12PowerControlMode_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct PowerPrefIndicationConfig_r11_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct PowerPrefIndicationConfig_r11_setupPowerPrefIndicationTimer_r11(pub u8);
impl PowerPrefIndicationConfig_r11_setupPowerPrefIndicationTimer_r11 {
    pub const S0: u8 = 0u8;
    pub const S0DOT5: u8 = 1u8;
    pub const S1: u8 = 2u8;
    pub const S2: u8 = 3u8;
    pub const S5: u8 = 4u8;
    pub const S10: u8 = 5u8;
    pub const S20: u8 = 6u8;
    pub const S30: u8 = 7u8;
    pub const S60: u8 = 8u8;
    pub const S90: u8 = 9u8;
    pub const S120: u8 = 10u8;
    pub const S300: u8 = 11u8;
    pub const S600: u8 = 12u8;
    pub const SPARE3: u8 = 13u8;
    pub const SPARE2: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PowerPrefIndicationConfig_r11_setup {
    pub power_pref_indication_timer_r11:
        PowerPrefIndicationConfig_r11_setupPowerPrefIndicationTimer_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct PowerRampingParametersPowerRampingStep(pub u8);
impl PowerRampingParametersPowerRampingStep {
    pub const D_B0: u8 = 0u8;
    pub const D_B2: u8 = 1u8;
    pub const D_B4: u8 = 2u8;
    pub const D_B6: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct PowerRampingParametersPreambleInitialReceivedTargetPower(pub u8);
impl PowerRampingParametersPreambleInitialReceivedTargetPower {
    pub const D_BM_120: u8 = 0u8;
    pub const D_BM_118: u8 = 1u8;
    pub const D_BM_116: u8 = 2u8;
    pub const D_BM_114: u8 = 3u8;
    pub const D_BM_112: u8 = 4u8;
    pub const D_BM_110: u8 = 5u8;
    pub const D_BM_108: u8 = 6u8;
    pub const D_BM_106: u8 = 7u8;
    pub const D_BM_104: u8 = 8u8;
    pub const D_BM_102: u8 = 9u8;
    pub const D_BM_100: u8 = 10u8;
    pub const D_BM_98: u8 = 11u8;
    pub const D_BM_96: u8 = 12u8;
    pub const D_BM_94: u8 = 13u8;
    pub const D_BM_92: u8 = 14u8;
    pub const D_BM_90: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct PreRegistrationInfoHRPDPreRegistrationAllowed(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct ProximityIndication_r9CriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct ProximityIndication_r9CriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct ProximityIndication_r9CriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum ProximityIndication_r9CriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    ProximityIndication_r9(ProximityIndication_r9_IEs),
    #[asn(key = 1, extended = false)]
    Spare3(ProximityIndication_r9CriticalExtensions_c1_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(ProximityIndication_r9CriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(ProximityIndication_r9CriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ProximityIndication_r9CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum ProximityIndication_r9CriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(ProximityIndication_r9CriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(ProximityIndication_r9CriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct ProximityIndication_r9_IEsType_r9(pub u8);
impl ProximityIndication_r9_IEsType_r9 {
    pub const ENTERING: u8 = 0u8;
    pub const LEAVING: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum ProximityIndication_r9_IEsCarrierFreq_r9 {
    #[asn(key = 0, extended = false)]
    Eutra_r9(ARFCN_ValueEUTRA),
    #[asn(key = 1, extended = false)]
    Utra_r9(ARFCN_ValueUTRA),
    #[asn(key = 0, extended = true)]
    Eutra2_v9e0(ARFCN_ValueEUTRA_v9e0),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct ProximityIndication_v930_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ProximityIndication_v930_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct QuantityConfigCDMA2000MeasQuantityCDMA2000(pub u8);
impl QuantityConfigCDMA2000MeasQuantityCDMA2000 {
    pub const PILOT_STRENGTH: u8 = 0u8;
    pub const PILOT_PN_PHASE_AND_PILOT_STRENGTH: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct QuantityConfigGERANMeasQuantityGERAN(pub u8);
impl QuantityConfigGERANMeasQuantityGERAN {
    pub const RSSI: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct QuantityConfigUTRAMeasQuantityUTRA_FDD(pub u8);
impl QuantityConfigUTRAMeasQuantityUTRA_FDD {
    pub const CPICH_RSCP: u8 = 0u8;
    pub const CPICH_EC_N0: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct QuantityConfigUTRAMeasQuantityUTRA_TDD(pub u8);
impl QuantityConfigUTRAMeasQuantityUTRA_TDD {
    pub const PCCPCH_RSCP: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct QuantityConfigWLAN_r13MeasQuantityWLAN_r13(pub u8);
impl QuantityConfigWLAN_r13MeasQuantityWLAN_r13 {
    pub const RSSI_WLAN: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63")]
pub struct RACH_CE_LevelInfo_r13PreambleMappingInfo_r13FirstPreamble_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63")]
pub struct RACH_CE_LevelInfo_r13PreambleMappingInfo_r13LastPreamble_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RACH_CE_LevelInfo_r13PreambleMappingInfo_r13 {
    pub first_preamble_r13: RACH_CE_LevelInfo_r13PreambleMappingInfo_r13FirstPreamble_r13,
    pub last_preamble_r13: RACH_CE_LevelInfo_r13PreambleMappingInfo_r13LastPreamble_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct RACH_CE_LevelInfo_r13Ra_ResponseWindowSize_r13(pub u8);
impl RACH_CE_LevelInfo_r13Ra_ResponseWindowSize_r13 {
    pub const SF20: u8 = 0u8;
    pub const SF50: u8 = 1u8;
    pub const SF80: u8 = 2u8;
    pub const SF120: u8 = 3u8;
    pub const SF180: u8 = 4u8;
    pub const SF240: u8 = 5u8;
    pub const SF320: u8 = 6u8;
    pub const SF400: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct RACH_CE_LevelInfo_r13Mac_ContentionResolutionTimer_r13(pub u8);
impl RACH_CE_LevelInfo_r13Mac_ContentionResolutionTimer_r13 {
    pub const SF80: u8 = 0u8;
    pub const SF100: u8 = 1u8;
    pub const SF120: u8 = 2u8;
    pub const SF160: u8 = 3u8;
    pub const SF200: u8 = 4u8;
    pub const SF240: u8 = 5u8;
    pub const SF480: u8 = 6u8;
    pub const SF960: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct RACH_CE_LevelInfo_r13Rar_HoppingConfig_r13(pub u8);
impl RACH_CE_LevelInfo_r13Rar_HoppingConfig_r13 {
    pub const ON: u8 = 0u8;
    pub const OFF: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct RACH_ConfigCommonPreambleInfoNumberOfRA_Preambles(pub u8);
impl RACH_ConfigCommonPreambleInfoNumberOfRA_Preambles {
    pub const N4: u8 = 0u8;
    pub const N8: u8 = 1u8;
    pub const N12: u8 = 2u8;
    pub const N16: u8 = 3u8;
    pub const N20: u8 = 4u8;
    pub const N24: u8 = 5u8;
    pub const N28: u8 = 6u8;
    pub const N32: u8 = 7u8;
    pub const N36: u8 = 8u8;
    pub const N40: u8 = 9u8;
    pub const N44: u8 = 10u8;
    pub const N48: u8 = 11u8;
    pub const N52: u8 = 12u8;
    pub const N56: u8 = 13u8;
    pub const N60: u8 = 14u8;
    pub const N64: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "14")]
pub struct RACH_ConfigCommonPreambleInfoPreamblesGroupAConfigSizeOfRA_PreamblesGroupA(pub u8);
impl RACH_ConfigCommonPreambleInfoPreamblesGroupAConfigSizeOfRA_PreamblesGroupA {
    pub const N4: u8 = 0u8;
    pub const N8: u8 = 1u8;
    pub const N12: u8 = 2u8;
    pub const N16: u8 = 3u8;
    pub const N20: u8 = 4u8;
    pub const N24: u8 = 5u8;
    pub const N28: u8 = 6u8;
    pub const N32: u8 = 7u8;
    pub const N36: u8 = 8u8;
    pub const N40: u8 = 9u8;
    pub const N44: u8 = 10u8;
    pub const N48: u8 = 11u8;
    pub const N52: u8 = 12u8;
    pub const N56: u8 = 13u8;
    pub const N60: u8 = 14u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct RACH_ConfigCommonPreambleInfoPreamblesGroupAConfigMessageSizeGroupA(pub u8);
impl RACH_ConfigCommonPreambleInfoPreamblesGroupAConfigMessageSizeGroupA {
    pub const B56: u8 = 0u8;
    pub const B144: u8 = 1u8;
    pub const B208: u8 = 2u8;
    pub const B256: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct RACH_ConfigCommonPreambleInfoPreamblesGroupAConfigMessagePowerOffsetGroupB(pub u8);
impl RACH_ConfigCommonPreambleInfoPreamblesGroupAConfigMessagePowerOffsetGroupB {
    pub const MINUSINFINITY: u8 = 0u8;
    pub const D_B0: u8 = 1u8;
    pub const D_B5: u8 = 2u8;
    pub const D_B8: u8 = 3u8;
    pub const D_B10: u8 = 4u8;
    pub const D_B12: u8 = 5u8;
    pub const D_B15: u8 = 6u8;
    pub const D_B18: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RACH_ConfigCommonPreambleInfoPreamblesGroupAConfig {
    pub size_of_ra_preambles_group_a:
        RACH_ConfigCommonPreambleInfoPreamblesGroupAConfigSizeOfRA_PreamblesGroupA,
    pub message_size_group_a: RACH_ConfigCommonPreambleInfoPreamblesGroupAConfigMessageSizeGroupA,
    pub message_power_offset_group_b:
        RACH_ConfigCommonPreambleInfoPreamblesGroupAConfigMessagePowerOffsetGroupB,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RACH_ConfigCommonPreambleInfo {
    pub number_of_ra_preambles: RACH_ConfigCommonPreambleInfoNumberOfRA_Preambles,
    #[asn(optional_idx = 0)]
    pub preambles_group_a_config: Option<RACH_ConfigCommonPreambleInfoPreamblesGroupAConfig>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct RACH_ConfigCommonRa_SupervisionInfoRa_ResponseWindowSize(pub u8);
impl RACH_ConfigCommonRa_SupervisionInfoRa_ResponseWindowSize {
    pub const SF2: u8 = 0u8;
    pub const SF3: u8 = 1u8;
    pub const SF4: u8 = 2u8;
    pub const SF5: u8 = 3u8;
    pub const SF6: u8 = 4u8;
    pub const SF7: u8 = 5u8;
    pub const SF8: u8 = 6u8;
    pub const SF10: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct RACH_ConfigCommonRa_SupervisionInfoMac_ContentionResolutionTimer(pub u8);
impl RACH_ConfigCommonRa_SupervisionInfoMac_ContentionResolutionTimer {
    pub const SF8: u8 = 0u8;
    pub const SF16: u8 = 1u8;
    pub const SF24: u8 = 2u8;
    pub const SF32: u8 = 3u8;
    pub const SF40: u8 = 4u8;
    pub const SF48: u8 = 5u8;
    pub const SF56: u8 = 6u8;
    pub const SF64: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RACH_ConfigCommonRa_SupervisionInfo {
    pub preamble_trans_max: PreambleTransMax,
    pub ra_response_window_size: RACH_ConfigCommonRa_SupervisionInfoRa_ResponseWindowSize,
    pub mac_contention_resolution_timer:
        RACH_ConfigCommonRa_SupervisionInfoMac_ContentionResolutionTimer,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8")]
pub struct RACH_ConfigCommonMaxHARQ_Msg3Tx(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct RACH_ConfigCommon_v1250TxFailParams_r12ConnEstFailCount_r12(pub u8);
impl RACH_ConfigCommon_v1250TxFailParams_r12ConnEstFailCount_r12 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N3: u8 = 2u8;
    pub const N4: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct RACH_ConfigCommon_v1250TxFailParams_r12ConnEstFailOffsetValidity_r12(pub u8);
impl RACH_ConfigCommon_v1250TxFailParams_r12ConnEstFailOffsetValidity_r12 {
    pub const S30: u8 = 0u8;
    pub const S60: u8 = 1u8;
    pub const S120: u8 = 2u8;
    pub const S240: u8 = 3u8;
    pub const S300: u8 = 4u8;
    pub const S420: u8 = 5u8;
    pub const S600: u8 = 6u8;
    pub const S900: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct RACH_ConfigCommon_v1250TxFailParams_r12ConnEstFailOffset_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RACH_ConfigCommon_v1250TxFailParams_r12 {
    pub conn_est_fail_count_r12: RACH_ConfigCommon_v1250TxFailParams_r12ConnEstFailCount_r12,
    pub conn_est_fail_offset_validity_r12:
        RACH_ConfigCommon_v1250TxFailParams_r12ConnEstFailOffsetValidity_r12,
    #[asn(optional_idx = 0)]
    pub conn_est_fail_offset_r12:
        Option<RACH_ConfigCommon_v1250TxFailParams_r12ConnEstFailOffset_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RACH_ConfigCommonSCell_r11Ra_SupervisionInfo_r11 {
    pub preamble_trans_max_r11: PreambleTransMax,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63")]
pub struct RACH_ConfigDedicatedRa_PreambleIndex(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct RACH_ConfigDedicatedRa_PRACH_MaskIndex(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct RACH_Report_r16ContentionDetected_r16(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct RACH_Report_v1610InitialCEL_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct RACH_Report_v1610Edt_Fallback_r16(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RACH_Skip_r14TargetTA_r14_ta0_r14;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RACH_Skip_r14TargetTA_r14_mcg_PTAG_r14;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RACH_Skip_r14TargetTA_r14_scg_PTAG_r14;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "4", extensible = false)]
pub enum RACH_Skip_r14TargetTA_r14 {
    #[asn(key = 0, extended = false)]
    Ta0_r14(RACH_Skip_r14TargetTA_r14_ta0_r14),
    #[asn(key = 1, extended = false)]
    Mcg_PTAG_r14(RACH_Skip_r14TargetTA_r14_mcg_PTAG_r14),
    #[asn(key = 2, extended = false)]
    Scg_PTAG_r14(RACH_Skip_r14TargetTA_r14_scg_PTAG_r14),
    #[asn(key = 3, extended = false)]
    Mcg_STAG_r14(STAG_Id_r11),
    #[asn(key = 4, extended = false)]
    Scg_STAG_r14(STAG_Id_r11),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8")]
pub struct RACH_Skip_r14Ul_ConfigInfo_r14NumberOfConfUL_Processes_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct RACH_Skip_r14Ul_ConfigInfo_r14Ul_SchedInterval_r14(pub u8);
impl RACH_Skip_r14Ul_ConfigInfo_r14Ul_SchedInterval_r14 {
    pub const SF2: u8 = 0u8;
    pub const SF5: u8 = 1u8;
    pub const SF10: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "9")]
pub struct RACH_Skip_r14Ul_ConfigInfo_r14Ul_StartSubframe_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct RACH_Skip_r14Ul_ConfigInfo_r14Ul_Grant_r14(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RACH_Skip_r14Ul_ConfigInfo_r14 {
    pub number_of_conf_ul_processes_r14: RACH_Skip_r14Ul_ConfigInfo_r14NumberOfConfUL_Processes_r14,
    pub ul_sched_interval_r14: RACH_Skip_r14Ul_ConfigInfo_r14Ul_SchedInterval_r14,
    pub ul_start_subframe_r14: RACH_Skip_r14Ul_ConfigInfo_r14Ul_StartSubframe_r14,
    pub ul_grant_r14: RACH_Skip_r14Ul_ConfigInfo_r14Ul_Grant_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct RAN_AreaConfig_r15Ran_AreaCodeList_r15(pub Vec<RAN_AreaCode_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RCLWI_Config_r13Command_steerToWLAN_r13 {
    pub mobility_config_r13: WLAN_Id_List_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RCLWI_Config_r13Command_steerToLTE_r13;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RCLWI_Config_r13Command {
    #[asn(key = 0, extended = false)]
    SteerToWLAN_r13(RCLWI_Config_r13Command_steerToWLAN_r13),
    #[asn(key = 1, extended = false)]
    SteerToLTE_r13(RCLWI_Config_r13Command_steerToLTE_r13),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RCLWI_Configuration_r13_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RCLWI_Configuration_r13_setup {
    pub rclwi_config_r13: RCLWI_Config_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct RF_Parameters_v10f0ModifiedMPR_Behavior_r10(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RF_Parameters_v10j0MultiNS_Pmax_r10(pub u8);
impl RF_Parameters_v10j0MultiNS_Pmax_r10 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RF_Parameters_v1180FreqBandRetrieval_r11(pub u8);
impl RF_Parameters_v1180FreqBandRetrieval_r11 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct RF_Parameters_v1180RequestedBands_r11(pub Vec<FreqBandIndicator_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RF_Parameters_v1250FreqBandPriorityAdjustment_r12(pub u8);
impl RF_Parameters_v1250FreqBandPriorityAdjustment_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RF_Parameters_v12b0MaxLayersMIMO_Indication_r12(pub u8);
impl RF_Parameters_v12b0MaxLayersMIMO_Indication_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RF_Parameters_v1310ENB_RequestedParameters_r13ReducedIntNonContCombRequested_r13(pub u8);
impl RF_Parameters_v1310ENB_RequestedParameters_r13ReducedIntNonContCombRequested_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "2", ub = "32")]
pub struct RF_Parameters_v1310ENB_RequestedParameters_r13RequestedCCsDL_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "2", ub = "32")]
pub struct RF_Parameters_v1310ENB_RequestedParameters_r13RequestedCCsUL_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RF_Parameters_v1310ENB_RequestedParameters_r13SkipFallbackCombRequested_r13(pub u8);
impl RF_Parameters_v1310ENB_RequestedParameters_r13SkipFallbackCombRequested_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct RF_Parameters_v1310ENB_RequestedParameters_r13 {
    #[asn(optional_idx = 0)]
    pub reduced_int_non_cont_comb_requested_r13:
        Option<RF_Parameters_v1310ENB_RequestedParameters_r13ReducedIntNonContCombRequested_r13>,
    #[asn(optional_idx = 1)]
    pub requested_c_cs_dl_r13:
        Option<RF_Parameters_v1310ENB_RequestedParameters_r13RequestedCCsDL_r13>,
    #[asn(optional_idx = 2)]
    pub requested_c_cs_ul_r13:
        Option<RF_Parameters_v1310ENB_RequestedParameters_r13RequestedCCsUL_r13>,
    #[asn(optional_idx = 3)]
    pub skip_fallback_comb_requested_r13:
        Option<RF_Parameters_v1310ENB_RequestedParameters_r13SkipFallbackCombRequested_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RF_Parameters_v1310MaximumCCsRetrieval_r13(pub u8);
impl RF_Parameters_v1310MaximumCCsRetrieval_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RF_Parameters_v1310SkipFallbackCombinations_r13(pub u8);
impl RF_Parameters_v1310SkipFallbackCombinations_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RF_Parameters_v1310ReducedIntNonContComb_r13(pub u8);
impl RF_Parameters_v1310ReducedIntNonContComb_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RF_Parameters_v1430ENB_RequestedParameters_v1430 {
    pub requested_diff_fallback_comb_list_r14: BandCombinationList_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RF_Parameters_v1430DiffFallbackCombReport_r14(pub u8);
impl RF_Parameters_v1430DiffFallbackCombReport_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RF_Parameters_v1530STTI_SPT_Supported_r15(pub u8);
impl RF_Parameters_v1530STTI_SPT_Supported_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RF_Parameters_v1530PowerClass_14dBm_r15(pub u8);
impl RF_Parameters_v1530PowerClass_14dBm_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct RF_Parameters_v1570Dl_1024QAM_ScalingFactor_r15(pub u8);
impl RF_Parameters_v1570Dl_1024QAM_ScalingFactor_r15 {
    pub const V1: u8 = 0u8;
    pub const V1DOT2: u8 = 1u8;
    pub const V1DOT25: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "10")]
pub struct RF_Parameters_v1570Dl_1024QAM_TotalWeightedLayers_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RLC_BearerConfig_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "10")]
pub struct RLC_BearerConfig_r15_setupLogicalChannelIdentityConfig_r15_logicalChannelIdentity_r15(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "32", ub = "38")]
pub struct RLC_BearerConfig_r15_setupLogicalChannelIdentityConfig_r15_logicalChannelIdentityExt_r15(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RLC_BearerConfig_r15_setupLogicalChannelIdentityConfig_r15 {
    #[asn(key = 0, extended = false)]
    LogicalChannelIdentity_r15(
        RLC_BearerConfig_r15_setupLogicalChannelIdentityConfig_r15_logicalChannelIdentity_r15,
    ),
    #[asn(key = 1, extended = false)]
    LogicalChannelIdentityExt_r15(
        RLC_BearerConfig_r15_setupLogicalChannelIdentityConfig_r15_logicalChannelIdentityExt_r15,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RLC_BearerConfig_r15_setup {
    #[asn(optional_idx = 0)]
    pub rlc_config_r15: Option<RLC_Config_r15>,
    pub logical_channel_identity_config_r15:
        RLC_BearerConfig_r15_setupLogicalChannelIdentityConfig_r15,
    #[asn(optional_idx = 1)]
    pub logical_channel_config_r15: Option<LogicalChannelConfig>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RLC_Config_am {
    pub ul_am_rlc: UL_AM_RLC,
    pub dl_am_rlc: DL_AM_RLC,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RLC_Config_um_Bi_Directional {
    pub ul_um_rlc: UL_UM_RLC,
    pub dl_um_rlc: DL_UM_RLC,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RLC_Config_um_Uni_Directional_UL {
    pub ul_um_rlc: UL_UM_RLC,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RLC_Config_um_Uni_Directional_DL {
    pub dl_um_rlc: DL_UM_RLC,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RLC_Config_r15Mode_r15_am_r15 {
    pub ul_am_rlc_r15: UL_AM_RLC_r15,
    pub dl_am_rlc_r15: DL_AM_RLC_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RLC_Config_r15Mode_r15_um_Bi_Directional_r15 {
    pub ul_um_rlc_r15: UL_UM_RLC,
    pub dl_um_rlc_r15: DL_UM_RLC_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RLC_Config_r15Mode_r15_um_Uni_Directional_UL_r15 {
    pub ul_um_rlc_r15: UL_UM_RLC,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RLC_Config_r15Mode_r15_um_Uni_Directional_DL_r15 {
    pub dl_um_rlc_r15: DL_UM_RLC_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum RLC_Config_r15Mode_r15 {
    #[asn(key = 0, extended = false)]
    Am_r15(RLC_Config_r15Mode_r15_am_r15),
    #[asn(key = 1, extended = false)]
    Um_Bi_Directional_r15(RLC_Config_r15Mode_r15_um_Bi_Directional_r15),
    #[asn(key = 2, extended = false)]
    Um_Uni_Directional_UL_r15(RLC_Config_r15Mode_r15_um_Uni_Directional_UL_r15),
    #[asn(key = 3, extended = false)]
    Um_Uni_Directional_DL_r15(RLC_Config_r15Mode_r15_um_Uni_Directional_DL_r15),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RLC_Config_r15ReestablishRLC_r15(pub u8);
impl RLC_Config_r15ReestablishRLC_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RLC_Config_r15Rlc_OutOfOrderDelivery_r15(pub u8);
impl RLC_Config_r15Rlc_OutOfOrderDelivery_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct RLC_Config_v1250Ul_extended_RLC_LI_Field_r12(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct RLC_Config_v1250Dl_extended_RLC_LI_Field_r12(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct RLC_Config_v1310Ul_extended_RLC_AM_SN_r13(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct RLC_Config_v1310Dl_extended_RLC_AM_SN_r13(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RLC_Config_v1430_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RLC_Config_v1430_setup {
    pub poll_byte_r14: PollByte_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RLC_Config_v1510ReestablishRLC_r15(pub u8);
impl RLC_Config_v1510ReestablishRLC_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RLC_Config_v1530_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RLC_Config_v1530_setupRlc_OutOfOrderDelivery_r15(pub u8);
impl RLC_Config_v1530_setupRlc_OutOfOrderDelivery_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RLC_Config_v1530_setup {
    pub rlc_out_of_order_delivery_r15: RLC_Config_v1530_setupRlc_OutOfOrderDelivery_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RLC_Config_v1700T_ReorderingExt_r17_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RLC_Config_v1700T_ReorderingExt_r17 {
    #[asn(key = 0, extended = false)]
    Release(RLC_Config_v1700T_ReorderingExt_r17_release),
    #[asn(key = 1, extended = false)]
    Setup(T_ReorderingExt_r17),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RLC_Parameters_r12Extended_RLC_LI_Field_r12(pub u8);
impl RLC_Parameters_r12Extended_RLC_LI_Field_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RLC_Parameters_v1310ExtendedRLC_SN_SO_Field_r13(pub u8);
impl RLC_Parameters_v1310ExtendedRLC_SN_SO_Field_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RLC_Parameters_v1430ExtendedPollByte_r14(pub u8);
impl RLC_Parameters_v1430ExtendedPollByte_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RLC_Parameters_v1530FlexibleUM_AM_Combinations_r15(pub u8);
impl RLC_Parameters_v1530FlexibleUM_AM_Combinations_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RLC_Parameters_v1530Rlc_AM_Ooo_Delivery_r15(pub u8);
impl RLC_Parameters_v1530Rlc_AM_Ooo_Delivery_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RLC_Parameters_v1530Rlc_UM_Ooo_Delivery_r15(pub u8);
impl RLC_Parameters_v1530Rlc_UM_Ooo_Delivery_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RLF_Report_r9MeasResultLastServCell_r9 {
    pub rsrp_result_r9: RSRP_Range,
    #[asn(optional_idx = 0)]
    pub rsrq_result_r9: Option<RSRQ_Range>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct RLF_Report_r9MeasResultNeighCells_r9 {
    #[asn(optional_idx = 0)]
    pub meas_result_list_eutra_r9: Option<MeasResultList2EUTRA_r9>,
    #[asn(optional_idx = 1)]
    pub meas_result_list_utra_r9: Option<MeasResultList2UTRA_r9>,
    #[asn(optional_idx = 2)]
    pub meas_result_list_geran_r9: Option<MeasResultListGERAN>,
    #[asn(optional_idx = 3)]
    pub meas_results_cdma2000_r9: Option<MeasResultList2CDMA2000_r9>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RLF_TimersAndConstants_r13_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct RLF_TimersAndConstants_r13_setupT301_v1310(pub u8);
impl RLF_TimersAndConstants_r13_setupT301_v1310 {
    pub const MS2500: u8 = 0u8;
    pub const MS3000: u8 = 1u8;
    pub const MS3500: u8 = 2u8;
    pub const MS4000: u8 = 3u8;
    pub const MS5000: u8 = 4u8;
    pub const MS6000: u8 = 5u8;
    pub const MS8000: u8 = 6u8;
    pub const MS10000: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RLF_TimersAndConstants_r13_setup {
    pub t301_v1310: RLF_TimersAndConstants_r13_setupT301_v1310,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RLF_TimersAndConstants_r9_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct RLF_TimersAndConstants_r9_setupT301_r9(pub u8);
impl RLF_TimersAndConstants_r9_setupT301_r9 {
    pub const MS100: u8 = 0u8;
    pub const MS200: u8 = 1u8;
    pub const MS300: u8 = 2u8;
    pub const MS400: u8 = 3u8;
    pub const MS600: u8 = 4u8;
    pub const MS1000: u8 = 5u8;
    pub const MS1500: u8 = 6u8;
    pub const MS2000: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "6")]
pub struct RLF_TimersAndConstants_r9_setupT310_r9(pub u8);
impl RLF_TimersAndConstants_r9_setupT310_r9 {
    pub const MS0: u8 = 0u8;
    pub const MS50: u8 = 1u8;
    pub const MS100: u8 = 2u8;
    pub const MS200: u8 = 3u8;
    pub const MS500: u8 = 4u8;
    pub const MS1000: u8 = 5u8;
    pub const MS2000: u8 = 6u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct RLF_TimersAndConstants_r9_setupN310_r9(pub u8);
impl RLF_TimersAndConstants_r9_setupN310_r9 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N3: u8 = 2u8;
    pub const N4: u8 = 3u8;
    pub const N6: u8 = 4u8;
    pub const N8: u8 = 5u8;
    pub const N10: u8 = 6u8;
    pub const N20: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "6")]
pub struct RLF_TimersAndConstants_r9_setupT311_r9(pub u8);
impl RLF_TimersAndConstants_r9_setupT311_r9 {
    pub const MS1000: u8 = 0u8;
    pub const MS3000: u8 = 1u8;
    pub const MS5000: u8 = 2u8;
    pub const MS10000: u8 = 3u8;
    pub const MS15000: u8 = 4u8;
    pub const MS20000: u8 = 5u8;
    pub const MS30000: u8 = 6u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct RLF_TimersAndConstants_r9_setupN311_r9(pub u8);
impl RLF_TimersAndConstants_r9_setupN311_r9 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N3: u8 = 2u8;
    pub const N4: u8 = 3u8;
    pub const N5: u8 = 4u8;
    pub const N6: u8 = 5u8;
    pub const N8: u8 = 6u8;
    pub const N10: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RLF_TimersAndConstants_r9_setup {
    pub t301_r9: RLF_TimersAndConstants_r9_setupT301_r9,
    pub t310_r9: RLF_TimersAndConstants_r9_setupT310_r9,
    pub n310_r9: RLF_TimersAndConstants_r9_setupN310_r9,
    pub t311_r9: RLF_TimersAndConstants_r9_setupT311_r9,
    pub n311_r9: RLF_TimersAndConstants_r9_setupN311_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RLF_TimersAndConstantsMCG_Failure_r16_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "9")]
pub struct RLF_TimersAndConstantsMCG_Failure_r16_setupT316_r16(pub u8);
impl RLF_TimersAndConstantsMCG_Failure_r16_setupT316_r16 {
    pub const MS50: u8 = 0u8;
    pub const MS100: u8 = 1u8;
    pub const MS200: u8 = 2u8;
    pub const MS300: u8 = 3u8;
    pub const MS400: u8 = 4u8;
    pub const MS500: u8 = 5u8;
    pub const MS600: u8 = 6u8;
    pub const MS1000: u8 = 7u8;
    pub const MS1500: u8 = 8u8;
    pub const MS2000: u8 = 9u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RLF_TimersAndConstantsMCG_Failure_r16_setup {
    pub t316_r16: RLF_TimersAndConstantsMCG_Failure_r16_setupT316_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RLF_TimersAndConstantsSCG_r12_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "6")]
pub struct RLF_TimersAndConstantsSCG_r12_setupT313_r12(pub u8);
impl RLF_TimersAndConstantsSCG_r12_setupT313_r12 {
    pub const MS0: u8 = 0u8;
    pub const MS50: u8 = 1u8;
    pub const MS100: u8 = 2u8;
    pub const MS200: u8 = 3u8;
    pub const MS500: u8 = 4u8;
    pub const MS1000: u8 = 5u8;
    pub const MS2000: u8 = 6u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct RLF_TimersAndConstantsSCG_r12_setupN313_r12(pub u8);
impl RLF_TimersAndConstantsSCG_r12_setupN313_r12 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N3: u8 = 2u8;
    pub const N4: u8 = 3u8;
    pub const N6: u8 = 4u8;
    pub const N8: u8 = 5u8;
    pub const N10: u8 = 6u8;
    pub const N20: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct RLF_TimersAndConstantsSCG_r12_setupN314_r12(pub u8);
impl RLF_TimersAndConstantsSCG_r12_setupN314_r12 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N3: u8 = 2u8;
    pub const N4: u8 = 3u8;
    pub const N5: u8 = 4u8;
    pub const N6: u8 = 5u8;
    pub const N8: u8 = 6u8;
    pub const N10: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RLF_TimersAndConstantsSCG_r12_setup {
    pub t313_r12: RLF_TimersAndConstantsSCG_r12_setupT313_r12,
    pub n313_r12: RLF_TimersAndConstantsSCG_r12_setupN313_r12,
    pub n314_r12: RLF_TimersAndConstantsSCG_r12_setupN314_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RMTC_Config_r13_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "4")]
pub struct RMTC_Config_r13_setupRmtc_Period_r13(pub u8);
impl RMTC_Config_r13_setupRmtc_Period_r13 {
    pub const MS40: u8 = 0u8;
    pub const MS80: u8 = 1u8;
    pub const MS160: u8 = 2u8;
    pub const MS320: u8 = 3u8;
    pub const MS640: u8 = 4u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "639")]
pub struct RMTC_Config_r13_setupRmtc_SubframeOffset_r13(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "4")]
pub struct RMTC_Config_r13_setupMeasDuration_r13(pub u8);
impl RMTC_Config_r13_setupMeasDuration_r13 {
    pub const SYM1: u8 = 0u8;
    pub const SYM14: u8 = 1u8;
    pub const SYM28: u8 = 2u8;
    pub const SYM42: u8 = 3u8;
    pub const SYM70: u8 = 4u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RMTC_Config_r13_setup {
    pub rmtc_period_r13: RMTC_Config_r13_setupRmtc_Period_r13,
    #[asn(optional_idx = 0)]
    pub rmtc_subframe_offset_r13: Option<RMTC_Config_r13_setupRmtc_SubframeOffset_r13>,
    pub meas_duration_r13: RMTC_Config_r13_setupMeasDuration_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "4")]
pub struct RMTC_ConfigNR_r16Rmtc_PeriodicityNR_r16(pub u8);
impl RMTC_ConfigNR_r16Rmtc_PeriodicityNR_r16 {
    pub const MS40: u8 = 0u8;
    pub const MS80: u8 = 1u8;
    pub const MS160: u8 = 2u8;
    pub const MS320: u8 = 3u8;
    pub const MS640: u8 = 4u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "639")]
pub struct RMTC_ConfigNR_r16Rmtc_SubframeOffsetNR_r16(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "4")]
pub struct RMTC_ConfigNR_r16MeasDurationNR_r16(pub u8);
impl RMTC_ConfigNR_r16MeasDurationNR_r16 {
    pub const SYM1: u8 = 0u8;
    pub const SYM14OR12: u8 = 1u8;
    pub const SYM28OR24: u8 = 2u8;
    pub const SYM42OR36: u8 = 3u8;
    pub const SYM70OR60: u8 = 4u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct RMTC_ConfigNR_r16RefSCS_CP_NR_r16(pub u8);
impl RMTC_ConfigNR_r16RefSCS_CP_NR_r16 {
    pub const K_HZ15: u8 = 0u8;
    pub const K_HZ30: u8 = 1u8;
    pub const K_HZ60_NCP: u8 = 2u8;
    pub const K_HZ60_ECP: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct RN_SubframeConfig_r10SubframeConfigPattern_r10_subframeConfigPatternFDD_r10(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct RN_SubframeConfig_r10SubframeConfigPattern_r10_subframeConfigPatternTDD_r10(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RN_SubframeConfig_r10SubframeConfigPattern_r10 {
    #[asn(key = 0, extended = false)]
    SubframeConfigPatternFDD_r10(
        RN_SubframeConfig_r10SubframeConfigPattern_r10_subframeConfigPatternFDD_r10,
    ),
    #[asn(key = 1, extended = false)]
    SubframeConfigPatternTDD_r10(
        RN_SubframeConfig_r10SubframeConfigPattern_r10_subframeConfigPatternTDD_r10,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct RN_SubframeConfig_r10Rpdcch_Config_r10ResourceAllocationType_r10(pub u8);
impl RN_SubframeConfig_r10Rpdcch_Config_r10ResourceAllocationType_r10 {
    pub const TYPE0: u8 = 0u8;
    pub const TYPE1: u8 = 1u8;
    pub const TYPE2_LOCALIZED: u8 = 2u8;
    pub const TYPE2_DISTRIBUTED: u8 = 3u8;
    pub const SPARE4: u8 = 4u8;
    pub const SPARE3: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "6", sz_ub = "6")]
pub struct RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type01_r10_nrb6_r10(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type01_r10_nrb15_r10(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "13", sz_ub = "13")]
pub struct RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type01_r10_nrb25_r10(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "17", sz_ub = "17")]
pub struct RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type01_r10_nrb50_r10(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "19", sz_ub = "19")]
pub struct RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type01_r10_nrb75_r10(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "25", sz_ub = "25")]
pub struct RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type01_r10_nrb100_r10(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "5", extensible = false)]
pub enum RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type01_r10 {
    #[asn(key = 0, extended = false)]
    Nrb6_r10(RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type01_r10_nrb6_r10),
    #[asn(key = 1, extended = false)]
    Nrb15_r10(
        RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type01_r10_nrb15_r10,
    ),
    #[asn(key = 2, extended = false)]
    Nrb25_r10(
        RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type01_r10_nrb25_r10,
    ),
    #[asn(key = 3, extended = false)]
    Nrb50_r10(
        RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type01_r10_nrb50_r10,
    ),
    #[asn(key = 4, extended = false)]
    Nrb75_r10(
        RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type01_r10_nrb75_r10,
    ),
    #[asn(key = 5, extended = false)]
    Nrb100_r10(
        RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type01_r10_nrb100_r10,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "5", sz_ub = "5")]
pub struct RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type2_r10_nrb6_r10(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "7", sz_ub = "7")]
pub struct RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type2_r10_nrb15_r10(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "9", sz_ub = "9")]
pub struct RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type2_r10_nrb25_r10(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "11", sz_ub = "11")]
pub struct RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type2_r10_nrb50_r10(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "12", sz_ub = "12")]
pub struct RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type2_r10_nrb75_r10(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "13", sz_ub = "13")]
pub struct RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type2_r10_nrb100_r10(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "5", extensible = false)]
pub enum RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type2_r10 {
    #[asn(key = 0, extended = false)]
    Nrb6_r10(RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type2_r10_nrb6_r10),
    #[asn(key = 1, extended = false)]
    Nrb15_r10(
        RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type2_r10_nrb15_r10,
    ),
    #[asn(key = 2, extended = false)]
    Nrb25_r10(
        RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type2_r10_nrb25_r10,
    ),
    #[asn(key = 3, extended = false)]
    Nrb50_r10(
        RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type2_r10_nrb50_r10,
    ),
    #[asn(key = 4, extended = false)]
    Nrb75_r10(
        RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type2_r10_nrb75_r10,
    ),
    #[asn(key = 5, extended = false)]
    Nrb100_r10(
        RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type2_r10_nrb100_r10,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10 {
    #[asn(key = 0, extended = false)]
    Type01_r10(RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type01_r10),
    #[asn(key = 1, extended = false)]
    Type2_r10(RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10_type2_r10),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RN_SubframeConfig_r10Rpdcch_Config_r10DemodulationRS_r10_interleaving_r10(pub u8);
impl RN_SubframeConfig_r10Rpdcch_Config_r10DemodulationRS_r10_interleaving_r10 {
    pub const CRS: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct RN_SubframeConfig_r10Rpdcch_Config_r10DemodulationRS_r10_noInterleaving_r10(pub u8);
impl RN_SubframeConfig_r10Rpdcch_Config_r10DemodulationRS_r10_noInterleaving_r10 {
    pub const CRS: u8 = 0u8;
    pub const DMRS: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RN_SubframeConfig_r10Rpdcch_Config_r10DemodulationRS_r10 {
    #[asn(key = 0, extended = false)]
    Interleaving_r10(RN_SubframeConfig_r10Rpdcch_Config_r10DemodulationRS_r10_interleaving_r10),
    #[asn(key = 1, extended = false)]
    NoInterleaving_r10(RN_SubframeConfig_r10Rpdcch_Config_r10DemodulationRS_r10_noInterleaving_r10),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "3")]
pub struct RN_SubframeConfig_r10Rpdcch_Config_r10Pdsch_Start_r10(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct RN_SubframeConfig_r10Rpdcch_Config_r10Pucch_Config_r10_tdd_channelSelectionMultiplexingBundlingN1PUCCH_AN_List_r10_Entry(
    pub u16,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct RN_SubframeConfig_r10Rpdcch_Config_r10Pucch_Config_r10_tdd_channelSelectionMultiplexingBundlingN1PUCCH_AN_List_r10 (pub Vec < RN_SubframeConfig_r10Rpdcch_Config_r10Pucch_Config_r10_tdd_channelSelectionMultiplexingBundlingN1PUCCH_AN_List_r10_Entry >) ;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RN_SubframeConfig_r10Rpdcch_Config_r10Pucch_Config_r10_tdd_channelSelectionMultiplexingBundling { pub n1pucch_an_list_r10 : RN_SubframeConfig_r10Rpdcch_Config_r10Pucch_Config_r10_tdd_channelSelectionMultiplexingBundlingN1PUCCH_AN_List_r10 , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct RN_SubframeConfig_r10Rpdcch_Config_r10Pucch_Config_r10_tdd_fallbackForFormat3N1PUCCH_AN_P0_r10(
    pub u16,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct RN_SubframeConfig_r10Rpdcch_Config_r10Pucch_Config_r10_tdd_fallbackForFormat3N1PUCCH_AN_P1_r10(
    pub u16,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RN_SubframeConfig_r10Rpdcch_Config_r10Pucch_Config_r10_tdd_fallbackForFormat3 { pub n1pucch_an_p0_r10 : RN_SubframeConfig_r10Rpdcch_Config_r10Pucch_Config_r10_tdd_fallbackForFormat3N1PUCCH_AN_P0_r10 , # [asn (optional_idx = 0 ,)] pub n1pucch_an_p1_r10 : Option < RN_SubframeConfig_r10Rpdcch_Config_r10Pucch_Config_r10_tdd_fallbackForFormat3N1PUCCH_AN_P1_r10 > , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RN_SubframeConfig_r10Rpdcch_Config_r10Pucch_Config_r10_tdd {
    # [asn (key = 0 , extended = false)] ChannelSelectionMultiplexingBundling (RN_SubframeConfig_r10Rpdcch_Config_r10Pucch_Config_r10_tdd_channelSelectionMultiplexingBundling) , # [asn (key = 1 , extended = false)] FallbackForFormat3 (RN_SubframeConfig_r10Rpdcch_Config_r10Pucch_Config_r10_tdd_fallbackForFormat3) , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct RN_SubframeConfig_r10Rpdcch_Config_r10Pucch_Config_r10_fddN1PUCCH_AN_P0_r10(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct RN_SubframeConfig_r10Rpdcch_Config_r10Pucch_Config_r10_fddN1PUCCH_AN_P1_r10(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RN_SubframeConfig_r10Rpdcch_Config_r10Pucch_Config_r10_fdd {
    pub n1pucch_an_p0_r10:
        RN_SubframeConfig_r10Rpdcch_Config_r10Pucch_Config_r10_fddN1PUCCH_AN_P0_r10,
    #[asn(optional_idx = 0)]
    pub n1pucch_an_p1_r10:
        Option<RN_SubframeConfig_r10Rpdcch_Config_r10Pucch_Config_r10_fddN1PUCCH_AN_P1_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RN_SubframeConfig_r10Rpdcch_Config_r10Pucch_Config_r10 {
    #[asn(key = 0, extended = false)]
    Tdd(RN_SubframeConfig_r10Rpdcch_Config_r10Pucch_Config_r10_tdd),
    #[asn(key = 1, extended = false)]
    Fdd(RN_SubframeConfig_r10Rpdcch_Config_r10Pucch_Config_r10_fdd),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RN_SubframeConfig_r10Rpdcch_Config_r10 {
    pub resource_allocation_type_r10:
        RN_SubframeConfig_r10Rpdcch_Config_r10ResourceAllocationType_r10,
    pub resource_block_assignment_r10:
        RN_SubframeConfig_r10Rpdcch_Config_r10ResourceBlockAssignment_r10,
    pub demodulation_rs_r10: RN_SubframeConfig_r10Rpdcch_Config_r10DemodulationRS_r10,
    pub pdsch_start_r10: RN_SubframeConfig_r10Rpdcch_Config_r10Pdsch_Start_r10,
    pub pucch_config_r10: RN_SubframeConfig_r10Rpdcch_Config_r10Pucch_Config_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RN_SystemInfo_r10SystemInformationBlockType1_r10(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RNReconfiguration_r10CriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RNReconfiguration_r10CriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RNReconfiguration_r10CriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum RNReconfiguration_r10CriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    RnReconfiguration_r10(RNReconfiguration_r10_IEs),
    #[asn(key = 1, extended = false)]
    Spare3(RNReconfiguration_r10CriticalExtensions_c1_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(RNReconfiguration_r10CriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(RNReconfiguration_r10CriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RNReconfiguration_r10CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RNReconfiguration_r10CriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(RNReconfiguration_r10CriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(RNReconfiguration_r10CriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RNReconfiguration_r10_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RNReconfiguration_r10_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RNReconfigurationComplete_r10CriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RNReconfigurationComplete_r10CriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RNReconfigurationComplete_r10CriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum RNReconfigurationComplete_r10CriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    RnReconfigurationComplete_r10(RNReconfigurationComplete_r10_IEs),
    #[asn(key = 1, extended = false)]
    Spare3(RNReconfigurationComplete_r10CriticalExtensions_c1_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(RNReconfigurationComplete_r10CriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(RNReconfigurationComplete_r10CriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RNReconfigurationComplete_r10CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RNReconfigurationComplete_r10CriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(RNReconfigurationComplete_r10CriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        RNReconfigurationComplete_r10CriticalExtensions_criticalExtensionsFuture,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RNReconfigurationComplete_r10_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RNReconfigurationComplete_r10_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct ROHC_ProfileSupportList_r15Profile0x0001_r15(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct ROHC_ProfileSupportList_r15Profile0x0002_r15(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct ROHC_ProfileSupportList_r15Profile0x0003_r15(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct ROHC_ProfileSupportList_r15Profile0x0004_r15(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct ROHC_ProfileSupportList_r15Profile0x0006_r15(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct ROHC_ProfileSupportList_r15Profile0x0101_r15(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct ROHC_ProfileSupportList_r15Profile0x0102_r15(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct ROHC_ProfileSupportList_r15Profile0x0103_r15(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct ROHC_ProfileSupportList_r15Profile0x0104_r15(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct RRC_InactiveConfig_r15Ran_PagingCycle_r15(pub u8);
impl RRC_InactiveConfig_r15Ran_PagingCycle_r15 {
    pub const RF32: u8 = 0u8;
    pub const RF64: u8 = 1u8;
    pub const RF128: u8 = 2u8;
    pub const RF256: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct RRC_InactiveConfig_r15Periodic_RNAU_timer_r15(pub u8);
impl RRC_InactiveConfig_r15Periodic_RNAU_timer_r15 {
    pub const MIN5: u8 = 0u8;
    pub const MIN10: u8 = 1u8;
    pub const MIN20: u8 = 2u8;
    pub const MIN30: u8 = 3u8;
    pub const MIN60: u8 = 4u8;
    pub const MIN120: u8 = 5u8;
    pub const MIN360: u8 = 6u8;
    pub const MIN720: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRC_InactiveConfig_r15Dummy {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct RRC_InactiveConfig_v1610Ran_PagingCycle_v1610(pub u8);
impl RRC_InactiveConfig_v1610Ran_PagingCycle_v1610 {
    pub const RF512: u8 = 0u8;
    pub const RF1024: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionReconfigurationCriticalExtensions_c1_spare7;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionReconfigurationCriticalExtensions_c1_spare6;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionReconfigurationCriticalExtensions_c1_spare5;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionReconfigurationCriticalExtensions_c1_spare4;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionReconfigurationCriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionReconfigurationCriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionReconfigurationCriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "7", extensible = false)]
pub enum RRCConnectionReconfigurationCriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    RrcConnectionReconfiguration_r8(RRCConnectionReconfiguration_r8_IEs),
    #[asn(key = 1, extended = false)]
    Spare7(RRCConnectionReconfigurationCriticalExtensions_c1_spare7),
    #[asn(key = 2, extended = false)]
    Spare6(RRCConnectionReconfigurationCriticalExtensions_c1_spare6),
    #[asn(key = 3, extended = false)]
    Spare5(RRCConnectionReconfigurationCriticalExtensions_c1_spare5),
    #[asn(key = 4, extended = false)]
    Spare4(RRCConnectionReconfigurationCriticalExtensions_c1_spare4),
    #[asn(key = 5, extended = false)]
    Spare3(RRCConnectionReconfigurationCriticalExtensions_c1_spare3),
    #[asn(key = 6, extended = false)]
    Spare2(RRCConnectionReconfigurationCriticalExtensions_c1_spare2),
    #[asn(key = 7, extended = false)]
    Spare1(RRCConnectionReconfigurationCriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionReconfigurationCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RRCConnectionReconfigurationCriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(RRCConnectionReconfigurationCriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        RRCConnectionReconfigurationCriticalExtensions_criticalExtensionsFuture,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "11")]
pub struct RRCConnectionReconfiguration_r8_IEsDedicatedInfoNASList(pub Vec<DedicatedInfoNAS>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCConnectionReconfiguration_v10l0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCConnectionReconfiguration_v1130_IEsSystemInformationBlockType1Dedicated_r11(
    pub Vec<u8>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionReconfiguration_v1250_IEsWlan_OffloadInfo_r12_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct RRCConnectionReconfiguration_v1250_IEsWlan_OffloadInfo_r12_setupT350_r12(pub u8);
impl RRCConnectionReconfiguration_v1250_IEsWlan_OffloadInfo_r12_setupT350_r12 {
    pub const MIN5: u8 = 0u8;
    pub const MIN10: u8 = 1u8;
    pub const MIN20: u8 = 2u8;
    pub const MIN30: u8 = 3u8;
    pub const MIN60: u8 = 4u8;
    pub const MIN120: u8 = 5u8;
    pub const MIN180: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct RRCConnectionReconfiguration_v1250_IEsWlan_OffloadInfo_r12_setup {
    pub wlan_offload_config_dedicated_r12: WLAN_OffloadConfig_r12,
    #[asn(optional_idx = 0)]
    pub t350_r12: Option<RRCConnectionReconfiguration_v1250_IEsWlan_OffloadInfo_r12_setupT350_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RRCConnectionReconfiguration_v1250_IEsWlan_OffloadInfo_r12 {
    #[asn(key = 0, extended = false)]
    Release(RRCConnectionReconfiguration_v1250_IEsWlan_OffloadInfo_r12_release),
    #[asn(key = 1, extended = false)]
    Setup(RRCConnectionReconfiguration_v1250_IEsWlan_OffloadInfo_r12_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCConnectionReconfiguration_v12f0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionReconfiguration_v13c0_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionReconfiguration_v1430_IEsPerCC_GapIndicationRequest_r14(pub u8);
impl RRCConnectionReconfiguration_v1430_IEsPerCC_GapIndicationRequest_r14 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCConnectionReconfiguration_v1430_IEsSystemInformationBlockType2Dedicated_r14(
    pub Vec<u8>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionReconfiguration_v1510_IEsNr_Config_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct RRCConnectionReconfiguration_v1510_IEsNr_Config_r15_setupEndc_ReleaseAndAdd_r15(
    pub bool,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCConnectionReconfiguration_v1510_IEsNr_Config_r15_setupNr_SecondaryCellGroupConfig_r15(
    pub Vec<u8>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RRCConnectionReconfiguration_v1510_IEsNr_Config_r15_setup {
    pub endc_release_and_add_r15:
        RRCConnectionReconfiguration_v1510_IEsNr_Config_r15_setupEndc_ReleaseAndAdd_r15,
    #[asn(optional_idx = 0)]
    pub nr_secondary_cell_group_config_r15: Option<
        RRCConnectionReconfiguration_v1510_IEsNr_Config_r15_setupNr_SecondaryCellGroupConfig_r15,
    >,
    #[asn(optional_idx = 1)]
    pub p_max_eutra_r15: Option<P_Max>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RRCConnectionReconfiguration_v1510_IEsNr_Config_r15 {
    #[asn(key = 0, extended = false)]
    Release(RRCConnectionReconfiguration_v1510_IEsNr_Config_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(RRCConnectionReconfiguration_v1510_IEsNr_Config_r15_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct RRCConnectionReconfiguration_v1510_IEsSk_Counter_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCConnectionReconfiguration_v1510_IEsNr_RadioBearerConfig1_r15(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCConnectionReconfiguration_v1510_IEsNr_RadioBearerConfig2_r15(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "15")]
pub struct RRCConnectionReconfiguration_v1530_IEsDedicatedInfoNASList_r15(
    pub Vec<DedicatedInfoNAS>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionReconfiguration_v1610_IEsDaps_SourceRelease_r16(pub u8);
impl RRCConnectionReconfiguration_v1610_IEsDaps_SourceRelease_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCConnectionReconfiguration_v1610_IEsSl_ConfigDedicatedForNR_r16(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8")]
pub struct RRCConnectionReconfiguration_v1610_IEsSl_SSB_PriorityEUTRA_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCConnectionReconfiguration_v1700_IEsSystemInformationBlockType31Dedicated_r17(
    pub Vec<u8>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionReconfiguration_v1700_IEsScg_State_r17(pub u8);
impl RRCConnectionReconfiguration_v1700_IEsScg_State_r17 {
    pub const DEACTIVATED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionReconfiguration_v1700_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCConnectionReconfiguration_v890_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCConnectionReconfiguration_v8m0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionReconfiguration_v920_IEsFullConfig_r9(pub u8);
impl RRCConnectionReconfiguration_v920_IEsFullConfig_r9 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionReconfigurationCompleteCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RRCConnectionReconfigurationCompleteCriticalExtensions {
    #[asn(key = 0, extended = false)]
    RrcConnectionReconfigurationComplete_r8(RRCConnectionReconfigurationComplete_r8_IEs),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        RRCConnectionReconfigurationCompleteCriticalExtensions_criticalExtensionsFuture,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionReconfigurationComplete_v1020_IEsRlf_InfoAvailable_r10(pub u8);
impl RRCConnectionReconfigurationComplete_v1020_IEsRlf_InfoAvailable_r10 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionReconfigurationComplete_v1020_IEsLogMeasAvailable_r10(pub u8);
impl RRCConnectionReconfigurationComplete_v1020_IEsLogMeasAvailable_r10 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionReconfigurationComplete_v1130_IEsConnEstFailInfoAvailable_r11(pub u8);
impl RRCConnectionReconfigurationComplete_v1130_IEsConnEstFailInfoAvailable_r11 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionReconfigurationComplete_v1250_IEsLogMeasAvailableMBSFN_r12(pub u8);
impl RRCConnectionReconfigurationComplete_v1250_IEsLogMeasAvailableMBSFN_r12 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "12")]
pub struct RRCConnectionReconfigurationComplete_v1430_IEsNumFreqEffective_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "12")]
pub struct RRCConnectionReconfigurationComplete_v1430_IEsNumFreqEffectiveReduced_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCConnectionReconfigurationComplete_v1510_IEsScg_ConfigResponseNR_r15(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionReconfigurationComplete_v1530_IEsLogMeasAvailableBT_r15(pub u8);
impl RRCConnectionReconfigurationComplete_v1530_IEsLogMeasAvailableBT_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionReconfigurationComplete_v1530_IEsLogMeasAvailableWLAN_r15(pub u8);
impl RRCConnectionReconfigurationComplete_v1530_IEsLogMeasAvailableWLAN_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionReconfigurationComplete_v1530_IEsFlightPathInfoAvailable_r15(pub u8);
impl RRCConnectionReconfigurationComplete_v1530_IEsFlightPathInfoAvailable_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionReconfigurationComplete_v1710_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCConnectionReconfigurationComplete_v8a0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionReestablishmentCriticalExtensions_c1_spare7;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionReestablishmentCriticalExtensions_c1_spare6;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionReestablishmentCriticalExtensions_c1_spare5;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionReestablishmentCriticalExtensions_c1_spare4;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionReestablishmentCriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionReestablishmentCriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionReestablishmentCriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "7", extensible = false)]
pub enum RRCConnectionReestablishmentCriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    RrcConnectionReestablishment_r8(RRCConnectionReestablishment_r8_IEs),
    #[asn(key = 1, extended = false)]
    Spare7(RRCConnectionReestablishmentCriticalExtensions_c1_spare7),
    #[asn(key = 2, extended = false)]
    Spare6(RRCConnectionReestablishmentCriticalExtensions_c1_spare6),
    #[asn(key = 3, extended = false)]
    Spare5(RRCConnectionReestablishmentCriticalExtensions_c1_spare5),
    #[asn(key = 4, extended = false)]
    Spare4(RRCConnectionReestablishmentCriticalExtensions_c1_spare4),
    #[asn(key = 5, extended = false)]
    Spare3(RRCConnectionReestablishmentCriticalExtensions_c1_spare3),
    #[asn(key = 6, extended = false)]
    Spare2(RRCConnectionReestablishmentCriticalExtensions_c1_spare2),
    #[asn(key = 7, extended = false)]
    Spare1(RRCConnectionReestablishmentCriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionReestablishmentCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RRCConnectionReestablishmentCriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(RRCConnectionReestablishmentCriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        RRCConnectionReestablishmentCriticalExtensions_criticalExtensionsFuture,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCConnectionReestablishment_v8a0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionReestablishment_v8a0_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionReestablishmentCompleteCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RRCConnectionReestablishmentCompleteCriticalExtensions {
    #[asn(key = 0, extended = false)]
    RrcConnectionReestablishmentComplete_r8(RRCConnectionReestablishmentComplete_r8_IEs),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        RRCConnectionReestablishmentCompleteCriticalExtensions_criticalExtensionsFuture,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionReestablishmentComplete_v1020_IEsLogMeasAvailable_r10(pub u8);
impl RRCConnectionReestablishmentComplete_v1020_IEsLogMeasAvailable_r10 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionReestablishmentComplete_v1130_IEsConnEstFailInfoAvailable_r11(pub u8);
impl RRCConnectionReestablishmentComplete_v1130_IEsConnEstFailInfoAvailable_r11 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionReestablishmentComplete_v1250_IEsLogMeasAvailableMBSFN_r12(pub u8);
impl RRCConnectionReestablishmentComplete_v1250_IEsLogMeasAvailableMBSFN_r12 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionReestablishmentComplete_v1530_IEsLogMeasAvailableBT_r15(pub u8);
impl RRCConnectionReestablishmentComplete_v1530_IEsLogMeasAvailableBT_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionReestablishmentComplete_v1530_IEsLogMeasAvailableWLAN_r15(pub u8);
impl RRCConnectionReestablishmentComplete_v1530_IEsLogMeasAvailableWLAN_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionReestablishmentComplete_v1530_IEsFlightPathInfoAvailable_r15(pub u8);
impl RRCConnectionReestablishmentComplete_v1530_IEsFlightPathInfoAvailable_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionReestablishmentComplete_v1710_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCConnectionReestablishmentComplete_v8a0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionReestablishmentComplete_v920_IEsRlf_InfoAvailable_r9(pub u8);
impl RRCConnectionReestablishmentComplete_v920_IEsRlf_InfoAvailable_r9 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionReestablishmentRejectCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RRCConnectionReestablishmentRejectCriticalExtensions {
    #[asn(key = 0, extended = false)]
    RrcConnectionReestablishmentReject_r8(RRCConnectionReestablishmentReject_r8_IEs),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        RRCConnectionReestablishmentRejectCriticalExtensions_criticalExtensionsFuture,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCConnectionReestablishmentReject_v8a0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionReestablishmentReject_v8a0_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionReestablishmentRequestCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RRCConnectionReestablishmentRequestCriticalExtensions {
    #[asn(key = 0, extended = false)]
    RrcConnectionReestablishmentRequest_r8(RRCConnectionReestablishmentRequest_r8_IEs),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        RRCConnectionReestablishmentRequestCriticalExtensions_criticalExtensionsFuture,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct RRCConnectionReestablishmentRequest_r8_IEsSpare(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionRejectCriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionRejectCriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionRejectCriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum RRCConnectionRejectCriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    RrcConnectionReject_r8(RRCConnectionReject_r8_IEs),
    #[asn(key = 1, extended = false)]
    Spare3(RRCConnectionRejectCriticalExtensions_c1_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(RRCConnectionRejectCriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(RRCConnectionRejectCriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionRejectCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RRCConnectionRejectCriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(RRCConnectionRejectCriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(RRCConnectionRejectCriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct RRCConnectionReject_r8_IEsWaitTime(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "1800")]
pub struct RRCConnectionReject_v1020_IEsExtendedWaitTime_r10(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct RRCConnectionReject_v1130_IEsDeprioritisationReq_r11DeprioritisationType_r11(pub u8);
impl RRCConnectionReject_v1130_IEsDeprioritisationReq_r11DeprioritisationType_r11 {
    pub const FREQUENCY: u8 = 0u8;
    pub const E_UTRA: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct RRCConnectionReject_v1130_IEsDeprioritisationReq_r11DeprioritisationTimer_r11(pub u8);
impl RRCConnectionReject_v1130_IEsDeprioritisationReq_r11DeprioritisationTimer_r11 {
    pub const MIN5: u8 = 0u8;
    pub const MIN10: u8 = 1u8;
    pub const MIN15: u8 = 2u8;
    pub const MIN30: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionReject_v1130_IEsDeprioritisationReq_r11 {
    pub deprioritisation_type_r11:
        RRCConnectionReject_v1130_IEsDeprioritisationReq_r11DeprioritisationType_r11,
    pub deprioritisation_timer_r11:
        RRCConnectionReject_v1130_IEsDeprioritisationReq_r11DeprioritisationTimer_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionReject_v1320_IEsRrc_SuspendIndication_r13(pub u8);
impl RRCConnectionReject_v1320_IEsRrc_SuspendIndication_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionReject_v1320_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCConnectionReject_v8a0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionReleaseCriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionReleaseCriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionReleaseCriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum RRCConnectionReleaseCriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    RrcConnectionRelease_r8(RRCConnectionRelease_r8_IEs),
    #[asn(key = 1, extended = false)]
    Spare3(RRCConnectionReleaseCriticalExtensions_c1_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(RRCConnectionReleaseCriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(RRCConnectionReleaseCriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionReleaseCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RRCConnectionReleaseCriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(RRCConnectionReleaseCriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(RRCConnectionReleaseCriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "1800")]
pub struct RRCConnectionRelease_v1020_IEsExtendedWaitTime_r10(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionRelease_v1530_IEsDrb_ContinueROHC_r15(pub u8);
impl RRCConnectionRelease_v1530_IEsDrb_ContinueROHC_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct RRCConnectionRelease_v1530_IEsCn_Type_r15(pub u8);
impl RRCConnectionRelease_v1530_IEsCn_Type_r15 {
    pub const EPC: u8 = 0u8;
    pub const FIVEGC: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct RRCConnectionRelease_v1540_IEsWaitTime(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionRelease_v15b0_IEsNoLastCellUpdate_r15(pub u8);
impl RRCConnectionRelease_v15b0_IEsNoLastCellUpdate_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionRelease_v1610_IEsPur_Config_r16_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RRCConnectionRelease_v1610_IEsPur_Config_r16 {
    #[asn(key = 0, extended = false)]
    Release(RRCConnectionRelease_v1610_IEsPur_Config_r16_release),
    #[asn(key = 1, extended = false)]
    Setup(PUR_Config_r16),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionRelease_v1610_IEsReleaseIdleMeasConfig_r16(pub u8);
impl RRCConnectionRelease_v1610_IEsReleaseIdleMeasConfig_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionRelease_v1610_IEsAltFreqPriorities_r16(pub u8);
impl RRCConnectionRelease_v1610_IEsAltFreqPriorities_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct RRCConnectionRelease_v1610_IEsT323_r16(pub u8);
impl RRCConnectionRelease_v1610_IEsT323_r16 {
    pub const MIN5: u8 = 0u8;
    pub const MIN10: u8 = 1u8;
    pub const MIN20: u8 = 2u8;
    pub const MIN30: u8 = 3u8;
    pub const MIN60: u8 = 4u8;
    pub const MIN120: u8 = 5u8;
    pub const MIN180: u8 = 6u8;
    pub const MIN720: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionRelease_v1650_IEsMpsPriorityIndication_r16(pub u8);
impl RRCConnectionRelease_v1650_IEsMpsPriorityIndication_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionRelease_v1650_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCConnectionRelease_v890_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum RRCConnectionRelease_v920_IEsCellInfoList_r9 {
    #[asn(key = 0, extended = false)]
    Geran_r9(CellInfoListGERAN_r9),
    #[asn(key = 1, extended = false)]
    Utra_FDD_r9(CellInfoListUTRA_FDD_r9),
    #[asn(key = 2, extended = false)]
    Utra_TDD_r9(CellInfoListUTRA_TDD_r9),
    #[asn(key = 0, extended = true)]
    Utra_TDD_r10(CellInfoListUTRA_TDD_r10),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionRelease_v9e0_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RRCConnectionRequestCriticalExtensions {
    #[asn(key = 0, extended = false)]
    RrcConnectionRequest_r8(RRCConnectionRequest_r8_IEs),
    #[asn(key = 1, extended = false)]
    RrcConnectionRequest_r15(RRCConnectionRequest_5GC_r15_IEs),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "1", sz_ub = "1")]
pub struct RRCConnectionRequest_5GC_r15_IEsSpare(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "1", sz_ub = "1")]
pub struct RRCConnectionRequest_r8_IEsSpare(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionResume_r13CriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionResume_r13CriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionResume_r13CriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum RRCConnectionResume_r13CriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    RrcConnectionResume_r13(RRCConnectionResume_r13_IEs),
    #[asn(key = 1, extended = false)]
    Spare3(RRCConnectionResume_r13CriticalExtensions_c1_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(RRCConnectionResume_r13CriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(RRCConnectionResume_r13CriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionResume_r13CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RRCConnectionResume_r13CriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(RRCConnectionResume_r13CriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(RRCConnectionResume_r13CriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionResume_r13_IEsDrb_ContinueROHC_r13(pub u8);
impl RRCConnectionResume_r13_IEsDrb_ContinueROHC_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCConnectionResume_r13_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct RRCConnectionResume_v1510_IEsSk_Counter_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCConnectionResume_v1510_IEsNr_RadioBearerConfig1_r15(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCConnectionResume_v1510_IEsNr_RadioBearerConfig2_r15(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionResume_v1530_IEsFullConfig_r15(pub u8);
impl RRCConnectionResume_v1530_IEsFullConfig_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionResume_v1610_IEsIdleModeMeasurementReq_r16(pub u8);
impl RRCConnectionResume_v1610_IEsIdleModeMeasurementReq_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionResume_v1610_IEsRestoreMCG_SCells_r16(pub u8);
impl RRCConnectionResume_v1610_IEsRestoreMCG_SCells_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionResume_v1610_IEsRestoreSCG_r16(pub u8);
impl RRCConnectionResume_v1610_IEsRestoreSCG_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCConnectionResume_v1610_IEsNr_SecondaryCellGroupConfig_r16(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionResume_v1700_IEsScg_State_r17(pub u8);
impl RRCConnectionResume_v1700_IEsScg_State_r17 {
    pub const DEACTIVATED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionResume_v1700_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionResumeComplete_r13CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RRCConnectionResumeComplete_r13CriticalExtensions {
    #[asn(key = 0, extended = false)]
    RrcConnectionResumeComplete_r13(RRCConnectionResumeComplete_r13_IEs),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        RRCConnectionResumeComplete_r13CriticalExtensions_criticalExtensionsFuture,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "6")]
pub struct RRCConnectionResumeComplete_r13_IEsSelectedPLMN_Identity_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionResumeComplete_r13_IEsRlf_InfoAvailable_r13(pub u8);
impl RRCConnectionResumeComplete_r13_IEsRlf_InfoAvailable_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionResumeComplete_r13_IEsLogMeasAvailable_r13(pub u8);
impl RRCConnectionResumeComplete_r13_IEsLogMeasAvailable_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionResumeComplete_r13_IEsConnEstFailInfoAvailable_r13(pub u8);
impl RRCConnectionResumeComplete_r13_IEsConnEstFailInfoAvailable_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct RRCConnectionResumeComplete_r13_IEsMobilityState_r13(pub u8);
impl RRCConnectionResumeComplete_r13_IEsMobilityState_r13 {
    pub const NORMAL: u8 = 0u8;
    pub const MEDIUM: u8 = 1u8;
    pub const HIGH: u8 = 2u8;
    pub const SPARE: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionResumeComplete_r13_IEsMobilityHistoryAvail_r13(pub u8);
impl RRCConnectionResumeComplete_r13_IEsMobilityHistoryAvail_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionResumeComplete_r13_IEsLogMeasAvailableMBSFN_r13(pub u8);
impl RRCConnectionResumeComplete_r13_IEsLogMeasAvailableMBSFN_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCConnectionResumeComplete_r13_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionResumeComplete_v1530_IEsLogMeasAvailableBT_r15(pub u8);
impl RRCConnectionResumeComplete_v1530_IEsLogMeasAvailableBT_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionResumeComplete_v1530_IEsLogMeasAvailableWLAN_r15(pub u8);
impl RRCConnectionResumeComplete_v1530_IEsLogMeasAvailableWLAN_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionResumeComplete_v1530_IEsIdleMeasAvailable_r15(pub u8);
impl RRCConnectionResumeComplete_v1530_IEsIdleMeasAvailable_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionResumeComplete_v1530_IEsFlightPathInfoAvailable_r15(pub u8);
impl RRCConnectionResumeComplete_v1530_IEsFlightPathInfoAvailable_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCConnectionResumeComplete_v1610_IEsScg_ConfigResponseNR_r16(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionResumeComplete_v1710_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RRCConnectionResumeRequest_5GC_r15_IEsResumeIdentity_r15 {
    #[asn(key = 0, extended = false)]
    FullI_RNTI_r15(I_RNTI_r15),
    #[asn(key = 1, extended = false)]
    ShortI_RNTI_r15(ShortI_RNTI_r15),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct RRCConnectionResumeRequest_5GC_r15_IEsShortResumeMAC_I_r15(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "1", sz_ub = "1")]
pub struct RRCConnectionResumeRequest_5GC_r15_IEsSpare(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RRCConnectionResumeRequest_r13CriticalExtensions {
    #[asn(key = 0, extended = false)]
    RrcConnectionResumeRequest_r13(RRCConnectionResumeRequest_r13_IEs),
    #[asn(key = 1, extended = false)]
    RrcConnectionResumeRequest_r15(RRCConnectionResumeRequest_5GC_r15_IEs),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "24", sz_ub = "24")]
pub struct RRCConnectionResumeRequest_r13_IEsResumeIdentity_r13_truncatedResumeID_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RRCConnectionResumeRequest_r13_IEsResumeIdentity_r13 {
    #[asn(key = 0, extended = false)]
    ResumeID_r13(ResumeIdentity_r13),
    #[asn(key = 1, extended = false)]
    TruncatedResumeID_r13(
        RRCConnectionResumeRequest_r13_IEsResumeIdentity_r13_truncatedResumeID_r13,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct RRCConnectionResumeRequest_r13_IEsShortResumeMAC_I_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "1", sz_ub = "1")]
pub struct RRCConnectionResumeRequest_r13_IEsSpare(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionSetupCriticalExtensions_c1_spare7;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionSetupCriticalExtensions_c1_spare6;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionSetupCriticalExtensions_c1_spare5;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionSetupCriticalExtensions_c1_spare4;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionSetupCriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionSetupCriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionSetupCriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "7", extensible = false)]
pub enum RRCConnectionSetupCriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    RrcConnectionSetup_r8(RRCConnectionSetup_r8_IEs),
    #[asn(key = 1, extended = false)]
    Spare7(RRCConnectionSetupCriticalExtensions_c1_spare7),
    #[asn(key = 2, extended = false)]
    Spare6(RRCConnectionSetupCriticalExtensions_c1_spare6),
    #[asn(key = 3, extended = false)]
    Spare5(RRCConnectionSetupCriticalExtensions_c1_spare5),
    #[asn(key = 4, extended = false)]
    Spare4(RRCConnectionSetupCriticalExtensions_c1_spare4),
    #[asn(key = 5, extended = false)]
    Spare3(RRCConnectionSetupCriticalExtensions_c1_spare3),
    #[asn(key = 6, extended = false)]
    Spare2(RRCConnectionSetupCriticalExtensions_c1_spare2),
    #[asn(key = 7, extended = false)]
    Spare1(RRCConnectionSetupCriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionSetupCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RRCConnectionSetupCriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(RRCConnectionSetupCriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(RRCConnectionSetupCriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionSetup_v1610_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCConnectionSetup_v8a0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionSetupCompleteCriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionSetupCompleteCriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RRCConnectionSetupCompleteCriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum RRCConnectionSetupCompleteCriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    RrcConnectionSetupComplete_r8(RRCConnectionSetupComplete_r8_IEs),
    #[asn(key = 1, extended = false)]
    Spare3(RRCConnectionSetupCompleteCriticalExtensions_c1_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(RRCConnectionSetupCompleteCriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(RRCConnectionSetupCompleteCriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionSetupCompleteCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RRCConnectionSetupCompleteCriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(RRCConnectionSetupCompleteCriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(RRCConnectionSetupCompleteCriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "6")]
pub struct RRCConnectionSetupComplete_r8_IEsSelectedPLMN_Identity(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct RRCConnectionSetupComplete_v1020_IEsGummei_Type_r10(pub u8);
impl RRCConnectionSetupComplete_v1020_IEsGummei_Type_r10 {
    pub const NATIVE: u8 = 0u8;
    pub const MAPPED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionSetupComplete_v1020_IEsRlf_InfoAvailable_r10(pub u8);
impl RRCConnectionSetupComplete_v1020_IEsRlf_InfoAvailable_r10 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionSetupComplete_v1020_IEsLogMeasAvailable_r10(pub u8);
impl RRCConnectionSetupComplete_v1020_IEsLogMeasAvailable_r10 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct RRCConnectionSetupComplete_v1020_IEsRn_SubframeConfigReq_r10(pub u8);
impl RRCConnectionSetupComplete_v1020_IEsRn_SubframeConfigReq_r10 {
    pub const REQUIRED: u8 = 0u8;
    pub const NOT_REQUIRED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionSetupComplete_v1130_IEsConnEstFailInfoAvailable_r11(pub u8);
impl RRCConnectionSetupComplete_v1130_IEsConnEstFailInfoAvailable_r11 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct RRCConnectionSetupComplete_v1250_IEsMobilityState_r12(pub u8);
impl RRCConnectionSetupComplete_v1250_IEsMobilityState_r12 {
    pub const NORMAL: u8 = 0u8;
    pub const MEDIUM: u8 = 1u8;
    pub const HIGH: u8 = 2u8;
    pub const SPARE: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionSetupComplete_v1250_IEsMobilityHistoryAvail_r12(pub u8);
impl RRCConnectionSetupComplete_v1250_IEsMobilityHistoryAvail_r12 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionSetupComplete_v1250_IEsLogMeasAvailableMBSFN_r12(pub u8);
impl RRCConnectionSetupComplete_v1250_IEsLogMeasAvailableMBSFN_r12 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionSetupComplete_v1320_IEsCe_ModeB_r13(pub u8);
impl RRCConnectionSetupComplete_v1320_IEsCe_ModeB_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionSetupComplete_v1320_IEsAttachWithoutPDN_Connectivity_r13(pub u8);
impl RRCConnectionSetupComplete_v1320_IEsAttachWithoutPDN_Connectivity_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionSetupComplete_v1320_IEsUp_CIoT_EPS_Optimisation_r13(pub u8);
impl RRCConnectionSetupComplete_v1320_IEsUp_CIoT_EPS_Optimisation_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionSetupComplete_v1320_IEsCp_CIoT_EPS_Optimisation_r13(pub u8);
impl RRCConnectionSetupComplete_v1320_IEsCp_CIoT_EPS_Optimisation_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionSetupComplete_v1330_IEsUe_CE_NeedULGaps_r13(pub u8);
impl RRCConnectionSetupComplete_v1330_IEsUe_CE_NeedULGaps_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct RRCConnectionSetupComplete_v1430_IEsDcn_ID_r14(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionSetupComplete_v1530_IEsLogMeasAvailableBT_r15(pub u8);
impl RRCConnectionSetupComplete_v1530_IEsLogMeasAvailableBT_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionSetupComplete_v1530_IEsLogMeasAvailableWLAN_r15(pub u8);
impl RRCConnectionSetupComplete_v1530_IEsLogMeasAvailableWLAN_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionSetupComplete_v1530_IEsIdleMeasAvailable_r15(pub u8);
impl RRCConnectionSetupComplete_v1530_IEsIdleMeasAvailable_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionSetupComplete_v1530_IEsFlightPathInfoAvailable_r15(pub u8);
impl RRCConnectionSetupComplete_v1530_IEsFlightPathInfoAvailable_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionSetupComplete_v1530_IEsConnectTo5GC_r15(pub u8);
impl RRCConnectionSetupComplete_v1530_IEsConnectTo5GC_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct RRCConnectionSetupComplete_v1530_IEsS_NSSAI_list_r15(pub Vec<S_NSSAI_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct RRCConnectionSetupComplete_v1530_IEsNg_5G_S_TMSI_Bits_r15_ng_5G_S_TMSI_Part2_r15(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RRCConnectionSetupComplete_v1530_IEsNg_5G_S_TMSI_Bits_r15 {
    #[asn(key = 0, extended = false)]
    Ng_5G_S_TMSI_r15(NG_5G_S_TMSI_r15),
    #[asn(key = 1, extended = false)]
    Ng_5G_S_TMSI_Part2_r15(
        RRCConnectionSetupComplete_v1530_IEsNg_5G_S_TMSI_Bits_r15_ng_5G_S_TMSI_Part2_r15,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionSetupComplete_v1540_IEsGummei_Type_v1540(pub u8);
impl RRCConnectionSetupComplete_v1540_IEsGummei_Type_v1540 {
    pub const MAPPED_FROM5_G_V1540: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct RRCConnectionSetupComplete_v1540_IEsGuami_Type_r15(pub u8);
impl RRCConnectionSetupComplete_v1540_IEsGuami_Type_r15 {
    pub const NATIVE: u8 = 0u8;
    pub const MAPPED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionSetupComplete_v1610_IEsRlos_Request_r16(pub u8);
impl RRCConnectionSetupComplete_v1610_IEsRlos_Request_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionSetupComplete_v1610_IEsCp_CIoT_5GS_Optimisation_r16(pub u8);
impl RRCConnectionSetupComplete_v1610_IEsCp_CIoT_5GS_Optimisation_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionSetupComplete_v1610_IEsUp_CIoT_5GS_Optimisation_r16(pub u8);
impl RRCConnectionSetupComplete_v1610_IEsUp_CIoT_5GS_Optimisation_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionSetupComplete_v1610_IEsLte_M_r16(pub u8);
impl RRCConnectionSetupComplete_v1610_IEsLte_M_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionSetupComplete_v1610_IEsIab_NodeIndication_r16(pub u8);
impl RRCConnectionSetupComplete_v1610_IEsIab_NodeIndication_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RRCConnectionSetupComplete_v1690_IEsUl_RRC_Segmentation_r16(pub u8);
impl RRCConnectionSetupComplete_v1690_IEsUl_RRC_Segmentation_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCConnectionSetupComplete_v1710_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCConnectionSetupComplete_v8a0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCEarlyDataComplete_r15CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RRCEarlyDataComplete_r15CriticalExtensions {
    #[asn(key = 0, extended = false)]
    RrcEarlyDataComplete_r15(RRCEarlyDataComplete_r15_IEs),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(RRCEarlyDataComplete_r15CriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "1800")]
pub struct RRCEarlyDataComplete_r15_IEsExtendedWaitTime_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCEarlyDataComplete_v1590_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCEarlyDataComplete_v1590_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct RRCEarlyDataRequest_5GC_r16_IEsEstablishmentCause_r16(pub u8);
impl RRCEarlyDataRequest_5GC_r16_IEsEstablishmentCause_r16 {
    pub const MO_DATA: u8 = 0u8;
    pub const SPARE3: u8 = 1u8;
    pub const SPARE2: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCEarlyDataRequest_5GC_r16_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCEarlyDataRequest_5GC_r16_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCEarlyDataRequest_r15CriticalExtensions_criticalExtensionsFuture_criticalExtensionsFuture_r16
{}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RRCEarlyDataRequest_r15CriticalExtensions_criticalExtensionsFuture {
    # [asn (key = 0 , extended = false)] RrcEarlyDataRequest_5GC_r16 (RRCEarlyDataRequest_5GC_r16_IEs) , # [asn (key = 1 , extended = false)] CriticalExtensionsFuture_r16 (RRCEarlyDataRequest_r15CriticalExtensions_criticalExtensionsFuture_criticalExtensionsFuture_r16) , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RRCEarlyDataRequest_r15CriticalExtensions {
    #[asn(key = 0, extended = false)]
    RrcEarlyDataRequest_r15(RRCEarlyDataRequest_r15_IEs),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(RRCEarlyDataRequest_r15CriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct RRCEarlyDataRequest_r15_IEsEstablishmentCause_r15(pub u8);
impl RRCEarlyDataRequest_r15_IEsEstablishmentCause_r15 {
    pub const MO_DATA: u8 = 0u8;
    pub const DELAY_TOLERANT_ACCESS: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCEarlyDataRequest_v1590_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct RRCEarlyDataRequest_v1610_IEsEstablishmentCause_v1610(pub u8);
impl RRCEarlyDataRequest_v1610_IEsEstablishmentCause_v1610 {
    pub const MT_ACCESS: u8 = 0u8;
    pub const SPARE3: u8 = 1u8;
    pub const SPARE2: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCEarlyDataRequest_v1610_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "63")]
pub struct RRM_ConfigUe_InactiveTime(pub u8);
impl RRM_ConfigUe_InactiveTime {
    pub const S1: u8 = 0u8;
    pub const S2: u8 = 1u8;
    pub const S3: u8 = 2u8;
    pub const S5: u8 = 3u8;
    pub const S7: u8 = 4u8;
    pub const S10: u8 = 5u8;
    pub const S15: u8 = 6u8;
    pub const S20: u8 = 7u8;
    pub const S25: u8 = 8u8;
    pub const S30: u8 = 9u8;
    pub const S40: u8 = 10u8;
    pub const S50: u8 = 11u8;
    pub const MIN1: u8 = 12u8;
    pub const MIN1S20C: u8 = 13u8;
    pub const MIN1S40: u8 = 14u8;
    pub const MIN2: u8 = 15u8;
    pub const MIN2S30: u8 = 16u8;
    pub const MIN3: u8 = 17u8;
    pub const MIN3S30: u8 = 18u8;
    pub const MIN4: u8 = 19u8;
    pub const MIN5: u8 = 20u8;
    pub const MIN6: u8 = 21u8;
    pub const MIN7: u8 = 22u8;
    pub const MIN8: u8 = 23u8;
    pub const MIN9: u8 = 24u8;
    pub const MIN10: u8 = 25u8;
    pub const MIN12: u8 = 26u8;
    pub const MIN14: u8 = 27u8;
    pub const MIN17: u8 = 28u8;
    pub const MIN20: u8 = 29u8;
    pub const MIN24: u8 = 30u8;
    pub const MIN28: u8 = 31u8;
    pub const MIN33: u8 = 32u8;
    pub const MIN38: u8 = 33u8;
    pub const MIN44: u8 = 34u8;
    pub const MIN50: u8 = 35u8;
    pub const HR1: u8 = 36u8;
    pub const HR1MIN30: u8 = 37u8;
    pub const HR2: u8 = 38u8;
    pub const HR2MIN30: u8 = 39u8;
    pub const HR3: u8 = 40u8;
    pub const HR3MIN30: u8 = 41u8;
    pub const HR4: u8 = 42u8;
    pub const HR5: u8 = 43u8;
    pub const HR6: u8 = 44u8;
    pub const HR8: u8 = 45u8;
    pub const HR10: u8 = 46u8;
    pub const HR13: u8 = 47u8;
    pub const HR16: u8 = 48u8;
    pub const HR20: u8 = 49u8;
    pub const DAY1: u8 = 50u8;
    pub const DAY1HR12: u8 = 51u8;
    pub const DAY2: u8 = 52u8;
    pub const DAY2HR12: u8 = 53u8;
    pub const DAY3: u8 = 54u8;
    pub const DAY4: u8 = 55u8;
    pub const DAY5: u8 = 56u8;
    pub const DAY7: u8 = 57u8;
    pub const DAY10: u8 = 58u8;
    pub const DAY14: u8 = 59u8;
    pub const DAY19: u8 = 60u8;
    pub const DAY24: u8 = 61u8;
    pub const DAY30: u8 = 62u8;
    pub const DAY_MORE_THAN30: u8 = 63u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct RS_ConfigSSB_NR_r15SubcarrierSpacingSSB_r15(pub u8);
impl RS_ConfigSSB_NR_r15SubcarrierSpacingSSB_r15 {
    pub const K_HZ15: u8 = 0u8;
    pub const K_HZ30: u8 = 1u8;
    pub const K_HZ120: u8 = 2u8;
    pub const K_HZ240: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RSRQ_RangeConfig_r12_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct RSRQ_Type_r12AllSymbols_r12(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct RSRQ_Type_r12WideBand_r12(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct RSS_Config_r15Duration_r15(pub u8);
impl RSS_Config_r15Duration_r15 {
    pub const SF8: u8 = 0u8;
    pub const SF16: u8 = 1u8;
    pub const SF32: u8 = 2u8;
    pub const SF40: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "98")]
pub struct RSS_Config_r15FreqLocation_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct RSS_Config_r15Periodicity_r15(pub u8);
impl RSS_Config_r15Periodicity_r15 {
    pub const MS160: u8 = 0u8;
    pub const MS320: u8 = 1u8;
    pub const MS640: u8 = 2u8;
    pub const MS1280: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct RSS_Config_r15PowerBoost_r15(pub u8);
impl RSS_Config_r15PowerBoost_r15 {
    pub const D_B0: u8 = 0u8;
    pub const D_B3: u8 = 1u8;
    pub const D_B4DOT8: u8 = 2u8;
    pub const D_B6: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct RSS_Config_r15TimeOffset_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "1", sz_ub = "15")]
pub struct RSS_ConfigCarrierInfo_r16NarrowbandIndex_r16(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct RSS_ConfigCarrierInfo_r16TimeOffsetGranularity_r16(pub u8);
impl RSS_ConfigCarrierInfo_r16TimeOffsetGranularity_r16 {
    pub const G1: u8 = 0u8;
    pub const G2: u8 = 1u8;
    pub const G4: u8 = 2u8;
    pub const G8: u8 = 3u8;
    pub const G16: u8 = 4u8;
    pub const G32: u8 = 5u8;
    pub const G64: u8 = 6u8;
    pub const G128: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "39")]
pub struct RSTD_InterFreqInfo_r10MeasPRS_Offset_r10(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct RadioResourceConfigCommonSCell_r10NonUL_Configuration_r10Dl_Bandwidth_r10(pub u8);
impl RadioResourceConfigCommonSCell_r10NonUL_Configuration_r10Dl_Bandwidth_r10 {
    pub const N6: u8 = 0u8;
    pub const N15: u8 = 1u8;
    pub const N25: u8 = 2u8;
    pub const N50: u8 = 3u8;
    pub const N75: u8 = 4u8;
    pub const N100: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RadioResourceConfigCommonSCell_r10NonUL_Configuration_r10 {
    pub dl_bandwidth_r10: RadioResourceConfigCommonSCell_r10NonUL_Configuration_r10Dl_Bandwidth_r10,
    pub antenna_info_common_r10: AntennaInfoCommon,
    #[asn(optional_idx = 0)]
    pub mbsfn_subframe_config_list_r10: Option<MBSFN_SubframeConfigList>,
    pub phich_config_r10: PHICH_Config,
    pub pdsch_config_common_r10: PDSCH_ConfigCommon,
    #[asn(optional_idx = 1)]
    pub tdd_config_r10: Option<TDD_Config>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct RadioResourceConfigCommonSCell_r10Ul_Configuration_r10Ul_FreqInfo_r10Ul_Bandwidth_r10(
    pub u8,
);
impl RadioResourceConfigCommonSCell_r10Ul_Configuration_r10Ul_FreqInfo_r10Ul_Bandwidth_r10 {
    pub const N6: u8 = 0u8;
    pub const N15: u8 = 1u8;
    pub const N25: u8 = 2u8;
    pub const N50: u8 = 3u8;
    pub const N75: u8 = 4u8;
    pub const N100: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RadioResourceConfigCommonSCell_r10Ul_Configuration_r10Ul_FreqInfo_r10 {
    #[asn(optional_idx = 0)]
    pub ul_carrier_freq_r10: Option<ARFCN_ValueEUTRA>,
    #[asn(optional_idx = 1)]
    pub ul_bandwidth_r10: Option<
        RadioResourceConfigCommonSCell_r10Ul_Configuration_r10Ul_FreqInfo_r10Ul_Bandwidth_r10,
    >,
    pub additional_spectrum_emission_s_cell_r10: AdditionalSpectrumEmission,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct RadioResourceConfigCommonSCell_r10Ul_Configuration_r10 {
    pub ul_freq_info_r10: RadioResourceConfigCommonSCell_r10Ul_Configuration_r10Ul_FreqInfo_r10,
    #[asn(optional_idx = 0)]
    pub p_max_r10: Option<P_Max>,
    pub uplink_power_control_common_s_cell_r10: UplinkPowerControlCommonSCell_r10,
    pub sounding_rs_ul_config_common_r10: SoundingRS_UL_ConfigCommon,
    pub ul_cyclic_prefix_length_r10: UL_CyclicPrefixLength,
    #[asn(optional_idx = 1)]
    pub prach_config_s_cell_r10: Option<PRACH_ConfigSCell_r10>,
    pub pusch_config_common_r10: PUSCH_ConfigCommon,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RadioResourceConfigCommonSCell_v10l0Ul_Configuration_v10l0 {
    pub additional_spectrum_emission_s_cell_v10l0: AdditionalSpectrumEmission_v10l0,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RadioResourceConfigCommonSCell_v1440Ul_Configuration_v1440Ul_FreqInfo_v1440 {
    pub additional_spectrum_emission_s_cell_v1440: AdditionalSpectrumEmission_v10l0,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RadioResourceConfigCommonSCell_v1440Ul_Configuration_v1440 {
    pub ul_freq_info_v1440:
        RadioResourceConfigCommonSCell_v1440Ul_Configuration_v1440Ul_FreqInfo_v1440,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct RadioResourceConfigDedicatedMac_MainConfig_defaultValue;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum RadioResourceConfigDedicatedMac_MainConfig {
    #[asn(key = 0, extended = false)]
    ExplicitValue(MAC_MainConfig),
    #[asn(key = 1, extended = false)]
    DefaultValue(RadioResourceConfigDedicatedMac_MainConfig_defaultValue),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "10")]
pub struct RedistributionServingInfo_r13RedistributionFactorServing_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RedistributionServingInfo_r13RedistributionFactorCell_r13(pub u8);
impl RedistributionServingInfo_r13RedistributionFactorCell_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct RedistributionServingInfo_r13T360_r13(pub u8);
impl RedistributionServingInfo_r13T360_r13 {
    pub const MIN4: u8 = 0u8;
    pub const MIN8: u8 = 1u8;
    pub const MIN16: u8 = 2u8;
    pub const MIN32: u8 = 3u8;
    pub const INFINITY: u8 = 4u8;
    pub const SPARE3: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct RedistributionServingInfo_r13RedistrOnPagingOnly_r13(pub u8);
impl RedistributionServingInfo_r13RedistrOnPagingOnly_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "72999")]
pub struct ReferenceTime_r15RefDays_r15(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "86399")]
pub struct ReferenceTime_r15RefSeconds_r15(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "999")]
pub struct ReferenceTime_r15RefMilliSeconds_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3999")]
pub struct ReferenceTime_r15RefQuarterMicroSeconds_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct RegisteredMMEMmegi(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReportConfigEUTRATriggerType_eventEventId_eventA1 {
    pub a1_threshold: ThresholdEUTRA,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReportConfigEUTRATriggerType_eventEventId_eventA2 {
    pub a2_threshold: ThresholdEUTRA,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-30", ub = "30")]
pub struct ReportConfigEUTRATriggerType_eventEventId_eventA3A3_Offset(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct ReportConfigEUTRATriggerType_eventEventId_eventA3ReportOnLeave(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReportConfigEUTRATriggerType_eventEventId_eventA3 {
    pub a3_offset: ReportConfigEUTRATriggerType_eventEventId_eventA3A3_Offset,
    pub report_on_leave: ReportConfigEUTRATriggerType_eventEventId_eventA3ReportOnLeave,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReportConfigEUTRATriggerType_eventEventId_eventA4 {
    pub a4_threshold: ThresholdEUTRA,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReportConfigEUTRATriggerType_eventEventId_eventA5 {
    pub a5_threshold1: ThresholdEUTRA,
    pub a5_threshold2: ThresholdEUTRA,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-30", ub = "30")]
pub struct ReportConfigEUTRATriggerType_eventEventId_eventA6_r10A6_Offset_r10(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct ReportConfigEUTRATriggerType_eventEventId_eventA6_r10A6_ReportOnLeave_r10(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReportConfigEUTRATriggerType_eventEventId_eventA6_r10 {
    pub a6_offset_r10: ReportConfigEUTRATriggerType_eventEventId_eventA6_r10A6_Offset_r10,
    pub a6_report_on_leave_r10:
        ReportConfigEUTRATriggerType_eventEventId_eventA6_r10A6_ReportOnLeave_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct ReportConfigEUTRATriggerType_eventEventId_eventC1_r12C1_ReportOnLeave_r12(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReportConfigEUTRATriggerType_eventEventId_eventC1_r12 {
    pub c1_threshold_r12: ThresholdEUTRA_v1250,
    pub c1_report_on_leave_r12:
        ReportConfigEUTRATriggerType_eventEventId_eventC1_r12C1_ReportOnLeave_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-30", ub = "30")]
pub struct ReportConfigEUTRATriggerType_eventEventId_eventC2_r12C2_Offset_r12(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct ReportConfigEUTRATriggerType_eventEventId_eventC2_r12C2_ReportOnLeave_r12(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReportConfigEUTRATriggerType_eventEventId_eventC2_r12 {
    pub c2_ref_csi_rs_r12: MeasCSI_RS_Id_r12,
    pub c2_offset_r12: ReportConfigEUTRATriggerType_eventEventId_eventC2_r12C2_Offset_r12,
    pub c2_report_on_leave_r12:
        ReportConfigEUTRATriggerType_eventEventId_eventC2_r12C2_ReportOnLeave_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReportConfigEUTRATriggerType_eventEventId_eventV1_r14 {
    pub v1_threshold_r14: SL_CBR_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReportConfigEUTRATriggerType_eventEventId_eventV2_r14 {
    pub v2_threshold_r14: SL_CBR_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "300")]
pub struct ReportConfigEUTRATriggerType_eventEventId_eventH1_r15H1_ThresholdOffset_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct ReportConfigEUTRATriggerType_eventEventId_eventH1_r15H1_Hysteresis_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReportConfigEUTRATriggerType_eventEventId_eventH1_r15 {
    pub h1_threshold_offset_r15:
        ReportConfigEUTRATriggerType_eventEventId_eventH1_r15H1_ThresholdOffset_r15,
    pub h1_hysteresis_r15: ReportConfigEUTRATriggerType_eventEventId_eventH1_r15H1_Hysteresis_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "300")]
pub struct ReportConfigEUTRATriggerType_eventEventId_eventH2_r15H2_ThresholdOffset_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct ReportConfigEUTRATriggerType_eventEventId_eventH2_r15H2_Hysteresis_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReportConfigEUTRATriggerType_eventEventId_eventH2_r15 {
    pub h2_threshold_offset_r15:
        ReportConfigEUTRATriggerType_eventEventId_eventH2_r15H2_ThresholdOffset_r15,
    pub h2_hysteresis_r15: ReportConfigEUTRATriggerType_eventEventId_eventH2_r15H2_Hysteresis_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "4", extensible = true)]
pub enum ReportConfigEUTRATriggerType_eventEventId {
    #[asn(key = 0, extended = false)]
    EventA1(ReportConfigEUTRATriggerType_eventEventId_eventA1),
    #[asn(key = 1, extended = false)]
    EventA2(ReportConfigEUTRATriggerType_eventEventId_eventA2),
    #[asn(key = 2, extended = false)]
    EventA3(ReportConfigEUTRATriggerType_eventEventId_eventA3),
    #[asn(key = 3, extended = false)]
    EventA4(ReportConfigEUTRATriggerType_eventEventId_eventA4),
    #[asn(key = 4, extended = false)]
    EventA5(ReportConfigEUTRATriggerType_eventEventId_eventA5),
    #[asn(key = 0, extended = true)]
    EventA6_r10(ReportConfigEUTRATriggerType_eventEventId_eventA6_r10),
    #[asn(key = 1, extended = true)]
    EventC1_r12(ReportConfigEUTRATriggerType_eventEventId_eventC1_r12),
    #[asn(key = 2, extended = true)]
    EventC2_r12(ReportConfigEUTRATriggerType_eventEventId_eventC2_r12),
    #[asn(key = 3, extended = true)]
    EventV1_r14(ReportConfigEUTRATriggerType_eventEventId_eventV1_r14),
    #[asn(key = 4, extended = true)]
    EventV2_r14(ReportConfigEUTRATriggerType_eventEventId_eventV2_r14),
    #[asn(key = 5, extended = true)]
    EventH1_r15(ReportConfigEUTRATriggerType_eventEventId_eventH1_r15),
    #[asn(key = 6, extended = true)]
    EventH2_r15(ReportConfigEUTRATriggerType_eventEventId_eventH2_r15),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReportConfigEUTRATriggerType_event {
    pub event_id: ReportConfigEUTRATriggerType_eventEventId,
    pub hysteresis: Hysteresis,
    pub time_to_trigger: TimeToTrigger,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct ReportConfigEUTRATriggerType_periodicalPurpose(pub u8);
impl ReportConfigEUTRATriggerType_periodicalPurpose {
    pub const REPORT_STRONGEST_CELLS: u8 = 0u8;
    pub const REPORT_CGI: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReportConfigEUTRATriggerType_periodical {
    pub purpose: ReportConfigEUTRATriggerType_periodicalPurpose,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum ReportConfigEUTRATriggerType {
    #[asn(key = 0, extended = false)]
    Event(ReportConfigEUTRATriggerType_event),
    #[asn(key = 1, extended = false)]
    Periodical(ReportConfigEUTRATriggerType_periodical),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct ReportConfigEUTRATriggerQuantity(pub u8);
impl ReportConfigEUTRATriggerQuantity {
    pub const RSRP: u8 = 0u8;
    pub const RSRQ: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct ReportConfigEUTRAReportQuantity(pub u8);
impl ReportConfigEUTRAReportQuantity {
    pub const SAME_AS_TRIGGER_QUANTITY: u8 = 0u8;
    pub const BOTH: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8")]
pub struct ReportConfigEUTRAMaxReportCells(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct ReportConfigEUTRAReportAmount(pub u8);
impl ReportConfigEUTRAReportAmount {
    pub const R1: u8 = 0u8;
    pub const R2: u8 = 1u8;
    pub const R4: u8 = 2u8;
    pub const R8: u8 = 3u8;
    pub const R16: u8 = 4u8;
    pub const R32: u8 = 5u8;
    pub const R64: u8 = 6u8;
    pub const INFINITY: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum ReportConfigInterRATTriggerType_eventEventId_eventB1B1_Threshold {
    #[asn(key = 0, extended = false)]
    B1_ThresholdUTRA(ThresholdUTRA),
    #[asn(key = 1, extended = false)]
    B1_ThresholdGERAN(ThresholdGERAN),
    #[asn(key = 2, extended = false)]
    B1_ThresholdCDMA2000(ThresholdCDMA2000),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReportConfigInterRATTriggerType_eventEventId_eventB1 {
    pub b1_threshold: ReportConfigInterRATTriggerType_eventEventId_eventB1B1_Threshold,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum ReportConfigInterRATTriggerType_eventEventId_eventB2B2_Threshold2 {
    #[asn(key = 0, extended = false)]
    B2_Threshold2UTRA(ThresholdUTRA),
    #[asn(key = 1, extended = false)]
    B2_Threshold2GERAN(ThresholdGERAN),
    #[asn(key = 2, extended = false)]
    B2_Threshold2CDMA2000(ThresholdCDMA2000),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReportConfigInterRATTriggerType_eventEventId_eventB2 {
    pub b2_threshold1: ThresholdEUTRA,
    pub b2_threshold2: ReportConfigInterRATTriggerType_eventEventId_eventB2B2_Threshold2,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReportConfigInterRATTriggerType_eventEventId_eventW1_r13 {
    pub w1_threshold_r13: WLAN_RSSI_Range_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReportConfigInterRATTriggerType_eventEventId_eventW2_r13 {
    pub w2_threshold1_r13: WLAN_RSSI_Range_r13,
    pub w2_threshold2_r13: WLAN_RSSI_Range_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReportConfigInterRATTriggerType_eventEventId_eventW3_r13 {
    pub w3_threshold_r13: WLAN_RSSI_Range_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct ReportConfigInterRATTriggerType_eventEventId_eventB1_NR_r15ReportOnLeave_r15(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReportConfigInterRATTriggerType_eventEventId_eventB1_NR_r15 {
    pub b1_threshold_nr_r15: ThresholdNR_r15,
    pub report_on_leave_r15:
        ReportConfigInterRATTriggerType_eventEventId_eventB1_NR_r15ReportOnLeave_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct ReportConfigInterRATTriggerType_eventEventId_eventB2_NR_r15ReportOnLeave_r15(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReportConfigInterRATTriggerType_eventEventId_eventB2_NR_r15 {
    pub b2_threshold1_r15: ThresholdEUTRA,
    pub b2_threshold2_nr_r15: ThresholdNR_r15,
    pub report_on_leave_r15:
        ReportConfigInterRATTriggerType_eventEventId_eventB2_NR_r15ReportOnLeave_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum ReportConfigInterRATTriggerType_eventEventId {
    #[asn(key = 0, extended = false)]
    EventB1(ReportConfigInterRATTriggerType_eventEventId_eventB1),
    #[asn(key = 1, extended = false)]
    EventB2(ReportConfigInterRATTriggerType_eventEventId_eventB2),
    #[asn(key = 0, extended = true)]
    EventW1_r13(ReportConfigInterRATTriggerType_eventEventId_eventW1_r13),
    #[asn(key = 1, extended = true)]
    EventW2_r13(ReportConfigInterRATTriggerType_eventEventId_eventW2_r13),
    #[asn(key = 2, extended = true)]
    EventW3_r13(ReportConfigInterRATTriggerType_eventEventId_eventW3_r13),
    #[asn(key = 3, extended = true)]
    EventB1_NR_r15(ReportConfigInterRATTriggerType_eventEventId_eventB1_NR_r15),
    #[asn(key = 4, extended = true)]
    EventB2_NR_r15(ReportConfigInterRATTriggerType_eventEventId_eventB2_NR_r15),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReportConfigInterRATTriggerType_event {
    pub event_id: ReportConfigInterRATTriggerType_eventEventId,
    pub hysteresis: Hysteresis,
    pub time_to_trigger: TimeToTrigger,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct ReportConfigInterRATTriggerType_periodicalPurpose(pub u8);
impl ReportConfigInterRATTriggerType_periodicalPurpose {
    pub const REPORT_STRONGEST_CELLS: u8 = 0u8;
    pub const REPORT_STRONGEST_CELLS_FOR_SON: u8 = 1u8;
    pub const REPORT_CGI: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ReportConfigInterRATTriggerType_periodical {
    pub purpose: ReportConfigInterRATTriggerType_periodicalPurpose,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum ReportConfigInterRATTriggerType {
    #[asn(key = 0, extended = false)]
    Event(ReportConfigInterRATTriggerType_event),
    #[asn(key = 1, extended = false)]
    Periodical(ReportConfigInterRATTriggerType_periodical),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8")]
pub struct ReportConfigInterRATMaxReportCells(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct ReportConfigInterRATReportAmount(pub u8);
impl ReportConfigInterRATReportAmount {
    pub const R1: u8 = 0u8;
    pub const R2: u8 = 1u8;
    pub const R4: u8 = 2u8;
    pub const R8: u8 = 3u8;
    pub const R16: u8 = 4u8;
    pub const R32: u8 = 5u8;
    pub const R64: u8 = 6u8;
    pub const INFINITY: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum ReportConfigToAddModReportConfig {
    #[asn(key = 0, extended = false)]
    ReportConfigEUTRA(ReportConfigEUTRA),
    #[asn(key = 1, extended = false)]
    ReportConfigInterRAT(ReportConfigInterRAT),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct ReportProximityConfig_r9ProximityIndicationEUTRA_r9(pub u8);
impl ReportProximityConfig_r9ProximityIndicationEUTRA_r9 {
    pub const ENABLED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct ReportProximityConfig_r9ProximityIndicationUTRA_r9(pub u8);
impl ReportProximityConfig_r9ProximityIndicationUTRA_r9 {
    pub const ENABLED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct ReportQuantityNR_r15Ss_rsrp(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct ReportQuantityNR_r15Ss_rsrq(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct ReportQuantityNR_r15Ss_sinr(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct ReportQuantityWLAN_r13BandRequestWLAN_r13(pub u8);
impl ReportQuantityWLAN_r13BandRequestWLAN_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct ReportQuantityWLAN_r13CarrierInfoRequestWLAN_r13(pub u8);
impl ReportQuantityWLAN_r13CarrierInfoRequestWLAN_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct ReportQuantityWLAN_r13AvailableAdmissionCapacityRequestWLAN_r13(pub u8);
impl ReportQuantityWLAN_r13AvailableAdmissionCapacityRequestWLAN_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct ReportQuantityWLAN_r13BackhaulDL_BandwidthRequestWLAN_r13(pub u8);
impl ReportQuantityWLAN_r13BackhaulDL_BandwidthRequestWLAN_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct ReportQuantityWLAN_r13BackhaulUL_BandwidthRequestWLAN_r13(pub u8);
impl ReportQuantityWLAN_r13BackhaulUL_BandwidthRequestWLAN_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct ReportQuantityWLAN_r13ChannelUtilizationRequestWLAN_r13(pub u8);
impl ReportQuantityWLAN_r13ChannelUtilizationRequestWLAN_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct ReportQuantityWLAN_r13StationCountRequestWLAN_r13(pub u8);
impl ReportQuantityWLAN_r13StationCountRequestWLAN_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct ReselectionInfoRelay_r13MinHyst_r13(pub u8);
impl ReselectionInfoRelay_r13MinHyst_r13 {
    pub const D_B0: u8 = 0u8;
    pub const D_B3: u8 = 1u8;
    pub const D_B6: u8 = 2u8;
    pub const D_B9: u8 = 3u8;
    pub const D_B12: u8 = 4u8;
    pub const D_BINF: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "6", sz_ub = "6")]
pub struct ResourceReservationConfigDL_r16ResourceReservationFreq_r16_rbg_Bitmap1dot4(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct ResourceReservationConfigDL_r16ResourceReservationFreq_r16_rbg_Bitmap3(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "13", sz_ub = "13")]
pub struct ResourceReservationConfigDL_r16ResourceReservationFreq_r16_rbg_Bitmap5(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "17", sz_ub = "17")]
pub struct ResourceReservationConfigDL_r16ResourceReservationFreq_r16_rbg_Bitmap10(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "19", sz_ub = "19")]
pub struct ResourceReservationConfigDL_r16ResourceReservationFreq_r16_rbg_Bitmap15(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "25", sz_ub = "25")]
pub struct ResourceReservationConfigDL_r16ResourceReservationFreq_r16_rbg_Bitmap20(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "5", extensible = false)]
pub enum ResourceReservationConfigDL_r16ResourceReservationFreq_r16 {
    #[asn(key = 0, extended = false)]
    Rbg_Bitmap1dot4(ResourceReservationConfigDL_r16ResourceReservationFreq_r16_rbg_Bitmap1dot4),
    #[asn(key = 1, extended = false)]
    Rbg_Bitmap3(ResourceReservationConfigDL_r16ResourceReservationFreq_r16_rbg_Bitmap3),
    #[asn(key = 2, extended = false)]
    Rbg_Bitmap5(ResourceReservationConfigDL_r16ResourceReservationFreq_r16_rbg_Bitmap5),
    #[asn(key = 3, extended = false)]
    Rbg_Bitmap10(ResourceReservationConfigDL_r16ResourceReservationFreq_r16_rbg_Bitmap10),
    #[asn(key = 4, extended = false)]
    Rbg_Bitmap15(ResourceReservationConfigDL_r16ResourceReservationFreq_r16_rbg_Bitmap15),
    #[asn(key = 5, extended = false)]
    Rbg_Bitmap20(ResourceReservationConfigDL_r16ResourceReservationFreq_r16_rbg_Bitmap20),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "20", sz_ub = "20")]
pub struct ResourceReservationConfigDL_r16SlotBitmap_r16_slotPattern10ms(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "80", sz_ub = "80")]
pub struct ResourceReservationConfigDL_r16SlotBitmap_r16_slotPattern40ms(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum ResourceReservationConfigDL_r16SlotBitmap_r16 {
    #[asn(key = 0, extended = false)]
    SlotPattern10ms(ResourceReservationConfigDL_r16SlotBitmap_r16_slotPattern10ms),
    #[asn(key = 1, extended = false)]
    SlotPattern40ms(ResourceReservationConfigDL_r16SlotBitmap_r16_slotPattern40ms),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "7", sz_ub = "7")]
pub struct ResourceReservationConfigDL_r16SymbolBitmap1_r16(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "7", sz_ub = "7")]
pub struct ResourceReservationConfigDL_r16SymbolBitmap2_r16(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "20", sz_ub = "20")]
pub struct ResourceReservationConfigUL_r16SlotBitmap_r16_slotPattern10ms(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "80", sz_ub = "80")]
pub struct ResourceReservationConfigUL_r16SlotBitmap_r16_slotPattern40ms(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum ResourceReservationConfigUL_r16SlotBitmap_r16 {
    #[asn(key = 0, extended = false)]
    SlotPattern10ms(ResourceReservationConfigUL_r16SlotBitmap_r16_slotPattern10ms),
    #[asn(key = 1, extended = false)]
    SlotPattern40ms(ResourceReservationConfigUL_r16SlotBitmap_r16_slotPattern40ms),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "7", sz_ub = "7")]
pub struct ResourceReservationConfigUL_r16SymbolBitmap1_r16(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "7", sz_ub = "7")]
pub struct ResourceReservationConfigUL_r16SymbolBitmap2_r16(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct ResultsPerSSB_IndexIdle_r16Ssb_Results_r16 {
    #[asn(optional_idx = 0)]
    pub ssb_rsrp_result_r16: Option<RSRP_RangeNR_r15>,
    #[asn(optional_idx = 1)]
    pub ssb_rsrq_result_r16: Option<RSRQ_RangeNR_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct S_NSSAI_r15_sst(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct S_NSSAI_r15_sst_SD(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct S_TMSIM_TMSI(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct SBAS_ID_r15Sbas_id_r15(pub u8);
impl SBAS_ID_r15Sbas_id_r15 {
    pub const WAAS: u8 = 0u8;
    pub const EGNOS: u8 = 1u8;
    pub const MSAS: u8 = 2u8;
    pub const GAGAN: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = false)]
pub enum SC_MCCH_MessageType_r13_c1 {
    #[asn(key = 0, extended = false)]
    ScptmConfiguration_r13(SCPTMConfiguration_r13),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SC_MCCH_MessageType_r13_messageClassExtension_c2_spare;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SC_MCCH_MessageType_r13_messageClassExtension_c2 {
    #[asn(key = 0, extended = false)]
    ScptmConfiguration_BR_r14(SCPTMConfiguration_BR_r14),
    #[asn(key = 1, extended = false)]
    Spare(SC_MCCH_MessageType_r13_messageClassExtension_c2_spare),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SC_MCCH_MessageType_r13_messageClassExtension_messageClassExtensionFuture_r14 {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SC_MCCH_MessageType_r13_messageClassExtension {
    #[asn(key = 0, extended = false)]
    C2(SC_MCCH_MessageType_r13_messageClassExtension_c2),
    #[asn(key = 1, extended = false)]
    MessageClassExtensionFuture_r14(
        SC_MCCH_MessageType_r13_messageClassExtension_messageClassExtensionFuture_r14,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct SC_MCCH_SchedulingInfo_r14OnDurationTimerSCPTM_r14(pub u8);
impl SC_MCCH_SchedulingInfo_r14OnDurationTimerSCPTM_r14 {
    pub const PSF10: u8 = 0u8;
    pub const PSF20: u8 = 1u8;
    pub const PSF100: u8 = 2u8;
    pub const PSF300: u8 = 3u8;
    pub const PSF500: u8 = 4u8;
    pub const PSF1000: u8 = 5u8;
    pub const PSF1200: u8 = 6u8;
    pub const PSF1600: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct SC_MCCH_SchedulingInfo_r14Drx_InactivityTimerSCPTM_r14(pub u8);
impl SC_MCCH_SchedulingInfo_r14Drx_InactivityTimerSCPTM_r14 {
    pub const PSF0: u8 = 0u8;
    pub const PSF1: u8 = 1u8;
    pub const PSF2: u8 = 2u8;
    pub const PSF4: u8 = 3u8;
    pub const PSF8: u8 = 4u8;
    pub const PSF16: u8 = 5u8;
    pub const PSF32: u8 = 6u8;
    pub const PSF64: u8 = 7u8;
    pub const PSF128: u8 = 8u8;
    pub const PSF256: u8 = 9u8;
    pub const PS512: u8 = 10u8;
    pub const PSF1024: u8 = 11u8;
    pub const PSF2048: u8 = 12u8;
    pub const PSF4096: u8 = 13u8;
    pub const PSF8192: u8 = 14u8;
    pub const PSF16384: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "9")]
pub struct SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf10(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "19")]
pub struct SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf20(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf32(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "39")]
pub struct SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf40(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63")]
pub struct SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf64(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "79")]
pub struct SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf80(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "127")]
pub struct SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf128(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "159")]
pub struct SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf160(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf256(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "319")]
pub struct SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf320(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "511")]
pub struct SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf512(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "639")]
pub struct SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf640(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf1024(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf2048(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf4096(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "8191")]
pub struct SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf8192(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "15", extensible = false)]
pub enum SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14 {
    #[asn(key = 0, extended = false)]
    Sf10(SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf10),
    #[asn(key = 1, extended = false)]
    Sf20(SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf20),
    #[asn(key = 2, extended = false)]
    Sf32(SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf32),
    #[asn(key = 3, extended = false)]
    Sf40(SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf40),
    #[asn(key = 4, extended = false)]
    Sf64(SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf64),
    #[asn(key = 5, extended = false)]
    Sf80(SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf80),
    #[asn(key = 6, extended = false)]
    Sf128(SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf128),
    #[asn(key = 7, extended = false)]
    Sf160(SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf160),
    #[asn(key = 8, extended = false)]
    Sf256(SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf256),
    #[asn(key = 9, extended = false)]
    Sf320(SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf320),
    #[asn(key = 10, extended = false)]
    Sf512(SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf512),
    #[asn(key = 11, extended = false)]
    Sf640(SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf640),
    #[asn(key = 12, extended = false)]
    Sf1024(SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf1024),
    #[asn(key = 13, extended = false)]
    Sf2048(SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf2048),
    #[asn(key = 14, extended = false)]
    Sf4096(SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf4096),
    #[asn(key = 15, extended = false)]
    Sf8192(SC_MCCH_SchedulingInfo_r14SchedulingPeriodStartOffsetSCPTM_r14_sf8192),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct SC_MTCH_Info_BR_r14G_RNTI_r14(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct SC_MTCH_Info_BR_r14Sc_mtch_neighbourCell_r14(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct SC_MTCH_Info_BR_r14Mpdcch_Narrowband_SC_MTCH_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "8")]
pub struct SC_MTCH_Info_BR_r14Mpdcch_NumRepetition_SC_MTCH_r14(pub u8);
impl SC_MTCH_Info_BR_r14Mpdcch_NumRepetition_SC_MTCH_r14 {
    pub const R1: u8 = 0u8;
    pub const R2: u8 = 1u8;
    pub const R4: u8 = 2u8;
    pub const R8: u8 = 3u8;
    pub const R16: u8 = 4u8;
    pub const R32: u8 = 5u8;
    pub const R64: u8 = 6u8;
    pub const R128: u8 = 7u8;
    pub const R256: u8 = 8u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct SC_MTCH_Info_BR_r14Mpdcch_StartSF_SC_MTCH_r14_fdd_r14(pub u8);
impl SC_MTCH_Info_BR_r14Mpdcch_StartSF_SC_MTCH_r14_fdd_r14 {
    pub const V1: u8 = 0u8;
    pub const V1DOT5: u8 = 1u8;
    pub const V2: u8 = 2u8;
    pub const V2DOT5: u8 = 3u8;
    pub const V4: u8 = 4u8;
    pub const V5: u8 = 5u8;
    pub const V8: u8 = 6u8;
    pub const V10: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "6")]
pub struct SC_MTCH_Info_BR_r14Mpdcch_StartSF_SC_MTCH_r14_tdd_r14(pub u8);
impl SC_MTCH_Info_BR_r14Mpdcch_StartSF_SC_MTCH_r14_tdd_r14 {
    pub const V1: u8 = 0u8;
    pub const V2: u8 = 1u8;
    pub const V4: u8 = 2u8;
    pub const V5: u8 = 3u8;
    pub const V8: u8 = 4u8;
    pub const V10: u8 = 5u8;
    pub const V20: u8 = 6u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SC_MTCH_Info_BR_r14Mpdcch_StartSF_SC_MTCH_r14 {
    #[asn(key = 0, extended = false)]
    Fdd_r14(SC_MTCH_Info_BR_r14Mpdcch_StartSF_SC_MTCH_r14_fdd_r14),
    #[asn(key = 1, extended = false)]
    Tdd_r14(SC_MTCH_Info_BR_r14Mpdcch_StartSF_SC_MTCH_r14_tdd_r14),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SC_MTCH_Info_BR_r14Mpdcch_PDSCH_HoppingConfig_SC_MTCH_r14(pub u8);
impl SC_MTCH_Info_BR_r14Mpdcch_PDSCH_HoppingConfig_SC_MTCH_r14 {
    pub const ON: u8 = 0u8;
    pub const OFF: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SC_MTCH_Info_BR_r14Mpdcch_PDSCH_CEmodeConfig_SC_MTCH_r14(pub u8);
impl SC_MTCH_Info_BR_r14Mpdcch_PDSCH_CEmodeConfig_SC_MTCH_r14 {
    pub const CE_MODE_A: u8 = 0u8;
    pub const CE_MODE_B: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SC_MTCH_Info_BR_r14Mpdcch_PDSCH_MaxBandwidth_SC_MTCH_r14(pub u8);
impl SC_MTCH_Info_BR_r14Mpdcch_PDSCH_MaxBandwidth_SC_MTCH_r14 {
    pub const BW1DOT4: u8 = 0u8;
    pub const BW5: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct SC_MTCH_Info_BR_r14Mpdcch_Offset_SC_MTCH_r14(pub u8);
impl SC_MTCH_Info_BR_r14Mpdcch_Offset_SC_MTCH_r14 {
    pub const ZERO: u8 = 0u8;
    pub const ONE_EIGHTH: u8 = 1u8;
    pub const ONE_QUARTER: u8 = 2u8;
    pub const THREE_EIGHTH: u8 = 3u8;
    pub const ONE_HALF: u8 = 4u8;
    pub const FIVE_EIGHTH: u8 = 5u8;
    pub const THREE_QUARTER: u8 = 6u8;
    pub const SEVEN_EIGHTH: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct SC_MTCH_Info_BR_r14P_a_r14(pub u8);
impl SC_MTCH_Info_BR_r14P_a_r14 {
    pub const D_B_6: u8 = 0u8;
    pub const D_B_4DOT77: u8 = 1u8;
    pub const D_B_3: u8 = 2u8;
    pub const D_B_1DOT77: u8 = 3u8;
    pub const D_B0: u8 = 4u8;
    pub const D_B1: u8 = 5u8;
    pub const D_B2: u8 = 6u8;
    pub const D_B3: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct SC_MTCH_Info_r13G_RNTI_r13(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct SC_MTCH_Info_r13Sc_mtch_neighbourCell_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct SC_MTCH_SchedulingInfo_BR_r14OnDurationTimerSCPTM_r14(pub u8);
impl SC_MTCH_SchedulingInfo_BR_r14OnDurationTimerSCPTM_r14 {
    pub const PSF300: u8 = 0u8;
    pub const PSF400: u8 = 1u8;
    pub const PSF500: u8 = 2u8;
    pub const PSF600: u8 = 3u8;
    pub const PSF800: u8 = 4u8;
    pub const PSF1000: u8 = 5u8;
    pub const PSF1200: u8 = 6u8;
    pub const PSF1600: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct SC_MTCH_SchedulingInfo_BR_r14Drx_InactivityTimerSCPTM_r14(pub u8);
impl SC_MTCH_SchedulingInfo_BR_r14Drx_InactivityTimerSCPTM_r14 {
    pub const PSF0: u8 = 0u8;
    pub const PSF1: u8 = 1u8;
    pub const PSF2: u8 = 2u8;
    pub const PSF4: u8 = 3u8;
    pub const PSF8: u8 = 4u8;
    pub const PSF16: u8 = 5u8;
    pub const PSF32: u8 = 6u8;
    pub const PSF64: u8 = 7u8;
    pub const PSF128: u8 = 8u8;
    pub const PSF256: u8 = 9u8;
    pub const PS512: u8 = 10u8;
    pub const PSF1024: u8 = 11u8;
    pub const PSF2048: u8 = 12u8;
    pub const PSF4096: u8 = 13u8;
    pub const PSF8192: u8 = 14u8;
    pub const PSF16384: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "9")]
pub struct SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf10(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "19")]
pub struct SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf20(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf32(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "39")]
pub struct SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf40(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63")]
pub struct SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf64(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "79")]
pub struct SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf80(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "127")]
pub struct SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf128(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "159")]
pub struct SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf160(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf256(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "319")]
pub struct SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf320(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "511")]
pub struct SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf512(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "639")]
pub struct SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf640(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf1024(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf2048(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf4096(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "8191")]
pub struct SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf8192(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "15", extensible = false)]
pub enum SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14 {
    #[asn(key = 0, extended = false)]
    Sf10(SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf10),
    #[asn(key = 1, extended = false)]
    Sf20(SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf20),
    #[asn(key = 2, extended = false)]
    Sf32(SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf32),
    #[asn(key = 3, extended = false)]
    Sf40(SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf40),
    #[asn(key = 4, extended = false)]
    Sf64(SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf64),
    #[asn(key = 5, extended = false)]
    Sf80(SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf80),
    #[asn(key = 6, extended = false)]
    Sf128(SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf128),
    #[asn(key = 7, extended = false)]
    Sf160(SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf160),
    #[asn(key = 8, extended = false)]
    Sf256(SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf256),
    #[asn(key = 9, extended = false)]
    Sf320(SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf320),
    #[asn(key = 10, extended = false)]
    Sf512(SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf512),
    #[asn(key = 11, extended = false)]
    Sf640(SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf640),
    #[asn(key = 12, extended = false)]
    Sf1024(SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf1024),
    #[asn(key = 13, extended = false)]
    Sf2048(SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf2048),
    #[asn(key = 14, extended = false)]
    Sf4096(SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf4096),
    #[asn(key = 15, extended = false)]
    Sf8192(SC_MTCH_SchedulingInfo_BR_r14SchedulingPeriodStartOffsetSCPTM_r14_sf8192),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct SC_MTCH_SchedulingInfo_r13OnDurationTimerSCPTM_r13(pub u8);
impl SC_MTCH_SchedulingInfo_r13OnDurationTimerSCPTM_r13 {
    pub const PSF1: u8 = 0u8;
    pub const PSF2: u8 = 1u8;
    pub const PSF3: u8 = 2u8;
    pub const PSF4: u8 = 3u8;
    pub const PSF5: u8 = 4u8;
    pub const PSF6: u8 = 5u8;
    pub const PSF8: u8 = 6u8;
    pub const PSF10: u8 = 7u8;
    pub const PSF20: u8 = 8u8;
    pub const PSF30: u8 = 9u8;
    pub const PSF40: u8 = 10u8;
    pub const PSF50: u8 = 11u8;
    pub const PSF60: u8 = 12u8;
    pub const PSF80: u8 = 13u8;
    pub const PSF100: u8 = 14u8;
    pub const PSF200: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct SC_MTCH_SchedulingInfo_r13Drx_InactivityTimerSCPTM_r13(pub u8);
impl SC_MTCH_SchedulingInfo_r13Drx_InactivityTimerSCPTM_r13 {
    pub const PSF0: u8 = 0u8;
    pub const PSF1: u8 = 1u8;
    pub const PSF2: u8 = 2u8;
    pub const PSF4: u8 = 3u8;
    pub const PSF8: u8 = 4u8;
    pub const PSF10: u8 = 5u8;
    pub const PSF20: u8 = 6u8;
    pub const PSF40: u8 = 7u8;
    pub const PSF80: u8 = 8u8;
    pub const PSF160: u8 = 9u8;
    pub const PS320: u8 = 10u8;
    pub const PSF640: u8 = 11u8;
    pub const PSF960: u8 = 12u8;
    pub const PSF1280: u8 = 13u8;
    pub const PSF1920: u8 = 14u8;
    pub const PSF2560: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "9")]
pub struct SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf10(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "19")]
pub struct SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf20(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf32(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "39")]
pub struct SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf40(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63")]
pub struct SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf64(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "79")]
pub struct SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf80(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "127")]
pub struct SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf128(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "159")]
pub struct SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf160(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf256(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "319")]
pub struct SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf320(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "511")]
pub struct SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf512(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "639")]
pub struct SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf640(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf1024(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2048")]
pub struct SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf2048(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4096")]
pub struct SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf4096(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "8192")]
pub struct SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf8192(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "15", extensible = false)]
pub enum SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13 {
    #[asn(key = 0, extended = false)]
    Sf10(SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf10),
    #[asn(key = 1, extended = false)]
    Sf20(SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf20),
    #[asn(key = 2, extended = false)]
    Sf32(SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf32),
    #[asn(key = 3, extended = false)]
    Sf40(SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf40),
    #[asn(key = 4, extended = false)]
    Sf64(SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf64),
    #[asn(key = 5, extended = false)]
    Sf80(SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf80),
    #[asn(key = 6, extended = false)]
    Sf128(SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf128),
    #[asn(key = 7, extended = false)]
    Sf160(SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf160),
    #[asn(key = 8, extended = false)]
    Sf256(SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf256),
    #[asn(key = 9, extended = false)]
    Sf320(SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf320),
    #[asn(key = 10, extended = false)]
    Sf512(SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf512),
    #[asn(key = 11, extended = false)]
    Sf640(SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf640),
    #[asn(key = 12, extended = false)]
    Sf1024(SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf1024),
    #[asn(key = 13, extended = false)]
    Sf2048(SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf2048),
    #[asn(key = 14, extended = false)]
    Sf4096(SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf4096),
    #[asn(key = 15, extended = false)]
    Sf8192(SC_MTCH_SchedulingInfo_r13SchedulingPeriodStartOffsetSCPTM_r13_sf8192),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SCG_Config_r12CriticalExtensions_c1_spare7;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SCG_Config_r12CriticalExtensions_c1_spare6;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SCG_Config_r12CriticalExtensions_c1_spare5;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SCG_Config_r12CriticalExtensions_c1_spare4;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SCG_Config_r12CriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SCG_Config_r12CriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SCG_Config_r12CriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "7", extensible = false)]
pub enum SCG_Config_r12CriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    Scg_Config_r12(SCG_Config_r12_IEs),
    #[asn(key = 1, extended = false)]
    Spare7(SCG_Config_r12CriticalExtensions_c1_spare7),
    #[asn(key = 2, extended = false)]
    Spare6(SCG_Config_r12CriticalExtensions_c1_spare6),
    #[asn(key = 3, extended = false)]
    Spare5(SCG_Config_r12CriticalExtensions_c1_spare5),
    #[asn(key = 4, extended = false)]
    Spare4(SCG_Config_r12CriticalExtensions_c1_spare4),
    #[asn(key = 5, extended = false)]
    Spare3(SCG_Config_r12CriticalExtensions_c1_spare3),
    #[asn(key = 6, extended = false)]
    Spare2(SCG_Config_r12CriticalExtensions_c1_spare2),
    #[asn(key = 7, extended = false)]
    Spare1(SCG_Config_r12CriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SCG_Config_r12CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SCG_Config_r12CriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(SCG_Config_r12CriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(SCG_Config_r12CriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SCG_Config_v12i0a_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SCG_Config_v12i0b_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SCG_Config_v13c0_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SCG_ConfigInfo_r12CriticalExtensions_c1_spare7;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SCG_ConfigInfo_r12CriticalExtensions_c1_spare6;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SCG_ConfigInfo_r12CriticalExtensions_c1_spare5;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SCG_ConfigInfo_r12CriticalExtensions_c1_spare4;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SCG_ConfigInfo_r12CriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SCG_ConfigInfo_r12CriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SCG_ConfigInfo_r12CriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "7", extensible = false)]
pub enum SCG_ConfigInfo_r12CriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    Scg_ConfigInfo_r12(SCG_ConfigInfo_r12_IEs),
    #[asn(key = 1, extended = false)]
    Spare7(SCG_ConfigInfo_r12CriticalExtensions_c1_spare7),
    #[asn(key = 2, extended = false)]
    Spare6(SCG_ConfigInfo_r12CriticalExtensions_c1_spare6),
    #[asn(key = 3, extended = false)]
    Spare5(SCG_ConfigInfo_r12CriticalExtensions_c1_spare5),
    #[asn(key = 4, extended = false)]
    Spare4(SCG_ConfigInfo_r12CriticalExtensions_c1_spare4),
    #[asn(key = 5, extended = false)]
    Spare3(SCG_ConfigInfo_r12CriticalExtensions_c1_spare3),
    #[asn(key = 6, extended = false)]
    Spare2(SCG_ConfigInfo_r12CriticalExtensions_c1_spare2),
    #[asn(key = 7, extended = false)]
    Spare1(SCG_ConfigInfo_r12CriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SCG_ConfigInfo_r12CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SCG_ConfigInfo_r12CriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(SCG_ConfigInfo_r12CriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(SCG_ConfigInfo_r12CriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SCG_ConfigInfo_r12_IEsEutra_CapabilityInfo_r12(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SCG_ConfigInfo_r12_IEsMbmsInterestIndication_r12(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SCG_ConfigInfo_v1430_IEsMakeBeforeBreakSCG_Req_r14(pub u8);
impl SCG_ConfigInfo_v1430_IEsMakeBeforeBreakSCG_Req_r14 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SCG_ConfigInfo_v1530_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "100")]
pub struct SCG_ConfigRestrictInfo_r12MaxSCH_TB_BitsDL_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "100")]
pub struct SCG_ConfigRestrictInfo_r12MaxSCH_TB_BitsUL_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SCG_Configuration_r12_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct SCG_Configuration_r12_setupScg_ConfigPartMCG_r12Scg_Counter_r12(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SCG_Configuration_r12_setupScg_ConfigPartMCG_r12 {
    #[asn(optional_idx = 0)]
    pub scg_counter_r12: Option<SCG_Configuration_r12_setupScg_ConfigPartMCG_r12Scg_Counter_r12>,
    #[asn(optional_idx = 1)]
    pub power_coordination_info_r12: Option<PowerCoordinationInfo_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SCG_Configuration_r12_setup {
    #[asn(optional_idx = 0)]
    pub scg_config_part_mcg_r12: Option<SCG_Configuration_r12_setupScg_ConfigPartMCG_r12>,
    #[asn(optional_idx = 1)]
    pub scg_config_part_scg_r12: Option<SCG_ConfigPartSCG_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SCG_Configuration_v12f0_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SCG_Configuration_v12f0_setup {
    #[asn(optional_idx = 0)]
    pub scg_config_part_scg_v12f0: Option<SCG_ConfigPartSCG_v12f0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SCG_Configuration_v13c0_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SCG_Configuration_v13c0_setup {
    #[asn(optional_idx = 0)]
    pub scg_config_part_scg_v13c0: Option<SCG_ConfigPartSCG_v13c0>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct SCG_DeactivationPreferenceConfig_r17Scg_DeactivationPreferenceProhibitTimer_r17(pub u8);
impl SCG_DeactivationPreferenceConfig_r17Scg_DeactivationPreferenceProhibitTimer_r17 {
    pub const S0: u8 = 0u8;
    pub const S1: u8 = 1u8;
    pub const S2: u8 = 2u8;
    pub const S4: u8 = 3u8;
    pub const S8: u8 = 4u8;
    pub const S10: u8 = 5u8;
    pub const S20: u8 = 6u8;
    pub const S30: u8 = 7u8;
    pub const S60: u8 = 8u8;
    pub const S120: u8 = 9u8;
    pub const S180: u8 = 10u8;
    pub const S240: u8 = 11u8;
    pub const S300: u8 = 12u8;
    pub const S600: u8 = 13u8;
    pub const S900: u8 = 14u8;
    pub const S1800: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SCGFailureInformation_r12CriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SCGFailureInformation_r12CriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SCGFailureInformation_r12CriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum SCGFailureInformation_r12CriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    ScgFailureInformation_r12(SCGFailureInformation_r12_IEs),
    #[asn(key = 1, extended = false)]
    Spare3(SCGFailureInformation_r12CriticalExtensions_c1_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(SCGFailureInformation_r12CriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(SCGFailureInformation_r12CriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SCGFailureInformation_r12CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SCGFailureInformation_r12CriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(SCGFailureInformation_r12CriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(SCGFailureInformation_r12CriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SCGFailureInformation_v12d0a_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SCGFailureInformation_v12d0a_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SCGFailureInformation_v12d0b_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SCGFailureInformationNR_r15CriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SCGFailureInformationNR_r15CriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SCGFailureInformationNR_r15CriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum SCGFailureInformationNR_r15CriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    ScgFailureInformationNR_r15(SCGFailureInformationNR_r15_IEs),
    #[asn(key = 1, extended = false)]
    Spare3(SCGFailureInformationNR_r15CriticalExtensions_c1_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(SCGFailureInformationNR_r15CriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(SCGFailureInformationNR_r15CriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SCGFailureInformationNR_r15CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SCGFailureInformationNR_r15CriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(SCGFailureInformationNR_r15CriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        SCGFailureInformationNR_r15CriticalExtensions_criticalExtensionsFuture,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SCGFailureInformationNR_v1590_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SCGFailureInformationNR_v1590_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SCPTM_Parameters_r13Scptm_ParallelReception_r13(pub u8);
impl SCPTM_Parameters_r13Scptm_ParallelReception_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SCPTM_Parameters_r13Scptm_SCell_r13(pub u8);
impl SCPTM_Parameters_r13Scptm_SCell_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SCPTM_Parameters_r13Scptm_NonServingCell_r13(pub u8);
impl SCPTM_Parameters_r13Scptm_NonServingCell_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SCPTM_Parameters_r13Scptm_AsyncDC_r13(pub u8);
impl SCPTM_Parameters_r13Scptm_AsyncDC_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct SCPTMConfiguration_BR_r14P_b_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SCPTMConfiguration_BR_r14LateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct SCPTMConfiguration_BR_v1610MultiTB_Gap_r16(pub u8);
impl SCPTMConfiguration_BR_v1610MultiTB_Gap_r16 {
    pub const SF2: u8 = 0u8;
    pub const SF4: u8 = 1u8;
    pub const SF8: u8 = 2u8;
    pub const SF16: u8 = 3u8;
    pub const SF32: u8 = 4u8;
    pub const SF64: u8 = 5u8;
    pub const SF128: u8 = 6u8;
    pub const SPARE: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SCPTMConfiguration_BR_v1610NonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SCPTMConfiguration_r13LateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct SCPTMConfiguration_v1340P_b_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SCPTMConfiguration_v1340NonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SCellToAddMod_r10CellIdentification_r10 {
    pub phys_cell_id_r10: PhysCellId,
    pub dl_carrier_freq_r10: ARFCN_ValueEUTRA,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SCellToAddMod_r16CellIdentification_r16 {
    pub phys_cell_id_r16: PhysCellId,
    pub dl_carrier_freq_r16: ARFCN_ValueEUTRA_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct SCellToAddMod_r16Srs_SwitchFromServCellIndex_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SCellToAddMod_r16SCellState_r16(pub u8);
impl SCellToAddMod_r16SCellState_r16 {
    pub const ACTIVATED: u8 = 0u8;
    pub const DORMANT: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SCellToAddModExt_r13CellIdentification_r13 {
    pub phys_cell_id_r13: PhysCellId,
    pub dl_carrier_freq_r13: ARFCN_ValueEUTRA_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct SCellToAddModExt_v1430Srs_SwitchFromServCellIndex_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "6")]
pub struct SIB8_PerPLMN_r11Plmn_Identity_r11(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SIB8_PerPLMN_r11ParametersCDMA2000_r11_defaultValue;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SIB8_PerPLMN_r11ParametersCDMA2000_r11 {
    #[asn(key = 0, extended = false)]
    ExplicitValue(ParametersCDMA2000_r11),
    #[asn(key = 1, extended = false)]
    DefaultValue(SIB8_PerPLMN_r11ParametersCDMA2000_r11_defaultValue),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_AllowedCarrierFreqList_r15AllowedCarrierFreqSet1(pub Vec<ARFCN_ValueEUTRA_r9>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_AllowedCarrierFreqList_r15AllowedCarrierFreqSet2(pub Vec<ARFCN_ValueEUTRA_r9>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SL_CBR_CommonTxConfigList_r14Cbr_RangeCommonConfigList_r14(
    pub Vec<SL_CBR_Levels_Config_r14>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct SL_CBR_CommonTxConfigList_r14Sl_CBR_PSSCH_TxConfigList_r14(
    pub Vec<SL_CBR_PSSCH_TxConfig_r14>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "10000")]
pub struct SL_CBR_PSSCH_TxConfig_r14Cr_Limit_r14(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_CBR_PreconfigTxConfigList_r14Cbr_RangeCommonConfigList_r14(
    pub Vec<SL_CBR_Levels_Config_r14>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct SL_CBR_PreconfigTxConfigList_r14Sl_CBR_PSSCH_TxConfigList_r14(
    pub Vec<SL_CBR_PSSCH_TxConfig_r14>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SL_CommConfig_r12CommTxResources_r12_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "28")]
pub struct SL_CommConfig_r12CommTxResources_r12_setup_scheduled_r12Mcs_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SL_CommConfig_r12CommTxResources_r12_setup_scheduled_r12 {
    pub sl_rnti_r12: C_RNTI,
    pub mac_main_config_r12: MAC_MainConfigSL_r12,
    pub sc_comm_tx_config_r12: SL_CommResourcePool_r12,
    #[asn(optional_idx = 0)]
    pub mcs_r12: Option<SL_CommConfig_r12CommTxResources_r12_setup_scheduled_r12Mcs_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SL_CommConfig_r12CommTxResources_r12_setup_ue_Selected_r12CommTxPoolNormalDedicated_r12 {
    #[asn(optional_idx = 0)]
    pub pool_to_release_list_r12: Option<SL_TxPoolToReleaseList_r12>,
    #[asn(optional_idx = 1)]
    pub pool_to_add_mod_list_r12: Option<SL_CommTxPoolToAddModList_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_CommConfig_r12CommTxResources_r12_setup_ue_Selected_r12 {
    pub comm_tx_pool_normal_dedicated_r12:
        SL_CommConfig_r12CommTxResources_r12_setup_ue_Selected_r12CommTxPoolNormalDedicated_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SL_CommConfig_r12CommTxResources_r12_setup {
    #[asn(key = 0, extended = false)]
    Scheduled_r12(SL_CommConfig_r12CommTxResources_r12_setup_scheduled_r12),
    #[asn(key = 1, extended = false)]
    Ue_Selected_r12(SL_CommConfig_r12CommTxResources_r12_setup_ue_Selected_r12),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SL_CommConfig_r12CommTxResources_r12 {
    #[asn(key = 0, extended = false)]
    Release(SL_CommConfig_r12CommTxResources_r12_release),
    #[asn(key = 1, extended = false)]
    Setup(SL_CommConfig_r12CommTxResources_r12_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SL_CommResourcePool_r12Ue_SelectedResourceConfig_r12 {
    pub data_tf_resource_config_r12: SL_TF_ResourceConfig_r12,
    #[asn(optional_idx = 0)]
    pub trpt_subset_r12: Option<SL_TRPT_Subset_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct SL_CommResourcePool_r12RxParametersNCell_r12SyncConfigIndex_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SL_CommResourcePool_r12RxParametersNCell_r12 {
    #[asn(optional_idx = 0)]
    pub tdd_config_r12: Option<TDD_Config>,
    pub sync_config_index_r12: SL_CommResourcePool_r12RxParametersNCell_r12SyncConfigIndex_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_CommResourcePool_r12TxParameters_r12 {
    pub sc_tx_parameters_r12: SL_TxParameters_r12,
    pub data_tx_parameters_r12: SL_TxParameters_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct SL_CommResourcePoolV2X_r14AdjacencyPSCCH_PSSCH_r14(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "31")]
pub struct SL_CommResourcePoolV2X_r14SizeSubchannel_r14(pub u8);
impl SL_CommResourcePoolV2X_r14SizeSubchannel_r14 {
    pub const N4: u8 = 0u8;
    pub const N5: u8 = 1u8;
    pub const N6: u8 = 2u8;
    pub const N8: u8 = 3u8;
    pub const N9: u8 = 4u8;
    pub const N10: u8 = 5u8;
    pub const N12: u8 = 6u8;
    pub const N15: u8 = 7u8;
    pub const N16: u8 = 8u8;
    pub const N18: u8 = 9u8;
    pub const N20: u8 = 10u8;
    pub const N25: u8 = 11u8;
    pub const N30: u8 = 12u8;
    pub const N48: u8 = 13u8;
    pub const N50: u8 = 14u8;
    pub const N72: u8 = 15u8;
    pub const N75: u8 = 16u8;
    pub const N96: u8 = 17u8;
    pub const N100: u8 = 18u8;
    pub const SPARE13: u8 = 19u8;
    pub const SPARE12: u8 = 20u8;
    pub const SPARE11: u8 = 21u8;
    pub const SPARE10: u8 = 22u8;
    pub const SPARE9: u8 = 23u8;
    pub const SPARE8: u8 = 24u8;
    pub const SPARE7: u8 = 25u8;
    pub const SPARE6: u8 = 26u8;
    pub const SPARE5: u8 = 27u8;
    pub const SPARE4: u8 = 28u8;
    pub const SPARE3: u8 = 29u8;
    pub const SPARE2: u8 = 30u8;
    pub const SPARE1: u8 = 31u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct SL_CommResourcePoolV2X_r14NumSubchannel_r14(pub u8);
impl SL_CommResourcePoolV2X_r14NumSubchannel_r14 {
    pub const N1: u8 = 0u8;
    pub const N3: u8 = 1u8;
    pub const N5: u8 = 2u8;
    pub const N8: u8 = 3u8;
    pub const N10: u8 = 4u8;
    pub const N15: u8 = 5u8;
    pub const N20: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "99")]
pub struct SL_CommResourcePoolV2X_r14StartRB_Subchannel_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "99")]
pub struct SL_CommResourcePoolV2X_r14StartRB_PSCCH_Pool_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct SL_CommResourcePoolV2X_r14RxParametersNCell_r14SyncConfigIndex_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SL_CommResourcePoolV2X_r14RxParametersNCell_r14 {
    #[asn(optional_idx = 0)]
    pub tdd_config_r14: Option<TDD_Config>,
    pub sync_config_index_r14: SL_CommResourcePoolV2X_r14RxParametersNCell_r14SyncConfigIndex_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct SL_CommResourcePoolV2X_r14ZoneID_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "45")]
pub struct SL_CommResourcePoolV2X_r14ThreshS_RSSI_CBR_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct SL_CommTxPoolSensingConfig_r14ProbResourceKeep_r14(pub u8);
impl SL_CommTxPoolSensingConfig_r14ProbResourceKeep_r14 {
    pub const V0: u8 = 0u8;
    pub const V0DOT2: u8 = 1u8;
    pub const V0DOT4: u8 = 2u8;
    pub const V0DOT6: u8 = 3u8;
    pub const V0DOT8: u8 = 4u8;
    pub const SPARE3: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "13")]
pub struct SL_CommTxPoolSensingConfig_r14P2x_SensingConfig_r14MinNumCandidateSF_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "10", sz_ub = "10")]
pub struct SL_CommTxPoolSensingConfig_r14P2x_SensingConfig_r14GapCandidateSensing_r14(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_CommTxPoolSensingConfig_r14P2x_SensingConfig_r14 {
    pub min_num_candidate_sf_r14:
        SL_CommTxPoolSensingConfig_r14P2x_SensingConfig_r14MinNumCandidateSF_r14,
    pub gap_candidate_sensing_r14:
        SL_CommTxPoolSensingConfig_r14P2x_SensingConfig_r14GapCandidateSensing_r14,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct SL_CommTxPoolSensingConfig_r14Sl_ReselectAfter_r14(pub u8);
impl SL_CommTxPoolSensingConfig_r14Sl_ReselectAfter_r14 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N3: u8 = 2u8;
    pub const N4: u8 = 3u8;
    pub const N5: u8 = 4u8;
    pub const N6: u8 = 5u8;
    pub const N7: u8 = 6u8;
    pub const N8: u8 = 7u8;
    pub const N9: u8 = 8u8;
    pub const SPARE7: u8 = 9u8;
    pub const SPARE6: u8 = 10u8;
    pub const SPARE5: u8 = 11u8;
    pub const SPARE4: u8 = 12u8;
    pub const SPARE3: u8 = 13u8;
    pub const SPARE2: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SL_DiscConfig_r12DiscTxResources_r12_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SL_DiscConfig_r12DiscTxResources_r12_setup_scheduled_r12 {
    #[asn(optional_idx = 0)]
    pub disc_tx_config_r12: Option<SL_DiscResourcePool_r12>,
    #[asn(optional_idx = 1)]
    pub disc_tf_index_list_r12: Option<SL_TF_IndexPairList_r12>,
    #[asn(optional_idx = 2)]
    pub disc_hopping_config_r12: Option<SL_HoppingConfigDisc_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SL_DiscConfig_r12DiscTxResources_r12_setup_ue_Selected_r12DiscTxPoolDedicated_r12 {
    #[asn(optional_idx = 0)]
    pub pool_to_release_list_r12: Option<SL_TxPoolToReleaseList_r12>,
    #[asn(optional_idx = 1)]
    pub pool_to_add_mod_list_r12: Option<SL_DiscTxPoolToAddModList_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SL_DiscConfig_r12DiscTxResources_r12_setup_ue_Selected_r12 {
    #[asn(optional_idx = 0)]
    pub disc_tx_pool_dedicated_r12:
        Option<SL_DiscConfig_r12DiscTxResources_r12_setup_ue_Selected_r12DiscTxPoolDedicated_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SL_DiscConfig_r12DiscTxResources_r12_setup {
    #[asn(key = 0, extended = false)]
    Scheduled_r12(SL_DiscConfig_r12DiscTxResources_r12_setup_scheduled_r12),
    #[asn(key = 1, extended = false)]
    Ue_Selected_r12(SL_DiscConfig_r12DiscTxResources_r12_setup_ue_Selected_r12),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SL_DiscConfig_r12DiscTxResources_r12 {
    #[asn(key = 0, extended = false)]
    Release(SL_DiscConfig_r12DiscTxResources_r12_release),
    #[asn(key = 1, extended = false)]
    Setup(SL_DiscConfig_r12DiscTxResources_r12_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_DiscConfigOtherInterFreq_r13RefCarrierCommon_r13(pub u8);
impl SL_DiscConfigOtherInterFreq_r13RefCarrierCommon_r13 {
    pub const P_CELL: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct SL_DiscConfigRelayUE_r13HystMax_r13(pub u8);
impl SL_DiscConfigRelayUE_r13HystMax_r13 {
    pub const D_B0: u8 = 0u8;
    pub const D_B3: u8 = 1u8;
    pub const D_B6: u8 = 2u8;
    pub const D_B9: u8 = 3u8;
    pub const D_B12: u8 = 4u8;
    pub const D_BINF: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "4")]
pub struct SL_DiscConfigRelayUE_r13HystMin_r13(pub u8);
impl SL_DiscConfigRelayUE_r13HystMin_r13 {
    pub const D_B0: u8 = 0u8;
    pub const D_B3: u8 = 1u8;
    pub const D_B6: u8 = 2u8;
    pub const D_B9: u8 = 3u8;
    pub const D_B12: u8 = 4u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "4")]
pub struct SL_DiscConfigRemoteUE_r13HystMax_r13(pub u8);
impl SL_DiscConfigRemoteUE_r13HystMax_r13 {
    pub const D_B0: u8 = 0u8;
    pub const D_B3: u8 = 1u8;
    pub const D_B6: u8 = 2u8;
    pub const D_B9: u8 = 3u8;
    pub const D_B12: u8 = 4u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct SL_DiscResourcePool_r12DiscPeriod_r12(pub u8);
impl SL_DiscResourcePool_r12DiscPeriod_r12 {
    pub const RF32: u8 = 0u8;
    pub const RF64: u8 = 1u8;
    pub const RF128: u8 = 2u8;
    pub const RF256: u8 = 3u8;
    pub const RF512: u8 = 4u8;
    pub const RF1024: u8 = 5u8;
    pub const RF16_V1310: u8 = 6u8;
    pub const SPARE: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct SL_DiscResourcePool_r12NumRetx_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "50")]
pub struct SL_DiscResourcePool_r12NumRepetition_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SL_DiscResourcePool_r12TxParameters_r12Ue_SelectedResourceConfig_r12PoolSelection_r12_random_r12;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SL_DiscResourcePool_r12TxParameters_r12Ue_SelectedResourceConfig_r12PoolSelection_r12 {
    # [asn (key = 0 , extended = false)] RsrpBased_r12 (SL_PoolSelectionConfig_r12) , # [asn (key = 1 , extended = false)] Random_r12 (SL_DiscResourcePool_r12TxParameters_r12Ue_SelectedResourceConfig_r12PoolSelection_r12_random_r12) , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SL_DiscResourcePool_r12TxParameters_r12Ue_SelectedResourceConfig_r12TxProbability_r12(
    pub u8,
);
impl SL_DiscResourcePool_r12TxParameters_r12Ue_SelectedResourceConfig_r12TxProbability_r12 {
    pub const P25: u8 = 0u8;
    pub const P50: u8 = 1u8;
    pub const P75: u8 = 2u8;
    pub const P100: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_DiscResourcePool_r12TxParameters_r12Ue_SelectedResourceConfig_r12 {
    pub pool_selection_r12:
        SL_DiscResourcePool_r12TxParameters_r12Ue_SelectedResourceConfig_r12PoolSelection_r12,
    pub tx_probability_r12:
        SL_DiscResourcePool_r12TxParameters_r12Ue_SelectedResourceConfig_r12TxProbability_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SL_DiscResourcePool_r12TxParameters_r12 {
    pub tx_parameters_general_r12: SL_TxParameters_r12,
    #[asn(optional_idx = 0)]
    pub ue_selected_resource_config_r12:
        Option<SL_DiscResourcePool_r12TxParameters_r12Ue_SelectedResourceConfig_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct SL_DiscResourcePool_r12RxParameters_r12SyncConfigIndex_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SL_DiscResourcePool_r12RxParameters_r12 {
    #[asn(optional_idx = 0)]
    pub tdd_config_r12: Option<TDD_Config>,
    pub sync_config_index_r12: SL_DiscResourcePool_r12RxParameters_r12SyncConfigIndex_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8")]
pub struct SL_DiscSysInfoReport_r13DiscCellSelectionInfo_r13Q_RxLevMinOffset_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SL_DiscSysInfoReport_r13DiscCellSelectionInfo_r13 {
    pub q_rx_lev_min_r13: Q_RxLevMin,
    #[asn(optional_idx = 0)]
    pub q_rx_lev_min_offset_r13:
        Option<SL_DiscSysInfoReport_r13DiscCellSelectionInfo_r13Q_RxLevMinOffset_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct SL_DiscSysInfoReport_r13CellReselectionInfo_r13Q_Hyst_r13(pub u8);
impl SL_DiscSysInfoReport_r13CellReselectionInfo_r13Q_Hyst_r13 {
    pub const D_B0: u8 = 0u8;
    pub const D_B1: u8 = 1u8;
    pub const D_B2: u8 = 2u8;
    pub const D_B3: u8 = 3u8;
    pub const D_B4: u8 = 4u8;
    pub const D_B5: u8 = 5u8;
    pub const D_B6: u8 = 6u8;
    pub const D_B8: u8 = 7u8;
    pub const D_B10: u8 = 8u8;
    pub const D_B12: u8 = 9u8;
    pub const D_B14: u8 = 10u8;
    pub const D_B16: u8 = 11u8;
    pub const D_B18: u8 = 12u8;
    pub const D_B20: u8 = 13u8;
    pub const D_B22: u8 = 14u8;
    pub const D_B24: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_DiscSysInfoReport_r13CellReselectionInfo_r13 {
    pub q_hyst_r13: SL_DiscSysInfoReport_r13CellReselectionInfo_r13Q_Hyst_r13,
    pub q_rx_lev_min_r13: Q_RxLevMin,
    pub t_reselection_eutra_r13: T_Reselection,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct SL_DiscSysInfoReport_r13FreqInfo_r13Ul_Bandwidth_r13(pub u8);
impl SL_DiscSysInfoReport_r13FreqInfo_r13Ul_Bandwidth_r13 {
    pub const N6: u8 = 0u8;
    pub const N15: u8 = 1u8;
    pub const N25: u8 = 2u8;
    pub const N50: u8 = 3u8;
    pub const N75: u8 = 4u8;
    pub const N100: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SL_DiscSysInfoReport_r13FreqInfo_r13 {
    #[asn(optional_idx = 0)]
    pub ul_carrier_freq_r13: Option<ARFCN_ValueEUTRA>,
    #[asn(optional_idx = 1)]
    pub ul_bandwidth_r13: Option<SL_DiscSysInfoReport_r13FreqInfo_r13Ul_Bandwidth_r13>,
    #[asn(optional_idx = 2)]
    pub additional_spectrum_emission_r13: Option<AdditionalSpectrumEmission>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-60", ub = "50")]
pub struct SL_DiscSysInfoReport_r13ReferenceSignalPower_r13(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_DiscTxInfoInterFreqListAdd_r13DiscTxFreqToAddModList_r13(
    pub Vec<SL_DiscTxResourceInfoPerFreq_r13>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SL_DiscTxInfoInterFreqListAdd_r13DiscTxFreqToReleaseList_r13(
    pub Vec<ARFCN_ValueEUTRA_r9>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SL_DiscTxRefCarrierDedicated_r13_pCell;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SL_DiscTxResource_r13_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SL_DiscTxResource_r13_setup {
    #[asn(key = 0, extended = false)]
    Scheduled_r13(SL_DiscTxConfigScheduled_r13),
    #[asn(key = 1, extended = false)]
    Ue_Selected_r13(SL_DiscTxPoolDedicated_r13),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8")]
pub struct SL_DiscTxResourceReq_r13CarrierFreqDiscTx_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "63")]
pub struct SL_DiscTxResourceReq_r13DiscTxResourceReq_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SL_DiscTxResourcesInterFreq_r13_acquireSI_FromCarrier_r13;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SL_DiscTxResourcesInterFreq_r13_requestDedicated_r13;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SL_DiscTxResourcesInterFreq_r13_noTxOnCarrier_r13;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "14")]
pub struct SL_GapPattern_r13GapPeriod_r13(pub u8);
impl SL_GapPattern_r13GapPeriod_r13 {
    pub const SF40: u8 = 0u8;
    pub const SF60: u8 = 1u8;
    pub const SF70: u8 = 2u8;
    pub const SF80: u8 = 3u8;
    pub const SF120: u8 = 4u8;
    pub const SF140: u8 = 5u8;
    pub const SF160: u8 = 6u8;
    pub const SF240: u8 = 7u8;
    pub const SF280: u8 = 8u8;
    pub const SF320: u8 = 9u8;
    pub const SF640: u8 = 10u8;
    pub const SF1280: u8 = 11u8;
    pub const SF2560: u8 = 12u8;
    pub const SF5120: u8 = 13u8;
    pub const SF10240: u8 = 14u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "BITSTRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "10240"
)]
pub struct SL_GapPattern_r13GapSubframeBitmap_r13(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "504")]
pub struct SL_HoppingConfigComm_r12HoppingParameter_r12(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct SL_HoppingConfigComm_r12NumSubbands_r12(pub u8);
impl SL_HoppingConfigComm_r12NumSubbands_r12 {
    pub const NS1: u8 = 0u8;
    pub const NS2: u8 = 1u8;
    pub const NS4: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "110")]
pub struct SL_HoppingConfigComm_r12Rb_Offset_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "200")]
pub struct SL_HoppingConfigDisc_r12A_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "10")]
pub struct SL_HoppingConfigDisc_r12B_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SL_HoppingConfigDisc_r12C_r12(pub u8);
impl SL_HoppingConfigDisc_r12C_r12 {
    pub const N1: u8 = 0u8;
    pub const N5: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct SL_InterFreqInfoV2X_r14Sl_Bandwidth_r14(pub u8);
impl SL_InterFreqInfoV2X_r14Sl_Bandwidth_r14 {
    pub const N6: u8 = 0u8;
    pub const N15: u8 = 1u8;
    pub const N25: u8 = 2u8;
    pub const N50: u8 = 3u8;
    pub const N75: u8 = 4u8;
    pub const N100: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "10", ub = "20")]
pub struct SL_MinT2Value_r15MinT2Value_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "319")]
pub struct SL_OffsetIndicator_r12_small_r12(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "10239")]
pub struct SL_OffsetIndicator_r12_large_r12(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_P2X_ResourceSelectionConfig_r14PartialSensing_r14(pub u8);
impl SL_P2X_ResourceSelectionConfig_r14PartialSensing_r14 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_P2X_ResourceSelectionConfig_r14RandomSelection_r14(pub u8);
impl SL_P2X_ResourceSelectionConfig_r14RandomSelection_r14 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct SL_PPPP_TxConfigIndex_r14DefaultTxConfigIndex_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct SL_PPPP_TxConfigIndex_r14Cbr_ConfigIndex_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct SL_PPPP_TxConfigIndex_r14Tx_ConfigIndexList_r14(pub Vec<Tx_ConfigIndex_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct SL_PPPP_TxConfigIndex_r15DefaultTxConfigIndex_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct SL_PPPP_TxConfigIndex_r15Cbr_ConfigIndex_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct SL_PPPP_TxConfigIndex_r15Tx_ConfigIndexList_r15(pub Vec<Tx_ConfigIndex_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct SL_PPPP_TxConfigIndex_r15Mcs_PSSCH_RangeList_r15(pub Vec<MCS_PSSCH_Range_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct SL_PPPP_TxConfigIndex_v1530Mcs_PSSCH_RangeList_r15(pub Vec<MCS_PSSCH_Range_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct SL_PPPP_TxPreconfigIndex_r14DefaultTxConfigIndex_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct SL_PPPP_TxPreconfigIndex_r14Cbr_ConfigIndex_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct SL_PPPP_TxPreconfigIndex_r14Tx_ConfigIndexList_r14(pub Vec<Tx_PreconfigIndex_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct SL_PPPP_TxPreconfigIndex_v1530Mcs_PSSCH_Range_r15(pub Vec<MCS_PSSCH_Range_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct SL_PSSCH_TxConfig_r14ThresUE_Speed_r14(pub u8);
impl SL_PSSCH_TxConfig_r14ThresUE_Speed_r14 {
    pub const KMPH60: u8 = 0u8;
    pub const KMPH80: u8 = 1u8;
    pub const KMPH100: u8 = 2u8;
    pub const KMPH120: u8 = 3u8;
    pub const KMPH140: u8 = 4u8;
    pub const KMPH160: u8 = 5u8;
    pub const KMPH180: u8 = 6u8;
    pub const KMPH200: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct SL_PSSCH_TxParameters_r14MinMCS_PSSCH_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct SL_PSSCH_TxParameters_r14MaxMCS_PSSCH_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "20")]
pub struct SL_PSSCH_TxParameters_r14MinSubChannel_NumberPSSCH_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "20")]
pub struct SL_PSSCH_TxParameters_r14MaxSubchannel_NumberPSSCH_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SL_PSSCH_TxParameters_r14AllowedRetxNumberPSSCH_r14(pub u8);
impl SL_PSSCH_TxParameters_r14AllowedRetxNumberPSSCH_r14 {
    pub const N0: u8 = 0u8;
    pub const N1: u8 = 1u8;
    pub const BOTH: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct SL_PSSCH_TxParameters_v1530MinMCS_PSSCH_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct SL_PSSCH_TxParameters_v1530MaxMCS_PSSCH_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_Parameters_r12CommSimultaneousTx_r12(pub u8);
impl SL_Parameters_r12CommSimultaneousTx_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_Parameters_r12DiscScheduledResourceAlloc_r12(pub u8);
impl SL_Parameters_r12DiscScheduledResourceAlloc_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_Parameters_r12Disc_UE_SelectedResourceAlloc_r12(pub u8);
impl SL_Parameters_r12Disc_UE_SelectedResourceAlloc_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_Parameters_r12Disc_SLSS_r12(pub u8);
impl SL_Parameters_r12Disc_SLSS_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SL_Parameters_r12DiscSupportedProc_r12(pub u8);
impl SL_Parameters_r12DiscSupportedProc_r12 {
    pub const N50: u8 = 0u8;
    pub const N400: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_Parameters_v1310DiscSysInfoReporting_r13(pub u8);
impl SL_Parameters_v1310DiscSysInfoReporting_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_Parameters_v1310CommMultipleTx_r13(pub u8);
impl SL_Parameters_v1310CommMultipleTx_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_Parameters_v1310DiscInterFreqTx_r13(pub u8);
impl SL_Parameters_v1310DiscInterFreqTx_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_Parameters_v1310DiscPeriodicSLSS_r13(pub u8);
impl SL_Parameters_v1310DiscPeriodicSLSS_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_Parameters_v1430ZoneBasedPoolSelection_r14(pub u8);
impl SL_Parameters_v1430ZoneBasedPoolSelection_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_Parameters_v1430Ue_AutonomousWithFullSensing_r14(pub u8);
impl SL_Parameters_v1430Ue_AutonomousWithFullSensing_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_Parameters_v1430Ue_AutonomousWithPartialSensing_r14(pub u8);
impl SL_Parameters_v1430Ue_AutonomousWithPartialSensing_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_Parameters_v1430Sl_CongestionControl_r14(pub u8);
impl SL_Parameters_v1430Sl_CongestionControl_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_Parameters_v1430V2x_TxWithShortResvInterval_r14(pub u8);
impl SL_Parameters_v1430V2x_TxWithShortResvInterval_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct SL_Parameters_v1430V2x_numberTxRxTiming_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_Parameters_v1430V2x_nonAdjacentPSCCH_PSSCH_r14(pub u8);
impl SL_Parameters_v1430V2x_nonAdjacentPSCCH_PSSCH_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_Parameters_v1430Slss_TxRx_r14(pub u8);
impl SL_Parameters_v1430Slss_TxRx_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SL_Parameters_v1530Slss_SupportedTxFreq_r15(pub u8);
impl SL_Parameters_v1530Slss_SupportedTxFreq_r15 {
    pub const SINGLE: u8 = 0u8;
    pub const MULTIPLE: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_Parameters_v1530Sl_64QAM_Tx_r15(pub u8);
impl SL_Parameters_v1530Sl_64QAM_Tx_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_Parameters_v1530Sl_TxDiversity_r15(pub u8);
impl SL_Parameters_v1530Sl_TxDiversity_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_Parameters_v1540Sl_64QAM_Rx_r15(pub u8);
impl SL_Parameters_v1540Sl_64QAM_Rx_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_Parameters_v1540Sl_RateMatchingTBSScaling_r15(pub u8);
impl SL_Parameters_v1540Sl_RateMatchingTBSScaling_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_Parameters_v1540Sl_LowT2min_r15(pub u8);
impl SL_Parameters_v1540Sl_LowT2min_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_Parameters_v1540V2x_SensingReportingMode3_r15(pub u8);
impl SL_Parameters_v1540V2x_SensingReportingMode3_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SL_Parameters_v1610Sl_ParameterNR_r16(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct SL_PreconfigDiscPool_r13DiscPeriod_r13(pub u8);
impl SL_PreconfigDiscPool_r13DiscPeriod_r13 {
    pub const RF4: u8 = 0u8;
    pub const RF6: u8 = 1u8;
    pub const RF7: u8 = 2u8;
    pub const RF8: u8 = 3u8;
    pub const RF12: u8 = 4u8;
    pub const RF14: u8 = 5u8;
    pub const RF16: u8 = 6u8;
    pub const RF24: u8 = 7u8;
    pub const RF28: u8 = 8u8;
    pub const RF32: u8 = 9u8;
    pub const RF64: u8 = 10u8;
    pub const RF128: u8 = 11u8;
    pub const RF256: u8 = 12u8;
    pub const RF512: u8 = 13u8;
    pub const RF1024: u8 = 14u8;
    pub const SPARE: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct SL_PreconfigDiscPool_r13NumRetx_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "50")]
pub struct SL_PreconfigDiscPool_r13NumRepetition_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SL_PreconfigDiscPool_r13TxParameters_r13TxProbability_r13(pub u8);
impl SL_PreconfigDiscPool_r13TxParameters_r13TxProbability_r13 {
    pub const P25: u8 = 0u8;
    pub const P50: u8 = 1u8;
    pub const P75: u8 = 2u8;
    pub const P100: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_PreconfigDiscPool_r13TxParameters_r13 {
    pub tx_parameters_general_r13: P0_SL_r12,
    pub tx_probability_r13: SL_PreconfigDiscPool_r13TxParameters_r13TxProbability_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct SL_PreconfigGeneral_r12Rohc_Profiles_r12Profile0x0001_r12(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct SL_PreconfigGeneral_r12Rohc_Profiles_r12Profile0x0002_r12(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct SL_PreconfigGeneral_r12Rohc_Profiles_r12Profile0x0004_r12(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct SL_PreconfigGeneral_r12Rohc_Profiles_r12Profile0x0006_r12(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct SL_PreconfigGeneral_r12Rohc_Profiles_r12Profile0x0101_r12(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct SL_PreconfigGeneral_r12Rohc_Profiles_r12Profile0x0102_r12(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct SL_PreconfigGeneral_r12Rohc_Profiles_r12Profile0x0104_r12(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_PreconfigGeneral_r12Rohc_Profiles_r12 {
    pub profile0x0001_r12: SL_PreconfigGeneral_r12Rohc_Profiles_r12Profile0x0001_r12,
    pub profile0x0002_r12: SL_PreconfigGeneral_r12Rohc_Profiles_r12Profile0x0002_r12,
    pub profile0x0004_r12: SL_PreconfigGeneral_r12Rohc_Profiles_r12Profile0x0004_r12,
    pub profile0x0006_r12: SL_PreconfigGeneral_r12Rohc_Profiles_r12Profile0x0006_r12,
    pub profile0x0101_r12: SL_PreconfigGeneral_r12Rohc_Profiles_r12Profile0x0101_r12,
    pub profile0x0102_r12: SL_PreconfigGeneral_r12Rohc_Profiles_r12Profile0x0102_r12,
    pub profile0x0104_r12: SL_PreconfigGeneral_r12Rohc_Profiles_r12Profile0x0104_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct SL_PreconfigGeneral_r12Sl_bandwidth_r12(pub u8);
impl SL_PreconfigGeneral_r12Sl_bandwidth_r12 {
    pub const N6: u8 = 0u8;
    pub const N15: u8 = 1u8;
    pub const N25: u8 = 2u8;
    pub const N50: u8 = 3u8;
    pub const N75: u8 = 4u8;
    pub const N100: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "19", sz_ub = "19")]
pub struct SL_PreconfigGeneral_r12Reserved_r12(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "4")]
pub struct SL_PreconfigSync_r12SyncRefMinHyst_r12(pub u8);
impl SL_PreconfigSync_r12SyncRefMinHyst_r12 {
    pub const D_B0: u8 = 0u8;
    pub const D_B3: u8 = 1u8;
    pub const D_B6: u8 = 2u8;
    pub const D_B9: u8 = 3u8;
    pub const D_B12: u8 = 4u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct SL_PreconfigSync_r12SyncRefDiffHyst_r12(pub u8);
impl SL_PreconfigSync_r12SyncRefDiffHyst_r12 {
    pub const D_B0: u8 = 0u8;
    pub const D_B3: u8 = 1u8;
    pub const D_B6: u8 = 2u8;
    pub const D_B9: u8 = 3u8;
    pub const D_B12: u8 = 4u8;
    pub const D_BINF: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "4")]
pub struct SL_PreconfigV2X_Sync_r14SyncRefMinHyst_r14(pub u8);
impl SL_PreconfigV2X_Sync_r14SyncRefMinHyst_r14 {
    pub const D_B0: u8 = 0u8;
    pub const D_B3: u8 = 1u8;
    pub const D_B6: u8 = 2u8;
    pub const D_B9: u8 = 3u8;
    pub const D_B12: u8 = 4u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct SL_PreconfigV2X_Sync_r14SyncRefDiffHyst_r14(pub u8);
impl SL_PreconfigV2X_Sync_r14SyncRefDiffHyst_r14 {
    pub const D_B0: u8 = 0u8;
    pub const D_B3: u8 = 1u8;
    pub const D_B6: u8 = 2u8;
    pub const D_B9: u8 = 3u8;
    pub const D_B12: u8 = 4u8;
    pub const D_BINF: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_SyncAllowed_r14Gnss_Sync_r14(pub u8);
impl SL_SyncAllowed_r14Gnss_Sync_r14 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_SyncAllowed_r14Enb_Sync_r14(pub u8);
impl SL_SyncAllowed_r14Enb_Sync_r14 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_SyncAllowed_r14Ue_Sync_r14(pub u8);
impl SL_SyncAllowed_r14Ue_Sync_r14 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "19", sz_ub = "19")]
pub struct SL_SyncConfig_r12TxParameters_r12SyncInfoReserved_r12(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SL_SyncConfig_r12TxParameters_r12 {
    pub sync_tx_parameters_r12: SL_TxParameters_r12,
    pub sync_tx_thresh_ic_r12: RSRP_RangeSL_r12,
    #[asn(optional_idx = 0)]
    pub sync_info_reserved_r12: Option<SL_SyncConfig_r12TxParameters_r12SyncInfoReserved_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SL_SyncConfig_r12RxParamsNCell_r12DiscSyncWindow_r12(pub u8);
impl SL_SyncConfig_r12RxParamsNCell_r12DiscSyncWindow_r12 {
    pub const W1: u8 = 0u8;
    pub const W2: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_SyncConfig_r12RxParamsNCell_r12 {
    pub phys_cell_id_r12: PhysCellId,
    pub disc_sync_window_r12: SL_SyncConfig_r12RxParamsNCell_r12DiscSyncWindow_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_SyncConfigNFreq_r13AsyncParameters_r13 {
    pub sync_cp_len_r13: SL_CP_Len_r12,
    pub sync_offset_indicator_r13: SL_OffsetIndicatorSync_r12,
    pub slssid_r13: SLSSID_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "19", sz_ub = "19")]
pub struct SL_SyncConfigNFreq_r13TxParameters_r13SyncInfoReserved_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SL_SyncConfigNFreq_r13TxParameters_r13SyncTxPeriodic_r13(pub u8);
impl SL_SyncConfigNFreq_r13TxParameters_r13SyncTxPeriodic_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SL_SyncConfigNFreq_r13TxParameters_r13 {
    pub sync_tx_parameters_r13: SL_TxParameters_r12,
    pub sync_tx_thresh_ic_r13: RSRP_RangeSL_r12,
    #[asn(optional_idx = 0)]
    pub sync_info_reserved_r13: Option<SL_SyncConfigNFreq_r13TxParameters_r13SyncInfoReserved_r13>,
    #[asn(optional_idx = 1)]
    pub sync_tx_periodic_r13: Option<SL_SyncConfigNFreq_r13TxParameters_r13SyncTxPeriodic_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SL_SyncConfigNFreq_r13RxParameters_r13DiscSyncWindow_r13(pub u8);
impl SL_SyncConfigNFreq_r13RxParameters_r13DiscSyncWindow_r13 {
    pub const W1: u8 = 0u8;
    pub const W2: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_SyncConfigNFreq_r13RxParameters_r13 {
    pub disc_sync_window_r13: SL_SyncConfigNFreq_r13RxParameters_r13DiscSyncWindow_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SL_SyncTxControl_r12NetworkControlledSyncTx_r12(pub u8);
impl SL_SyncTxControl_r12NetworkControlledSyncTx_r12 {
    pub const ON: u8 = 0u8;
    pub const OFF: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "200")]
pub struct SL_TF_IndexPair_r12DiscSF_Index_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "50")]
pub struct SL_TF_IndexPair_r12DiscPRB_Index_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "209")]
pub struct SL_TF_IndexPair_r12bDiscSF_Index_r12b(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "49")]
pub struct SL_TF_IndexPair_r12bDiscPRB_Index_r12b(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "100")]
pub struct SL_TF_ResourceConfig_r12Prb_Num_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "99")]
pub struct SL_TF_ResourceConfig_r12Prb_Start_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "99")]
pub struct SL_TF_ResourceConfig_r12Prb_End_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SL_TxPower_r14_minusinfinity_r14;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-41", ub = "31")]
pub struct SL_TxPower_r14_txPower_r14(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct SL_V2X_CommFreqList_r14_Entry(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct SL_V2X_CommTxResourceReq_r14CarrierFreqCommTx_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1000")]
pub struct SL_V2X_ConfigCommon_r14OffsetDFN_r14(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SL_V2X_ConfigDedicated_r14CommTxResources_r14_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct SL_V2X_ConfigDedicated_r14CommTxResources_r14_setup_scheduled_r14Mcs_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SL_V2X_ConfigDedicated_r14CommTxResources_r14_setup_scheduled_r14 {
    pub sl_v_rnti_r14: C_RNTI,
    pub mac_main_config_r14: MAC_MainConfigSL_r12,
    #[asn(optional_idx = 0)]
    pub v2x_scheduling_pool_r14: Option<SL_CommResourcePoolV2X_r14>,
    #[asn(optional_idx = 1)]
    pub mcs_r14: Option<SL_V2X_ConfigDedicated_r14CommTxResources_r14_setup_scheduled_r14Mcs_r14>,
    pub logical_ch_group_info_list_r14: LogicalChGroupInfoList_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SL_V2X_ConfigDedicated_r14CommTxResources_r14_setup_ue_Selected_r14V2x_CommTxPoolNormalDedicated_r14
{
    #[asn(optional_idx = 0)]
    pub pool_to_release_list_r14: Option<SL_TxPoolToReleaseListV2X_r14>,
    #[asn(optional_idx = 1)]
    pub pool_to_add_mod_list_r14: Option<SL_TxPoolToAddModListV2X_r14>,
    #[asn(optional_idx = 2)]
    pub v2x_comm_tx_pool_sensing_config_r14: Option<SL_CommTxPoolSensingConfig_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SL_V2X_ConfigDedicated_r14CommTxResources_r14_setup_ue_Selected_r14 { pub v2x_comm_tx_pool_normal_dedicated_r14 : SL_V2X_ConfigDedicated_r14CommTxResources_r14_setup_ue_Selected_r14V2x_CommTxPoolNormalDedicated_r14 , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SL_V2X_ConfigDedicated_r14CommTxResources_r14_setup {
    #[asn(key = 0, extended = false)]
    Scheduled_r14(SL_V2X_ConfigDedicated_r14CommTxResources_r14_setup_scheduled_r14),
    #[asn(key = 1, extended = false)]
    Ue_Selected_r14(SL_V2X_ConfigDedicated_r14CommTxResources_r14_setup_ue_Selected_r14),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SL_V2X_ConfigDedicated_r14CommTxResources_r14 {
    #[asn(key = 0, extended = false)]
    Release(SL_V2X_ConfigDedicated_r14CommTxResources_r14_release),
    #[asn(key = 1, extended = false)]
    Setup(SL_V2X_ConfigDedicated_r14CommTxResources_r14_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1000")]
pub struct SL_V2X_InterFreqUE_Config_r14OffsetDFN_r14(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct SL_V2X_PreconfigCommPool_r14AdjacencyPSCCH_PSSCH_r14(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "31")]
pub struct SL_V2X_PreconfigCommPool_r14SizeSubchannel_r14(pub u8);
impl SL_V2X_PreconfigCommPool_r14SizeSubchannel_r14 {
    pub const N4: u8 = 0u8;
    pub const N5: u8 = 1u8;
    pub const N6: u8 = 2u8;
    pub const N8: u8 = 3u8;
    pub const N9: u8 = 4u8;
    pub const N10: u8 = 5u8;
    pub const N12: u8 = 6u8;
    pub const N15: u8 = 7u8;
    pub const N16: u8 = 8u8;
    pub const N18: u8 = 9u8;
    pub const N20: u8 = 10u8;
    pub const N25: u8 = 11u8;
    pub const N30: u8 = 12u8;
    pub const N48: u8 = 13u8;
    pub const N50: u8 = 14u8;
    pub const N72: u8 = 15u8;
    pub const N75: u8 = 16u8;
    pub const N96: u8 = 17u8;
    pub const N100: u8 = 18u8;
    pub const SPARE13: u8 = 19u8;
    pub const SPARE12: u8 = 20u8;
    pub const SPARE11: u8 = 21u8;
    pub const SPARE10: u8 = 22u8;
    pub const SPARE9: u8 = 23u8;
    pub const SPARE8: u8 = 24u8;
    pub const SPARE7: u8 = 25u8;
    pub const SPARE6: u8 = 26u8;
    pub const SPARE5: u8 = 27u8;
    pub const SPARE4: u8 = 28u8;
    pub const SPARE3: u8 = 29u8;
    pub const SPARE2: u8 = 30u8;
    pub const SPARE1: u8 = 31u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct SL_V2X_PreconfigCommPool_r14NumSubchannel_r14(pub u8);
impl SL_V2X_PreconfigCommPool_r14NumSubchannel_r14 {
    pub const N1: u8 = 0u8;
    pub const N3: u8 = 1u8;
    pub const N5: u8 = 2u8;
    pub const N8: u8 = 3u8;
    pub const N10: u8 = 4u8;
    pub const N15: u8 = 5u8;
    pub const N20: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "99")]
pub struct SL_V2X_PreconfigCommPool_r14StartRB_Subchannel_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "99")]
pub struct SL_V2X_PreconfigCommPool_r14StartRB_PSCCH_Pool_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct SL_V2X_PreconfigCommPool_r14ZoneID_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "45")]
pub struct SL_V2X_PreconfigCommPool_r14ThreshS_RSSI_CBR_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SL_V2X_PreconfigFreqInfo_r14SyncPriority_r14(pub u8);
impl SL_V2X_PreconfigFreqInfo_r14SyncPriority_r14 {
    pub const GNSS: u8 = 0u8;
    pub const ENB: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1000")]
pub struct SL_V2X_PreconfigFreqInfo_r14OffsetDFN_r14(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct SL_ZoneConfig_r14ZoneLength_r14(pub u8);
impl SL_ZoneConfig_r14ZoneLength_r14 {
    pub const M5: u8 = 0u8;
    pub const M10: u8 = 1u8;
    pub const M20: u8 = 2u8;
    pub const M50: u8 = 3u8;
    pub const M100: u8 = 4u8;
    pub const M200: u8 = 5u8;
    pub const M500: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct SL_ZoneConfig_r14ZoneWidth_r14(pub u8);
impl SL_ZoneConfig_r14ZoneWidth_r14 {
    pub const M5: u8 = 0u8;
    pub const M10: u8 = 1u8;
    pub const M20: u8 = 2u8;
    pub const M50: u8 = 3u8;
    pub const M100: u8 = 4u8;
    pub const M200: u8 = 5u8;
    pub const M500: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4")]
pub struct SL_ZoneConfig_r14ZoneIdLongiMod_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4")]
pub struct SL_ZoneConfig_r14ZoneIdLatiMod_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SON_Parameters_r9Rach_Report_r9(pub u8);
impl SON_Parameters_r9Rach_Report_r9 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SPDCCH_Config_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct SPDCCH_Config_r15_setupSpdcch_L1_ReuseIndication_r15(pub u8);
impl SPDCCH_Config_r15_setupSpdcch_L1_ReuseIndication_r15 {
    pub const N0: u8 = 0u8;
    pub const N1: u8 = 1u8;
    pub const N2: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SPDCCH_Config_r15_setup {
    #[asn(optional_idx = 0)]
    pub spdcch_l1_reuse_indication_r15:
        Option<SPDCCH_Config_r15_setupSpdcch_L1_ReuseIndication_r15>,
    #[asn(optional_idx = 1)]
    pub spdcch_set_config_r15: Option<SPDCCH_Set_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SPDCCH_Elements_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct SPDCCH_Elements_r15_setupSpdcch_SetConfigId_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SPDCCH_Elements_r15_setupSpdcch_SetReferenceSig_r15(pub u8);
impl SPDCCH_Elements_r15_setupSpdcch_SetReferenceSig_r15 {
    pub const CRS: u8 = 0u8;
    pub const DMRS: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SPDCCH_Elements_r15_setupTransmissionType_r15(pub u8);
impl SPDCCH_Elements_r15_setupTransmissionType_r15 {
    pub const LOCALISED: u8 = 0u8;
    pub const DISTRIBUTED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "2")]
pub struct SPDCCH_Elements_r15_setupSpdcch_NoOfSymbols_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "503")]
pub struct SPDCCH_Elements_r15_setupDmrs_ScramblingSequenceInt_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SPDCCH_Elements_r15_setupDci7_CandidatesPerAL_PDCCH_r15(pub Vec<DCI7_Candidates_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct SPDCCH_Elements_r15_setupDci7_CandidateSetsPerAL_SPDCCH_r15(
    pub Vec<DCI7_CandidatesPerAL_SPDCCH_r15>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "2", ub = "100")]
pub struct SPDCCH_Elements_r15_setupResourceBlockAssignment_r15NumberRB_InFreq_domain_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "98", sz_ub = "98")]
pub struct SPDCCH_Elements_r15_setupResourceBlockAssignment_r15ResourceBlockAssignment_r15(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SPDCCH_Elements_r15_setupResourceBlockAssignment_r15 {
    pub number_rb_in_freq_domain_r15:
        SPDCCH_Elements_r15_setupResourceBlockAssignment_r15NumberRB_InFreq_domain_r15,
    pub resource_block_assignment_r15:
        SPDCCH_Elements_r15_setupResourceBlockAssignment_r15ResourceBlockAssignment_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "5", sz_ub = "5")]
pub struct SPDCCH_Elements_r15_setupSubslotApplicability_r15(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "49")]
pub struct SPDCCH_Elements_r15_setupAl_StartingPointSPDCCH_r15_Entry(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SPDCCH_Elements_r15_setupAl_StartingPointSPDCCH_r15(
    pub Vec<SPDCCH_Elements_r15_setupAl_StartingPointSPDCCH_r15_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct SPDCCH_Elements_r15_setupSubframeType_r15(pub u8);
impl SPDCCH_Elements_r15_setupSubframeType_r15 {
    pub const MBSFN: u8 = 0u8;
    pub const NONMBSFN: u8 = 1u8;
    pub const ALL: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SPDCCH_Elements_r15_setupRateMatchingMode_r15(pub u8);
impl SPDCCH_Elements_r15_setupRateMatchingMode_r15 {
    pub const M1: u8 = 0u8;
    pub const M2: u8 = 1u8;
    pub const M3: u8 = 2u8;
    pub const M4: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 12)]
pub struct SPDCCH_Elements_r15_setup {
    #[asn(optional_idx = 0)]
    pub spdcch_set_config_id_r15: Option<SPDCCH_Elements_r15_setupSpdcch_SetConfigId_r15>,
    #[asn(optional_idx = 1)]
    pub spdcch_set_reference_sig_r15: Option<SPDCCH_Elements_r15_setupSpdcch_SetReferenceSig_r15>,
    #[asn(optional_idx = 2)]
    pub transmission_type_r15: Option<SPDCCH_Elements_r15_setupTransmissionType_r15>,
    #[asn(optional_idx = 3)]
    pub spdcch_no_of_symbols_r15: Option<SPDCCH_Elements_r15_setupSpdcch_NoOfSymbols_r15>,
    #[asn(optional_idx = 4)]
    pub dmrs_scrambling_sequence_int_r15:
        Option<SPDCCH_Elements_r15_setupDmrs_ScramblingSequenceInt_r15>,
    #[asn(optional_idx = 5)]
    pub dci7_candidates_per_al_pdcch_r15:
        Option<SPDCCH_Elements_r15_setupDci7_CandidatesPerAL_PDCCH_r15>,
    #[asn(optional_idx = 6)]
    pub dci7_candidate_sets_per_al_spdcch_r15:
        Option<SPDCCH_Elements_r15_setupDci7_CandidateSetsPerAL_SPDCCH_r15>,
    #[asn(optional_idx = 7)]
    pub resource_block_assignment_r15: Option<SPDCCH_Elements_r15_setupResourceBlockAssignment_r15>,
    #[asn(optional_idx = 8)]
    pub subslot_applicability_r15: Option<SPDCCH_Elements_r15_setupSubslotApplicability_r15>,
    #[asn(optional_idx = 9)]
    pub al_starting_point_spdcch_r15: Option<SPDCCH_Elements_r15_setupAl_StartingPointSPDCCH_r15>,
    #[asn(optional_idx = 10)]
    pub subframe_type_r15: Option<SPDCCH_Elements_r15_setupSubframeType_r15>,
    #[asn(optional_idx = 11)]
    pub rate_matching_mode_r15: Option<SPDCCH_Elements_r15_setupRateMatchingMode_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SPS_ConfigDL_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct SPS_ConfigDL_setupSemiPersistSchedIntervalDL(pub u8);
impl SPS_ConfigDL_setupSemiPersistSchedIntervalDL {
    pub const SF10: u8 = 0u8;
    pub const SF20: u8 = 1u8;
    pub const SF32: u8 = 2u8;
    pub const SF40: u8 = 3u8;
    pub const SF64: u8 = 4u8;
    pub const SF80: u8 = 5u8;
    pub const SF128: u8 = 6u8;
    pub const SF160: u8 = 7u8;
    pub const SF320: u8 = 8u8;
    pub const SF640: u8 = 9u8;
    pub const SPARE6: u8 = 10u8;
    pub const SPARE5: u8 = 11u8;
    pub const SPARE4: u8 = 12u8;
    pub const SPARE3: u8 = 13u8;
    pub const SPARE2: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8")]
pub struct SPS_ConfigDL_setupNumberOfConfSPS_Processes(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SPS_ConfigDL_setup {
    pub semi_persist_sched_interval_dl: SPS_ConfigDL_setupSemiPersistSchedIntervalDL,
    pub number_of_conf_sps_processes: SPS_ConfigDL_setupNumberOfConfSPS_Processes,
    pub n1pucch_an_persistent_list: N1PUCCH_AN_PersistentList,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SPS_ConfigDL_STTI_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct SPS_ConfigDL_STTI_r15_setupSemiPersistSchedIntervalDL_STTI_r15(pub u8);
impl SPS_ConfigDL_STTI_r15_setupSemiPersistSchedIntervalDL_STTI_r15 {
    pub const S_TTI1: u8 = 0u8;
    pub const S_TTI2: u8 = 1u8;
    pub const S_TTI3: u8 = 2u8;
    pub const S_TTI4: u8 = 3u8;
    pub const S_TTI6: u8 = 4u8;
    pub const S_TTI8: u8 = 5u8;
    pub const S_TTI12: u8 = 6u8;
    pub const S_TTI16: u8 = 7u8;
    pub const S_TTI20: u8 = 8u8;
    pub const S_TTI40: u8 = 9u8;
    pub const S_TTI60: u8 = 10u8;
    pub const S_TTI80: u8 = 11u8;
    pub const S_TTI120: u8 = 12u8;
    pub const S_TTI240: u8 = 13u8;
    pub const SPARE2: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "12")]
pub struct SPS_ConfigDL_STTI_r15_setupNumberOfConfSPS_Processes_STTI_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SPS_ConfigDL_STTI_r15_setupTwoAntennaPortActivated_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SPS_ConfigDL_STTI_r15_setupTwoAntennaPortActivated_r15_setup {
    pub n1spucch_an_persistent_list_p1_r15: N1SPUCCH_AN_PersistentList_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SPS_ConfigDL_STTI_r15_setupTwoAntennaPortActivated_r15 {
    #[asn(key = 0, extended = false)]
    Release(SPS_ConfigDL_STTI_r15_setupTwoAntennaPortActivated_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(SPS_ConfigDL_STTI_r15_setupTwoAntennaPortActivated_r15_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "5")]
pub struct SPS_ConfigDL_STTI_r15_setupSTTI_StartTimeDL_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SPS_ConfigDL_STTI_r15_setup {
    pub semi_persist_sched_interval_dl_stti_r15:
        SPS_ConfigDL_STTI_r15_setupSemiPersistSchedIntervalDL_STTI_r15,
    pub number_of_conf_sps_processes_stti_r15:
        SPS_ConfigDL_STTI_r15_setupNumberOfConfSPS_Processes_STTI_r15,
    #[asn(optional_idx = 0)]
    pub two_antenna_port_activated_r15:
        Option<SPS_ConfigDL_STTI_r15_setupTwoAntennaPortActivated_r15>,
    pub stti_start_time_dl_r15: SPS_ConfigDL_STTI_r15_setupSTTI_StartTimeDL_r15,
    #[asn(optional_idx = 1)]
    pub tpc_pdcch_config_pucch_sps_r15: Option<TPC_PDCCH_Config>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct SPS_ConfigSL_r14SemiPersistSchedIntervalSL_r14(pub u8);
impl SPS_ConfigSL_r14SemiPersistSchedIntervalSL_r14 {
    pub const SF20: u8 = 0u8;
    pub const SF50: u8 = 1u8;
    pub const SF100: u8 = 2u8;
    pub const SF200: u8 = 3u8;
    pub const SF300: u8 = 4u8;
    pub const SF400: u8 = 5u8;
    pub const SF500: u8 = 6u8;
    pub const SF600: u8 = 7u8;
    pub const SF700: u8 = 8u8;
    pub const SF800: u8 = 9u8;
    pub const SF900: u8 = 10u8;
    pub const SF1000: u8 = 11u8;
    pub const SPARE4: u8 = 12u8;
    pub const SPARE3: u8 = 13u8;
    pub const SPARE2: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SPS_ConfigUL_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct SPS_ConfigUL_setupSemiPersistSchedIntervalUL(pub u8);
impl SPS_ConfigUL_setupSemiPersistSchedIntervalUL {
    pub const SF10: u8 = 0u8;
    pub const SF20: u8 = 1u8;
    pub const SF32: u8 = 2u8;
    pub const SF40: u8 = 3u8;
    pub const SF64: u8 = 4u8;
    pub const SF80: u8 = 5u8;
    pub const SF128: u8 = 6u8;
    pub const SF160: u8 = 7u8;
    pub const SF320: u8 = 8u8;
    pub const SF640: u8 = 9u8;
    pub const SF1_V1430: u8 = 10u8;
    pub const SF2_V1430: u8 = 11u8;
    pub const SF3_V1430: u8 = 12u8;
    pub const SF4_V1430: u8 = 13u8;
    pub const SF5_V1430: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SPS_ConfigUL_setupImplicitReleaseAfter(pub u8);
impl SPS_ConfigUL_setupImplicitReleaseAfter {
    pub const E2: u8 = 0u8;
    pub const E3: u8 = 1u8;
    pub const E4: u8 = 2u8;
    pub const E8: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-126", ub = "24")]
pub struct SPS_ConfigUL_setupP0_PersistentP0_NominalPUSCH_Persistent(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-8", ub = "7")]
pub struct SPS_ConfigUL_setupP0_PersistentP0_UE_PUSCH_Persistent(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SPS_ConfigUL_setupP0_Persistent {
    pub p0_nominal_pusch_persistent: SPS_ConfigUL_setupP0_PersistentP0_NominalPUSCH_Persistent,
    pub p0_ue_pusch_persistent: SPS_ConfigUL_setupP0_PersistentP0_UE_PUSCH_Persistent,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SPS_ConfigUL_setupTwoIntervalsConfig(pub u8);
impl SPS_ConfigUL_setupTwoIntervalsConfig {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SPS_ConfigUL_setup {
    pub semi_persist_sched_interval_ul: SPS_ConfigUL_setupSemiPersistSchedIntervalUL,
    pub implicit_release_after: SPS_ConfigUL_setupImplicitReleaseAfter,
    #[asn(optional_idx = 0)]
    pub p0_persistent: Option<SPS_ConfigUL_setupP0_Persistent>,
    #[asn(optional_idx = 1)]
    pub two_intervals_config: Option<SPS_ConfigUL_setupTwoIntervalsConfig>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SPS_ConfigUL_STTI_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct SPS_ConfigUL_STTI_r15_setupSemiPersistSchedIntervalUL_STTI_r15(pub u8);
impl SPS_ConfigUL_STTI_r15_setupSemiPersistSchedIntervalUL_STTI_r15 {
    pub const S_TTI1: u8 = 0u8;
    pub const S_TTI2: u8 = 1u8;
    pub const S_TTI3: u8 = 2u8;
    pub const S_TTI4: u8 = 3u8;
    pub const S_TTI6: u8 = 4u8;
    pub const S_TTI8: u8 = 5u8;
    pub const S_TTI12: u8 = 6u8;
    pub const S_TTI16: u8 = 7u8;
    pub const S_TTI20: u8 = 8u8;
    pub const S_TTI40: u8 = 9u8;
    pub const S_TTI60: u8 = 10u8;
    pub const S_TTI80: u8 = 11u8;
    pub const S_TTI120: u8 = 12u8;
    pub const S_TTI240: u8 = 13u8;
    pub const SPARE2: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SPS_ConfigUL_STTI_r15_setupImplicitReleaseAfter(pub u8);
impl SPS_ConfigUL_STTI_r15_setupImplicitReleaseAfter {
    pub const E2: u8 = 0u8;
    pub const E3: u8 = 1u8;
    pub const E4: u8 = 2u8;
    pub const E8: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-126", ub = "24")]
pub struct SPS_ConfigUL_STTI_r15_setupP0_Persistent_r15P0_NominalSPUSCH_Persistent_r15(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-8", ub = "7")]
pub struct SPS_ConfigUL_STTI_r15_setupP0_Persistent_r15P0_UE_SPUSCH_Persistent_r15(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SPS_ConfigUL_STTI_r15_setupP0_Persistent_r15 {
    pub p0_nominal_spusch_persistent_r15:
        SPS_ConfigUL_STTI_r15_setupP0_Persistent_r15P0_NominalSPUSCH_Persistent_r15,
    pub p0_ue_spusch_persistent_r15:
        SPS_ConfigUL_STTI_r15_setupP0_Persistent_r15P0_UE_SPUSCH_Persistent_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SPS_ConfigUL_STTI_r15_setupTwoIntervalsConfig_r15(pub u8);
impl SPS_ConfigUL_STTI_r15_setupTwoIntervalsConfig_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SPS_ConfigUL_STTI_r15_setupP0_PersistentSubframeSet2_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-126", ub = "24")]
pub struct SPS_ConfigUL_STTI_r15_setupP0_PersistentSubframeSet2_r15_setupP0_NominalSPUSCH_PersistentSubframeSet2_r15(
    pub i8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-8", ub = "7")]
pub struct SPS_ConfigUL_STTI_r15_setupP0_PersistentSubframeSet2_r15_setupP0_UE_SPUSCH_PersistentSubframeSet2_r15(
    pub i8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SPS_ConfigUL_STTI_r15_setupP0_PersistentSubframeSet2_r15_setup { pub p0_nominal_spusch_persistent_subframe_set2_r15 : SPS_ConfigUL_STTI_r15_setupP0_PersistentSubframeSet2_r15_setupP0_NominalSPUSCH_PersistentSubframeSet2_r15 , pub p0_ue_spusch_persistent_subframe_set2_r15 : SPS_ConfigUL_STTI_r15_setupP0_PersistentSubframeSet2_r15_setupP0_UE_SPUSCH_PersistentSubframeSet2_r15 , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SPS_ConfigUL_STTI_r15_setupP0_PersistentSubframeSet2_r15 {
    #[asn(key = 0, extended = false)]
    Release(SPS_ConfigUL_STTI_r15_setupP0_PersistentSubframeSet2_r15_release),
    #[asn(key = 1, extended = false)]
    Setup(SPS_ConfigUL_STTI_r15_setupP0_PersistentSubframeSet2_r15_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "12")]
pub struct SPS_ConfigUL_STTI_r15_setupNumberOfConfUL_SPS_Processes_STTI_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "5")]
pub struct SPS_ConfigUL_STTI_r15_setupSTTI_StartTimeUL_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct SPS_ConfigUL_STTI_r15_setupCyclicShiftSPS_sTTI_r15(pub u8);
impl SPS_ConfigUL_STTI_r15_setupCyclicShiftSPS_sTTI_r15 {
    pub const CS0: u8 = 0u8;
    pub const CS1: u8 = 1u8;
    pub const CS2: u8 = 2u8;
    pub const CS3: u8 = 3u8;
    pub const CS4: u8 = 4u8;
    pub const CS5: u8 = 5u8;
    pub const CS6: u8 = 6u8;
    pub const CS7: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct SPS_ConfigUL_STTI_r15_setupIfdma_Config_SPS_r15(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct SPS_ConfigUL_STTI_r15_setupHarq_ProcID_offset_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct SPS_ConfigUL_STTI_r15_setupRv_SPS_STTI_UL_Repetitions_r15(pub u8);
impl SPS_ConfigUL_STTI_r15_setupRv_SPS_STTI_UL_Repetitions_r15 {
    pub const ULRVSEQ1: u8 = 0u8;
    pub const ULRVSEQ2: u8 = 1u8;
    pub const ULRVSEQ3: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SPS_ConfigUL_STTI_r15_setupTbs_scalingFactorSubslotSPS_UL_Repetitions_r15(pub u8);
impl SPS_ConfigUL_STTI_r15_setupTbs_scalingFactorSubslotSPS_UL_Repetitions_r15 {
    pub const N6: u8 = 0u8;
    pub const N12: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SPS_ConfigUL_STTI_r15_setupTotalNumberPUSCH_SPS_STTI_UL_Repetitions_r15(pub u8);
impl SPS_ConfigUL_STTI_r15_setupTotalNumberPUSCH_SPS_STTI_UL_Repetitions_r15 {
    pub const N2: u8 = 0u8;
    pub const N3: u8 = 1u8;
    pub const N4: u8 = 2u8;
    pub const N6: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 12)]
pub struct SPS_ConfigUL_STTI_r15_setup {
    pub semi_persist_sched_interval_ul_stti_r15:
        SPS_ConfigUL_STTI_r15_setupSemiPersistSchedIntervalUL_STTI_r15,
    pub implicit_release_after: SPS_ConfigUL_STTI_r15_setupImplicitReleaseAfter,
    #[asn(optional_idx = 0)]
    pub p0_persistent_r15: Option<SPS_ConfigUL_STTI_r15_setupP0_Persistent_r15>,
    #[asn(optional_idx = 1)]
    pub two_intervals_config_r15: Option<SPS_ConfigUL_STTI_r15_setupTwoIntervalsConfig_r15>,
    #[asn(optional_idx = 2)]
    pub p0_persistent_subframe_set2_r15:
        Option<SPS_ConfigUL_STTI_r15_setupP0_PersistentSubframeSet2_r15>,
    #[asn(optional_idx = 3)]
    pub number_of_conf_ul_sps_processes_stti_r15:
        Option<SPS_ConfigUL_STTI_r15_setupNumberOfConfUL_SPS_Processes_STTI_r15>,
    pub stti_start_time_ul_r15: SPS_ConfigUL_STTI_r15_setupSTTI_StartTimeUL_r15,
    #[asn(optional_idx = 4)]
    pub tpc_pdcch_config_pusch_sps_r15: Option<TPC_PDCCH_Config>,
    #[asn(optional_idx = 5)]
    pub cyclic_shift_sps_s_tti_r15: Option<SPS_ConfigUL_STTI_r15_setupCyclicShiftSPS_sTTI_r15>,
    #[asn(optional_idx = 6)]
    pub ifdma_config_sps_r15: Option<SPS_ConfigUL_STTI_r15_setupIfdma_Config_SPS_r15>,
    #[asn(optional_idx = 7)]
    pub harq_proc_id_offset_r15: Option<SPS_ConfigUL_STTI_r15_setupHarq_ProcID_offset_r15>,
    #[asn(optional_idx = 8)]
    pub rv_sps_stti_ul_repetitions_r15:
        Option<SPS_ConfigUL_STTI_r15_setupRv_SPS_STTI_UL_Repetitions_r15>,
    #[asn(optional_idx = 9)]
    pub sps_config_index_r15: Option<SPS_ConfigIndex_r15>,
    #[asn(optional_idx = 10)]
    pub tbs_scaling_factor_subslot_sps_ul_repetitions_r15:
        Option<SPS_ConfigUL_STTI_r15_setupTbs_scalingFactorSubslotSPS_UL_Repetitions_r15>,
    #[asn(optional_idx = 11)]
    pub total_number_pusch_sps_stti_ul_repetitions_r15:
        Option<SPS_ConfigUL_STTI_r15_setupTotalNumberPUSCH_SPS_STTI_UL_Repetitions_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct SPT_Parameters_r15FrameStructureType_SPT_r15(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32")]
pub struct SPT_Parameters_r15MaxNumberCCs_SPT_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SPUCCH_Config_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SPUCCH_Config_r15_setupTwoAntennaPortActivatedSPUCCH_Format1a1b_r15(pub u8);
impl SPUCCH_Config_r15_setupTwoAntennaPortActivatedSPUCCH_Format1a1b_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "549")]
pub struct SPUCCH_Config_r15_setupDummyN3SPUCCH_AN_List_r15_Entry(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SPUCCH_Config_r15_setupDummyN3SPUCCH_AN_List_r15(
    pub Vec<SPUCCH_Config_r15_setupDummyN3SPUCCH_AN_List_r15_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SPUCCH_Config_r15_setupDummy {
    pub n3spucch_an_list_r15: SPUCCH_Config_r15_setupDummyN3SPUCCH_AN_List_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SPUCCH_Config_r15_setup {
    #[asn(optional_idx = 0)]
    pub spucch_set_r15: Option<SPUCCH_Set_r15>,
    #[asn(optional_idx = 1)]
    pub two_antenna_port_activated_spucch_format1a1b_r15:
        Option<SPUCCH_Config_r15_setupTwoAntennaPortActivatedSPUCCH_Format1a1b_r15>,
    pub dummy: SPUCCH_Config_r15_setupDummy,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SPUCCH_Config_v1550_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "549")]
pub struct SPUCCH_Config_v1550_setupTwoAntennaPortActivatedSPUCCH_Format3_v1550N3SPUCCH_AN_List_v1550_Entry(
    pub u16,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SPUCCH_Config_v1550_setupTwoAntennaPortActivatedSPUCCH_Format3_v1550N3SPUCCH_AN_List_v1550 (pub Vec < SPUCCH_Config_v1550_setupTwoAntennaPortActivatedSPUCCH_Format3_v1550N3SPUCCH_AN_List_v1550_Entry >) ;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SPUCCH_Config_v1550_setupTwoAntennaPortActivatedSPUCCH_Format3_v1550 {
    pub n3spucch_an_list_v1550:
        SPUCCH_Config_v1550_setupTwoAntennaPortActivatedSPUCCH_Format3_v1550N3SPUCCH_AN_List_v1550,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SPUCCH_Config_v1550_setup {
    pub two_antenna_port_activated_spucch_format3_v1550:
        SPUCCH_Config_v1550_setupTwoAntennaPortActivatedSPUCCH_Format3_v1550,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SPUCCH_Elements_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1319")]
pub struct SPUCCH_Elements_r15_setupN1SubslotSPUCCH_AN_List_r15_Entry(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SPUCCH_Elements_r15_setupN1SubslotSPUCCH_AN_List_r15(
    pub Vec<SPUCCH_Elements_r15_setupN1SubslotSPUCCH_AN_List_r15_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1319")]
pub struct SPUCCH_Elements_r15_setupN1SlotSPUCCH_FH_AN_List_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3959")]
pub struct SPUCCH_Elements_r15_setupN1SlotSPUCCH_NoFH_AN_List_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "549")]
pub struct SPUCCH_Elements_r15_setupN3SPUCCH_AN_List_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct SPUCCH_Elements_r15_setupN4SPUCCHSlot_Resource_r15(pub Vec<N4SPUCCH_Resource_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct SPUCCH_Elements_r15_setupN4SPUCCHSubslot_Resource_r15(pub Vec<N4SPUCCH_Resource_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct SPUCCH_Elements_r15_setupN4maxCoderateSlotPUCCH_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct SPUCCH_Elements_r15_setupN4maxCoderateSubslotPUCCH_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct SPUCCH_Elements_r15_setupN4maxCoderateMultiResourceSlotPUCCH_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct SPUCCH_Elements_r15_setupN4maxCoderateMultiResourceSubslotPUCCH_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 10)]
pub struct SPUCCH_Elements_r15_setup {
    #[asn(optional_idx = 0)]
    pub n1_subslot_spucch_an_list_r15: Option<SPUCCH_Elements_r15_setupN1SubslotSPUCCH_AN_List_r15>,
    #[asn(optional_idx = 1)]
    pub n1_slot_spucch_fh_an_list_r15: Option<SPUCCH_Elements_r15_setupN1SlotSPUCCH_FH_AN_List_r15>,
    #[asn(optional_idx = 2)]
    pub n1_slot_spucch_no_fh_an_list_r15:
        Option<SPUCCH_Elements_r15_setupN1SlotSPUCCH_NoFH_AN_List_r15>,
    #[asn(optional_idx = 3)]
    pub n3spucch_an_list_r15: Option<SPUCCH_Elements_r15_setupN3SPUCCH_AN_List_r15>,
    #[asn(optional_idx = 4)]
    pub n4spucch_slot_resource_r15: Option<SPUCCH_Elements_r15_setupN4SPUCCHSlot_Resource_r15>,
    #[asn(optional_idx = 5)]
    pub n4spucch_subslot_resource_r15:
        Option<SPUCCH_Elements_r15_setupN4SPUCCHSubslot_Resource_r15>,
    #[asn(optional_idx = 6)]
    pub n4max_coderate_slot_pucch_r15: Option<SPUCCH_Elements_r15_setupN4maxCoderateSlotPUCCH_r15>,
    #[asn(optional_idx = 7)]
    pub n4max_coderate_subslot_pucch_r15:
        Option<SPUCCH_Elements_r15_setupN4maxCoderateSubslotPUCCH_r15>,
    #[asn(optional_idx = 8)]
    pub n4max_coderate_multi_resource_slot_pucch_r15:
        Option<SPUCCH_Elements_r15_setupN4maxCoderateMultiResourceSlotPUCCH_r15>,
    #[asn(optional_idx = 9)]
    pub n4max_coderate_multi_resource_subslot_pucch_r15:
        Option<SPUCCH_Elements_r15_setupN4maxCoderateMultiResourceSubslotPUCCH_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1319")]
pub struct SR_SubslotSPUCCH_ResourceList_r15_Entry(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "2")]
pub struct SRB_ToAddModSrb_Identity(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SRB_ToAddModRlc_Config_defaultValue;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SRB_ToAddModRlc_Config {
    #[asn(key = 0, extended = false)]
    ExplicitValue(RLC_Config),
    #[asn(key = 1, extended = false)]
    DefaultValue(SRB_ToAddModRlc_Config_defaultValue),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SRB_ToAddModLogicalChannelConfig_defaultValue;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SRB_ToAddModLogicalChannelConfig {
    #[asn(key = 0, extended = false)]
    ExplicitValue(LogicalChannelConfig),
    #[asn(key = 1, extended = false)]
    DefaultValue(SRB_ToAddModLogicalChannelConfig_defaultValue),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "2")]
pub struct SRB_ToReleaseList_r15_Entry(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct SRS_CC_SetIndex_r14Cc_SetIndex_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct SRS_CC_SetIndex_r14Cc_IndexInOneCC_Set_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct SRS_CapabilityPerBandPair_r14RetuningInfoRf_RetuningTimeDL_r14(pub u8);
impl SRS_CapabilityPerBandPair_r14RetuningInfoRf_RetuningTimeDL_r14 {
    pub const N0: u8 = 0u8;
    pub const N0DOT5: u8 = 1u8;
    pub const N1: u8 = 2u8;
    pub const N1DOT5: u8 = 3u8;
    pub const N2: u8 = 4u8;
    pub const N2DOT5: u8 = 5u8;
    pub const N3: u8 = 6u8;
    pub const N3DOT5: u8 = 7u8;
    pub const N4: u8 = 8u8;
    pub const N4DOT5: u8 = 9u8;
    pub const N5: u8 = 10u8;
    pub const N5DOT5: u8 = 11u8;
    pub const N6: u8 = 12u8;
    pub const N6DOT5: u8 = 13u8;
    pub const N7: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct SRS_CapabilityPerBandPair_r14RetuningInfoRf_RetuningTimeUL_r14(pub u8);
impl SRS_CapabilityPerBandPair_r14RetuningInfoRf_RetuningTimeUL_r14 {
    pub const N0: u8 = 0u8;
    pub const N0DOT5: u8 = 1u8;
    pub const N1: u8 = 2u8;
    pub const N1DOT5: u8 = 3u8;
    pub const N2: u8 = 4u8;
    pub const N2DOT5: u8 = 5u8;
    pub const N3: u8 = 6u8;
    pub const N3DOT5: u8 = 7u8;
    pub const N4: u8 = 8u8;
    pub const N4DOT5: u8 = 9u8;
    pub const N5: u8 = 10u8;
    pub const N5DOT5: u8 = 11u8;
    pub const N6: u8 = 12u8;
    pub const N6DOT5: u8 = 13u8;
    pub const N7: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SRS_CapabilityPerBandPair_r14RetuningInfo {
    #[asn(optional_idx = 0)]
    pub rf_retuning_time_dl_r14:
        Option<SRS_CapabilityPerBandPair_r14RetuningInfoRf_RetuningTimeDL_r14>,
    #[asn(optional_idx = 1)]
    pub rf_retuning_time_ul_r14:
        Option<SRS_CapabilityPerBandPair_r14RetuningInfoRf_RetuningTimeUL_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SRS_CapabilityPerBandPair_v14b0Srs_FlexibleTiming_r14(pub u8);
impl SRS_CapabilityPerBandPair_v14b0Srs_FlexibleTiming_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SRS_CapabilityPerBandPair_v14b0Srs_HARQ_ReferenceConfig_r14(pub u8);
impl SRS_CapabilityPerBandPair_v14b0Srs_HARQ_ReferenceConfig_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SRS_CapabilityPerBandPair_v1610AddSRS_CarrierSwitching_r16(pub u8);
impl SRS_CapabilityPerBandPair_v1610AddSRS_CarrierSwitching_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "9")]
pub struct SRS_ConfigAdd_r16Srs_RepNumAdd_r16(pub u8);
impl SRS_ConfigAdd_r16Srs_RepNumAdd_r16 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N3: u8 = 2u8;
    pub const N4: u8 = 3u8;
    pub const N6: u8 = 4u8;
    pub const N7: u8 = 5u8;
    pub const N8: u8 = 6u8;
    pub const N9: u8 = 7u8;
    pub const N12: u8 = 8u8;
    pub const N13: u8 = 9u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SRS_ConfigAdd_r16Srs_BandwidthAdd_r16(pub u8);
impl SRS_ConfigAdd_r16Srs_BandwidthAdd_r16 {
    pub const BW0: u8 = 0u8;
    pub const BW1: u8 = 1u8;
    pub const BW2: u8 = 2u8;
    pub const BW3: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SRS_ConfigAdd_r16Srs_HoppingBandwidthAdd_r16(pub u8);
impl SRS_ConfigAdd_r16Srs_HoppingBandwidthAdd_r16 {
    pub const HBW0: u8 = 0u8;
    pub const HBW1: u8 = 1u8;
    pub const HBW2: u8 = 2u8;
    pub const HBW3: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "23")]
pub struct SRS_ConfigAdd_r16Srs_FreqDomainPosAdd_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "11")]
pub struct SRS_ConfigAdd_r16Srs_CyclicShiftAdd_r16(pub u8);
impl SRS_ConfigAdd_r16Srs_CyclicShiftAdd_r16 {
    pub const CS0: u8 = 0u8;
    pub const CS1: u8 = 1u8;
    pub const CS2: u8 = 2u8;
    pub const CS3: u8 = 3u8;
    pub const CS4: u8 = 4u8;
    pub const CS5: u8 = 5u8;
    pub const CS6: u8 = 6u8;
    pub const CS7: u8 = 7u8;
    pub const CS8: u8 = 8u8;
    pub const CS9: u8 = 9u8;
    pub const CS10: u8 = 10u8;
    pub const CS11: u8 = 11u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SRS_ConfigAdd_r16Srs_TransmissionCombNumAdd_r16(pub u8);
impl SRS_ConfigAdd_r16Srs_TransmissionCombNumAdd_r16 {
    pub const N2: u8 = 0u8;
    pub const N4: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct SRS_ConfigAdd_r16Srs_TransmissionCombAdd_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "13")]
pub struct SRS_ConfigAdd_r16Srs_StartPosAdd_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "13")]
pub struct SRS_ConfigAdd_r16Srs_DurationAdd_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SRS_ConfigAdd_r16Srs_GuardSymbolAS_Add_r16(pub u8);
impl SRS_ConfigAdd_r16Srs_GuardSymbolAS_Add_r16 {
    pub const ENABLED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SRS_ConfigAdd_r16Srs_GuardSymbolFH_Add_r16(pub u8);
impl SRS_ConfigAdd_r16Srs_GuardSymbolFH_Add_r16 {
    pub const ENABLED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SRS_ConfigAp_r10Srs_BandwidthAp_r10(pub u8);
impl SRS_ConfigAp_r10Srs_BandwidthAp_r10 {
    pub const BW0: u8 = 0u8;
    pub const BW1: u8 = 1u8;
    pub const BW2: u8 = 2u8;
    pub const BW3: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "23")]
pub struct SRS_ConfigAp_r10FreqDomainPositionAp_r10(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1")]
pub struct SRS_ConfigAp_r10TransmissionCombAp_r10(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct SRS_ConfigAp_r10CyclicShiftAp_r10(pub u8);
impl SRS_ConfigAp_r10CyclicShiftAp_r10 {
    pub const CS0: u8 = 0u8;
    pub const CS1: u8 = 1u8;
    pub const CS2: u8 = 2u8;
    pub const CS3: u8 = 3u8;
    pub const CS4: u8 = 4u8;
    pub const CS5: u8 = 5u8;
    pub const CS6: u8 = 6u8;
    pub const CS7: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SRS_ConfigAp_r13Srs_BandwidthAp_r13(pub u8);
impl SRS_ConfigAp_r13Srs_BandwidthAp_r13 {
    pub const BW0: u8 = 0u8;
    pub const BW1: u8 = 1u8;
    pub const BW2: u8 = 2u8;
    pub const BW3: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "23")]
pub struct SRS_ConfigAp_r13FreqDomainPositionAp_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct SRS_ConfigAp_r13TransmissionCombAp_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "11")]
pub struct SRS_ConfigAp_r13CyclicShiftAp_r13(pub u8);
impl SRS_ConfigAp_r13CyclicShiftAp_r13 {
    pub const CS0: u8 = 0u8;
    pub const CS1: u8 = 1u8;
    pub const CS2: u8 = 2u8;
    pub const CS3: u8 = 3u8;
    pub const CS4: u8 = 4u8;
    pub const CS5: u8 = 5u8;
    pub const CS6: u8 = 6u8;
    pub const CS7: u8 = 7u8;
    pub const CS8: u8 = 8u8;
    pub const CS9: u8 = 9u8;
    pub const CS10: u8 = 10u8;
    pub const CS11: u8 = 11u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SRS_ConfigAp_r13TransmissionCombNum_r13(pub u8);
impl SRS_ConfigAp_r13TransmissionCombNum_r13 {
    pub const N2: u8 = 0u8;
    pub const N4: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "2", ub = "3")]
pub struct SRS_ConfigAp_v1310TransmissionCombAp_v1310(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SRS_ConfigAp_v1310CyclicShiftAp_v1310(pub u8);
impl SRS_ConfigAp_v1310CyclicShiftAp_v1310 {
    pub const CS8: u8 = 0u8;
    pub const CS9: u8 = 1u8;
    pub const CS10: u8 = 2u8;
    pub const CS11: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SRS_ConfigAp_v1310TransmissionCombNum_r13(pub u8);
impl SRS_ConfigAp_v1310TransmissionCombNum_r13 {
    pub const N2: u8 = 0u8;
    pub const N4: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SRS_TPC_PDCCH_Config_r14_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct SRS_TPC_PDCCH_Config_r14_setupSrs_TPC_RNTI_r14(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct SRS_TPC_PDCCH_Config_r14_setupStartingBitOfFormat3B_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4")]
pub struct SRS_TPC_PDCCH_Config_r14_setupFieldTypeFormat3B_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SRS_TPC_PDCCH_Config_r14_setupSrs_CC_SetIndexlist_r14(pub Vec<SRS_CC_SetIndex_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SRS_TPC_PDCCH_Config_r14_setup {
    pub srs_tpc_rnti_r14: SRS_TPC_PDCCH_Config_r14_setupSrs_TPC_RNTI_r14,
    pub starting_bit_of_format3_b_r14: SRS_TPC_PDCCH_Config_r14_setupStartingBitOfFormat3B_r14,
    pub field_type_format3_b_r14: SRS_TPC_PDCCH_Config_r14_setupFieldTypeFormat3B_r14,
    #[asn(optional_idx = 0)]
    pub srs_cc_set_indexlist_r14: Option<SRS_TPC_PDCCH_Config_r14_setupSrs_CC_SetIndexlist_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "1", sz_ub = "80")]
pub struct SS_RSSI_Measurement_r15MeasurementSlots_r15(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct SS_RSSI_Measurement_r15EndSymbol_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct SSB_ToMeasure_r15_shortBitmap_r15(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct SSB_ToMeasure_r15_mediumBitmap_r15(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "64", sz_ub = "64")]
pub struct SSB_ToMeasure_r15_longBitmap_r15(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct STTI_SPT_BandParameters_r15Dl_1024QAM_Slot_r15(pub u8);
impl STTI_SPT_BandParameters_r15Dl_1024QAM_Slot_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct STTI_SPT_BandParameters_r15Dl_1024QAM_SubslotTA_1_r15(pub u8);
impl STTI_SPT_BandParameters_r15Dl_1024QAM_SubslotTA_1_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct STTI_SPT_BandParameters_r15Dl_1024QAM_SubslotTA_2_r15(pub u8);
impl STTI_SPT_BandParameters_r15Dl_1024QAM_SubslotTA_2_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct STTI_SPT_BandParameters_r15SimultaneousTx_differentTx_duration_r15(pub u8);
impl STTI_SPT_BandParameters_r15SimultaneousTx_differentTx_duration_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct STTI_SPT_BandParameters_r15STTI_FD_MIMO_Coexistence(pub u8);
impl STTI_SPT_BandParameters_r15STTI_FD_MIMO_Coexistence {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct STTI_SPT_BandParameters_r15STTI_SupportedCSI_Proc_r15(pub u8);
impl STTI_SPT_BandParameters_r15STTI_SupportedCSI_Proc_r15 {
    pub const N1: u8 = 0u8;
    pub const N3: u8 = 1u8;
    pub const N4: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct STTI_SPT_BandParameters_r15Ul_256QAM_Slot_r15(pub u8);
impl STTI_SPT_BandParameters_r15Ul_256QAM_Slot_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct STTI_SPT_BandParameters_r15Ul_256QAM_Subslot_r15(pub u8);
impl STTI_SPT_BandParameters_r15Ul_256QAM_Subslot_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct STTI_SupportedCombinations_r15Combination_22_27_r15(pub Vec<DL_UL_CCs_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct STTI_SupportedCombinations_r15Combination_77_22_r15(pub Vec<DL_UL_CCs_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct STTI_SupportedCombinations_r15Combination_77_27_r15(pub Vec<DL_UL_CCs_r15>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct SatelliteInfo_r17SatelliteId_r17(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SatelliteInfo_r17ServiceInfo_r17 {
    #[asn(optional_idx = 0)]
    pub tle_ephemeris_parameters_r17: Option<TLE_EphemerisParameters_r17>,
    #[asn(optional_idx = 1)]
    pub t_service_start_r17: Option<TimeOffsetUTC_r17>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-131072", ub = "131071")]
pub struct SatelliteInfo_r17FootprintInfo_r17ReferencePoint_r17Longitude_r17(pub i32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-131072", ub = "131071")]
pub struct SatelliteInfo_r17FootprintInfo_r17ReferencePoint_r17Latitude_r17(pub i32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SatelliteInfo_r17FootprintInfo_r17ReferencePoint_r17 {
    pub longitude_r17: SatelliteInfo_r17FootprintInfo_r17ReferencePoint_r17Longitude_r17,
    pub latitude_r17: SatelliteInfo_r17FootprintInfo_r17ReferencePoint_r17Latitude_r17,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-14", ub = "14")]
pub struct SatelliteInfo_r17FootprintInfo_r17ElevationAngles_r17ElevationAngleRight_r17(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-14", ub = "14")]
pub struct SatelliteInfo_r17FootprintInfo_r17ElevationAngles_r17ElevationAngleLeft_r17(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SatelliteInfo_r17FootprintInfo_r17ElevationAngles_r17 {
    pub elevation_angle_right_r17:
        SatelliteInfo_r17FootprintInfo_r17ElevationAngles_r17ElevationAngleRight_r17,
    #[asn(optional_idx = 0)]
    pub elevation_angle_left_r17:
        Option<SatelliteInfo_r17FootprintInfo_r17ElevationAngles_r17ElevationAngleLeft_r17>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "256")]
pub struct SatelliteInfo_r17FootprintInfo_r17Radius_r17(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SatelliteInfo_r17FootprintInfo_r17 {
    #[asn(optional_idx = 0)]
    pub reference_point_r17: Option<SatelliteInfo_r17FootprintInfo_r17ReferencePoint_r17>,
    #[asn(optional_idx = 1)]
    pub elevation_angles_r17: Option<SatelliteInfo_r17FootprintInfo_r17ElevationAngles_r17>,
    #[asn(optional_idx = 2)]
    pub radius_r17: Option<SatelliteInfo_r17FootprintInfo_r17Radius_r17>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct SchedulingInfo_BR_r13Si_Narrowband_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "9")]
pub struct SchedulingInfo_BR_r13Si_TBS_r13(pub u8);
impl SchedulingInfo_BR_r13Si_TBS_r13 {
    pub const B152: u8 = 0u8;
    pub const B208: u8 = 1u8;
    pub const B256: u8 = 2u8;
    pub const B328: u8 = 3u8;
    pub const B408: u8 = 4u8;
    pub const B504: u8 = 5u8;
    pub const B600: u8 = 6u8;
    pub const B712: u8 = 7u8;
    pub const B808: u8 = 8u8;
    pub const B936: u8 = 9u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct SchedulingInfo_MBMS_r14Si_Periodicity_r14(pub u8);
impl SchedulingInfo_MBMS_r14Si_Periodicity_r14 {
    pub const RF16: u8 = 0u8;
    pub const RF32: u8 = 1u8;
    pub const RF64: u8 = 2u8;
    pub const RF128: u8 = 3u8;
    pub const RF256: u8 = 4u8;
    pub const RF512: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SchedulingRequestConfig_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct SchedulingRequestConfig_setupSr_PUCCH_ResourceIndex(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "157")]
pub struct SchedulingRequestConfig_setupSr_ConfigIndex(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct SchedulingRequestConfig_setupDsr_TransMax(pub u8);
impl SchedulingRequestConfig_setupDsr_TransMax {
    pub const N4: u8 = 0u8;
    pub const N8: u8 = 1u8;
    pub const N16: u8 = 2u8;
    pub const N32: u8 = 3u8;
    pub const N64: u8 = 4u8;
    pub const SPARE3: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SchedulingRequestConfig_setup {
    pub sr_pucch_resource_index: SchedulingRequestConfig_setupSr_PUCCH_ResourceIndex,
    pub sr_config_index: SchedulingRequestConfig_setupSr_ConfigIndex,
    pub dsr_trans_max: SchedulingRequestConfig_setupDsr_TransMax,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct SchedulingRequestConfig_v1020Sr_PUCCH_ResourceIndexP1_r10(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SchedulingRequestConfig_v1530_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1319")]
pub struct SchedulingRequestConfig_v1530_setupSr_SlotSPUCCH_IndexFH_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3959")]
pub struct SchedulingRequestConfig_v1530_setupSr_SlotSPUCCH_IndexNoFH_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "36")]
pub struct SchedulingRequestConfig_v1530_setupSr_ConfigIndexSlot_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "122")]
pub struct SchedulingRequestConfig_v1530_setupSr_ConfigIndexSubslot_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct SchedulingRequestConfig_v1530_setupDssr_TransMax_r15(pub u8);
impl SchedulingRequestConfig_v1530_setupDssr_TransMax_r15 {
    pub const N4: u8 = 0u8;
    pub const N8: u8 = 1u8;
    pub const N16: u8 = 2u8;
    pub const N32: u8 = 3u8;
    pub const N64: u8 = 4u8;
    pub const SPARE3: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct SchedulingRequestConfig_v1530_setup {
    #[asn(optional_idx = 0)]
    pub sr_slot_spucch_index_fh_r15:
        Option<SchedulingRequestConfig_v1530_setupSr_SlotSPUCCH_IndexFH_r15>,
    #[asn(optional_idx = 1)]
    pub sr_slot_spucch_index_no_fh_r15:
        Option<SchedulingRequestConfig_v1530_setupSr_SlotSPUCCH_IndexNoFH_r15>,
    #[asn(optional_idx = 2)]
    pub sr_subslot_spucch_resource_list_r15: Option<SR_SubslotSPUCCH_ResourceList_r15>,
    #[asn(optional_idx = 3)]
    pub sr_config_index_slot_r15: Option<SchedulingRequestConfig_v1530_setupSr_ConfigIndexSlot_r15>,
    #[asn(optional_idx = 4)]
    pub sr_config_index_subslot_r15:
        Option<SchedulingRequestConfig_v1530_setupSr_ConfigIndexSubslot_r15>,
    pub dssr_trans_max_r15: SchedulingRequestConfig_v1530_setupDssr_TransMax_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SchedulingRequestConfigSCell_r13_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct SchedulingRequestConfigSCell_r13_setupSr_PUCCH_ResourceIndex_r13(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct SchedulingRequestConfigSCell_r13_setupSr_PUCCH_ResourceIndexP1_r13(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "157")]
pub struct SchedulingRequestConfigSCell_r13_setupSr_ConfigIndex_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct SchedulingRequestConfigSCell_r13_setupDsr_TransMax_r13(pub u8);
impl SchedulingRequestConfigSCell_r13_setupDsr_TransMax_r13 {
    pub const N4: u8 = 0u8;
    pub const N8: u8 = 1u8;
    pub const N16: u8 = 2u8;
    pub const N32: u8 = 3u8;
    pub const N64: u8 = 4u8;
    pub const SPARE3: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SchedulingRequestConfigSCell_r13_setup {
    pub sr_pucch_resource_index_r13:
        SchedulingRequestConfigSCell_r13_setupSr_PUCCH_ResourceIndex_r13,
    #[asn(optional_idx = 0)]
    pub sr_pucch_resource_index_p1_r13:
        Option<SchedulingRequestConfigSCell_r13_setupSr_PUCCH_ResourceIndexP1_r13>,
    pub sr_config_index_r13: SchedulingRequestConfigSCell_r13_setupSr_ConfigIndex_r13,
    pub dsr_trans_max_r13: SchedulingRequestConfigSCell_r13_setupDsr_TransMax_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "7")]
pub struct SecurityAlgorithmConfigIntegrityProtAlgorithm(pub u8);
impl SecurityAlgorithmConfigIntegrityProtAlgorithm {
    pub const EIA0_V920: u8 = 0u8;
    pub const EIA1: u8 = 1u8;
    pub const EIA2: u8 = 2u8;
    pub const EIA3_V1130: u8 = 3u8;
    pub const SPARE4: u8 = 4u8;
    pub const SPARE3: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct SecurityConfigHOHandoverType_intraLTEKeyChangeIndicator(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SecurityConfigHOHandoverType_intraLTE {
    #[asn(optional_idx = 0)]
    pub security_algorithm_config: Option<SecurityAlgorithmConfig>,
    pub key_change_indicator: SecurityConfigHOHandoverType_intraLTEKeyChangeIndicator,
    pub next_hop_chaining_count: NextHopChainingCount,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "6", sz_ub = "6")]
pub struct SecurityConfigHOHandoverType_interRATNas_SecurityParamToEUTRA(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecurityConfigHOHandoverType_interRAT {
    pub security_algorithm_config: SecurityAlgorithmConfig,
    pub nas_security_param_to_eutra: SecurityConfigHOHandoverType_interRATNas_SecurityParamToEUTRA,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SecurityConfigHOHandoverType {
    #[asn(key = 0, extended = false)]
    IntraLTE(SecurityConfigHOHandoverType_intraLTE),
    #[asn(key = 1, extended = false)]
    InterRAT(SecurityConfigHOHandoverType_interRAT),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct SecurityConfigHO_v1530HandoverType_v1530_intra5GCKeyChangeIndicator_r15(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SecurityConfigHO_v1530HandoverType_v1530_intra5GCNas_Container_r15(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SecurityConfigHO_v1530HandoverType_v1530_intra5GC {
    #[asn(optional_idx = 0)]
    pub security_algorithm_config_r15: Option<SecurityAlgorithmConfig>,
    pub key_change_indicator_r15:
        SecurityConfigHO_v1530HandoverType_v1530_intra5GCKeyChangeIndicator_r15,
    pub next_hop_chaining_count_r15: NextHopChainingCount,
    #[asn(optional_idx = 1)]
    pub nas_container_r15:
        Option<SecurityConfigHO_v1530HandoverType_v1530_intra5GCNas_Container_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecurityConfigHO_v1530HandoverType_v1530_fivegc_ToEPC {
    pub security_algorithm_config_r15: SecurityAlgorithmConfig,
    pub next_hop_chaining_count_r15: NextHopChainingCount,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SecurityConfigHO_v1530HandoverType_v1530_epc_To5GCNas_Container_r15(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecurityConfigHO_v1530HandoverType_v1530_epc_To5GC {
    pub security_algorithm_config_r15: SecurityAlgorithmConfig,
    pub nas_container_r15: SecurityConfigHO_v1530HandoverType_v1530_epc_To5GCNas_Container_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum SecurityConfigHO_v1530HandoverType_v1530 {
    #[asn(key = 0, extended = false)]
    Intra5GC(SecurityConfigHO_v1530HandoverType_v1530_intra5GC),
    #[asn(key = 1, extended = false)]
    Fivegc_ToEPC(SecurityConfigHO_v1530HandoverType_v1530_fivegc_ToEPC),
    #[asn(key = 2, extended = false)]
    Epc_To5GC(SecurityConfigHO_v1530HandoverType_v1530_epc_To5GC),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SecurityModeCommandCriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SecurityModeCommandCriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SecurityModeCommandCriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum SecurityModeCommandCriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    SecurityModeCommand_r8(SecurityModeCommand_r8_IEs),
    #[asn(key = 1, extended = false)]
    Spare3(SecurityModeCommandCriticalExtensions_c1_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(SecurityModeCommandCriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(SecurityModeCommandCriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecurityModeCommandCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SecurityModeCommandCriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(SecurityModeCommandCriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(SecurityModeCommandCriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SecurityModeCommand_v8a0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecurityModeCommand_v8a0_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecurityModeCompleteCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SecurityModeCompleteCriticalExtensions {
    #[asn(key = 0, extended = false)]
    SecurityModeComplete_r8(SecurityModeComplete_r8_IEs),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(SecurityModeCompleteCriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SecurityModeComplete_v8a0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecurityModeComplete_v8a0_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecurityModeFailureCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SecurityModeFailureCriticalExtensions {
    #[asn(key = 0, extended = false)]
    SecurityModeFailure_r8(SecurityModeFailure_r8_IEs),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(SecurityModeFailureCriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SecurityModeFailure_v8a0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecurityModeFailure_v8a0_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "2000")]
pub struct SensingResult_r15ResourceIndex_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum ServingSatelliteInfo_r17EphemerisInfo_r17 {
    #[asn(key = 0, extended = false)]
    StateVectors(EphemerisStateVectors_r17),
    #[asn(key = 1, extended = false)]
    OrbitalParameters(EphemerisOrbitalParameters_r17),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "8316827")]
pub struct ServingSatelliteInfo_r17Nta_CommonParameters_17Nta_Common_r17(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-261935", ub = "261935")]
pub struct ServingSatelliteInfo_r17Nta_CommonParameters_17Nta_CommonDrift_r17(pub i32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "29479")]
pub struct ServingSatelliteInfo_r17Nta_CommonParameters_17Nta_CommonDriftVariation_r17(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct ServingSatelliteInfo_r17Nta_CommonParameters_17 {
    #[asn(optional_idx = 0)]
    pub nta_common_r17: Option<ServingSatelliteInfo_r17Nta_CommonParameters_17Nta_Common_r17>,
    #[asn(optional_idx = 1)]
    pub nta_common_drift_r17:
        Option<ServingSatelliteInfo_r17Nta_CommonParameters_17Nta_CommonDrift_r17>,
    #[asn(optional_idx = 2)]
    pub nta_common_drift_variation_r17:
        Option<ServingSatelliteInfo_r17Nta_CommonParameters_17Nta_CommonDriftVariation_r17>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct ServingSatelliteInfo_r17Ul_SyncValidityDuration_r17(pub u8);
impl ServingSatelliteInfo_r17Ul_SyncValidityDuration_r17 {
    pub const S5: u8 = 0u8;
    pub const S10: u8 = 1u8;
    pub const S15: u8 = 2u8;
    pub const S20: u8 = 3u8;
    pub const S25: u8 = 4u8;
    pub const S30: u8 = 5u8;
    pub const S35: u8 = 6u8;
    pub const S40: u8 = 7u8;
    pub const S45: u8 = 8u8;
    pub const S50: u8 = 9u8;
    pub const S55: u8 = 10u8;
    pub const S60: u8 = 11u8;
    pub const S120: u8 = 12u8;
    pub const S180: u8 = 13u8;
    pub const S240: u8 = 14u8;
    pub const S900: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct ServingSatelliteInfo_r17EpochTime_r17StartSFN_r17(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "9")]
pub struct ServingSatelliteInfo_r17EpochTime_r17StartSubFrame_r17(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ServingSatelliteInfo_r17EpochTime_r17 {
    pub start_sfn_r17: ServingSatelliteInfo_r17EpochTime_r17StartSFN_r17,
    pub start_sub_frame_r17: ServingSatelliteInfo_r17EpochTime_r17StartSubFrame_r17,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct ServingSatelliteInfo_r17K_Offset_r17(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "512")]
pub struct ServingSatelliteInfo_r17K_Mac_r17(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct SharedSpectrumMeasNR_r17Nr_RSSI_ChannelOccupancyReporting_r17(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SidelinkUEInformation_r12CriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SidelinkUEInformation_r12CriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SidelinkUEInformation_r12CriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum SidelinkUEInformation_r12CriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    SidelinkUEInformation_r12(SidelinkUEInformation_r12_IEs),
    #[asn(key = 1, extended = false)]
    Spare3(SidelinkUEInformation_r12CriticalExtensions_c1_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(SidelinkUEInformation_r12CriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(SidelinkUEInformation_r12CriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SidelinkUEInformation_r12CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SidelinkUEInformation_r12CriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(SidelinkUEInformation_r12CriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(SidelinkUEInformation_r12CriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SidelinkUEInformation_r12_IEsDiscRxInterest_r12(pub u8);
impl SidelinkUEInformation_r12_IEsDiscRxInterest_r12 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "63")]
pub struct SidelinkUEInformation_r12_IEsDiscTxResourceReq_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SidelinkUEInformation_r12_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SidelinkUEInformation_v1310_IEsCommTxResourceInfoReqRelay_r13Ue_Type_r13(pub u8);
impl SidelinkUEInformation_v1310_IEsCommTxResourceInfoReqRelay_r13Ue_Type_r13 {
    pub const RELAY_UE: u8 = 0u8;
    pub const REMOTE_UE: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SidelinkUEInformation_v1310_IEsCommTxResourceInfoReqRelay_r13 {
    #[asn(optional_idx = 0)]
    pub comm_tx_resource_req_relay_r13: Option<SL_CommTxResourceReq_r12>,
    #[asn(optional_idx = 1)]
    pub comm_tx_resource_req_relay_uc_r13: Option<SL_CommTxResourceReq_r12>,
    pub ue_type_r13: SidelinkUEInformation_v1310_IEsCommTxResourceInfoReqRelay_r13Ue_Type_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8")]
pub struct SidelinkUEInformation_v1310_IEsDiscTxResourceReq_v1310CarrierFreqDiscTx_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SidelinkUEInformation_v1310_IEsDiscTxResourceReq_v1310 {
    #[asn(optional_idx = 0)]
    pub carrier_freq_disc_tx_r13:
        Option<SidelinkUEInformation_v1310_IEsDiscTxResourceReq_v1310CarrierFreqDiscTx_r13>,
    #[asn(optional_idx = 1)]
    pub disc_tx_resource_req_add_freq_r13: Option<SL_DiscTxResourceReqPerFreqList_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SidelinkUEInformation_v1430_IEsP2x_CommTxType_r14(pub u8);
impl SidelinkUEInformation_v1430_IEsP2x_CommTxType_r14 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SidelinkUEInformation_v1530_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct SkipSubframeProcessing_r15SkipProcessingDL_Slot_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct SkipSubframeProcessing_r15SkipProcessingDL_SubSlot_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct SkipSubframeProcessing_r15SkipProcessingUL_Slot_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct SkipSubframeProcessing_r15SkipProcessingUL_SubSlot_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SlotOrSubslotPDSCH_Config_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SlotOrSubslotPDSCH_Config_r15_setupAltCQI_TableSTTI_r15(pub u8);
impl SlotOrSubslotPDSCH_Config_r15_setupAltCQI_TableSTTI_r15 {
    pub const ALL_SUBFRAMES: u8 = 0u8;
    pub const CSI_SUBFRAME_SET1: u8 = 1u8;
    pub const CSI_SUBFRAME_SET2: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SlotOrSubslotPDSCH_Config_r15_setupAltCQI_Table1024QAM_STTI_r15(pub u8);
impl SlotOrSubslotPDSCH_Config_r15_setupAltCQI_Table1024QAM_STTI_r15 {
    pub const ALL_SUBFRAMES: u8 = 0u8;
    pub const CSI_SUBFRAME_SET1: u8 = 1u8;
    pub const CSI_SUBFRAME_SET2: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SlotOrSubslotPDSCH_Config_r15_setupResourceAllocation_r15(pub u8);
impl SlotOrSubslotPDSCH_Config_r15_setupResourceAllocation_r15 {
    pub const RESOURCE_ALLOCATION_TYPE0: u8 = 0u8;
    pub const RESOURCE_ALLOCATION_TYPE2: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SlotOrSubslotPDSCH_Config_r15_setupTbsIndexAlt_STTI_r15(pub u8);
impl SlotOrSubslotPDSCH_Config_r15_setupTbsIndexAlt_STTI_r15 {
    pub const A33: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SlotOrSubslotPDSCH_Config_r15_setupTbsIndexAlt2_STTI_r15(pub u8);
impl SlotOrSubslotPDSCH_Config_r15_setupTbsIndexAlt2_STTI_r15 {
    pub const B33: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SlotOrSubslotPDSCH_Config_r15_setupTbsIndexAlt3_STTI_r15(pub u8);
impl SlotOrSubslotPDSCH_Config_r15_setupTbsIndexAlt3_STTI_r15 {
    pub const A37: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 6)]
pub struct SlotOrSubslotPDSCH_Config_r15_setup {
    #[asn(optional_idx = 0)]
    pub alt_cqi_table_stti_r15: Option<SlotOrSubslotPDSCH_Config_r15_setupAltCQI_TableSTTI_r15>,
    #[asn(optional_idx = 1)]
    pub alt_cqi_table1024_qam_stti_r15:
        Option<SlotOrSubslotPDSCH_Config_r15_setupAltCQI_Table1024QAM_STTI_r15>,
    #[asn(optional_idx = 2)]
    pub resource_allocation_r15: Option<SlotOrSubslotPDSCH_Config_r15_setupResourceAllocation_r15>,
    #[asn(optional_idx = 3)]
    pub tbs_index_alt_stti_r15: Option<SlotOrSubslotPDSCH_Config_r15_setupTbsIndexAlt_STTI_r15>,
    #[asn(optional_idx = 4)]
    pub tbs_index_alt2_stti_r15: Option<SlotOrSubslotPDSCH_Config_r15_setupTbsIndexAlt2_STTI_r15>,
    #[asn(optional_idx = 5)]
    pub tbs_index_alt3_stti_r15: Option<SlotOrSubslotPDSCH_Config_r15_setupTbsIndexAlt3_STTI_r15>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SlotOrSubslotPUSCH_Config_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct SlotOrSubslotPUSCH_Config_r15_setupBetaOffsetSlot_ACK_Index_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct SlotOrSubslotPUSCH_Config_r15_setupBetaOffset2Slot_ACK_Index_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct SlotOrSubslotPUSCH_Config_r15_setupBetaOffsetSubslot_ACK_Index_r15_Entry(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct SlotOrSubslotPUSCH_Config_r15_setupBetaOffsetSubslot_ACK_Index_r15(
    pub Vec<SlotOrSubslotPUSCH_Config_r15_setupBetaOffsetSubslot_ACK_Index_r15_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct SlotOrSubslotPUSCH_Config_r15_setupBetaOffset2Subslot_ACK_Index_r15_Entry(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct SlotOrSubslotPUSCH_Config_r15_setupBetaOffset2Subslot_ACK_Index_r15(
    pub Vec<SlotOrSubslotPUSCH_Config_r15_setupBetaOffset2Subslot_ACK_Index_r15_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct SlotOrSubslotPUSCH_Config_r15_setupBetaOffsetSlot_RI_Index_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct SlotOrSubslotPUSCH_Config_r15_setupBetaOffsetSubslot_RI_Index_r15_Entry(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct SlotOrSubslotPUSCH_Config_r15_setupBetaOffsetSubslot_RI_Index_r15(
    pub Vec<SlotOrSubslotPUSCH_Config_r15_setupBetaOffsetSubslot_RI_Index_r15_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct SlotOrSubslotPUSCH_Config_r15_setupBetaOffsetSlot_CQI_Index_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct SlotOrSubslotPUSCH_Config_r15_setupBetaOffsetSubslot_CQI_Index_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "2")]
pub struct SlotOrSubslotPUSCH_Config_r15_setupResourceAllocationOffset_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct SlotOrSubslotPUSCH_Config_r15_setupUl_DMRS_IFDMA_SlotOrSubslot_r15(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 10)]
pub struct SlotOrSubslotPUSCH_Config_r15_setup {
    #[asn(optional_idx = 0)]
    pub beta_offset_slot_ack_index_r15:
        Option<SlotOrSubslotPUSCH_Config_r15_setupBetaOffsetSlot_ACK_Index_r15>,
    #[asn(optional_idx = 1)]
    pub beta_offset2_slot_ack_index_r15:
        Option<SlotOrSubslotPUSCH_Config_r15_setupBetaOffset2Slot_ACK_Index_r15>,
    #[asn(optional_idx = 2)]
    pub beta_offset_subslot_ack_index_r15:
        Option<SlotOrSubslotPUSCH_Config_r15_setupBetaOffsetSubslot_ACK_Index_r15>,
    #[asn(optional_idx = 3)]
    pub beta_offset2_subslot_ack_index_r15:
        Option<SlotOrSubslotPUSCH_Config_r15_setupBetaOffset2Subslot_ACK_Index_r15>,
    #[asn(optional_idx = 4)]
    pub beta_offset_slot_ri_index_r15:
        Option<SlotOrSubslotPUSCH_Config_r15_setupBetaOffsetSlot_RI_Index_r15>,
    #[asn(optional_idx = 5)]
    pub beta_offset_subslot_ri_index_r15:
        Option<SlotOrSubslotPUSCH_Config_r15_setupBetaOffsetSubslot_RI_Index_r15>,
    #[asn(optional_idx = 6)]
    pub beta_offset_slot_cqi_index_r15:
        Option<SlotOrSubslotPUSCH_Config_r15_setupBetaOffsetSlot_CQI_Index_r15>,
    #[asn(optional_idx = 7)]
    pub beta_offset_subslot_cqi_index_r15:
        Option<SlotOrSubslotPUSCH_Config_r15_setupBetaOffsetSubslot_CQI_Index_r15>,
    #[asn(optional_idx = 8)]
    pub enable256_qam_slot_or_subslot_r15: Option<Enable256QAM_r14>,
    #[asn(optional_idx = 9)]
    pub resource_allocation_offset_r15:
        Option<SlotOrSubslotPUSCH_Config_r15_setupResourceAllocationOffset_r15>,
    pub ul_dmrs_ifdma_slot_or_subslot_r15:
        SlotOrSubslotPUSCH_Config_r15_setupUl_DMRS_IFDMA_SlotOrSubslot_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SoundingRS_AperiodicSet_r14Srs_CC_SetIndexList_r14(pub Vec<SRS_CC_SetIndex_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct SoundingRS_AperiodicSetUpPTsExt_r14Srs_CC_SetIndexList_r14(pub Vec<SRS_CC_SetIndex_r14>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SoundingRS_UL_ConfigCommon_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct SoundingRS_UL_ConfigCommon_setupSrs_BandwidthConfig(pub u8);
impl SoundingRS_UL_ConfigCommon_setupSrs_BandwidthConfig {
    pub const BW0: u8 = 0u8;
    pub const BW1: u8 = 1u8;
    pub const BW2: u8 = 2u8;
    pub const BW3: u8 = 3u8;
    pub const BW4: u8 = 4u8;
    pub const BW5: u8 = 5u8;
    pub const BW6: u8 = 6u8;
    pub const BW7: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct SoundingRS_UL_ConfigCommon_setupSrs_SubframeConfig(pub u8);
impl SoundingRS_UL_ConfigCommon_setupSrs_SubframeConfig {
    pub const SC0: u8 = 0u8;
    pub const SC1: u8 = 1u8;
    pub const SC2: u8 = 2u8;
    pub const SC3: u8 = 3u8;
    pub const SC4: u8 = 4u8;
    pub const SC5: u8 = 5u8;
    pub const SC6: u8 = 6u8;
    pub const SC7: u8 = 7u8;
    pub const SC8: u8 = 8u8;
    pub const SC9: u8 = 9u8;
    pub const SC10: u8 = 10u8;
    pub const SC11: u8 = 11u8;
    pub const SC12: u8 = 12u8;
    pub const SC13: u8 = 13u8;
    pub const SC14: u8 = 14u8;
    pub const SC15: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct SoundingRS_UL_ConfigCommon_setupAckNackSRS_SimultaneousTransmission(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SoundingRS_UL_ConfigCommon_setupSrs_MaxUpPts(pub u8);
impl SoundingRS_UL_ConfigCommon_setupSrs_MaxUpPts {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SoundingRS_UL_ConfigCommon_setup {
    pub srs_bandwidth_config: SoundingRS_UL_ConfigCommon_setupSrs_BandwidthConfig,
    pub srs_subframe_config: SoundingRS_UL_ConfigCommon_setupSrs_SubframeConfig,
    pub ack_nack_srs_simultaneous_transmission:
        SoundingRS_UL_ConfigCommon_setupAckNackSRS_SimultaneousTransmission,
    #[asn(optional_idx = 0)]
    pub srs_max_up_pts: Option<SoundingRS_UL_ConfigCommon_setupSrs_MaxUpPts>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SoundingRS_UL_ConfigDedicated_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SoundingRS_UL_ConfigDedicated_setupSrs_Bandwidth(pub u8);
impl SoundingRS_UL_ConfigDedicated_setupSrs_Bandwidth {
    pub const BW0: u8 = 0u8;
    pub const BW1: u8 = 1u8;
    pub const BW2: u8 = 2u8;
    pub const BW3: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SoundingRS_UL_ConfigDedicated_setupSrs_HoppingBandwidth(pub u8);
impl SoundingRS_UL_ConfigDedicated_setupSrs_HoppingBandwidth {
    pub const HBW0: u8 = 0u8;
    pub const HBW1: u8 = 1u8;
    pub const HBW2: u8 = 2u8;
    pub const HBW3: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "23")]
pub struct SoundingRS_UL_ConfigDedicated_setupFreqDomainPosition(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct SoundingRS_UL_ConfigDedicated_setupDuration(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct SoundingRS_UL_ConfigDedicated_setupSrs_ConfigIndex(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1")]
pub struct SoundingRS_UL_ConfigDedicated_setupTransmissionComb(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct SoundingRS_UL_ConfigDedicated_setupCyclicShift(pub u8);
impl SoundingRS_UL_ConfigDedicated_setupCyclicShift {
    pub const CS0: u8 = 0u8;
    pub const CS1: u8 = 1u8;
    pub const CS2: u8 = 2u8;
    pub const CS3: u8 = 3u8;
    pub const CS4: u8 = 4u8;
    pub const CS5: u8 = 5u8;
    pub const CS6: u8 = 6u8;
    pub const CS7: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SoundingRS_UL_ConfigDedicated_setup {
    pub srs_bandwidth: SoundingRS_UL_ConfigDedicated_setupSrs_Bandwidth,
    pub srs_hopping_bandwidth: SoundingRS_UL_ConfigDedicated_setupSrs_HoppingBandwidth,
    pub freq_domain_position: SoundingRS_UL_ConfigDedicated_setupFreqDomainPosition,
    pub duration: SoundingRS_UL_ConfigDedicated_setupDuration,
    pub srs_config_index: SoundingRS_UL_ConfigDedicated_setupSrs_ConfigIndex,
    pub transmission_comb: SoundingRS_UL_ConfigDedicated_setupTransmissionComb,
    pub cyclic_shift: SoundingRS_UL_ConfigDedicated_setupCyclicShift,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SoundingRS_UL_ConfigDedicated_v1310_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "2", ub = "3")]
pub struct SoundingRS_UL_ConfigDedicated_v1310_setupTransmissionComb_v1310(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SoundingRS_UL_ConfigDedicated_v1310_setupCyclicShift_v1310(pub u8);
impl SoundingRS_UL_ConfigDedicated_v1310_setupCyclicShift_v1310 {
    pub const CS8: u8 = 0u8;
    pub const CS9: u8 = 1u8;
    pub const CS10: u8 = 2u8;
    pub const CS11: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SoundingRS_UL_ConfigDedicated_v1310_setupTransmissionCombNum_r13(pub u8);
impl SoundingRS_UL_ConfigDedicated_v1310_setupTransmissionCombNum_r13 {
    pub const N2: u8 = 0u8;
    pub const N4: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SoundingRS_UL_ConfigDedicated_v1310_setup {
    #[asn(optional_idx = 0)]
    pub transmission_comb_v1310:
        Option<SoundingRS_UL_ConfigDedicated_v1310_setupTransmissionComb_v1310>,
    #[asn(optional_idx = 1)]
    pub cyclic_shift_v1310: Option<SoundingRS_UL_ConfigDedicated_v1310_setupCyclicShift_v1310>,
    #[asn(optional_idx = 2)]
    pub transmission_comb_num_r13:
        Option<SoundingRS_UL_ConfigDedicated_v1310_setupTransmissionCombNum_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct SoundingRS_UL_ConfigDedicatedAdd_r16Srs_ConfigIndexAp_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct SoundingRS_UL_ConfigDedicatedAdd_r16Srs_ConfigApDCI_Format4_r16(
    pub Vec<SRS_ConfigAdd_r16>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SoundingRS_UL_ConfigDedicatedAdd_r16Srs_ActivateAp_r13_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SoundingRS_UL_ConfigDedicatedAdd_r16Srs_ActivateAp_r13_setup {
    pub srs_config_ap_dci_format0_r16: SRS_ConfigAdd_r16,
    pub srs_config_ap_dci_format1a2b2c_r16: SRS_ConfigAdd_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SoundingRS_UL_ConfigDedicatedAdd_r16Srs_ActivateAp_r13 {
    #[asn(key = 0, extended = false)]
    Release(SoundingRS_UL_ConfigDedicatedAdd_r16Srs_ActivateAp_r13_release),
    #[asn(key = 1, extended = false)]
    Setup(SoundingRS_UL_ConfigDedicatedAdd_r16Srs_ActivateAp_r13_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SoundingRS_UL_ConfigDedicatedAperiodic_r10_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct SoundingRS_UL_ConfigDedicatedAperiodic_r10_setupSrs_ConfigIndexAp_r10(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct SoundingRS_UL_ConfigDedicatedAperiodic_r10_setupSrs_ConfigApDCI_Format4_r10(
    pub Vec<SRS_ConfigAp_r10>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SoundingRS_UL_ConfigDedicatedAperiodic_r10_setupSrs_ActivateAp_r10_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SoundingRS_UL_ConfigDedicatedAperiodic_r10_setupSrs_ActivateAp_r10_setup {
    pub srs_config_ap_dci_format0_r10: SRS_ConfigAp_r10,
    pub srs_config_ap_dci_format1a2b2c_r10: SRS_ConfigAp_r10,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SoundingRS_UL_ConfigDedicatedAperiodic_r10_setupSrs_ActivateAp_r10 {
    #[asn(key = 0, extended = false)]
    Release(SoundingRS_UL_ConfigDedicatedAperiodic_r10_setupSrs_ActivateAp_r10_release),
    #[asn(key = 1, extended = false)]
    Setup(SoundingRS_UL_ConfigDedicatedAperiodic_r10_setupSrs_ActivateAp_r10_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup {
    pub srs_config_index_ap_r10:
        SoundingRS_UL_ConfigDedicatedAperiodic_r10_setupSrs_ConfigIndexAp_r10,
    #[asn(optional_idx = 0)]
    pub srs_config_ap_dci_format4_r10:
        Option<SoundingRS_UL_ConfigDedicatedAperiodic_r10_setupSrs_ConfigApDCI_Format4_r10>,
    #[asn(optional_idx = 1)]
    pub srs_activate_ap_r10:
        Option<SoundingRS_UL_ConfigDedicatedAperiodic_r10_setupSrs_ActivateAp_r10>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SoundingRS_UL_ConfigDedicatedAperiodic_v1310_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct SoundingRS_UL_ConfigDedicatedAperiodic_v1310_setupSrs_ConfigApDCI_Format4_v1310(
    pub Vec<SRS_ConfigAp_v1310>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SoundingRS_UL_ConfigDedicatedAperiodic_v1310_setupSrs_ActivateAp_v1310_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SoundingRS_UL_ConfigDedicatedAperiodic_v1310_setupSrs_ActivateAp_v1310_setup {
    #[asn(optional_idx = 0)]
    pub srs_config_ap_dci_format0_v1310: Option<SRS_ConfigAp_v1310>,
    #[asn(optional_idx = 1)]
    pub srs_config_ap_dci_format1a2b2c_v1310: Option<SRS_ConfigAp_v1310>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SoundingRS_UL_ConfigDedicatedAperiodic_v1310_setupSrs_ActivateAp_v1310 {
    #[asn(key = 0, extended = false)]
    Release(SoundingRS_UL_ConfigDedicatedAperiodic_v1310_setupSrs_ActivateAp_v1310_release),
    #[asn(key = 1, extended = false)]
    Setup(SoundingRS_UL_ConfigDedicatedAperiodic_v1310_setupSrs_ActivateAp_v1310_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SoundingRS_UL_ConfigDedicatedAperiodic_v1310_setup {
    #[asn(optional_idx = 0)]
    pub srs_config_ap_dci_format4_v1310:
        Option<SoundingRS_UL_ConfigDedicatedAperiodic_v1310_setupSrs_ConfigApDCI_Format4_v1310>,
    #[asn(optional_idx = 1)]
    pub srs_activate_ap_v1310:
        Option<SoundingRS_UL_ConfigDedicatedAperiodic_v1310_setupSrs_ActivateAp_v1310>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SoundingRS_UL_ConfigDedicatedAperiodic_v1430_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4")]
pub struct SoundingRS_UL_ConfigDedicatedAperiodic_v1430_setupSrs_SubframeIndication_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SoundingRS_UL_ConfigDedicatedAperiodic_v1430_setup {
    #[asn(optional_idx = 0)]
    pub srs_subframe_indication_r14:
        Option<SoundingRS_UL_ConfigDedicatedAperiodic_v1430_setupSrs_SubframeIndication_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SoundingRS_UL_ConfigDedicatedAperiodicUpPTsExt_r13_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SoundingRS_UL_ConfigDedicatedAperiodicUpPTsExt_r13_setupSrs_UpPtsAdd_r13(pub u8);
impl SoundingRS_UL_ConfigDedicatedAperiodicUpPTsExt_r13_setupSrs_UpPtsAdd_r13 {
    pub const SYM2: u8 = 0u8;
    pub const SYM4: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct SoundingRS_UL_ConfigDedicatedAperiodicUpPTsExt_r13_setupSrs_ConfigIndexAp_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct SoundingRS_UL_ConfigDedicatedAperiodicUpPTsExt_r13_setupSrs_ConfigApDCI_Format4_r13(
    pub Vec<SRS_ConfigAp_r13>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SoundingRS_UL_ConfigDedicatedAperiodicUpPTsExt_r13_setupSrs_ActivateAp_r13_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SoundingRS_UL_ConfigDedicatedAperiodicUpPTsExt_r13_setupSrs_ActivateAp_r13_setup {
    pub srs_config_ap_dci_format0_r13: SRS_ConfigAp_r13,
    pub srs_config_ap_dci_format1a2b2c_r13: SRS_ConfigAp_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SoundingRS_UL_ConfigDedicatedAperiodicUpPTsExt_r13_setupSrs_ActivateAp_r13 {
    #[asn(key = 0, extended = false)]
    Release(SoundingRS_UL_ConfigDedicatedAperiodicUpPTsExt_r13_setupSrs_ActivateAp_r13_release),
    #[asn(key = 1, extended = false)]
    Setup(SoundingRS_UL_ConfigDedicatedAperiodicUpPTsExt_r13_setupSrs_ActivateAp_r13_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SoundingRS_UL_ConfigDedicatedAperiodicUpPTsExt_r13_setup {
    pub srs_up_pts_add_r13:
        SoundingRS_UL_ConfigDedicatedAperiodicUpPTsExt_r13_setupSrs_UpPtsAdd_r13,
    pub srs_config_index_ap_r13:
        SoundingRS_UL_ConfigDedicatedAperiodicUpPTsExt_r13_setupSrs_ConfigIndexAp_r13,
    #[asn(optional_idx = 0)]
    pub srs_config_ap_dci_format4_r13:
        Option<SoundingRS_UL_ConfigDedicatedAperiodicUpPTsExt_r13_setupSrs_ConfigApDCI_Format4_r13>,
    #[asn(optional_idx = 1)]
    pub srs_activate_ap_r13:
        Option<SoundingRS_UL_ConfigDedicatedAperiodicUpPTsExt_r13_setupSrs_ActivateAp_r13>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_setupSrs_UpPtsAdd_r13(pub u8);
impl SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_setupSrs_UpPtsAdd_r13 {
    pub const SYM2: u8 = 0u8;
    pub const SYM4: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_setupSrs_Bandwidth_r13(pub u8);
impl SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_setupSrs_Bandwidth_r13 {
    pub const BW0: u8 = 0u8;
    pub const BW1: u8 = 1u8;
    pub const BW2: u8 = 2u8;
    pub const BW3: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_setupSrs_HoppingBandwidth_r13(pub u8);
impl SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_setupSrs_HoppingBandwidth_r13 {
    pub const HBW0: u8 = 0u8;
    pub const HBW1: u8 = 1u8;
    pub const HBW2: u8 = 2u8;
    pub const HBW3: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "23")]
pub struct SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_setupFreqDomainPosition_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_setupDuration_r13(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_setupSrs_ConfigIndex_r13(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3")]
pub struct SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_setupTransmissionComb_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "11")]
pub struct SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_setupCyclicShift_r13(pub u8);
impl SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_setupCyclicShift_r13 {
    pub const CS0: u8 = 0u8;
    pub const CS1: u8 = 1u8;
    pub const CS2: u8 = 2u8;
    pub const CS3: u8 = 3u8;
    pub const CS4: u8 = 4u8;
    pub const CS5: u8 = 5u8;
    pub const CS6: u8 = 6u8;
    pub const CS7: u8 = 7u8;
    pub const CS8: u8 = 8u8;
    pub const CS9: u8 = 9u8;
    pub const CS10: u8 = 10u8;
    pub const CS11: u8 = 11u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_setupTransmissionCombNum_r13(pub u8);
impl SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_setupTransmissionCombNum_r13 {
    pub const N2: u8 = 0u8;
    pub const N4: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_setup {
    pub srs_up_pts_add_r13: SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_setupSrs_UpPtsAdd_r13,
    pub srs_bandwidth_r13: SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_setupSrs_Bandwidth_r13,
    pub srs_hopping_bandwidth_r13:
        SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_setupSrs_HoppingBandwidth_r13,
    pub freq_domain_position_r13:
        SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_setupFreqDomainPosition_r13,
    pub duration_r13: SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_setupDuration_r13,
    pub srs_config_index_r13: SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_setupSrs_ConfigIndex_r13,
    pub transmission_comb_r13: SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_setupTransmissionComb_r13,
    pub cyclic_shift_r13: SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_setupCyclicShift_r13,
    pub srs_antenna_port_r13: SRS_AntennaPort,
    pub transmission_comb_num_r13:
        SoundingRS_UL_ConfigDedicatedUpPTsExt_r13_setupTransmissionCombNum_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "503")]
pub struct SoundingRS_VirtualCellID_r16Srs_VirtualCellID_r16(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct SoundingRS_VirtualCellID_r16Srs_VirtualCellID_AllSRS_r16(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SpeedStateScaleFactorsSf_Medium(pub u8);
impl SpeedStateScaleFactorsSf_Medium {
    pub const O_DOT25: u8 = 0u8;
    pub const O_DOT5: u8 = 1u8;
    pub const O_DOT75: u8 = 2u8;
    pub const L_DOT0: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SpeedStateScaleFactorsSf_High(pub u8);
impl SpeedStateScaleFactorsSf_High {
    pub const O_DOT25: u8 = 0u8;
    pub const O_DOT5: u8 = 1u8;
    pub const O_DOT75: u8 = 2u8;
    pub const L_DOT0: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct SubframeBitmapSL_r12_bs4_r12(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct SubframeBitmapSL_r12_bs8_r12(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "12", sz_ub = "12")]
pub struct SubframeBitmapSL_r12_bs12_r12(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct SubframeBitmapSL_r12_bs16_r12(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "30", sz_ub = "30")]
pub struct SubframeBitmapSL_r12_bs30_r12(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "40", sz_ub = "40")]
pub struct SubframeBitmapSL_r12_bs40_r12(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "42", sz_ub = "42")]
pub struct SubframeBitmapSL_r12_bs42_r12(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "10", sz_ub = "10")]
pub struct SubframeBitmapSL_r14_bs10_r14(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct SubframeBitmapSL_r14_bs16_r14(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "20", sz_ub = "20")]
pub struct SubframeBitmapSL_r14_bs20_r14(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "30", sz_ub = "30")]
pub struct SubframeBitmapSL_r14_bs30_r14(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "40", sz_ub = "40")]
pub struct SubframeBitmapSL_r14_bs40_r14(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "50", sz_ub = "50")]
pub struct SubframeBitmapSL_r14_bs50_r14(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "60", sz_ub = "60")]
pub struct SubframeBitmapSL_r14_bs60_r14(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "BITSTRING",
    sz_extensible = false,
    sz_lb = "100",
    sz_ub = "100"
)]
pub struct SubframeBitmapSL_r14_bs100_r14(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct SupportedBandEUTRAHalfDuplex(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SupportedBandEUTRA_v1250Dl_256QAM_r12(pub u8);
impl SupportedBandEUTRA_v1250Dl_256QAM_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SupportedBandEUTRA_v1250Ul_64QAM_r12(pub u8);
impl SupportedBandEUTRA_v1250Ul_64QAM_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SupportedBandEUTRA_v1310Ue_PowerClass_5_r13(pub u8);
impl SupportedBandEUTRA_v1310Ue_PowerClass_5_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SupportedBandEUTRA_v1320IntraFreq_CE_NeedForGaps_r13(pub u8);
impl SupportedBandEUTRA_v1320IntraFreq_CE_NeedForGaps_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct SupportedBandEUTRA_v1320Ue_PowerClass_N_r13(pub u8);
impl SupportedBandEUTRA_v1320Ue_PowerClass_N_r13 {
    pub const CLASS1: u8 = 0u8;
    pub const CLASS2: u8 = 1u8;
    pub const CLASS4: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SupportedBandInfo_r12Support_r12(pub u8);
impl SupportedBandInfo_r12Support_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct SupportedOperatorDic_r15VersionOfDictionary_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SupportedUDC_r15SupportedStandardDic_r15(pub u8);
impl SupportedUDC_r15SupportedStandardDic_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "23"
)]
pub struct SystemInfoListGERAN_Entry(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SystemInformationCriticalExtensions_criticalExtensionsFuture_r15_criticalExtensionsFuture
{}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SystemInformationCriticalExtensions_criticalExtensionsFuture_r15 {
    #[asn(key = 0, extended = false)]
    PosSystemInformation_r15(PosSystemInformation_r15_IEs),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        SystemInformationCriticalExtensions_criticalExtensionsFuture_r15_criticalExtensionsFuture,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SystemInformationCriticalExtensions {
    #[asn(key = 0, extended = false)]
    SystemInformation_r8(SystemInformation_r8_IEs),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture_r15(SystemInformationCriticalExtensions_criticalExtensionsFuture_r15),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "9", extensible = true)]
pub enum SystemInformation_r8_IEsSib_TypeAndInfo_Entry {
    #[asn(key = 0, extended = false)]
    Sib2(SystemInformationBlockType2),
    #[asn(key = 1, extended = false)]
    Sib3(SystemInformationBlockType3),
    #[asn(key = 2, extended = false)]
    Sib4(SystemInformationBlockType4),
    #[asn(key = 3, extended = false)]
    Sib5(SystemInformationBlockType5),
    #[asn(key = 4, extended = false)]
    Sib6(SystemInformationBlockType6),
    #[asn(key = 5, extended = false)]
    Sib7(SystemInformationBlockType7),
    #[asn(key = 6, extended = false)]
    Sib8(SystemInformationBlockType8),
    #[asn(key = 7, extended = false)]
    Sib9(SystemInformationBlockType9),
    #[asn(key = 8, extended = false)]
    Sib10(SystemInformationBlockType10),
    #[asn(key = 9, extended = false)]
    Sib11(SystemInformationBlockType11),
    #[asn(key = 0, extended = true)]
    Sib12_v920(SystemInformationBlockType12_r9),
    #[asn(key = 1, extended = true)]
    Sib13_v920(SystemInformationBlockType13_r9),
    #[asn(key = 2, extended = true)]
    Sib14_v1130(SystemInformationBlockType14_r11),
    #[asn(key = 3, extended = true)]
    Sib15_v1130(SystemInformationBlockType15_r11),
    #[asn(key = 4, extended = true)]
    Sib16_v1130(SystemInformationBlockType16_r11),
    #[asn(key = 5, extended = true)]
    Sib17_v1250(SystemInformationBlockType17_r12),
    #[asn(key = 6, extended = true)]
    Sib18_v1250(SystemInformationBlockType18_r12),
    #[asn(key = 7, extended = true)]
    Sib19_v1250(SystemInformationBlockType19_r12),
    #[asn(key = 8, extended = true)]
    Sib20_v1310(SystemInformationBlockType20_r13),
    #[asn(key = 9, extended = true)]
    Sib21_v1430(SystemInformationBlockType21_r14),
    #[asn(key = 10, extended = true)]
    Sib24_v1530(SystemInformationBlockType24_r15),
    #[asn(key = 11, extended = true)]
    Sib25_v1530(SystemInformationBlockType25_r15),
    #[asn(key = 12, extended = true)]
    Sib26_v1530(SystemInformationBlockType26_r15),
    #[asn(key = 13, extended = true)]
    Sib26a_v1610(SystemInformationBlockType26a_r16),
    #[asn(key = 14, extended = true)]
    Sib27_v1610(SystemInformationBlockType27_r16),
    #[asn(key = 15, extended = true)]
    Sib28_v1610(SystemInformationBlockType28_r16),
    #[asn(key = 16, extended = true)]
    Sib29_v1610(SystemInformationBlockType29_r16),
    #[asn(key = 17, extended = true)]
    Sib30_v1700(SystemInformationBlockType30_r17),
    #[asn(key = 18, extended = true)]
    Sib31_v1700(SystemInformationBlockType31_r17),
    #[asn(key = 19, extended = true)]
    Sib32_v1700(SystemInformationBlockType32_r17),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct SystemInformation_r8_IEsSib_TypeAndInfo(
    pub Vec<SystemInformation_r8_IEsSib_TypeAndInfo_Entry>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformation_v8a0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SystemInformation_v8a0_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockPos_r15AssistanceDataSIB_Element_r15(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockPos_r15LateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SystemInformationBlockType1CellAccessRelatedInfoCellBarred(pub u8);
impl SystemInformationBlockType1CellAccessRelatedInfoCellBarred {
    pub const BARRED: u8 = 0u8;
    pub const NOT_BARRED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SystemInformationBlockType1CellAccessRelatedInfoIntraFreqReselection(pub u8);
impl SystemInformationBlockType1CellAccessRelatedInfoIntraFreqReselection {
    pub const ALLOWED: u8 = 0u8;
    pub const NOT_ALLOWED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct SystemInformationBlockType1CellAccessRelatedInfoCsg_Indication(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SystemInformationBlockType1CellAccessRelatedInfo {
    pub plmn_identity_list: PLMN_IdentityList,
    pub tracking_area_code: TrackingAreaCode,
    pub cell_identity: CellIdentity,
    pub cell_barred: SystemInformationBlockType1CellAccessRelatedInfoCellBarred,
    pub intra_freq_reselection:
        SystemInformationBlockType1CellAccessRelatedInfoIntraFreqReselection,
    pub csg_indication: SystemInformationBlockType1CellAccessRelatedInfoCsg_Indication,
    #[asn(optional_idx = 0)]
    pub csg_identity: Option<CSG_Identity>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8")]
pub struct SystemInformationBlockType1CellSelectionInfoQ_RxLevMinOffset(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SystemInformationBlockType1CellSelectionInfo {
    pub q_rx_lev_min: Q_RxLevMin,
    #[asn(optional_idx = 0)]
    pub q_rx_lev_min_offset: Option<SystemInformationBlockType1CellSelectionInfoQ_RxLevMinOffset>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "6")]
pub struct SystemInformationBlockType1Si_WindowLength(pub u8);
impl SystemInformationBlockType1Si_WindowLength {
    pub const MS1: u8 = 0u8;
    pub const MS2: u8 = 1u8;
    pub const MS5: u8 = 2u8;
    pub const MS10: u8 = 3u8;
    pub const MS15: u8 = 4u8;
    pub const MS20: u8 = 5u8;
    pub const MS40: u8 = 6u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct SystemInformationBlockType1SystemInfoValueTag(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SystemInformationBlockType1_MBMS_r14CellAccessRelatedInfo_r14 {
    pub plmn_identity_list_r14: PLMN_IdentityList_MBMS_r14,
    pub tracking_area_code_r14: TrackingAreaCode,
    pub cell_identity_r14: CellIdentity,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct SystemInformationBlockType1_MBMS_r14Si_WindowLength_r14(pub u8);
impl SystemInformationBlockType1_MBMS_r14Si_WindowLength_r14 {
    pub const MS1: u8 = 0u8;
    pub const MS2: u8 = 1u8;
    pub const MS5: u8 = 2u8;
    pub const MS10: u8 = 3u8;
    pub const MS15: u8 = 4u8;
    pub const MS20: u8 = 5u8;
    pub const MS40: u8 = 6u8;
    pub const MS80: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct SystemInformationBlockType1_MBMS_r14SystemInfoValueTag_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "5")]
pub struct SystemInformationBlockType1_MBMS_r14CellAccessRelatedInfoList_r14(
    pub Vec<CellAccessRelatedInfo_r14>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SystemInformationBlockType1_MBMS_r14NonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType1_v10x0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SystemInformationBlockType1_v1250_IEsCellAccessRelatedInfo_v1250Category0Allowed_r12(
    pub u8,
);
impl SystemInformationBlockType1_v1250_IEsCellAccessRelatedInfo_v1250Category0Allowed_r12 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SystemInformationBlockType1_v1250_IEsCellAccessRelatedInfo_v1250 {
    #[asn(optional_idx = 0)]
    pub category0_allowed_r12: Option<
        SystemInformationBlockType1_v1250_IEsCellAccessRelatedInfo_v1250Category0Allowed_r12,
    >,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SystemInformationBlockType1_v1250_IEsFreqBandIndicatorPriority_r12(pub u8);
impl SystemInformationBlockType1_v1250_IEsFreqBandIndicatorPriority_r12 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "10", sz_ub = "10")]
pub struct SystemInformationBlockType1_v1310_IEsHyperSFN_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SystemInformationBlockType1_v1310_IEsEDRX_Allowed_r13(pub u8);
impl SystemInformationBlockType1_v1310_IEsEDRX_Allowed_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct SystemInformationBlockType1_v1310_IEsBandwidthReducedAccessRelatedInfo_r13Si_WindowLength_BR_r13(
    pub u8,
);
impl
    SystemInformationBlockType1_v1310_IEsBandwidthReducedAccessRelatedInfo_r13Si_WindowLength_BR_r13
{
    pub const MS20: u8 = 0u8;
    pub const MS40: u8 = 1u8;
    pub const MS60: u8 = 2u8;
    pub const MS80: u8 = 3u8;
    pub const MS120: u8 = 4u8;
    pub const MS160: u8 = 5u8;
    pub const MS200: u8 = 6u8;
    pub const SPARE: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SystemInformationBlockType1_v1310_IEsBandwidthReducedAccessRelatedInfo_r13Si_RepetitionPattern_r13(
    pub u8,
);
impl SystemInformationBlockType1_v1310_IEsBandwidthReducedAccessRelatedInfo_r13Si_RepetitionPattern_r13 { pub const EVERY_RF : u8 = 0u8 ; pub const EVERY2ND_RF : u8 = 1u8 ; pub const EVERY4TH_RF : u8 = 2u8 ; pub const EVERY8TH_RF : u8 = 3u8 ; }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "10", sz_ub = "10")]
pub struct SystemInformationBlockType1_v1310_IEsBandwidthReducedAccessRelatedInfo_r13Fdd_DownlinkOrTddSubframeBitmapBR_r13_subframePattern10_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "40", sz_ub = "40")]
pub struct SystemInformationBlockType1_v1310_IEsBandwidthReducedAccessRelatedInfo_r13Fdd_DownlinkOrTddSubframeBitmapBR_r13_subframePattern40_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SystemInformationBlockType1_v1310_IEsBandwidthReducedAccessRelatedInfo_r13Fdd_DownlinkOrTddSubframeBitmapBR_r13
{
    # [asn (key = 0 , extended = false)] SubframePattern10_r13 (SystemInformationBlockType1_v1310_IEsBandwidthReducedAccessRelatedInfo_r13Fdd_DownlinkOrTddSubframeBitmapBR_r13_subframePattern10_r13) , # [asn (key = 1 , extended = false)] SubframePattern40_r13 (SystemInformationBlockType1_v1310_IEsBandwidthReducedAccessRelatedInfo_r13Fdd_DownlinkOrTddSubframeBitmapBR_r13_subframePattern40_r13) , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "10", sz_ub = "10")]
pub struct SystemInformationBlockType1_v1310_IEsBandwidthReducedAccessRelatedInfo_r13Fdd_UplinkSubframeBitmapBR_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4")]
pub struct SystemInformationBlockType1_v1310_IEsBandwidthReducedAccessRelatedInfo_r13StartSymbolBR_r13(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SystemInformationBlockType1_v1310_IEsBandwidthReducedAccessRelatedInfo_r13Si_HoppingConfigCommon_r13(
    pub u8,
);
impl SystemInformationBlockType1_v1310_IEsBandwidthReducedAccessRelatedInfo_r13Si_HoppingConfigCommon_r13 { pub const ON : u8 = 0u8 ; pub const OFF : u8 = 1u8 ; }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SystemInformationBlockType1_v1310_IEsBandwidthReducedAccessRelatedInfo_r13Si_ValidityTime_r13(
    pub u8,
);
impl SystemInformationBlockType1_v1310_IEsBandwidthReducedAccessRelatedInfo_r13Si_ValidityTime_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 5)]
pub struct SystemInformationBlockType1_v1310_IEsBandwidthReducedAccessRelatedInfo_r13 { pub si_window_length_br_r13 : SystemInformationBlockType1_v1310_IEsBandwidthReducedAccessRelatedInfo_r13Si_WindowLength_BR_r13 , pub si_repetition_pattern_r13 : SystemInformationBlockType1_v1310_IEsBandwidthReducedAccessRelatedInfo_r13Si_RepetitionPattern_r13 , # [asn (optional_idx = 0 ,)] pub scheduling_info_list_br_r13 : Option < SchedulingInfoList_BR_r13 > , # [asn (optional_idx = 1 ,)] pub fdd_downlink_or_tdd_subframe_bitmap_br_r13 : Option < SystemInformationBlockType1_v1310_IEsBandwidthReducedAccessRelatedInfo_r13Fdd_DownlinkOrTddSubframeBitmapBR_r13 > , # [asn (optional_idx = 2 ,)] pub fdd_uplink_subframe_bitmap_br_r13 : Option < SystemInformationBlockType1_v1310_IEsBandwidthReducedAccessRelatedInfo_r13Fdd_UplinkSubframeBitmapBR_r13 > , pub start_symbol_br_r13 : SystemInformationBlockType1_v1310_IEsBandwidthReducedAccessRelatedInfo_r13StartSymbolBR_r13 , pub si_hopping_config_common_r13 : SystemInformationBlockType1_v1310_IEsBandwidthReducedAccessRelatedInfo_r13Si_HoppingConfigCommon_r13 , # [asn (optional_idx = 3 ,)] pub si_validity_time_r13 : Option < SystemInformationBlockType1_v1310_IEsBandwidthReducedAccessRelatedInfo_r13Si_ValidityTime_r13 > , # [asn (optional_idx = 4 ,)] pub system_info_value_tag_list_r13 : Option < SystemInfoValueTagList_r13 > , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SystemInformationBlockType1_v1320_IEsFreqHoppingParametersDL_r13Mpdcch_pdsch_HoppingNB_r13(
    pub u8,
);
impl SystemInformationBlockType1_v1320_IEsFreqHoppingParametersDL_r13Mpdcch_pdsch_HoppingNB_r13 {
    pub const NB2: u8 = 0u8;
    pub const NB4: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SystemInformationBlockType1_v1320_IEsFreqHoppingParametersDL_r13Interval_DLHoppingConfigCommonModeA_r13_interval_FDD_r13(
    pub u8,
);
impl SystemInformationBlockType1_v1320_IEsFreqHoppingParametersDL_r13Interval_DLHoppingConfigCommonModeA_r13_interval_FDD_r13 { pub const INT1 : u8 = 0u8 ; pub const INT2 : u8 = 1u8 ; pub const INT4 : u8 = 2u8 ; pub const INT8 : u8 = 3u8 ; }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SystemInformationBlockType1_v1320_IEsFreqHoppingParametersDL_r13Interval_DLHoppingConfigCommonModeA_r13_interval_TDD_r13(
    pub u8,
);
impl SystemInformationBlockType1_v1320_IEsFreqHoppingParametersDL_r13Interval_DLHoppingConfigCommonModeA_r13_interval_TDD_r13 { pub const INT1 : u8 = 0u8 ; pub const INT5 : u8 = 1u8 ; pub const INT10 : u8 = 2u8 ; pub const INT20 : u8 = 3u8 ; }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SystemInformationBlockType1_v1320_IEsFreqHoppingParametersDL_r13Interval_DLHoppingConfigCommonModeA_r13
{
    # [asn (key = 0 , extended = false)] Interval_FDD_r13 (SystemInformationBlockType1_v1320_IEsFreqHoppingParametersDL_r13Interval_DLHoppingConfigCommonModeA_r13_interval_FDD_r13) , # [asn (key = 1 , extended = false)] Interval_TDD_r13 (SystemInformationBlockType1_v1320_IEsFreqHoppingParametersDL_r13Interval_DLHoppingConfigCommonModeA_r13_interval_TDD_r13) , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SystemInformationBlockType1_v1320_IEsFreqHoppingParametersDL_r13Interval_DLHoppingConfigCommonModeB_r13_interval_FDD_r13(
    pub u8,
);
impl SystemInformationBlockType1_v1320_IEsFreqHoppingParametersDL_r13Interval_DLHoppingConfigCommonModeB_r13_interval_FDD_r13 { pub const INT2 : u8 = 0u8 ; pub const INT4 : u8 = 1u8 ; pub const INT8 : u8 = 2u8 ; pub const INT16 : u8 = 3u8 ; }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SystemInformationBlockType1_v1320_IEsFreqHoppingParametersDL_r13Interval_DLHoppingConfigCommonModeB_r13_interval_TDD_r13(
    pub u8,
);
impl SystemInformationBlockType1_v1320_IEsFreqHoppingParametersDL_r13Interval_DLHoppingConfigCommonModeB_r13_interval_TDD_r13 { pub const INT5 : u8 = 0u8 ; pub const INT10 : u8 = 1u8 ; pub const INT20 : u8 = 2u8 ; pub const INT40 : u8 = 3u8 ; }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SystemInformationBlockType1_v1320_IEsFreqHoppingParametersDL_r13Interval_DLHoppingConfigCommonModeB_r13
{
    # [asn (key = 0 , extended = false)] Interval_FDD_r13 (SystemInformationBlockType1_v1320_IEsFreqHoppingParametersDL_r13Interval_DLHoppingConfigCommonModeB_r13_interval_FDD_r13) , # [asn (key = 1 , extended = false)] Interval_TDD_r13 (SystemInformationBlockType1_v1320_IEsFreqHoppingParametersDL_r13Interval_DLHoppingConfigCommonModeB_r13_interval_TDD_r13) , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct SystemInformationBlockType1_v1320_IEsFreqHoppingParametersDL_r13Mpdcch_pdsch_HoppingOffset_r13(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct SystemInformationBlockType1_v1320_IEsFreqHoppingParametersDL_r13 { # [asn (optional_idx = 0 ,)] pub mpdcch_pdsch_hopping_nb_r13 : Option < SystemInformationBlockType1_v1320_IEsFreqHoppingParametersDL_r13Mpdcch_pdsch_HoppingNB_r13 > , # [asn (optional_idx = 1 ,)] pub interval_dl_hopping_config_common_mode_a_r13 : Option < SystemInformationBlockType1_v1320_IEsFreqHoppingParametersDL_r13Interval_DLHoppingConfigCommonModeA_r13 > , # [asn (optional_idx = 2 ,)] pub interval_dl_hopping_config_common_mode_b_r13 : Option < SystemInformationBlockType1_v1320_IEsFreqHoppingParametersDL_r13Interval_DLHoppingConfigCommonModeB_r13 > , # [asn (optional_idx = 3 ,)] pub mpdcch_pdsch_hopping_offset_r13 : Option < SystemInformationBlockType1_v1320_IEsFreqHoppingParametersDL_r13Mpdcch_pdsch_HoppingOffset_r13 > , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SystemInformationBlockType1_v1430_IEsECallOverIMS_Support_r14(pub u8);
impl SystemInformationBlockType1_v1430_IEsECallOverIMS_Support_r14 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "5")]
pub struct SystemInformationBlockType1_v1430_IEsCellAccessRelatedInfoList_r14(
    pub Vec<CellAccessRelatedInfo_r14>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SystemInformationBlockType1_v1530_IEsHsdn_Cell_r15(pub u8);
impl SystemInformationBlockType1_v1530_IEsHsdn_Cell_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct SystemInformationBlockType1_v1530_IEsCrs_IntfMitigConfig_r15_crs_IntfMitigEnabled;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SystemInformationBlockType1_v1530_IEsCrs_IntfMitigConfig_r15_crs_IntfMitigNumPRBs(
    pub u8,
);
impl SystemInformationBlockType1_v1530_IEsCrs_IntfMitigConfig_r15_crs_IntfMitigNumPRBs {
    pub const N6: u8 = 0u8;
    pub const N24: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SystemInformationBlockType1_v1530_IEsCrs_IntfMitigConfig_r15 {
    #[asn(key = 0, extended = false)]
    Crs_IntfMitigEnabled(
        SystemInformationBlockType1_v1530_IEsCrs_IntfMitigConfig_r15_crs_IntfMitigEnabled,
    ),
    #[asn(key = 1, extended = false)]
    Crs_IntfMitigNumPRBs(
        SystemInformationBlockType1_v1530_IEsCrs_IntfMitigConfig_r15_crs_IntfMitigNumPRBs,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SystemInformationBlockType1_v1530_IEsCellBarred_CRS_r15(pub u8);
impl SystemInformationBlockType1_v1530_IEsCellBarred_CRS_r15 {
    pub const BARRED: u8 = 0u8;
    pub const NOT_BARRED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SystemInformationBlockType1_v1530_IEsCellAccessRelatedInfo_5GC_r15CellBarred_5GC_r15(
    pub u8,
);
impl SystemInformationBlockType1_v1530_IEsCellAccessRelatedInfo_5GC_r15CellBarred_5GC_r15 {
    pub const BARRED: u8 = 0u8;
    pub const NOT_BARRED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SystemInformationBlockType1_v1530_IEsCellAccessRelatedInfo_5GC_r15CellBarred_5GC_CRS_r15(
    pub u8,
);
impl SystemInformationBlockType1_v1530_IEsCellAccessRelatedInfo_5GC_r15CellBarred_5GC_CRS_r15 {
    pub const BARRED: u8 = 0u8;
    pub const NOT_BARRED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct SystemInformationBlockType1_v1530_IEsCellAccessRelatedInfo_5GC_r15CellAccessRelatedInfoList_5GC_r15(
    pub Vec<CellAccessRelatedInfo_5GC_r15>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SystemInformationBlockType1_v1530_IEsCellAccessRelatedInfo_5GC_r15 { pub cell_barred_5gc_r15 : SystemInformationBlockType1_v1530_IEsCellAccessRelatedInfo_5GC_r15CellBarred_5GC_r15 , pub cell_barred_5gc_crs_r15 : SystemInformationBlockType1_v1530_IEsCellAccessRelatedInfo_5GC_r15CellBarred_5GC_CRS_r15 , pub cell_access_related_info_list_5gc_r15 : SystemInformationBlockType1_v1530_IEsCellAccessRelatedInfo_5GC_r15CellAccessRelatedInfoList_5GC_r15 , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SystemInformationBlockType1_v1530_IEsIms_EmergencySupport5GC_r15(pub u8);
impl SystemInformationBlockType1_v1530_IEsIms_EmergencySupport5GC_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SystemInformationBlockType1_v1530_IEsECallOverIMS_Support5GC_r15(pub u8);
impl SystemInformationBlockType1_v1530_IEsECallOverIMS_Support5GC_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SystemInformationBlockType1_v1540_IEsSi_posOffset_r15(pub u8);
impl SystemInformationBlockType1_v1540_IEsSi_posOffset_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SystemInformationBlockType1_v15g0_IEsBandwidthReducedAccessRelatedInfo_v15g0 {
    pub pos_scheduling_info_list_br_r15: SchedulingInfoList_BR_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SystemInformationBlockType1_v15g0_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SystemInformationBlockType1_v1610_IEsEDRX_Allowed_5GC_r16(pub u8);
impl SystemInformationBlockType1_v1610_IEsEDRX_Allowed_5GC_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SystemInformationBlockType1_v1610_IEsTransmissionInControlChRegion_r16(pub u8);
impl SystemInformationBlockType1_v1610_IEsTransmissionInControlChRegion_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SystemInformationBlockType1_v1610_IEsCampingAllowedInCE_r16(pub u8);
impl SystemInformationBlockType1_v1610_IEsCampingAllowedInCE_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SystemInformationBlockType1_v1700_IEsCellAccessRelatedInfo_NTN_r17CellBarred_NTN_r17(
    pub u8,
);
impl SystemInformationBlockType1_v1700_IEsCellAccessRelatedInfo_NTN_r17CellBarred_NTN_r17 {
    pub const BARRED: u8 = 0u8;
    pub const NOT_BARRED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SystemInformationBlockType1_v1700_IEsCellAccessRelatedInfo_NTN_r17 {
    pub cell_barred_ntn_r17:
        SystemInformationBlockType1_v1700_IEsCellAccessRelatedInfo_NTN_r17CellBarred_NTN_r17,
    #[asn(optional_idx = 0)]
    pub plmn_identity_list_v1700: Option<PLMN_IdentityList_v1700>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SystemInformationBlockType1_v1700_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType1_v890_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SystemInformationBlockType1_v920_IEsIms_EmergencySupport_r9(pub u8);
impl SystemInformationBlockType1_v920_IEsIms_EmergencySupport_r9 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct SystemInformationBlockType10MessageIdentifier(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct SystemInformationBlockType10SerialNumber(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct SystemInformationBlockType10WarningType(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "50",
    sz_ub = "50"
)]
pub struct SystemInformationBlockType10Dummy(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct SystemInformationBlockType11MessageIdentifier(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct SystemInformationBlockType11SerialNumber(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SystemInformationBlockType11WarningMessageSegmentType(pub u8);
impl SystemInformationBlockType11WarningMessageSegmentType {
    pub const NOT_LAST_SEGMENT: u8 = 0u8;
    pub const LAST_SEGMENT: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63")]
pub struct SystemInformationBlockType11WarningMessageSegmentNumber(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType11WarningMessageSegment(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "1", sz_ub = "1")]
pub struct SystemInformationBlockType11DataCodingScheme(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct SystemInformationBlockType12_r9MessageIdentifier_r9(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct SystemInformationBlockType12_r9SerialNumber_r9(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SystemInformationBlockType12_r9WarningMessageSegmentType_r9(pub u8);
impl SystemInformationBlockType12_r9WarningMessageSegmentType_r9 {
    pub const NOT_LAST_SEGMENT: u8 = 0u8;
    pub const LAST_SEGMENT: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63")]
pub struct SystemInformationBlockType12_r9WarningMessageSegmentNumber_r9(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType12_r9WarningMessageSegment_r9(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "1", sz_ub = "1")]
pub struct SystemInformationBlockType12_r9DataCodingScheme_r9(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType12_r9LateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType13_r9LateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct SystemInformationBlockType14_r11Eab_Param_r11_eab_PerPLMN_List_r11(
    pub Vec<EAB_ConfigPLMN_r11>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SystemInformationBlockType14_r11Eab_Param_r11 {
    #[asn(key = 0, extended = false)]
    Eab_Common_r11(EAB_Config_r11),
    #[asn(key = 1, extended = false)]
    Eab_PerPLMN_List_r11(SystemInformationBlockType14_r11Eab_Param_r11_eab_PerPLMN_List_r11),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType14_r11LateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType15_r11LateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "549755813887")]
pub struct SystemInformationBlockType16_r11TimeInfo_r11TimeInfoUTC_r11(pub u64);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct SystemInformationBlockType16_r11TimeInfo_r11DayLightSavingTime_r11(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-127", ub = "128")]
pub struct SystemInformationBlockType16_r11TimeInfo_r11LeapSeconds_r11(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-63", ub = "64")]
pub struct SystemInformationBlockType16_r11TimeInfo_r11LocalTimeOffset_r11(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SystemInformationBlockType16_r11TimeInfo_r11 {
    pub time_info_utc_r11: SystemInformationBlockType16_r11TimeInfo_r11TimeInfoUTC_r11,
    #[asn(optional_idx = 0)]
    pub day_light_saving_time_r11:
        Option<SystemInformationBlockType16_r11TimeInfo_r11DayLightSavingTime_r11>,
    #[asn(optional_idx = 1)]
    pub leap_seconds_r11: Option<SystemInformationBlockType16_r11TimeInfo_r11LeapSeconds_r11>,
    #[asn(optional_idx = 2)]
    pub local_time_offset_r11:
        Option<SystemInformationBlockType16_r11TimeInfo_r11LocalTimeOffset_r11>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType16_r11LateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct SystemInformationBlockType17_r12Wlan_OffloadInfoPerPLMN_List_r12(
    pub Vec<WLAN_OffloadInfoPerPLMN_r12>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType17_r12LateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SystemInformationBlockType18_r12CommConfig_r12 {
    pub comm_rx_pool_r12: SL_CommRxPoolList_r12,
    #[asn(optional_idx = 0)]
    pub comm_tx_pool_normal_common_r12: Option<SL_CommTxPoolList_r12>,
    #[asn(optional_idx = 1)]
    pub comm_tx_pool_exceptional_r12: Option<SL_CommTxPoolList_r12>,
    #[asn(optional_idx = 2)]
    pub comm_sync_config_r12: Option<SL_SyncConfigList_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType18_r12LateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SystemInformationBlockType19_r12DiscConfig_r12 {
    pub disc_rx_pool_r12: SL_DiscRxPoolList_r12,
    #[asn(optional_idx = 0)]
    pub disc_tx_pool_common_r12: Option<SL_DiscTxPoolList_r12>,
    #[asn(optional_idx = 1)]
    pub disc_tx_power_info_r12: Option<SL_DiscTxPowerInfoList_r12>,
    #[asn(optional_idx = 2)]
    pub disc_sync_config_r12: Option<SL_SyncConfigList_r12>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType19_r12LateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct SystemInformationBlockType2Ac_BarringInfoAc_BarringForEmergency(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SystemInformationBlockType2Ac_BarringInfo {
    pub ac_barring_for_emergency: SystemInformationBlockType2Ac_BarringInfoAc_BarringForEmergency,
    #[asn(optional_idx = 0)]
    pub ac_barring_for_mo_signalling: Option<AC_BarringConfig>,
    #[asn(optional_idx = 1)]
    pub ac_barring_for_mo_data: Option<AC_BarringConfig>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct SystemInformationBlockType2FreqInfoUl_Bandwidth(pub u8);
impl SystemInformationBlockType2FreqInfoUl_Bandwidth {
    pub const N6: u8 = 0u8;
    pub const N15: u8 = 1u8;
    pub const N25: u8 = 2u8;
    pub const N50: u8 = 3u8;
    pub const N75: u8 = 4u8;
    pub const N100: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct SystemInformationBlockType2FreqInfo {
    #[asn(optional_idx = 0)]
    pub ul_carrier_freq: Option<ARFCN_ValueEUTRA>,
    #[asn(optional_idx = 1)]
    pub ul_bandwidth: Option<SystemInformationBlockType2FreqInfoUl_Bandwidth>,
    pub additional_spectrum_emission: AdditionalSpectrumEmission,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SystemInformationBlockType2_v10m0_IEsFreqInfo_v10l0 {
    pub additional_spectrum_emission_v10l0: AdditionalSpectrumEmission_v10l0,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SystemInformationBlockType2_v10m0_IEsMultiBandInfoList_v10l0(
    pub Vec<AdditionalSpectrumEmission_v10l0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType2_v10n0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SystemInformationBlockType2_v13c0_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SystemInformationBlockType2_v8h0_IEsMultiBandInfoList(
    pub Vec<AdditionalSpectrumEmission>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType2_v9i0_IEsNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SystemInformationBlockType2_v9i0_IEsDummy {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct SystemInformationBlockType20_r13Sc_mcch_RepetitionPeriod_r13(pub u8);
impl SystemInformationBlockType20_r13Sc_mcch_RepetitionPeriod_r13 {
    pub const RF2: u8 = 0u8;
    pub const RF4: u8 = 1u8;
    pub const RF8: u8 = 2u8;
    pub const RF16: u8 = 3u8;
    pub const RF32: u8 = 4u8;
    pub const RF64: u8 = 5u8;
    pub const RF128: u8 = 6u8;
    pub const RF256: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "10")]
pub struct SystemInformationBlockType20_r13Sc_mcch_Offset_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "9")]
pub struct SystemInformationBlockType20_r13Sc_mcch_FirstSubframe_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "2", ub = "9")]
pub struct SystemInformationBlockType20_r13Sc_mcch_duration_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct SystemInformationBlockType20_r13Sc_mcch_ModificationPeriod_r13(pub u8);
impl SystemInformationBlockType20_r13Sc_mcch_ModificationPeriod_r13 {
    pub const RF2: u8 = 0u8;
    pub const RF4: u8 = 1u8;
    pub const RF8: u8 = 2u8;
    pub const RF16: u8 = 3u8;
    pub const RF32: u8 = 4u8;
    pub const RF64: u8 = 5u8;
    pub const RF128: u8 = 6u8;
    pub const RF256: u8 = 7u8;
    pub const RF512: u8 = 8u8;
    pub const RF1024: u8 = 9u8;
    pub const R2048: u8 = 10u8;
    pub const RF4096: u8 = 11u8;
    pub const RF8192: u8 = 12u8;
    pub const RF16384: u8 = 13u8;
    pub const RF32768: u8 = 14u8;
    pub const RF65536: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType20_r13LateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType21_r14LateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType24_r15LateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "2", sz_ub = "6")]
pub struct SystemInformationBlockType25_r15Uac_AC1_SelectAssistInfo_r15_individualPLMNList_r15(
    pub Vec<UAC_AC1_SelectAssistInfo_r15>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SystemInformationBlockType25_r15Uac_AC1_SelectAssistInfo_r15 {
    #[asn(key = 0, extended = false)]
    PlmnCommon_r15(UAC_AC1_SelectAssistInfo_r15),
    #[asn(key = 1, extended = false)]
    IndividualPLMNList_r15(
        SystemInformationBlockType25_r15Uac_AC1_SelectAssistInfo_r15_individualPLMNList_r15,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType25_r15LateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct SystemInformationBlockType26_r15Slss_TxMultiFreq_r15(pub u8);
impl SystemInformationBlockType26_r15Slss_TxMultiFreq_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "45")]
pub struct SystemInformationBlockType26_r15ThreshS_RSSI_CBR_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType26a_r16LateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType27_r16LateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63")]
pub struct SystemInformationBlockType28_r16SegmentNumber_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct SystemInformationBlockType28_r16SegmentType_r16(pub u8);
impl SystemInformationBlockType28_r16SegmentType_r16 {
    pub const NOT_LAST_SEGMENT: u8 = 0u8;
    pub const LAST_SEGMENT: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType28_r16SegmentContainer_r16(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType28_r16LateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType29_r16LateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct SystemInformationBlockType3CellReselectionInfoCommonQ_Hyst(pub u8);
impl SystemInformationBlockType3CellReselectionInfoCommonQ_Hyst {
    pub const D_B0: u8 = 0u8;
    pub const D_B1: u8 = 1u8;
    pub const D_B2: u8 = 2u8;
    pub const D_B3: u8 = 3u8;
    pub const D_B4: u8 = 4u8;
    pub const D_B5: u8 = 5u8;
    pub const D_B6: u8 = 6u8;
    pub const D_B8: u8 = 7u8;
    pub const D_B10: u8 = 8u8;
    pub const D_B12: u8 = 9u8;
    pub const D_B14: u8 = 10u8;
    pub const D_B16: u8 = 11u8;
    pub const D_B18: u8 = 12u8;
    pub const D_B20: u8 = 13u8;
    pub const D_B22: u8 = 14u8;
    pub const D_B24: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SystemInformationBlockType3CellReselectionInfoCommonSpeedStateReselectionParsQ_HystSFSf_Medium(
    pub u8,
);
impl
    SystemInformationBlockType3CellReselectionInfoCommonSpeedStateReselectionParsQ_HystSFSf_Medium
{
    pub const D_B_6: u8 = 0u8;
    pub const D_B_4: u8 = 1u8;
    pub const D_B_2: u8 = 2u8;
    pub const D_B0: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct SystemInformationBlockType3CellReselectionInfoCommonSpeedStateReselectionParsQ_HystSFSf_High(
    pub u8,
);
impl SystemInformationBlockType3CellReselectionInfoCommonSpeedStateReselectionParsQ_HystSFSf_High {
    pub const D_B_6: u8 = 0u8;
    pub const D_B_4: u8 = 1u8;
    pub const D_B_2: u8 = 2u8;
    pub const D_B0: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SystemInformationBlockType3CellReselectionInfoCommonSpeedStateReselectionParsQ_HystSF { pub sf_medium : SystemInformationBlockType3CellReselectionInfoCommonSpeedStateReselectionParsQ_HystSFSf_Medium , pub sf_high : SystemInformationBlockType3CellReselectionInfoCommonSpeedStateReselectionParsQ_HystSFSf_High , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SystemInformationBlockType3CellReselectionInfoCommonSpeedStateReselectionPars {
    pub mobility_state_parameters: MobilityStateParameters,
    pub q_hyst_sf:
        SystemInformationBlockType3CellReselectionInfoCommonSpeedStateReselectionParsQ_HystSF,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SystemInformationBlockType3CellReselectionInfoCommon {
    pub q_hyst: SystemInformationBlockType3CellReselectionInfoCommonQ_Hyst,
    #[asn(optional_idx = 0)]
    pub speed_state_reselection_pars:
        Option<SystemInformationBlockType3CellReselectionInfoCommonSpeedStateReselectionPars>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SystemInformationBlockType3CellReselectionServingFreqInfo {
    #[asn(optional_idx = 0)]
    pub s_non_intra_search: Option<ReselectionThreshold>,
    pub thresh_serving_low: ReselectionThreshold,
    pub cell_reselection_priority: CellReselectionPriority,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 4)]
pub struct SystemInformationBlockType3IntraFreqCellReselectionInfo {
    pub q_rx_lev_min: Q_RxLevMin,
    #[asn(optional_idx = 0)]
    pub p_max: Option<P_Max>,
    #[asn(optional_idx = 1)]
    pub s_intra_search: Option<ReselectionThreshold>,
    #[asn(optional_idx = 2)]
    pub allowed_meas_bandwidth: Option<AllowedMeasBandwidth>,
    pub presence_antenna_port1: PresenceAntennaPort1,
    pub neigh_cell_config: NeighCellConfig,
    pub t_reselection_eutra: T_Reselection,
    #[asn(optional_idx = 3)]
    pub t_reselection_eutra_sf: Option<SpeedStateScaleFactors>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SystemInformationBlockType3_v10l0_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct SystemInformationBlockType30_r17CommonPLMNsWithDisasterCondition_r17(
    pub Vec<PLMN_Identity>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct SystemInformationBlockType30_r17ApplicableDisasterInfoList_r17(
    pub Vec<ApplicableDisasterInfo_r17>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType30_r17LateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType31_r17LateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType32_r17LateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SystemInformationBlockType5_v10j0_IEsInterFreqCarrierFreqList_v10j0(
    pub Vec<InterFreqCarrierFreqInfo_v10j0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SystemInformationBlockType5_v10l0_IEsInterFreqCarrierFreqList_v10l0(
    pub Vec<InterFreqCarrierFreqInfo_v10l0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SystemInformationBlockType5_v13a0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SystemInformationBlockType5_v13a0_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SystemInformationBlockType5_v8h0_IEsInterFreqCarrierFreqList_v8h0(
    pub Vec<InterFreqCarrierFreqInfo_v8h0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct SystemInformationBlockType5_v9e0_IEsInterFreqCarrierFreqList_v9e0(
    pub Vec<InterFreqCarrierFreqInfo_v9e0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct SystemInformationBlockType6_v8h0_IEsCarrierFreqListUTRA_FDD_v8h0(
    pub Vec<CarrierFreqInfoUTRA_FDD_v8h0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SystemInformationBlockType6_v8h0_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct SystemInformationBlockType8SearchWindowSize(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SystemInformationBlockType8ParametersHRPD {
    pub pre_registration_info_hrpd: PreRegistrationInfoHRPD,
    #[asn(optional_idx = 0)]
    pub cell_reselection_parameters_hrpd: Option<CellReselectionParametersCDMA2000>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "42", sz_ub = "42")]
pub struct SystemInformationBlockType8Parameters1XRTTLongCodeState1XRTT(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 3)]
pub struct SystemInformationBlockType8Parameters1XRTT {
    #[asn(optional_idx = 0)]
    pub csfb_registration_param1_xrtt: Option<CSFB_RegistrationParam1XRTT>,
    #[asn(optional_idx = 1)]
    pub long_code_state1_xrtt: Option<SystemInformationBlockType8Parameters1XRTTLongCodeState1XRTT>,
    #[asn(optional_idx = 2)]
    pub cell_reselection_parameters1_xrtt: Option<CellReselectionParametersCDMA2000>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "48"
)]
pub struct SystemInformationBlockType9Hnb_Name(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct SystemTimeInfoCDMA2000Cdma_EUTRA_Synchronisation(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "39", sz_ub = "39")]
pub struct SystemTimeInfoCDMA2000Cdma_SystemTime_synchronousSystemTime(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "49", sz_ub = "49")]
pub struct SystemTimeInfoCDMA2000Cdma_SystemTime_asynchronousSystemTime(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SystemTimeInfoCDMA2000Cdma_SystemTime {
    #[asn(key = 0, extended = false)]
    SynchronousSystemTime(SystemTimeInfoCDMA2000Cdma_SystemTime_synchronousSystemTime),
    #[asn(key = 1, extended = false)]
    AsynchronousSystemTime(SystemTimeInfoCDMA2000Cdma_SystemTime_asynchronousSystemTime),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "6")]
pub struct TDD_ConfigSubframeAssignment(pub u8);
impl TDD_ConfigSubframeAssignment {
    pub const SA0: u8 = 0u8;
    pub const SA1: u8 = 1u8;
    pub const SA2: u8 = 2u8;
    pub const SA3: u8 = 3u8;
    pub const SA4: u8 = 4u8;
    pub const SA5: u8 = 5u8;
    pub const SA6: u8 = 6u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "8")]
pub struct TDD_ConfigSpecialSubframePatterns(pub u8);
impl TDD_ConfigSpecialSubframePatterns {
    pub const SSP0: u8 = 0u8;
    pub const SSP1: u8 = 1u8;
    pub const SSP2: u8 = 2u8;
    pub const SSP3: u8 = 3u8;
    pub const SSP4: u8 = 4u8;
    pub const SSP5: u8 = 5u8;
    pub const SSP6: u8 = 6u8;
    pub const SSP7: u8 = 7u8;
    pub const SSP8: u8 = 8u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct TDD_Config_v1130SpecialSubframePatterns_v1130(pub u8);
impl TDD_Config_v1130SpecialSubframePatterns_v1130 {
    pub const SSP7: u8 = 0u8;
    pub const SSP9: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct TDD_Config_v1430SpecialSubframePatterns_v1430(pub u8);
impl TDD_Config_v1430SpecialSubframePatterns_v1430 {
    pub const SSP10: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct TDD_Config_v1450SpecialSubframePatterns_v1450(pub u8);
impl TDD_Config_v1450SpecialSubframePatterns_v1450 {
    pub const SSP10_CRS_LESS_DW_PTS: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct TDD_ConfigSL_r12SubframeAssignmentSL_r12(pub u8);
impl TDD_ConfigSL_r12SubframeAssignmentSL_r12 {
    pub const NONE: u8 = 0u8;
    pub const SA0: u8 = 1u8;
    pub const SA1: u8 = 2u8;
    pub const SA2: u8 = 3u8;
    pub const SA3: u8 = 4u8;
    pub const SA4: u8 = 5u8;
    pub const SA5: u8 = 6u8;
    pub const SA6: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct TDD_PUSCH_UpPTS_r14_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct TDD_PUSCH_UpPTS_r14_setupSymPUSCH_UpPTS_r14(pub u8);
impl TDD_PUSCH_UpPTS_r14_setupSymPUSCH_UpPTS_r14 {
    pub const SYM1: u8 = 0u8;
    pub const SYM2: u8 = 1u8;
    pub const SYM3: u8 = 2u8;
    pub const SYM4: u8 = 3u8;
    pub const SYM5: u8 = 4u8;
    pub const SYM6: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct TDD_PUSCH_UpPTS_r14_setupDmrs_LessUpPTS_Config_r14(pub u8);
impl TDD_PUSCH_UpPTS_r14_setupDmrs_LessUpPTS_Config_r14 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct TDD_PUSCH_UpPTS_r14_setup {
    #[asn(optional_idx = 0)]
    pub sym_pusch_up_pts_r14: Option<TDD_PUSCH_UpPTS_r14_setupSymPUSCH_UpPTS_r14>,
    #[asn(optional_idx = 1)]
    pub dmrs_less_up_pts_config_r14: Option<TDD_PUSCH_UpPTS_r14_setupDmrs_LessUpPTS_Config_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct TDM_AssistanceInfo_r11_drx_AssistanceInfo_r11Drx_CycleLength_r11(pub u8);
impl TDM_AssistanceInfo_r11_drx_AssistanceInfo_r11Drx_CycleLength_r11 {
    pub const SF40: u8 = 0u8;
    pub const SF64: u8 = 1u8;
    pub const SF80: u8 = 2u8;
    pub const SF128: u8 = 3u8;
    pub const SF160: u8 = 4u8;
    pub const SF256: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct TDM_AssistanceInfo_r11_drx_AssistanceInfo_r11Drx_Offset_r11(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct TDM_AssistanceInfo_r11_drx_AssistanceInfo_r11Drx_ActiveTime_r11(pub u8);
impl TDM_AssistanceInfo_r11_drx_AssistanceInfo_r11Drx_ActiveTime_r11 {
    pub const SF20: u8 = 0u8;
    pub const SF30: u8 = 1u8;
    pub const SF40: u8 = 2u8;
    pub const SF60: u8 = 3u8;
    pub const SF80: u8 = 4u8;
    pub const SF100: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct TDM_AssistanceInfo_r11_drx_AssistanceInfo_r11 {
    pub drx_cycle_length_r11: TDM_AssistanceInfo_r11_drx_AssistanceInfo_r11Drx_CycleLength_r11,
    #[asn(optional_idx = 0)]
    pub drx_offset_r11: Option<TDM_AssistanceInfo_r11_drx_AssistanceInfo_r11Drx_Offset_r11>,
    pub drx_active_time_r11: TDM_AssistanceInfo_r11_drx_AssistanceInfo_r11Drx_ActiveTime_r11,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct TDM_PatternConfig_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "9")]
pub struct TDM_PatternConfig_r15_setupHarq_Offset_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TDM_PatternConfig_r15_setup {
    pub subframe_assignment_r15: SubframeAssignment_r15,
    pub harq_offset_r15: TDM_PatternConfig_r15_setupHarq_Offset_r15,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2097151")]
pub struct TLE_EphemerisParameters_r17Inclination_r17(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4194303")]
pub struct TLE_EphemerisParameters_r17ArgumentPerigee_r17(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4194303")]
pub struct TLE_EphemerisParameters_r17RightAscension_r17(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4194303")]
pub struct TLE_EphemerisParameters_r17MeanAnomaly_r17(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "16777215")]
pub struct TLE_EphemerisParameters_r17Eccentricity_r17(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "17179869183")]
pub struct TLE_EphemerisParameters_r17MeanMotion_r17(pub u64);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-99999", ub = "99999")]
pub struct TLE_EphemerisParameters_r17BStarDecimal_r17(pub i32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-9", ub = "9")]
pub struct TLE_EphemerisParameters_r17BStarExponent_r17(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-1048575", ub = "1048575")]
pub struct TLE_EphemerisParameters_r17EpochStar_r17(pub i32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "6")]
pub struct TMGI_r9Plmn_Id_r9_plmn_Index_r9(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum TMGI_r9Plmn_Id_r9 {
    #[asn(key = 0, extended = false)]
    Plmn_Index_r9(TMGI_r9Plmn_Id_r9_plmn_Index_r9),
    #[asn(key = 1, extended = false)]
    ExplicitValue_r9(PLMN_Identity),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct TMGI_r9ServiceId_r9(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "15")]
pub struct TPC_Index_indexOfFormat3(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "31")]
pub struct TPC_Index_indexOfFormat3A(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct TPC_PDCCH_Config_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct TPC_PDCCH_Config_setupTpc_RNTI(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TPC_PDCCH_Config_setup {
    pub tpc_rnti: TPC_PDCCH_Config_setupTpc_RNTI,
    pub tpc_index: TPC_Index,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct TPC_PDCCH_ConfigSCell_r13_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TPC_PDCCH_ConfigSCell_r13_setup {
    pub tpc_index_pucch_s_cell_r13: TPC_Index,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-5", ub = "91")]
pub struct ThresholdUTRA_utra_RSCP(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "49")]
pub struct ThresholdUTRA_utra_EcN0(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "12")]
pub struct TimeReferenceInfo_r15Uncertainty_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct TimeReferenceInfo_r15TimeInfoType_r15(pub u8);
impl TimeReferenceInfo_r15TimeInfoType_r15 {
    pub const LOCAL_CLOCK: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023")]
pub struct TimeReferenceInfo_r15ReferenceSFN_r15(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct TraceReference_r10TraceId_r10(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct TrackingAreaCodeList_v1130Plmn_Identity_perTAC_List_r11(pub Vec<PLMN_Identity>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "11")]
pub struct TrafficPatternInfo_r14TrafficPeriodicity_r14(pub u8);
impl TrafficPatternInfo_r14TrafficPeriodicity_r14 {
    pub const SF20: u8 = 0u8;
    pub const SF50: u8 = 1u8;
    pub const SF100: u8 = 2u8;
    pub const SF200: u8 = 3u8;
    pub const SF300: u8 = 4u8;
    pub const SF400: u8 = 5u8;
    pub const SF500: u8 = 6u8;
    pub const SF600: u8 = 7u8;
    pub const SF700: u8 = 8u8;
    pub const SF800: u8 = 9u8;
    pub const SF900: u8 = 10u8;
    pub const SF1000: u8 = 11u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "10239")]
pub struct TrafficPatternInfo_r14TimingOffset_r14(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "3", ub = "10")]
pub struct TrafficPatternInfo_r14LogicalChannelIdentityUL_r14(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "6", sz_ub = "6")]
pub struct TrafficPatternInfo_r14MessageSize_r14(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct UAC_BarringInfoSet_r15Uac_BarringFactor_r15(pub u8);
impl UAC_BarringInfoSet_r15Uac_BarringFactor_r15 {
    pub const P00: u8 = 0u8;
    pub const P05: u8 = 1u8;
    pub const P10: u8 = 2u8;
    pub const P15: u8 = 3u8;
    pub const P20: u8 = 4u8;
    pub const P25: u8 = 5u8;
    pub const P30: u8 = 6u8;
    pub const P40: u8 = 7u8;
    pub const P50: u8 = 8u8;
    pub const P60: u8 = 9u8;
    pub const P70: u8 = 10u8;
    pub const P75: u8 = 11u8;
    pub const P80: u8 = 12u8;
    pub const P85: u8 = 13u8;
    pub const P90: u8 = 14u8;
    pub const P95: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct UAC_BarringInfoSet_r15Uac_BarringTime_r15(pub u8);
impl UAC_BarringInfoSet_r15Uac_BarringTime_r15 {
    pub const S4: u8 = 0u8;
    pub const S8: u8 = 1u8;
    pub const S16: u8 = 2u8;
    pub const S32: u8 = 3u8;
    pub const S64: u8 = 4u8;
    pub const S128: u8 = 5u8;
    pub const S256: u8 = 6u8;
    pub const S512: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "7", sz_ub = "7")]
pub struct UAC_BarringInfoSet_r15Uac_BarringForAccessIdentity_r15(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct UAC_BarringInfoSet_v1700Uac_BarringFactorForAI3_r17(pub u8);
impl UAC_BarringInfoSet_v1700Uac_BarringFactorForAI3_r17 {
    pub const P00: u8 = 0u8;
    pub const P05: u8 = 1u8;
    pub const P10: u8 = 2u8;
    pub const P15: u8 = 3u8;
    pub const P20: u8 = 4u8;
    pub const P25: u8 = 5u8;
    pub const P30: u8 = 6u8;
    pub const P40: u8 = 7u8;
    pub const P50: u8 = 8u8;
    pub const P60: u8 = 9u8;
    pub const P70: u8 = 10u8;
    pub const P75: u8 = 11u8;
    pub const P80: u8 = 12u8;
    pub const P85: u8 = 13u8;
    pub const P90: u8 = 14u8;
    pub const P95: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "63")]
pub struct UAC_BarringPerCat_r15AccessCategory_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "6")]
pub struct UAC_BarringPerPLMN_r15Plmn_IdentityIndex_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "63",
    sz_ub = "63"
)]
pub struct UAC_BarringPerPLMN_r15Uac_AC_BarringListType_r15_uac_ImplicitAC_BarringList_r15(
    pub Vec<UAC_BarringInfoSetIndex_r15>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UAC_BarringPerPLMN_r15Uac_AC_BarringListType_r15 {
    #[asn(key = 0, extended = false)]
    Uac_ImplicitAC_BarringList_r15(
        UAC_BarringPerPLMN_r15Uac_AC_BarringListType_r15_uac_ImplicitAC_BarringList_r15,
    ),
    #[asn(key = 1, extended = false)]
    Uac_ExplicitAC_BarringList_r15(UAC_BarringPerCatList_r15),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UDT_Restricting_r13Udt_Restricting_r13(pub u8);
impl UDT_Restricting_r13Udt_Restricting_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct UDT_Restricting_r13Udt_RestrictingTime_r13(pub u8);
impl UDT_Restricting_r13Udt_RestrictingTime_r13 {
    pub const S4: u8 = 0u8;
    pub const S8: u8 = 1u8;
    pub const S16: u8 = 2u8;
    pub const S32: u8 = 3u8;
    pub const S64: u8 = 4u8;
    pub const S128: u8 = 5u8;
    pub const S256: u8 = 6u8;
    pub const S512: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "6")]
pub struct UDT_RestrictingPerPLMN_r13Plmn_IdentityIndex_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UE_BasedNetwPerfMeasParameters_r10LoggedMeasurementsIdle_r10(pub u8);
impl UE_BasedNetwPerfMeasParameters_r10LoggedMeasurementsIdle_r10 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UE_BasedNetwPerfMeasParameters_r10StandaloneGNSS_Location_r10(pub u8);
impl UE_BasedNetwPerfMeasParameters_r10StandaloneGNSS_Location_r10 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UE_BasedNetwPerfMeasParameters_v1250LoggedMBSFNMeasurements_r12(pub u8);
impl UE_BasedNetwPerfMeasParameters_v1250LoggedMBSFNMeasurements_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UE_BasedNetwPerfMeasParameters_v1430LocationReport_r14(pub u8);
impl UE_BasedNetwPerfMeasParameters_v1430LocationReport_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UE_BasedNetwPerfMeasParameters_v1530LoggedMeasBT_r15(pub u8);
impl UE_BasedNetwPerfMeasParameters_v1530LoggedMeasBT_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UE_BasedNetwPerfMeasParameters_v1530LoggedMeasWLAN_r15(pub u8);
impl UE_BasedNetwPerfMeasParameters_v1530LoggedMeasWLAN_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UE_BasedNetwPerfMeasParameters_v1530ImmMeasBT_r15(pub u8);
impl UE_BasedNetwPerfMeasParameters_v1530ImmMeasBT_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UE_BasedNetwPerfMeasParameters_v1530ImmMeasWLAN_r15(pub u8);
impl UE_BasedNetwPerfMeasParameters_v1530ImmMeasWLAN_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UE_BasedNetwPerfMeasParameters_v1610Ul_PDCP_AvgDelay_r16(pub u8);
impl UE_BasedNetwPerfMeasParameters_v1610Ul_PDCP_AvgDelay_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UE_BasedNetwPerfMeasParameters_v1700LoggedMeasIdleEventL1_r17(pub u8);
impl UE_BasedNetwPerfMeasParameters_v1700LoggedMeasIdleEventL1_r17 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UE_BasedNetwPerfMeasParameters_v1700LoggedMeasIdleEventOutOfCoverage_r17(pub u8);
impl UE_BasedNetwPerfMeasParameters_v1700LoggedMeasIdleEventOutOfCoverage_r17 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UE_BasedNetwPerfMeasParameters_v1700LoggedMeasUncomBarPre_r17(pub u8);
impl UE_BasedNetwPerfMeasParameters_v1700LoggedMeasUncomBarPre_r17 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UE_BasedNetwPerfMeasParameters_v1700ImmMeasUncomBarPre_r17(pub u8);
impl UE_BasedNetwPerfMeasParameters_v1700ImmMeasUncomBarPre_r17 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UE_CapabilityRAT_ContainerUeCapabilityRAT_Container(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "5")]
pub struct UE_CategorySL_r15Ue_CategorySL_C_TX_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4")]
pub struct UE_CategorySL_r15Ue_CategorySL_C_RX_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "5")]
pub struct UE_EUTRA_CapabilityUe_Category(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct UE_EUTRA_CapabilityFeatureGroupIndicators(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 7)]
pub struct UE_EUTRA_CapabilityInterRAT_Parameters {
    #[asn(optional_idx = 0)]
    pub utra_fdd: Option<IRAT_ParametersUTRA_FDD>,
    #[asn(optional_idx = 1)]
    pub utra_tdd128: Option<IRAT_ParametersUTRA_TDD128>,
    #[asn(optional_idx = 2)]
    pub utra_tdd384: Option<IRAT_ParametersUTRA_TDD384>,
    #[asn(optional_idx = 3)]
    pub utra_tdd768: Option<IRAT_ParametersUTRA_TDD768>,
    #[asn(optional_idx = 4)]
    pub geran: Option<IRAT_ParametersGERAN>,
    #[asn(optional_idx = 5)]
    pub cdma2000_hrpd: Option<IRAT_ParametersCDMA2000_HRPD>,
    #[asn(optional_idx = 6)]
    pub cdma2000_1x_rtt: Option<IRAT_ParametersCDMA2000_1XRTT>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "6", ub = "8")]
pub struct UE_EUTRA_Capability_v1020_IEsUe_Category_v1020(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct UE_EUTRA_Capability_v1020_IEsFeatureGroupIndRel10_r10(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UE_EUTRA_Capability_v10i0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_EUTRA_Capability_v10j0_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "9", ub = "10")]
pub struct UE_EUTRA_Capability_v1170_IEsUe_Category_v1170(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "11", ub = "12")]
pub struct UE_EUTRA_Capability_v11a0_IEsUe_Category_v11a0(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UE_EUTRA_Capability_v11x0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "14")]
pub struct UE_EUTRA_Capability_v1250_IEsUe_CategoryDL_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "13")]
pub struct UE_EUTRA_Capability_v1250_IEsUe_CategoryUL_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "15", ub = "16")]
pub struct UE_EUTRA_Capability_v1260_IEsUe_CategoryDL_v1260(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UE_EUTRA_Capability_v12x0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct UE_EUTRA_Capability_v1310_IEsUe_CategoryDL_v1310(pub u8);
impl UE_EUTRA_Capability_v1310_IEsUe_CategoryDL_v1310 {
    pub const N17: u8 = 0u8;
    pub const M1: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct UE_EUTRA_Capability_v1310_IEsUe_CategoryUL_v1310(pub u8);
impl UE_EUTRA_Capability_v1310_IEsUe_CategoryUL_v1310 {
    pub const N14: u8 = 0u8;
    pub const M1: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "18", ub = "19")]
pub struct UE_EUTRA_Capability_v1330_IEsUe_CategoryDL_v1330(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UE_EUTRA_Capability_v1330_IEsUe_CE_NeedULGaps_r13(pub u8);
impl UE_EUTRA_Capability_v1330_IEsUe_CE_NeedULGaps_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "15", ub = "15")]
pub struct UE_EUTRA_Capability_v1340_IEsUe_CategoryUL_v1340(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UE_EUTRA_Capability_v1350_IEsUe_CategoryDL_v1350(pub u8);
impl UE_EUTRA_Capability_v1350_IEsUe_CategoryDL_v1350 {
    pub const ONE_BIS: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UE_EUTRA_Capability_v1350_IEsUe_CategoryUL_v1350(pub u8);
impl UE_EUTRA_Capability_v1350_IEsUe_CategoryUL_v1350 {
    pub const ONE_BIS: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UE_EUTRA_Capability_v13e0a_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_EUTRA_Capability_v13e0b_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UE_EUTRA_Capability_v1430_IEsUe_CategoryDL_v1430(pub u8);
impl UE_EUTRA_Capability_v1430_IEsUe_CategoryDL_v1430 {
    pub const M2: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct UE_EUTRA_Capability_v1430_IEsUe_CategoryUL_v1430(pub u8);
impl UE_EUTRA_Capability_v1430_IEsUe_CategoryUL_v1430 {
    pub const N16: u8 = 0u8;
    pub const N17: u8 = 1u8;
    pub const N18: u8 = 2u8;
    pub const N19: u8 = 3u8;
    pub const N20: u8 = 4u8;
    pub const M2: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UE_EUTRA_Capability_v1430_IEsUe_CategoryUL_v1430b(pub u8);
impl UE_EUTRA_Capability_v1430_IEsUe_CategoryUL_v1430b {
    pub const N21: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "20", ub = "20")]
pub struct UE_EUTRA_Capability_v1450_IEsUe_CategoryDL_v1450(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "21", ub = "21")]
pub struct UE_EUTRA_Capability_v1460_IEsUe_CategoryDL_v1460(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UE_EUTRA_Capability_v14x0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "22", ub = "26")]
pub struct UE_EUTRA_Capability_v1530_IEsUe_CategoryDL_v1530(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UE_EUTRA_Capability_v1530_IEsExtendedNumberOfDRBs_r15(pub u8);
impl UE_EUTRA_Capability_v1530_IEsExtendedNumberOfDRBs_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UE_EUTRA_Capability_v1530_IEsReducedCP_Latency_r15(pub u8);
impl UE_EUTRA_Capability_v1530_IEsReducedCP_Latency_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "22", ub = "26")]
pub struct UE_EUTRA_Capability_v1530_IEsUe_CategoryUL_v1530(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UE_EUTRA_Capability_v1560_IEsAppliedCapabilityFilterCommon_r15(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UE_EUTRA_Capability_v15x0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UE_EUTRA_Capability_v1610_IEsDl_DedicatedMessageSegmentation_r16(pub u8);
impl UE_EUTRA_Capability_v1610_IEsDl_DedicatedMessageSegmentation_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UE_EUTRA_Capability_v1630_IEsEarlySecurityReactivation_r16(pub u8);
impl UE_EUTRA_Capability_v1630_IEsEarlySecurityReactivation_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UE_EUTRA_Capability_v16c0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_EUTRA_Capability_v16c0_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UE_EUTRA_Capability_v1710_IEsSidelinkRequested_r17(pub u8);
impl UE_EUTRA_Capability_v1710_IEsSidelinkRequested_r17 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_EUTRA_Capability_v1730_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UE_EUTRA_Capability_v920_IEsDeviceType_r9(pub u8);
impl UE_EUTRA_Capability_v920_IEsDeviceType_r9 {
    pub const NO_BEN_FROM_BAT_CONSUMP_OPT: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UE_EUTRA_Capability_v940_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct UE_EUTRA_Capability_v9a0_IEsFeatureGroupIndRel9Add_r9(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UE_EUTRA_Capability_v9h0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct UE_EUTRA_CapabilityAddXDD_Mode_r9FeatureGroupIndicators_r9(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct UE_EUTRA_CapabilityAddXDD_Mode_r9FeatureGroupIndRel9Add_r9(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct UE_EUTRA_CapabilityAddXDD_Mode_v1060FeatureGroupIndRel10_v1060(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UE_EUTRA_CapabilityAddXDD_Mode_v1530ReducedCP_Latency_r15(pub u8);
impl UE_EUTRA_CapabilityAddXDD_Mode_v1530ReducedCP_Latency_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "0")]
pub struct UE_RadioPagingInfo_r12Ue_Category_v1250(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct UE_TimersAndConstantsT300(pub u8);
impl UE_TimersAndConstantsT300 {
    pub const MS100: u8 = 0u8;
    pub const MS200: u8 = 1u8;
    pub const MS300: u8 = 2u8;
    pub const MS400: u8 = 3u8;
    pub const MS600: u8 = 4u8;
    pub const MS1000: u8 = 5u8;
    pub const MS1500: u8 = 6u8;
    pub const MS2000: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct UE_TimersAndConstantsT301(pub u8);
impl UE_TimersAndConstantsT301 {
    pub const MS100: u8 = 0u8;
    pub const MS200: u8 = 1u8;
    pub const MS300: u8 = 2u8;
    pub const MS400: u8 = 3u8;
    pub const MS600: u8 = 4u8;
    pub const MS1000: u8 = 5u8;
    pub const MS1500: u8 = 6u8;
    pub const MS2000: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "6")]
pub struct UE_TimersAndConstantsT310(pub u8);
impl UE_TimersAndConstantsT310 {
    pub const MS0: u8 = 0u8;
    pub const MS50: u8 = 1u8;
    pub const MS100: u8 = 2u8;
    pub const MS200: u8 = 3u8;
    pub const MS500: u8 = 4u8;
    pub const MS1000: u8 = 5u8;
    pub const MS2000: u8 = 6u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct UE_TimersAndConstantsN310(pub u8);
impl UE_TimersAndConstantsN310 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N3: u8 = 2u8;
    pub const N4: u8 = 3u8;
    pub const N6: u8 = 4u8;
    pub const N8: u8 = 5u8;
    pub const N10: u8 = 6u8;
    pub const N20: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "6")]
pub struct UE_TimersAndConstantsT311(pub u8);
impl UE_TimersAndConstantsT311 {
    pub const MS1000: u8 = 0u8;
    pub const MS3000: u8 = 1u8;
    pub const MS5000: u8 = 2u8;
    pub const MS10000: u8 = 3u8;
    pub const MS15000: u8 = 4u8;
    pub const MS20000: u8 = 5u8;
    pub const MS30000: u8 = 6u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct UE_TimersAndConstantsN311(pub u8);
impl UE_TimersAndConstantsN311 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N3: u8 = 2u8;
    pub const N4: u8 = 3u8;
    pub const N5: u8 = 4u8;
    pub const N6: u8 = 5u8;
    pub const N8: u8 = 6u8;
    pub const N10: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UEAssistanceInformation_r11CriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UEAssistanceInformation_r11CriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UEAssistanceInformation_r11CriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum UEAssistanceInformation_r11CriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    UeAssistanceInformation_r11(UEAssistanceInformation_r11_IEs),
    #[asn(key = 1, extended = false)]
    Spare3(UEAssistanceInformation_r11CriticalExtensions_c1_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(UEAssistanceInformation_r11CriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(UEAssistanceInformation_r11CriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEAssistanceInformation_r11CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UEAssistanceInformation_r11CriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(UEAssistanceInformation_r11CriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        UEAssistanceInformation_r11CriticalExtensions_criticalExtensionsFuture,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct UEAssistanceInformation_r11_IEsPowerPrefIndication_r11(pub u8);
impl UEAssistanceInformation_r11_IEsPowerPrefIndication_r11 {
    pub const NORMAL: u8 = 0u8;
    pub const LOW_POWER_CONSUMPTION: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UEAssistanceInformation_r11_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UEAssistanceInformation_v1430_IEsSps_AssistanceInformation_r14 {
    #[asn(optional_idx = 0)]
    pub traffic_pattern_info_list_sl_r14: Option<TrafficPatternInfoList_r14>,
    #[asn(optional_idx = 1)]
    pub traffic_pattern_info_list_ul_r14: Option<TrafficPatternInfoList_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct UEAssistanceInformation_v1430_IEsRlm_Report_r14Rlm_Event_r14(pub u8);
impl UEAssistanceInformation_v1430_IEsRlm_Report_r14Rlm_Event_r14 {
    pub const EARLY_OUT_OF_SYNC: u8 = 0u8;
    pub const EARLY_IN_SYNC: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct UEAssistanceInformation_v1430_IEsRlm_Report_r14ExcessRep_MPDCCH_r14(pub u8);
impl UEAssistanceInformation_v1430_IEsRlm_Report_r14ExcessRep_MPDCCH_r14 {
    pub const EXCESS_REP1: u8 = 0u8;
    pub const EXCESS_REP2: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct UEAssistanceInformation_v1430_IEsRlm_Report_r14 {
    pub rlm_event_r14: UEAssistanceInformation_v1430_IEsRlm_Report_r14Rlm_Event_r14,
    #[asn(optional_idx = 0)]
    pub excess_rep_mpdcch_r14:
        Option<UEAssistanceInformation_v1430_IEsRlm_Report_r14ExcessRep_MPDCCH_r14>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEAssistanceInformation_v1530_IEsSps_AssistanceInformation_v1530 {
    pub traffic_pattern_info_list_sl_v1530: TrafficPatternInfoList_v1530,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UEAssistanceInformation_v1700_IEsUplinkData_r17(pub u8);
impl UEAssistanceInformation_v1700_IEsUplinkData_r17 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct UEAssistanceInformation_v1700_IEsScg_DeactivationPreference_r17(pub u8);
impl UEAssistanceInformation_v1700_IEsScg_DeactivationPreference_r17 {
    pub const SCG_DEACTIVATION_PREFERRED: u8 = 0u8;
    pub const NO_PREFERENCE: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEAssistanceInformation_v1710_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UECapabilityEnquiryCriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UECapabilityEnquiryCriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UECapabilityEnquiryCriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum UECapabilityEnquiryCriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    UeCapabilityEnquiry_r8(UECapabilityEnquiry_r8_IEs),
    #[asn(key = 1, extended = false)]
    Spare3(UECapabilityEnquiryCriticalExtensions_c1_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(UECapabilityEnquiryCriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(UECapabilityEnquiryCriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UECapabilityEnquiryCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UECapabilityEnquiryCriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(UECapabilityEnquiryCriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(UECapabilityEnquiryCriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct UECapabilityEnquiry_v1180_IEsRequestedFrequencyBands_r11(pub Vec<FreqBandIndicator_r11>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UECapabilityEnquiry_v1310_IEsRequestReducedFormat_r13(pub u8);
impl UECapabilityEnquiry_v1310_IEsRequestReducedFormat_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UECapabilityEnquiry_v1310_IEsRequestSkipFallbackComb_r13(pub u8);
impl UECapabilityEnquiry_v1310_IEsRequestSkipFallbackComb_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "2", ub = "32")]
pub struct UECapabilityEnquiry_v1310_IEsRequestedMaxCCsDL_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "2", ub = "32")]
pub struct UECapabilityEnquiry_v1310_IEsRequestedMaxCCsUL_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UECapabilityEnquiry_v1310_IEsRequestReducedIntNonContComb_r13(pub u8);
impl UECapabilityEnquiry_v1310_IEsRequestReducedIntNonContComb_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UECapabilityEnquiry_v1510_IEsRequestedFreqBandsNR_MRDC_r15(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UECapabilityEnquiry_v1530_IEsRequestSTTI_SPT_Capability_r15(pub u8);
impl UECapabilityEnquiry_v1530_IEsRequestSTTI_SPT_Capability_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UECapabilityEnquiry_v1530_IEsEutra_nr_only_r15(pub u8);
impl UECapabilityEnquiry_v1530_IEsEutra_nr_only_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UECapabilityEnquiry_v1550_IEsRequestedCapabilityNR_r15(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UECapabilityEnquiry_v1560_IEsRequestedCapabilityCommon_r15(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UECapabilityEnquiry_v1610_IEsRrc_SegAllowed_r16(pub u8);
impl UECapabilityEnquiry_v1610_IEsRrc_SegAllowed_r16 {
    pub const ENABLED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UECapabilityEnquiry_v1710_IEsSidelinkRequest_r17(pub u8);
impl UECapabilityEnquiry_v1710_IEsSidelinkRequest_r17 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UECapabilityEnquiry_v1710_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UECapabilityEnquiry_v8a0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UECapabilityInformationCriticalExtensions_c1_spare7;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UECapabilityInformationCriticalExtensions_c1_spare6;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UECapabilityInformationCriticalExtensions_c1_spare5;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UECapabilityInformationCriticalExtensions_c1_spare4;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UECapabilityInformationCriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UECapabilityInformationCriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UECapabilityInformationCriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "7", extensible = false)]
pub enum UECapabilityInformationCriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    UeCapabilityInformation_r8(UECapabilityInformation_r8_IEs),
    #[asn(key = 1, extended = false)]
    Spare7(UECapabilityInformationCriticalExtensions_c1_spare7),
    #[asn(key = 2, extended = false)]
    Spare6(UECapabilityInformationCriticalExtensions_c1_spare6),
    #[asn(key = 3, extended = false)]
    Spare5(UECapabilityInformationCriticalExtensions_c1_spare5),
    #[asn(key = 4, extended = false)]
    Spare4(UECapabilityInformationCriticalExtensions_c1_spare4),
    #[asn(key = 5, extended = false)]
    Spare3(UECapabilityInformationCriticalExtensions_c1_spare3),
    #[asn(key = 6, extended = false)]
    Spare2(UECapabilityInformationCriticalExtensions_c1_spare2),
    #[asn(key = 7, extended = false)]
    Spare1(UECapabilityInformationCriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UECapabilityInformationCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UECapabilityInformationCriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(UECapabilityInformationCriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(UECapabilityInformationCriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UECapabilityInformation_v1250_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UECapabilityInformation_v8a0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UEInformationRequest_r9CriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UEInformationRequest_r9CriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UEInformationRequest_r9CriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum UEInformationRequest_r9CriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    UeInformationRequest_r9(UEInformationRequest_r9_IEs),
    #[asn(key = 1, extended = false)]
    Spare3(UEInformationRequest_r9CriticalExtensions_c1_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(UEInformationRequest_r9CriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(UEInformationRequest_r9CriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEInformationRequest_r9CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UEInformationRequest_r9CriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(UEInformationRequest_r9CriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(UEInformationRequest_r9CriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct UEInformationRequest_r9_IEsRach_ReportReq_r9(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct UEInformationRequest_r9_IEsRlf_ReportReq_r9(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UEInformationRequest_v1020_IEsLogMeasReportReq_r10(pub u8);
impl UEInformationRequest_v1020_IEsLogMeasReportReq_r10 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UEInformationRequest_v1130_IEsConnEstFailReportReq_r11(pub u8);
impl UEInformationRequest_v1130_IEsConnEstFailReportReq_r11 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UEInformationRequest_v1250_IEsMobilityHistoryReportReq_r12(pub u8);
impl UEInformationRequest_v1250_IEsMobilityHistoryReportReq_r12 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UEInformationRequest_v1530_IEsIdleModeMeasurementReq_r15(pub u8);
impl UEInformationRequest_v1530_IEsIdleModeMeasurementReq_r15 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UEInformationRequest_v1710_IEsCoarseLocationReq_r17(pub u8);
impl UEInformationRequest_v1710_IEsCoarseLocationReq_r17 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEInformationRequest_v1710_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UEInformationRequest_v930_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UEInformationResponse_r9CriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UEInformationResponse_r9CriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UEInformationResponse_r9CriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum UEInformationResponse_r9CriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    UeInformationResponse_r9(UEInformationResponse_r9_IEs),
    #[asn(key = 1, extended = false)]
    Spare3(UEInformationResponse_r9CriticalExtensions_c1_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(UEInformationResponse_r9CriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(UEInformationResponse_r9CriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEInformationResponse_r9CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UEInformationResponse_r9CriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(UEInformationResponse_r9CriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(UEInformationResponse_r9CriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UEInformationResponse_v1710_IEsCoarseLocationInfo_r17(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEInformationResponse_v1710_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UEInformationResponse_v930_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEInformationResponse_v9e0_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UEPagingCoverageInformationCriticalExtensions_c1_spare7;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UEPagingCoverageInformationCriticalExtensions_c1_spare6;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UEPagingCoverageInformationCriticalExtensions_c1_spare5;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UEPagingCoverageInformationCriticalExtensions_c1_spare4;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UEPagingCoverageInformationCriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UEPagingCoverageInformationCriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UEPagingCoverageInformationCriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "7", extensible = false)]
pub enum UEPagingCoverageInformationCriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    UePagingCoverageInformation_r13(UEPagingCoverageInformation_r13_IEs),
    #[asn(key = 1, extended = false)]
    Spare7(UEPagingCoverageInformationCriticalExtensions_c1_spare7),
    #[asn(key = 2, extended = false)]
    Spare6(UEPagingCoverageInformationCriticalExtensions_c1_spare6),
    #[asn(key = 3, extended = false)]
    Spare5(UEPagingCoverageInformationCriticalExtensions_c1_spare5),
    #[asn(key = 4, extended = false)]
    Spare4(UEPagingCoverageInformationCriticalExtensions_c1_spare4),
    #[asn(key = 5, extended = false)]
    Spare3(UEPagingCoverageInformationCriticalExtensions_c1_spare3),
    #[asn(key = 6, extended = false)]
    Spare2(UEPagingCoverageInformationCriticalExtensions_c1_spare2),
    #[asn(key = 7, extended = false)]
    Spare1(UEPagingCoverageInformationCriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEPagingCoverageInformationCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UEPagingCoverageInformationCriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(UEPagingCoverageInformationCriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        UEPagingCoverageInformationCriticalExtensions_criticalExtensionsFuture,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "256")]
pub struct UEPagingCoverageInformation_r13_IEsMpdcch_NumRepetition_r13(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEPagingCoverageInformation_r13_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UERadioAccessCapabilityInformationCriticalExtensions_c1_spare7;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UERadioAccessCapabilityInformationCriticalExtensions_c1_spare6;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UERadioAccessCapabilityInformationCriticalExtensions_c1_spare5;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UERadioAccessCapabilityInformationCriticalExtensions_c1_spare4;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UERadioAccessCapabilityInformationCriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UERadioAccessCapabilityInformationCriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UERadioAccessCapabilityInformationCriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "7", extensible = false)]
pub enum UERadioAccessCapabilityInformationCriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    UeRadioAccessCapabilityInformation_r8(UERadioAccessCapabilityInformation_r8_IEs),
    #[asn(key = 1, extended = false)]
    Spare7(UERadioAccessCapabilityInformationCriticalExtensions_c1_spare7),
    #[asn(key = 2, extended = false)]
    Spare6(UERadioAccessCapabilityInformationCriticalExtensions_c1_spare6),
    #[asn(key = 3, extended = false)]
    Spare5(UERadioAccessCapabilityInformationCriticalExtensions_c1_spare5),
    #[asn(key = 4, extended = false)]
    Spare4(UERadioAccessCapabilityInformationCriticalExtensions_c1_spare4),
    #[asn(key = 5, extended = false)]
    Spare3(UERadioAccessCapabilityInformationCriticalExtensions_c1_spare3),
    #[asn(key = 6, extended = false)]
    Spare2(UERadioAccessCapabilityInformationCriticalExtensions_c1_spare2),
    #[asn(key = 7, extended = false)]
    Spare1(UERadioAccessCapabilityInformationCriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioAccessCapabilityInformationCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UERadioAccessCapabilityInformationCriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(UERadioAccessCapabilityInformationCriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        UERadioAccessCapabilityInformationCriticalExtensions_criticalExtensionsFuture,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UERadioAccessCapabilityInformation_r8_IEsUe_RadioAccessCapabilityInfo(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioAccessCapabilityInformation_r8_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UERadioPagingInformationCriticalExtensions_c1_spare7;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UERadioPagingInformationCriticalExtensions_c1_spare6;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UERadioPagingInformationCriticalExtensions_c1_spare5;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UERadioPagingInformationCriticalExtensions_c1_spare4;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UERadioPagingInformationCriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UERadioPagingInformationCriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UERadioPagingInformationCriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "7", extensible = false)]
pub enum UERadioPagingInformationCriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    UeRadioPagingInformation_r12(UERadioPagingInformation_r12_IEs),
    #[asn(key = 1, extended = false)]
    Spare7(UERadioPagingInformationCriticalExtensions_c1_spare7),
    #[asn(key = 2, extended = false)]
    Spare6(UERadioPagingInformationCriticalExtensions_c1_spare6),
    #[asn(key = 3, extended = false)]
    Spare5(UERadioPagingInformationCriticalExtensions_c1_spare5),
    #[asn(key = 4, extended = false)]
    Spare4(UERadioPagingInformationCriticalExtensions_c1_spare4),
    #[asn(key = 5, extended = false)]
    Spare3(UERadioPagingInformationCriticalExtensions_c1_spare3),
    #[asn(key = 6, extended = false)]
    Spare2(UERadioPagingInformationCriticalExtensions_c1_spare2),
    #[asn(key = 7, extended = false)]
    Spare1(UERadioPagingInformationCriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioPagingInformationCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UERadioPagingInformationCriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(UERadioPagingInformationCriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(UERadioPagingInformationCriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UERadioPagingInformation_r12_IEsUe_RadioPagingInfo_r12(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct UERadioPagingInformation_v1310_IEsSupportedBandListEUTRAForPaging_r13(
    pub Vec<FreqBandIndicator_r11>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UERadioPagingInformation_v1610_IEsAccessStratumRelease_r16(pub u8);
impl UERadioPagingInformation_v1610_IEsAccessStratumRelease_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioPagingInformation_v1610_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct UL_256QAM_perCC_Info_r14Ul_256QAM_perCC_r14(pub u8);
impl UL_256QAM_perCC_Info_r14Ul_256QAM_perCC_r14 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct UL_AM_RLCMaxRetxThreshold(pub u8);
impl UL_AM_RLCMaxRetxThreshold {
    pub const T1: u8 = 0u8;
    pub const T2: u8 = 1u8;
    pub const T3: u8 = 2u8;
    pub const T4: u8 = 3u8;
    pub const T6: u8 = 4u8;
    pub const T8: u8 = 5u8;
    pub const T16: u8 = 6u8;
    pub const T32: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct UL_AM_RLC_r15MaxRetxThreshold_r15(pub u8);
impl UL_AM_RLC_r15MaxRetxThreshold_r15 {
    pub const T1: u8 = 0u8;
    pub const T2: u8 = 1u8;
    pub const T3: u8 = 2u8;
    pub const T4: u8 = 3u8;
    pub const T6: u8 = 4u8;
    pub const T8: u8 = 5u8;
    pub const T16: u8 = 6u8;
    pub const T32: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct UL_AM_RLC_r15Extended_RLC_LI_Field_r15(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UL_CCCH_MessageType_c1 {
    #[asn(key = 0, extended = false)]
    RrcConnectionReestablishmentRequest(RRCConnectionReestablishmentRequest),
    #[asn(key = 1, extended = false)]
    RrcConnectionRequest(RRCConnectionRequest),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = false)]
pub enum UL_CCCH_MessageType_messageClassExtension_c2 {
    #[asn(key = 0, extended = false)]
    RrcConnectionResumeRequest_r13(RRCConnectionResumeRequest_r13),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UL_CCCH_MessageType_messageClassExtension_messageClassExtensionFuture_r13_c3_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UL_CCCH_MessageType_messageClassExtension_messageClassExtensionFuture_r13_c3_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UL_CCCH_MessageType_messageClassExtension_messageClassExtensionFuture_r13_c3_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum UL_CCCH_MessageType_messageClassExtension_messageClassExtensionFuture_r13_c3 {
    #[asn(key = 0, extended = false)]
    RrcEarlyDataRequest_r15(RRCEarlyDataRequest_r15),
    #[asn(key = 1, extended = false)]
    Spare3(UL_CCCH_MessageType_messageClassExtension_messageClassExtensionFuture_r13_c3_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(UL_CCCH_MessageType_messageClassExtension_messageClassExtensionFuture_r13_c3_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(UL_CCCH_MessageType_messageClassExtension_messageClassExtensionFuture_r13_c3_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UL_CCCH_MessageType_messageClassExtension_messageClassExtensionFuture_r13_messageClassExtensionFuture_r15
{}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UL_CCCH_MessageType_messageClassExtension_messageClassExtensionFuture_r13 {
    # [asn (key = 0 , extended = false)] C3 (UL_CCCH_MessageType_messageClassExtension_messageClassExtensionFuture_r13_c3) , # [asn (key = 1 , extended = false)] MessageClassExtensionFuture_r15 (UL_CCCH_MessageType_messageClassExtension_messageClassExtensionFuture_r13_messageClassExtensionFuture_r15) , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UL_CCCH_MessageType_messageClassExtension {
    #[asn(key = 0, extended = false)]
    C2(UL_CCCH_MessageType_messageClassExtension_c2),
    #[asn(key = 1, extended = false)]
    MessageClassExtensionFuture_r13(
        UL_CCCH_MessageType_messageClassExtension_messageClassExtensionFuture_r13,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "15", extensible = false)]
pub enum UL_DCCH_MessageType_c1 {
    #[asn(key = 0, extended = false)]
    CsfbParametersRequestCDMA2000(CSFBParametersRequestCDMA2000),
    #[asn(key = 1, extended = false)]
    MeasurementReport(MeasurementReport),
    #[asn(key = 2, extended = false)]
    RrcConnectionReconfigurationComplete(RRCConnectionReconfigurationComplete),
    #[asn(key = 3, extended = false)]
    RrcConnectionReestablishmentComplete(RRCConnectionReestablishmentComplete),
    #[asn(key = 4, extended = false)]
    RrcConnectionSetupComplete(RRCConnectionSetupComplete),
    #[asn(key = 5, extended = false)]
    SecurityModeComplete(SecurityModeComplete),
    #[asn(key = 6, extended = false)]
    SecurityModeFailure(SecurityModeFailure),
    #[asn(key = 7, extended = false)]
    UeCapabilityInformation(UECapabilityInformation),
    #[asn(key = 8, extended = false)]
    UlHandoverPreparationTransfer(ULHandoverPreparationTransfer),
    #[asn(key = 9, extended = false)]
    UlInformationTransfer(ULInformationTransfer),
    #[asn(key = 10, extended = false)]
    CounterCheckResponse(CounterCheckResponse),
    #[asn(key = 11, extended = false)]
    UeInformationResponse_r9(UEInformationResponse_r9),
    #[asn(key = 12, extended = false)]
    ProximityIndication_r9(ProximityIndication_r9),
    #[asn(key = 13, extended = false)]
    RnReconfigurationComplete_r10(RNReconfigurationComplete_r10),
    #[asn(key = 14, extended = false)]
    MbmsCountingResponse_r10(MBMSCountingResponse_r10),
    #[asn(key = 15, extended = false)]
    InterFreqRSTDMeasurementIndication_r10(InterFreqRSTDMeasurementIndication_r10),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "15", extensible = false)]
pub enum UL_DCCH_MessageType_messageClassExtension_c2 {
    #[asn(key = 0, extended = false)]
    UeAssistanceInformation_r11(UEAssistanceInformation_r11),
    #[asn(key = 1, extended = false)]
    InDeviceCoexIndication_r11(InDeviceCoexIndication_r11),
    #[asn(key = 2, extended = false)]
    MbmsInterestIndication_r11(MBMSInterestIndication_r11),
    #[asn(key = 3, extended = false)]
    ScgFailureInformation_r12(SCGFailureInformation_r12),
    #[asn(key = 4, extended = false)]
    SidelinkUEInformation_r12(SidelinkUEInformation_r12),
    #[asn(key = 5, extended = false)]
    WlanConnectionStatusReport_r13(WLANConnectionStatusReport_r13),
    #[asn(key = 6, extended = false)]
    RrcConnectionResumeComplete_r13(RRCConnectionResumeComplete_r13),
    #[asn(key = 7, extended = false)]
    UlInformationTransferMRDC_r15(ULInformationTransferMRDC_r15),
    #[asn(key = 8, extended = false)]
    ScgFailureInformationNR_r15(SCGFailureInformationNR_r15),
    #[asn(key = 9, extended = false)]
    MeasReportAppLayer_r15(MeasReportAppLayer_r15),
    #[asn(key = 10, extended = false)]
    FailureInformation_r15(FailureInformation_r15),
    #[asn(key = 11, extended = false)]
    UlDedicatedMessageSegment_r16(ULDedicatedMessageSegment_r16),
    #[asn(key = 12, extended = false)]
    PurConfigurationRequest_r16(PURConfigurationRequest_r16),
    #[asn(key = 13, extended = false)]
    FailureInformation_r16(FailureInformation_r16),
    #[asn(key = 14, extended = false)]
    McgFailureInformation_r16(MCGFailureInformation_r16),
    #[asn(key = 15, extended = false)]
    UlInformationTransferIRAT_r16(ULInformationTransferIRAT_r16),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UL_DCCH_MessageType_messageClassExtension_messageClassExtensionFuture_r11 {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UL_DCCH_MessageType_messageClassExtension {
    #[asn(key = 0, extended = false)]
    C2(UL_DCCH_MessageType_messageClassExtension_c2),
    #[asn(key = 1, extended = false)]
    MessageClassExtensionFuture_r11(
        UL_DCCH_MessageType_messageClassExtension_messageClassExtensionFuture_r11,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UL_DelayConfig_r13_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct UL_DelayConfig_r13_setupDelayThreshold_r13(pub u8);
impl UL_DelayConfig_r13_setupDelayThreshold_r13 {
    pub const MS30: u8 = 0u8;
    pub const MS40: u8 = 1u8;
    pub const MS50: u8 = 2u8;
    pub const MS60: u8 = 3u8;
    pub const MS70: u8 = 4u8;
    pub const MS80: u8 = 5u8;
    pub const MS90: u8 = 6u8;
    pub const MS100: u8 = 7u8;
    pub const MS150: u8 = 8u8;
    pub const MS300: u8 = 9u8;
    pub const MS500: u8 = 10u8;
    pub const MS750: u8 = 11u8;
    pub const SPARE4: u8 = 12u8;
    pub const SPARE3: u8 = 13u8;
    pub const SPARE2: u8 = 14u8;
    pub const SPARE1: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UL_DelayConfig_r13_setup {
    pub delay_threshold_r13: UL_DelayConfig_r13_setupDelayThreshold_r13,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UL_DelayValueConfig_r16_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "11")]
pub struct UL_DelayValueConfig_r16_setupDelay_DRBlist_r16(pub Vec<DRB_Identity>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UL_DelayValueConfig_r16_setup {
    pub delay_dr_blist_r16: UL_DelayValueConfig_r16_setupDelay_DRBlist_r16,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct UL_PDCP_DelayResult_r13Qci_Id_r13(pub u8);
impl UL_PDCP_DelayResult_r13Qci_Id_r13 {
    pub const QCI1: u8 = 0u8;
    pub const QCI2: u8 = 1u8;
    pub const QCI3: u8 = 2u8;
    pub const QCI4: u8 = 3u8;
    pub const SPARE4: u8 = 4u8;
    pub const SPARE3: u8 = 5u8;
    pub const SPARE2: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct UL_PDCP_DelayResult_r13ExcessDelay_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "10000")]
pub struct UL_PDCP_DelayValueResult_r16AverageDelay_r16(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct UL_ReferenceSignalsPUSCHGroupHoppingEnabled(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "29")]
pub struct UL_ReferenceSignalsPUSCHGroupAssignmentPUSCH(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct UL_ReferenceSignalsPUSCHSequenceHoppingEnabled(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct UL_ReferenceSignalsPUSCHCyclicShift(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ULDedicatedMessageSegment_r16CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum ULDedicatedMessageSegment_r16CriticalExtensions {
    #[asn(key = 0, extended = false)]
    UlDedicatedMessageSegment_r16(ULDedicatedMessageSegment_r16_IEs),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        ULDedicatedMessageSegment_r16CriticalExtensions_criticalExtensionsFuture,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct ULDedicatedMessageSegment_r16_IEsSegmentNumber_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct ULDedicatedMessageSegment_r16_IEsRrc_MessageSegmentContainer_r16(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct ULDedicatedMessageSegment_r16_IEsRrc_MessageSegmentType_r16(pub u8);
impl ULDedicatedMessageSegment_r16_IEsRrc_MessageSegmentType_r16 {
    pub const NOT_LAST_SEGMENT: u8 = 0u8;
    pub const LAST_SEGMENT: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct ULDedicatedMessageSegment_r16_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ULDedicatedMessageSegment_r16_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct ULHandoverPreparationTransferCriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct ULHandoverPreparationTransferCriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct ULHandoverPreparationTransferCriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum ULHandoverPreparationTransferCriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    UlHandoverPreparationTransfer_r8(ULHandoverPreparationTransfer_r8_IEs),
    #[asn(key = 1, extended = false)]
    Spare3(ULHandoverPreparationTransferCriticalExtensions_c1_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(ULHandoverPreparationTransferCriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(ULHandoverPreparationTransferCriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ULHandoverPreparationTransferCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum ULHandoverPreparationTransferCriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(ULHandoverPreparationTransferCriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        ULHandoverPreparationTransferCriticalExtensions_criticalExtensionsFuture,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "56", sz_ub = "56")]
pub struct ULHandoverPreparationTransfer_r8_IEsMeid(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct ULHandoverPreparationTransfer_v8a0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ULHandoverPreparationTransfer_v8a0_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct ULInformationTransferCriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct ULInformationTransferCriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum ULInformationTransferCriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    UlInformationTransfer_r8(ULInformationTransfer_r8_IEs),
    #[asn(key = 1, extended = false)]
    UlInformationTransfer_r16(ULInformationTransfer_r16_IEs),
    #[asn(key = 2, extended = false)]
    Spare2(ULInformationTransferCriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(ULInformationTransferCriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ULInformationTransferCriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum ULInformationTransferCriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(ULInformationTransferCriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(ULInformationTransferCriticalExtensions_criticalExtensionsFuture),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum ULInformationTransfer_r16_IEsDedicatedInfoType_r16 {
    #[asn(key = 0, extended = false)]
    DedicatedInfoNAS_r16(DedicatedInfoNAS),
    #[asn(key = 1, extended = false)]
    DedicatedInfoCDMA2000_1XRTT_r16(DedicatedInfoCDMA2000),
    #[asn(key = 2, extended = false)]
    DedicatedInfoCDMA2000_HRPD_r16(DedicatedInfoCDMA2000),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum ULInformationTransfer_r8_IEsDedicatedInfoType {
    #[asn(key = 0, extended = false)]
    DedicatedInfoNAS(DedicatedInfoNAS),
    #[asn(key = 1, extended = false)]
    DedicatedInfoCDMA2000_1XRTT(DedicatedInfoCDMA2000),
    #[asn(key = 2, extended = false)]
    DedicatedInfoCDMA2000_HRPD(DedicatedInfoCDMA2000),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct ULInformationTransfer_v8a0_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ULInformationTransfer_v8a0_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct ULInformationTransferIRAT_r16CriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct ULInformationTransferIRAT_r16CriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct ULInformationTransferIRAT_r16CriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum ULInformationTransferIRAT_r16CriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    UlInformationTransferIRAT_r16(ULInformationTransferIRAT_r16_IEs),
    #[asn(key = 1, extended = false)]
    Spare3(ULInformationTransferIRAT_r16CriticalExtensions_c1_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(ULInformationTransferIRAT_r16CriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(ULInformationTransferIRAT_r16CriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ULInformationTransferIRAT_r16CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum ULInformationTransferIRAT_r16CriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(ULInformationTransferIRAT_r16CriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        ULInformationTransferIRAT_r16CriticalExtensions_criticalExtensionsFuture,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct ULInformationTransferIRAT_r16_IEsUl_DCCH_MessageNR_r16(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct ULInformationTransferIRAT_r16_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ULInformationTransferIRAT_r16_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct ULInformationTransferMRDC_r15CriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct ULInformationTransferMRDC_r15CriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct ULInformationTransferMRDC_r15CriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum ULInformationTransferMRDC_r15CriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    UlInformationTransferMRDC_r15(ULInformationTransferMRDC_r15_IEs),
    #[asn(key = 1, extended = false)]
    Spare3(ULInformationTransferMRDC_r15CriticalExtensions_c1_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(ULInformationTransferMRDC_r15CriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(ULInformationTransferMRDC_r15CriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ULInformationTransferMRDC_r15CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum ULInformationTransferMRDC_r15CriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(ULInformationTransferMRDC_r15CriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        ULInformationTransferMRDC_r15CriticalExtensions_criticalExtensionsFuture,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct ULInformationTransferMRDC_r15_IEsUl_DCCH_MessageNR_r15(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct ULInformationTransferMRDC_r15_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ULInformationTransferMRDC_r15_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-8", ub = "7")]
pub struct UplinkPUSCH_LessPowerControlDedicated_v1430P0_UE_PeriodicSRS_r14(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-8", ub = "7")]
pub struct UplinkPUSCH_LessPowerControlDedicated_v1430P0_UE_AperiodicSRS_r14(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct UplinkPUSCH_LessPowerControlDedicated_v1430AccumulationEnabled_r14(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "31")]
pub struct UplinkPowerControlAddSRS_r16StartingBitOfFormat3B_SRS_Add_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "2")]
pub struct UplinkPowerControlAddSRS_r16FieldTypeFormat3B_SRS_Add_r16(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-16", ub = "15")]
pub struct UplinkPowerControlAddSRS_r16P0_UE_SRS_Add_r16(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct UplinkPowerControlAddSRS_r16AccumulationEnabledSRS_Add_r16(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-126", ub = "24")]
pub struct UplinkPowerControlCommonP0_NominalPUSCH(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-127", ub = "-96")]
pub struct UplinkPowerControlCommonP0_NominalPUCCH(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-1", ub = "6")]
pub struct UplinkPowerControlCommonDeltaPreambleMsg3(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct UplinkPowerControlCommon_v1020DeltaF_PUCCH_Format3_r10(pub u8);
impl UplinkPowerControlCommon_v1020DeltaF_PUCCH_Format3_r10 {
    pub const DELTA_F_1: u8 = 0u8;
    pub const DELTA_F0: u8 = 1u8;
    pub const DELTA_F1: u8 = 2u8;
    pub const DELTA_F2: u8 = 3u8;
    pub const DELTA_F3: u8 = 4u8;
    pub const DELTA_F4: u8 = 5u8;
    pub const DELTA_F5: u8 = 6u8;
    pub const DELTA_F6: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct UplinkPowerControlCommon_v1020DeltaF_PUCCH_Format1bCS_r10(pub u8);
impl UplinkPowerControlCommon_v1020DeltaF_PUCCH_Format1bCS_r10 {
    pub const DELTA_F1: u8 = 0u8;
    pub const DELTA_F2: u8 = 1u8;
    pub const SPARE2: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct UplinkPowerControlCommon_v1310DeltaF_PUCCH_Format4_r13(pub u8);
impl UplinkPowerControlCommon_v1310DeltaF_PUCCH_Format4_r13 {
    pub const DELTA_F16: u8 = 0u8;
    pub const DELTA_F15: u8 = 1u8;
    pub const DELTA_F14: u8 = 2u8;
    pub const DELTA_F13: u8 = 3u8;
    pub const DELTA_F12: u8 = 4u8;
    pub const DELTA_F11: u8 = 5u8;
    pub const DELTA_F10: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct UplinkPowerControlCommon_v1310DeltaF_PUCCH_Format5_13(pub u8);
impl UplinkPowerControlCommon_v1310DeltaF_PUCCH_Format5_13 {
    pub const DELTA_F13: u8 = 0u8;
    pub const DELTA_F12: u8 = 1u8;
    pub const DELTA_F11: u8 = 2u8;
    pub const DELTA_F10: u8 = 3u8;
    pub const DELTA_F9: u8 = 4u8;
    pub const DELTA_F8: u8 = 5u8;
    pub const DELTA_F7: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-126", ub = "24")]
pub struct UplinkPowerControlCommon_v1610P0_NominalSRS_Add_r16(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct UplinkPowerControlCommonPSCell_r12DeltaF_PUCCH_Format3_r12(pub u8);
impl UplinkPowerControlCommonPSCell_r12DeltaF_PUCCH_Format3_r12 {
    pub const DELTA_F_1: u8 = 0u8;
    pub const DELTA_F0: u8 = 1u8;
    pub const DELTA_F1: u8 = 2u8;
    pub const DELTA_F2: u8 = 3u8;
    pub const DELTA_F3: u8 = 4u8;
    pub const DELTA_F4: u8 = 5u8;
    pub const DELTA_F5: u8 = 6u8;
    pub const DELTA_F6: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct UplinkPowerControlCommonPSCell_r12DeltaF_PUCCH_Format1bCS_r12(pub u8);
impl UplinkPowerControlCommonPSCell_r12DeltaF_PUCCH_Format1bCS_r12 {
    pub const DELTA_F1: u8 = 0u8;
    pub const DELTA_F2: u8 = 1u8;
    pub const SPARE2: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-127", ub = "-96")]
pub struct UplinkPowerControlCommonPSCell_r12P0_NominalPUCCH_r12(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-126", ub = "24")]
pub struct UplinkPowerControlCommonPUSCH_LessCell_v1430P0_Nominal_PeriodicSRS_r14(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-126", ub = "24")]
pub struct UplinkPowerControlCommonPUSCH_LessCell_v1430P0_Nominal_AperiodicSRS_r14(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-126", ub = "24")]
pub struct UplinkPowerControlCommonSCell_r10P0_NominalPUSCH_r10(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-1", ub = "6")]
pub struct UplinkPowerControlCommonSCell_v1130DeltaPreambleMsg3_r11(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-127", ub = "-96")]
pub struct UplinkPowerControlCommonSCell_v1310P0_NominalPUCCH(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct UplinkPowerControlCommonSCell_v1310DeltaF_PUCCH_Format3_r12(pub u8);
impl UplinkPowerControlCommonSCell_v1310DeltaF_PUCCH_Format3_r12 {
    pub const DELTA_F_1: u8 = 0u8;
    pub const DELTA_F0: u8 = 1u8;
    pub const DELTA_F1: u8 = 2u8;
    pub const DELTA_F2: u8 = 3u8;
    pub const DELTA_F3: u8 = 4u8;
    pub const DELTA_F4: u8 = 5u8;
    pub const DELTA_F5: u8 = 6u8;
    pub const DELTA_F6: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct UplinkPowerControlCommonSCell_v1310DeltaF_PUCCH_Format1bCS_r12(pub u8);
impl UplinkPowerControlCommonSCell_v1310DeltaF_PUCCH_Format1bCS_r12 {
    pub const DELTA_F1: u8 = 0u8;
    pub const DELTA_F2: u8 = 1u8;
    pub const SPARE2: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct UplinkPowerControlCommonSCell_v1310DeltaF_PUCCH_Format4_r13(pub u8);
impl UplinkPowerControlCommonSCell_v1310DeltaF_PUCCH_Format4_r13 {
    pub const DELTA_F16: u8 = 0u8;
    pub const DELTA_F15: u8 = 1u8;
    pub const DELTA_F14: u8 = 2u8;
    pub const DELTA_F13: u8 = 3u8;
    pub const DELTA_F12: u8 = 4u8;
    pub const DELTA_F11: u8 = 5u8;
    pub const DELTA_F10: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct UplinkPowerControlCommonSCell_v1310DeltaF_PUCCH_Format5_13(pub u8);
impl UplinkPowerControlCommonSCell_v1310DeltaF_PUCCH_Format5_13 {
    pub const DELTA_F13: u8 = 0u8;
    pub const DELTA_F12: u8 = 1u8;
    pub const DELTA_F11: u8 = 2u8;
    pub const DELTA_F10: u8 = 3u8;
    pub const DELTA_F9: u8 = 4u8;
    pub const DELTA_F8: u8 = 5u8;
    pub const DELTA_F7: u8 = 6u8;
    pub const SPARE1: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-8", ub = "7")]
pub struct UplinkPowerControlDedicatedP0_UE_PUSCH(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct UplinkPowerControlDedicatedDeltaMCS_Enabled(pub u8);
impl UplinkPowerControlDedicatedDeltaMCS_Enabled {
    pub const EN0: u8 = 0u8;
    pub const EN1: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct UplinkPowerControlDedicatedAccumulationEnabled(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-8", ub = "7")]
pub struct UplinkPowerControlDedicatedP0_UE_PUCCH(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct UplinkPowerControlDedicatedPSRS_Offset(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct UplinkPowerControlDedicated_v1020PSRS_OffsetAp_r10(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "16", ub = "31")]
pub struct UplinkPowerControlDedicated_v1130PSRS_Offset_v1130(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "16", ub = "31")]
pub struct UplinkPowerControlDedicated_v1130PSRS_OffsetAp_v1130(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct UplinkPowerControlDedicated_v1250Set2PowerControlParameter_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "10", sz_ub = "10")]
pub struct UplinkPowerControlDedicated_v1250Set2PowerControlParameter_setupTpc_SubframeSet_r12(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-126", ub = "24")]
pub struct UplinkPowerControlDedicated_v1250Set2PowerControlParameter_setupP0_NominalPUSCH_SubframeSet2_r12(
    pub i8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-8", ub = "7")]
pub struct UplinkPowerControlDedicated_v1250Set2PowerControlParameter_setupP0_UE_PUSCH_SubframeSet2_r12(
    pub i8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkPowerControlDedicated_v1250Set2PowerControlParameter_setup { pub tpc_subframe_set_r12 : UplinkPowerControlDedicated_v1250Set2PowerControlParameter_setupTpc_SubframeSet_r12 , pub p0_nominal_pusch_subframe_set2_r12 : UplinkPowerControlDedicated_v1250Set2PowerControlParameter_setupP0_NominalPUSCH_SubframeSet2_r12 , pub alpha_subframe_set2_r12 : Alpha_r12 , pub p0_ue_pusch_subframe_set2_r12 : UplinkPowerControlDedicated_v1250Set2PowerControlParameter_setupP0_UE_PUSCH_SubframeSet2_r12 , }

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UplinkPowerControlDedicated_v1250Set2PowerControlParameter {
    #[asn(key = 0, extended = false)]
    Release(UplinkPowerControlDedicated_v1250Set2PowerControlParameter_release),
    #[asn(key = 1, extended = false)]
    Setup(UplinkPowerControlDedicated_v1250Set2PowerControlParameter_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-16", ub = "15")]
pub struct UplinkPowerControlDedicated_v1530P0_UE_PUSCH_r15(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-8", ub = "7")]
pub struct UplinkPowerControlDedicatedSCell_r10P0_UE_PUSCH_r10(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct UplinkPowerControlDedicatedSCell_r10DeltaMCS_Enabled_r10(pub u8);
impl UplinkPowerControlDedicatedSCell_r10DeltaMCS_Enabled_r10 {
    pub const EN0: u8 = 0u8;
    pub const EN1: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct UplinkPowerControlDedicatedSCell_r10AccumulationEnabled_r10(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct UplinkPowerControlDedicatedSCell_r10PSRS_Offset_r10(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct UplinkPowerControlDedicatedSCell_r10PSRS_OffsetAp_r10(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct UplinkPowerControlDedicatedSCell_r10PathlossReferenceLinking_r10(pub u8);
impl UplinkPowerControlDedicatedSCell_r10PathlossReferenceLinking_r10 {
    pub const P_CELL: u8 = 0u8;
    pub const S_CELL: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-8", ub = "7")]
pub struct UplinkPowerControlDedicatedSCell_v1310P0_UE_PUCCH(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct UplinkPowerControlDedicatedSTTI_r15AccumulationEnabledSTTI_r15(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct UplinkPowerControlDedicatedSTTI_r15UplinkPower_CSIPayload(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct V2X_BandCombinationParametersEUTRA_NR_v1630BandListSidelinkEUTRA_NR_r16(
    pub Vec<V2X_BandParametersEUTRA_NR_r16>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct V2X_BandCombinationParametersEUTRA_NR_v1630BandListSidelinkEUTRA_NR_v1630(
    pub Vec<V2X_BandParametersEUTRA_NR_v1630>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct V2X_BandParameters_v1530V2x_EnhancedHighReception_r15(pub u8);
impl V2X_BandParameters_v1530V2x_EnhancedHighReception_r15 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct V2X_BandParametersEUTRA_NR_r16_eutra {
    #[asn(optional_idx = 0)]
    pub v2x_band_parameters1_r16: Option<V2X_BandParameters_r14>,
    #[asn(optional_idx = 1)]
    pub v2x_band_parameters2_r16: Option<V2X_BandParameters_v1530>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct V2X_BandParametersEUTRA_NR_r16_nrV2x_BandParametersNR_r16(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct V2X_BandParametersEUTRA_NR_r16_nr {
    #[asn(optional_idx = 0)]
    pub v2x_band_parameters_nr_r16:
        Option<V2X_BandParametersEUTRA_NR_r16_nrV2x_BandParametersNR_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct V2X_BandParametersEUTRA_NR_v1630_eutra;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct V2X_BandParametersEUTRA_NR_v1630_nrTx_Sidelink_r16(pub u8);
impl V2X_BandParametersEUTRA_NR_v1630_nrTx_Sidelink_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct V2X_BandParametersEUTRA_NR_v1630_nrRx_Sidelink_r16(pub u8);
impl V2X_BandParametersEUTRA_NR_v1630_nrRx_Sidelink_r16 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct V2X_BandParametersEUTRA_NR_v1630_nr {
    #[asn(optional_idx = 0)]
    pub tx_sidelink_r16: Option<V2X_BandParametersEUTRA_NR_v1630_nrTx_Sidelink_r16>,
    #[asn(optional_idx = 1)]
    pub rx_sidelink_r16: Option<V2X_BandParametersEUTRA_NR_v1630_nrRx_Sidelink_r16>,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct V2X_BandParametersEUTRA_NR_v1710V2x_BandParametersEUTRA_NR_v1710(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct VarLogMeasConfig_r17MeasUncomBarPre_r17(pub u8);
impl VarLogMeasConfig_r17MeasUncomBarPre_r17 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct VarLogMeasReport_r10TraceRecordingSessionRef_r10(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "1", sz_ub = "1")]
pub struct VarLogMeasReport_r10Tce_Id_r10(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct VarLogMeasReport_r11TraceRecordingSessionRef_r10(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "1", sz_ub = "1")]
pub struct VarLogMeasReport_r11Tce_Id_r10(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "-140", ub = "-44")]
pub struct VarMeasConfigS_Measure(pub i8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct VarMeasConfigSpeedStatePars_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct VarMeasConfigSpeedStatePars_setup {
    pub mobility_state_parameters: MobilityStateParameters,
    pub time_to_trigger_sf: SpeedStateScaleFactors,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum VarMeasConfigSpeedStatePars {
    #[asn(key = 0, extended = false)]
    Release(VarMeasConfigSpeedStatePars_release),
    #[asn(key = 1, extended = false)]
    Setup(VarMeasConfigSpeedStatePars_setup),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct VarMeasConfigAllowInterruptions_r11(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "6")]
pub struct VarMeasIdleConfig_r15MeasIdleDuration_r15(pub u8);
impl VarMeasIdleConfig_r15MeasIdleDuration_r15 {
    pub const SEC10: u8 = 0u8;
    pub const SEC30: u8 = 1u8;
    pub const SEC60: u8 = 2u8;
    pub const SEC120: u8 = 3u8;
    pub const SEC180: u8 = 4u8;
    pub const SEC240: u8 = 5u8;
    pub const SEC300: u8 = 6u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER")]
pub struct VarMeasReportNumberOfReportsSent(pub i64);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct VarPendingRnaUpdate_r15PendingRnaUpdate(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "1", sz_ub = "1")]
pub struct VarShortResumeMAC_Input_r13ResumeDiscriminator_r13(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct VarWLAN_MobilityConfigSuccessReportRequested(pub u8);
impl VarWLAN_MobilityConfigSuccessReportRequested {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct VictimSystemType_r11Gps_r11(pub u8);
impl VictimSystemType_r11Gps_r11 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct VictimSystemType_r11Glonass_r11(pub u8);
impl VictimSystemType_r11Glonass_r11 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct VictimSystemType_r11Bds_r11(pub u8);
impl VictimSystemType_r11Bds_r11 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct VictimSystemType_r11Galileo_r11(pub u8);
impl VictimSystemType_r11Galileo_r11 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct VictimSystemType_r11Wlan_r11(pub u8);
impl VictimSystemType_r11Wlan_r11 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct VictimSystemType_r11Bluetooth_r11(pub u8);
impl VictimSystemType_r11Bluetooth_r11 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct VictimSystemType_v1610Navic_r16(pub u8);
impl VictimSystemType_v1610Navic_r16 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct VisitedCellInfo_r12VisitedCellId_r12_pci_arfcn_r12 {
    pub phys_cell_id_r12: PhysCellId,
    pub carrier_freq_r12: ARFCN_ValueEUTRA_r9,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum VisitedCellInfo_r12VisitedCellId_r12 {
    #[asn(key = 0, extended = false)]
    CellGlobalId_r12(CellGlobalIdEUTRA),
    #[asn(key = 1, extended = false)]
    Pci_arfcn_r12(VisitedCellInfo_r12VisitedCellId_r12_pci_arfcn_r12),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct VisitedCellInfo_r12TimeSpent_r12(pub u16);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct WLAN_CarrierInfo_r13OperatingClass_r13(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct WLAN_CarrierInfo_r13CountryCode_r13(pub u8);
impl WLAN_CarrierInfo_r13CountryCode_r13 {
    pub const UNITED_STATES: u8 = 0u8;
    pub const EUROPE: u8 = 1u8;
    pub const JAPAN: u8 = 2u8;
    pub const GLOBAL: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct WLAN_IW_Parameters_r12Wlan_IW_RAN_Rules_r12(pub u8);
impl WLAN_IW_Parameters_r12Wlan_IW_RAN_Rules_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct WLAN_IW_Parameters_r12Wlan_IW_ANDSF_Policies_r12(pub u8);
impl WLAN_IW_Parameters_r12Wlan_IW_ANDSF_Policies_r12 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct WLAN_IW_Parameters_v1310Rclwi_r13(pub u8);
impl WLAN_IW_Parameters_v1310Rclwi_r13 {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "32"
)]
pub struct WLAN_Identifiers_r12Ssid_r12(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "6", sz_ub = "6")]
pub struct WLAN_Identifiers_r12Bssid_r12(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "6", sz_ub = "6")]
pub struct WLAN_Identifiers_r12Hessid_r12(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "4")]
pub struct WLAN_MobilityConfig_r13AssociationTimer_r13(pub u8);
impl WLAN_MobilityConfig_r13AssociationTimer_r13 {
    pub const S10: u8 = 0u8;
    pub const S30: u8 = 1u8;
    pub const S60: u8 = 2u8;
    pub const S120: u8 = 3u8;
    pub const S240: u8 = 4u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct WLAN_MobilityConfig_r13SuccessReportRequested_r13(pub u8);
impl WLAN_MobilityConfig_r13SuccessReportRequested_r13 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct WLAN_NameListConfig_r15_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WLAN_OffloadConfig_r12ThresholdRSRP_r12 {
    pub threshold_rsrp_low_r12: RSRP_Range,
    pub threshold_rsrp_high_r12: RSRP_Range,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WLAN_OffloadConfig_r12ThresholdRSRQ_r12 {
    pub threshold_rsrq_low_r12: RSRQ_Range,
    pub threshold_rsrq_high_r12: RSRQ_Range,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WLAN_OffloadConfig_r12ThresholdRSRQ_OnAllSymbolsWithWB_r12 {
    pub threshold_rsrq_on_all_symbols_with_wb_low_r12: RSRQ_Range,
    pub threshold_rsrq_on_all_symbols_with_wb_high_r12: RSRQ_Range,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WLAN_OffloadConfig_r12ThresholdRSRQ_OnAllSymbols_r12 {
    pub threshold_rsrq_on_all_symbols_low_r12: RSRQ_Range,
    pub threshold_rsrq_on_all_symbols_high_r12: RSRQ_Range,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WLAN_OffloadConfig_r12ThresholdRSRQ_WB_r12 {
    pub threshold_rsrq_wb_low_r12: RSRQ_Range,
    pub threshold_rsrq_wb_high_r12: RSRQ_Range,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct WLAN_OffloadConfig_r12ThresholdChannelUtilization_r12ThresholdChannelUtilizationLow_r12(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct WLAN_OffloadConfig_r12ThresholdChannelUtilization_r12ThresholdChannelUtilizationHigh_r12(
    pub u8,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WLAN_OffloadConfig_r12ThresholdChannelUtilization_r12 {
    pub threshold_channel_utilization_low_r12:
        WLAN_OffloadConfig_r12ThresholdChannelUtilization_r12ThresholdChannelUtilizationLow_r12,
    pub threshold_channel_utilization_high_r12:
        WLAN_OffloadConfig_r12ThresholdChannelUtilization_r12ThresholdChannelUtilizationHigh_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WLAN_OffloadConfig_r12ThresholdBackhaul_Bandwidth_r12 {
    pub threshold_backhaul_dl_bandwidth_low_r12: WLAN_backhaulRate_r12,
    pub threshold_backhaul_dl_bandwidth_high_r12: WLAN_backhaulRate_r12,
    pub threshold_backhaul_ul_bandwidth_low_r12: WLAN_backhaulRate_r12,
    pub threshold_backhaul_ul_bandwidth_high_r12: WLAN_backhaulRate_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct WLAN_OffloadConfig_r12ThresholdWLAN_RSSI_r12ThresholdWLAN_RSSI_Low_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct WLAN_OffloadConfig_r12ThresholdWLAN_RSSI_r12ThresholdWLAN_RSSI_High_r12(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WLAN_OffloadConfig_r12ThresholdWLAN_RSSI_r12 {
    pub threshold_wlan_rssi_low_r12:
        WLAN_OffloadConfig_r12ThresholdWLAN_RSSI_r12ThresholdWLAN_RSSI_Low_r12,
    pub threshold_wlan_rssi_high_r12:
        WLAN_OffloadConfig_r12ThresholdWLAN_RSSI_r12ThresholdWLAN_RSSI_High_r12,
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct WLAN_OffloadConfig_r12OffloadPreferenceIndicator_r12(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "16777215")]
pub struct WLAN_RTT_r15RttValue_r15(pub u32);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct WLAN_RTT_r15RttUnits_r15(pub u8);
impl WLAN_RTT_r15RttUnits_r15 {
    pub const MICROSECONDS: u8 = 0u8;
    pub const HUNDREDSOFNANOSECONDS: u8 = 1u8;
    pub const TENSOFNANOSECONDS: u8 = 2u8;
    pub const NANOSECONDS: u8 = 3u8;
    pub const TENTHSOFNANOSECONDS: u8 = 4u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct WLAN_RTT_r15RttAccuracy_r15(pub u8);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct WLAN_SuspendConfig_r14Wlan_SuspendResumeAllowed_r14(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct WLAN_SuspendConfig_r14Wlan_SuspendTriggersStatusReport_r14(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct WLANConnectionStatusReport_r13CriticalExtensions_c1_spare3;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct WLANConnectionStatusReport_r13CriticalExtensions_c1_spare2;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct WLANConnectionStatusReport_r13CriticalExtensions_c1_spare1;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum WLANConnectionStatusReport_r13CriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    WlanConnectionStatusReport_r13(WLANConnectionStatusReport_r13_IEs),
    #[asn(key = 1, extended = false)]
    Spare3(WLANConnectionStatusReport_r13CriticalExtensions_c1_spare3),
    #[asn(key = 2, extended = false)]
    Spare2(WLANConnectionStatusReport_r13CriticalExtensions_c1_spare2),
    #[asn(key = 3, extended = false)]
    Spare1(WLANConnectionStatusReport_r13CriticalExtensions_c1_spare1),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WLANConnectionStatusReport_r13CriticalExtensions_criticalExtensionsFuture {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum WLANConnectionStatusReport_r13CriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(WLANConnectionStatusReport_r13CriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        WLANConnectionStatusReport_r13CriticalExtensions_criticalExtensionsFuture,
    ),
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct WLANConnectionStatusReport_r13_IEsLateNonCriticalExtension(pub Vec<u8>);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WLANConnectionStatusReport_v1430_IEsNonCriticalExtension {}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct WUS_Config_r15MaxDurationFactor_r15(pub u8);
impl WUS_Config_r15MaxDurationFactor_r15 {
    pub const ONE32TH: u8 = 0u8;
    pub const ONE16TH: u8 = 1u8;
    pub const ONE8TH: u8 = 2u8;
    pub const ONE4TH: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct WUS_Config_r15NumPOs_r15(pub u8);
impl WUS_Config_r15NumPOs_r15 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N4: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct WUS_Config_r15FreqLocation_r15(pub u8);
impl WUS_Config_r15FreqLocation_r15 {
    pub const N0: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N4: u8 = 2u8;
    pub const SPARE1: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct WUS_Config_r15TimeOffsetDRX_r15(pub u8);
impl WUS_Config_r15TimeOffsetDRX_r15 {
    pub const MS40: u8 = 0u8;
    pub const MS80: u8 = 1u8;
    pub const MS160: u8 = 2u8;
    pub const MS240: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct WUS_Config_r15TimeOffset_eDRX_Short_r15(pub u8);
impl WUS_Config_r15TimeOffset_eDRX_Short_r15 {
    pub const MS40: u8 = 0u8;
    pub const MS80: u8 = 1u8;
    pub const MS160: u8 = 2u8;
    pub const MS240: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct WUS_Config_r15TimeOffset_eDRX_Long_r15(pub u8);
impl WUS_Config_r15TimeOffset_eDRX_Long_r15 {
    pub const MS1000: u8 = 0u8;
    pub const MS2000: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct WUS_Config_v1560PowerBoost_r15(pub u8);
impl WUS_Config_v1560PowerBoost_r15 {
    pub const D_B0: u8 = 0u8;
    pub const D_B1DOT8: u8 = 1u8;
    pub const D_B3: u8 = 2u8;
    pub const D_B4DOT8: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "3")]
pub struct WUS_Config_v1610NumDRX_CyclesRelaxed_r16(pub u8);
impl WUS_Config_v1610NumDRX_CyclesRelaxed_r16 {
    pub const N1: u8 = 0u8;
    pub const N2: u8 = 1u8;
    pub const N4: u8 = 2u8;
    pub const N8: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct WidebandPRG_r16WidebandPRG_Subframe_r16(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BOOLEAN")]
pub struct WidebandPRG_r16WidebandPRG_SlotSubslot_r16(pub bool);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "NULL")]
pub struct ZeroTxPowerCSI_RS_Conf_r12_release;

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct ZeroTxPowerCSI_RS_r12ZeroTxPowerResourceConfigList_r12(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);

#[derive(asn1_codecs_derive :: UperCodec, Clone, PartialEq, serde :: Serialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "154")]
pub struct ZeroTxPowerCSI_RS_r12ZeroTxPowerSubframeConfig_r12(pub u8);
